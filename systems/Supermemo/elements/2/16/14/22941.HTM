# Documentation/virtual/kvm/timekeeping.txt
<P></P>
<P>&nbsp;Timekeeping Virtualization for X86-Based Architectures</P>
<P></P>
<P>&nbsp;Zachary Amsden &lt;<A href="mailto:zamsden@redhat.com">zamsden@redhat.com</A>&gt;<BR>&nbsp;Copyright (c) 2010, Red Hat.&nbsp; All rights reserved.</P>
<P>1) Overview<BR>2) Timing Devices<BR>3) TSC Hardware<BR>4) Virtualization Problems</P>
<P>=========================================================================</P>
<P>1) Overview</P>
<P>One of the most complicated parts of the X86 platform, and specifically,<BR>the virtualization of this platform is the plethora of timing devices available<BR>and the complexity of emulating those devices.&nbsp; In addition, virtualization of<BR>time introduces a new set of challenges because it introduces a multiplexed<BR>division of time beyond the control of the guest CPU.</P>
<P>First, we will describe the various timekeeping hardware available, then<BR>present some of the problems which arise and solutions available, giving<BR>specific recommendations for certain classes of KVM guests.</P>
<P>The purpose of this document is to collect data and information relevant to<BR>timekeeping which may be difficult to find elsewhere, specifically,<BR>information relevant to KVM and hardware-based virtualization.</P>
<P>=========================================================================</P>
<P>2) Timing Devices</P>
<P>First we discuss the basic hardware devices available.&nbsp; TSC and the related<BR>KVM clock are special enough to warrant a full exposition and are described in<BR>the following section.</P>
<P>2.1) i8254 - PIT</P>
<P>One of the first timer devices available is the programmable interrupt timer,<BR>or PIT.&nbsp; The PIT has a fixed frequency 1.193182 MHz base clock and three<BR>channels which can be programmed to deliver periodic or one-shot interrupts.<BR>These three channels can be configured in different modes and have individual<BR>counters.&nbsp; Channel 1 and 2 were not available for general use in the original<BR>IBM PC, and historically were connected to control RAM refresh and the PC<BR>speaker.&nbsp; Now the PIT is typically integrated as part of an emulated chipset<BR>and a separate physical PIT is not used.</P>
<P>The PIT uses I/O ports 0x40 - 0x43.&nbsp; Access to the 16-bit counters is done<BR>using single or multiple byte access to the I/O ports.&nbsp; There are 6 modes<BR>available, but not all modes are available to all timers, as only timer 2<BR>has a connected gate input, required for modes 1 and 5.&nbsp; The gate line is<BR>controlled by port 61h, bit 0, as illustrated in the following diagram.</P>
<P>&nbsp;--------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------------<BR>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>|&nbsp; 1.1932 MHz&nbsp; |----------&gt;| CLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT | ---------&gt; IRQ 0<BR>|&nbsp;&nbsp;&nbsp; Clock&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;--------------&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; +-&gt;| GATE&nbsp; TIMER 0&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| CLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT | ---------&gt; 66.3 KHZ DRAM<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (aka /dev/null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; +-&gt;| GATE&nbsp; TIMER 1&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| CLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT | ---------&gt; Port 61h, bit 5<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>Port 61h, bit 0 ----------&gt;| GATE&nbsp; TIMER 2&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \_.----&nbsp;&nbsp; ____<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _|&nbsp;&nbsp;&nbsp; )--|LPF|---Speaker<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / *----&nbsp;&nbsp; \___/<BR>Port 61h, bit 1 -----------------------------------/</P>
<P>The timer modes are now described.</P>
<P>Mode 0: Single Timeout.&nbsp;&nbsp; This is a one-shot software timeout that counts down<BR>&nbsp;when the gate is high (always true for timers 0 and 1).&nbsp; When the count<BR>&nbsp;reaches zero, the output goes high.</P>
<P>Mode 1: Triggered One-shot.&nbsp; The output is initially set high.&nbsp; When the gate<BR>&nbsp;line is set high, a countdown is initiated (which does not stop if the gate is<BR>&nbsp;lowered), during which the output is set low.&nbsp; When the count reaches zero,<BR>&nbsp;the output goes high.</P>
<P>Mode 2: Rate Generator.&nbsp; The output is initially set high.&nbsp; When the countdown<BR>&nbsp;reaches 1, the output goes low for one count and then returns high.&nbsp; The value<BR>&nbsp;is reloaded and the countdown automatically resumes.&nbsp; If the gate line goes<BR>&nbsp;low, the count is halted.&nbsp; If the output is low when the gate is lowered, the<BR>&nbsp;output automatically goes high (this only affects timer 2).</P>
<P>Mode 3: Square Wave.&nbsp;&nbsp; This generates a high / low square wave.&nbsp; The count<BR>&nbsp;determines the length of the pulse, which alternates between high and low<BR>&nbsp;when zero is reached.&nbsp; The count only proceeds when gate is high and is<BR>&nbsp;automatically reloaded on reaching zero.&nbsp; The count is decremented twice at<BR>&nbsp;each clock to generate a full high / low cycle at the full periodic rate.<BR>&nbsp;If the count is even, the clock remains high for N/2 counts and low for N/2<BR>&nbsp;counts; if the clock is odd, the clock is high for (N+1)/2 counts and low<BR>&nbsp;for (N-1)/2 counts.&nbsp; Only even values are latched by the counter, so odd<BR>&nbsp;values are not observed when reading.&nbsp; This is the intended mode for timer 2,<BR>&nbsp;which generates sine-like tones by low-pass filtering the square wave output.</P>
<P>Mode 4: Software Strobe.&nbsp; After programming this mode and loading the counter,<BR>&nbsp;the output remains high until the counter reaches zero.&nbsp; Then the output<BR>&nbsp;goes low for 1 clock cycle and returns high.&nbsp; The counter is not reloaded.<BR>&nbsp;Counting only occurs when gate is high.</P>
<P>Mode 5: Hardware Strobe.&nbsp; After programming and loading the counter, the<BR>&nbsp;output remains high.&nbsp; When the gate is raised, a countdown is initiated<BR>&nbsp;(which does not stop if the gate is lowered).&nbsp; When the counter reaches zero,<BR>&nbsp;the output goes low for 1 clock cycle and then returns high.&nbsp; The counter is<BR>&nbsp;not reloaded.</P>
<P>In addition to normal binary counting, the PIT supports BCD counting.&nbsp; The<BR>command port, 0x43 is used to set the counter and mode for each of the three<BR>timers.</P>
<P>PIT commands, issued to port 0x43, using the following bit encoding:</P>
<P>Bit 7-4: Command (See table below)<BR>Bit 3-1: Mode (000 = Mode 0, 101 = Mode 5, 11X = undefined)<BR>Bit 0&nbsp; : Binary (0) / BCD (1)</P>
<P>Command table:</P>
<P>0000 - Latch Timer 0 count for port 0x40<BR>&nbsp;sample and hold the count to be read in port 0x40;<BR>&nbsp;additional commands ignored until counter is read;<BR>&nbsp;mode bits ignored.</P>
<P>0001 - Set Timer 0 LSB mode for port 0x40<BR>&nbsp;set timer to read LSB only and force MSB to zero;<BR>&nbsp;mode bits set timer mode</P>
<P>0010 - Set Timer 0 MSB mode for port 0x40<BR>&nbsp;set timer to read MSB only and force LSB to zero;<BR>&nbsp;mode bits set timer mode</P>
<P>0011 - Set Timer 0 16-bit mode for port 0x40<BR>&nbsp;set timer to read / write LSB first, then MSB;<BR>&nbsp;mode bits set timer mode</P>
<P>0100 - Latch Timer 1 count for port 0x41 - as described above<BR>0101 - Set Timer 1 LSB mode for port 0x41 - as described above<BR>0110 - Set Timer 1 MSB mode for port 0x41 - as described above<BR>0111 - Set Timer 1 16-bit mode for port 0x41 - as described above</P>
<P>1000 - Latch Timer 2 count for port 0x42 - as described above<BR>1001 - Set Timer 2 LSB mode for port 0x42 - as described above<BR>1010 - Set Timer 2 MSB mode for port 0x42 - as described above<BR>1011 - Set Timer 2 16-bit mode for port 0x42 as described above</P>
<P>1101 - General counter latch<BR>&nbsp;Latch combination of counters into corresponding ports<BR>&nbsp;Bit 3 = Counter 2<BR>&nbsp;Bit 2 = Counter 1<BR>&nbsp;Bit 1 = Counter 0<BR>&nbsp;Bit 0 = Unused</P>
<P>1110 - Latch timer status<BR>&nbsp;Latch combination of counter mode into corresponding ports<BR>&nbsp;Bit 3 = Counter 2<BR>&nbsp;Bit 2 = Counter 1<BR>&nbsp;Bit 1 = Counter 0</P>
<P>&nbsp;The output of ports 0x40-0x42 following this command will be:</P>
<P>&nbsp;Bit 7 = Output pin<BR>&nbsp;Bit 6 = Count loaded (0 if timer has expired)<BR>&nbsp;Bit 5-4 = Read / Write mode<BR>&nbsp;&nbsp;&nbsp;&nbsp; 01 = MSB only<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10 = LSB only<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11 = LSB / MSB (16-bit)<BR>&nbsp;Bit 3-1 = Mode<BR>&nbsp;Bit 0 = Binary (0) / BCD mode (1)</P>
<P>2.2) RTC</P>
<P>The second device which was available in the original PC was the MC146818 real<BR>time clock.&nbsp; The original device is now obsolete, and usually emulated by the<BR>system chipset, sometimes by an HPET and some frankenstein IRQ routing.</P>
<P>The RTC is accessed through CMOS variables, which uses an index register to<BR>control which bytes are read.&nbsp; Since there is only one index register, read<BR>of the CMOS and read of the RTC require lock protection (in addition, it is<BR>dangerous to allow userspace utilities such as hwclock to have direct RTC<BR>access, as they could corrupt kernel reads and writes of CMOS memory).</P>
<P>The RTC generates an interrupt which is usually routed to IRQ 8.&nbsp; The interrupt<BR>can function as a periodic timer, an additional once a day alarm, and can issue<BR>interrupts after an update of the CMOS registers by the MC146818 is complete.<BR>The type of interrupt is signalled in the RTC status registers.</P>
<P>The RTC will update the current time fields by battery power even while the<BR>system is off.&nbsp; The current time fields should not be read while an update is<BR>in progress, as indicated in the status register.</P>
<P>The clock uses a 32.768kHz crystal, so bits 6-4 of register A should be<BR>programmed to a 32kHz divider if the RTC is to count seconds.</P>
<P>This is the RAM map originally used for the RTC/CMOS:</P>
<P>Location&nbsp;&nbsp;&nbsp; Size&nbsp;&nbsp;&nbsp; Description<BR>------------------------------------------<BR>00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current second (BCD)<BR>01h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Seconds alarm (BCD)<BR>02h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current minute (BCD)<BR>03h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Minutes alarm (BCD)<BR>04h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current hour (BCD)<BR>05h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Hours alarm (BCD)<BR>06h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current day of week (BCD)<BR>07h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current day of month (BCD)<BR>08h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current month (BCD)<BR>09h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current year (BCD)<BR>0Ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Register A<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 7&nbsp;&nbsp; = Update in progress<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 6-4 = Divider for clock<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000 = 4.194 MHz<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001 = 1.049 MHz<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 010 = 32 kHz<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10X = test modes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 110 = reset / disable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 111 = reset / disable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 3-0 = Rate selection for periodic interrupt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000 = periodic timer disabled<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001 = 3.90625 uS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 010 = 7.8125 uS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 011 = .122070 mS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 = .244141 mS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1101 = 125 mS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1110 = 250 mS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1111 = 500 mS<BR>0Bh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Register B<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 7&nbsp;&nbsp; = Run (0) / Halt (1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 6&nbsp;&nbsp; = Periodic interrupt enable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 5&nbsp;&nbsp; = Alarm interrupt enable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 4&nbsp;&nbsp; = Update-ended interrupt enable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 3&nbsp;&nbsp; = Square wave interrupt enable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 2&nbsp;&nbsp; = BCD calendar (0) / Binary (1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 1&nbsp;&nbsp; = 12-hour mode (0) / 24-hour mode (1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 0&nbsp;&nbsp; = 0 (DST off) / 1 (DST enabled)<BR>OCh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Register C (read only)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 7&nbsp;&nbsp; = interrupt request flag (IRQF)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 6&nbsp;&nbsp; = periodic interrupt flag (PF)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 5&nbsp;&nbsp; = alarm interrupt flag (AF)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 4&nbsp;&nbsp; = update interrupt flag (UF)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 3-0 = reserved<BR>ODh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Register D (read only)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 7&nbsp;&nbsp; = RTC has power<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit 6-0 = reserved<BR>32h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; Current century BCD (*)<BR>&nbsp; (*) location vendor specific and now determined from ACPI global tables</P>
<P>2.3) APIC</P>
<P>On Pentium and later processors, an on-board timer is available to each CPU<BR>as part of the Advanced Programmable Interrupt Controller.&nbsp; The APIC is<BR>accessed through memory-mapped registers and provides interrupt service to each<BR>CPU, used for IPIs and local timer interrupts.</P>
<P>Although in theory the APIC is a safe and stable source for local interrupts,<BR>in practice, many bugs and glitches have occurred due to the special nature of<BR>the APIC CPU-local memory-mapped hardware.&nbsp; Beware that CPU errata may affect<BR>the use of the APIC and that workarounds may be required.&nbsp; In addition, some of<BR>these workarounds pose unique constraints for virtualization - requiring either<BR>extra overhead incurred from extra reads of memory-mapped I/O or additional<BR>functionality that may be more computationally expensive to implement.</P>
<P>Since the APIC is documented quite well in the Intel and AMD manuals, we will<BR>avoid repetition of the detail here.&nbsp; It should be pointed out that the APIC<BR>timer is programmed through the LVT (local vector timer) register, is capable<BR>of one-shot or periodic operation, and is based on the bus clock divided down<BR>by the programmable divider register.</P>
<P>2.4) HPET</P>
<P>HPET is quite complex, and was originally intended to replace the PIT / RTC<BR>support of the X86 PC.&nbsp; It remains to be seen whether that will be the case, as<BR>the de facto standard of PC hardware is to emulate these older devices.&nbsp; Some<BR>systems designated as legacy free may support only the HPET as a hardware timer<BR>device.</P>
<P>The HPET spec is rather loose and vague, requiring at least 3 hardware timers,<BR>but allowing implementation freedom to support many more.&nbsp; It also imposes no<BR>fixed rate on the timer frequency, but does impose some extremal values on<BR>frequency, error and slew.</P>
<P>In general, the HPET is recommended as a high precision (compared to PIT /RTC)<BR>time source which is independent of local variation (as there is only one HPET<BR>in any given system).&nbsp; The HPET is also memory-mapped, and its presence is<BR>indicated through ACPI tables by the BIOS.</P>
<P>Detailed specification of the HPET is beyond the current scope of this<BR>document, as it is also very well documented elsewhere.</P>
<P>2.5) Offboard Timers</P>
<P>Several cards, both proprietary (watchdog boards) and commonplace (e1000) have<BR>timing chips built into the cards which may have registers which are accessible<BR>to kernel or user drivers.&nbsp; To the author's knowledge, using these to generate<BR>a clocksource for a Linux or other kernel has not yet been attempted and is in<BR>general frowned upon as not playing by the agreed rules of the game.&nbsp; Such a<BR>timer device would require additional support to be virtualized properly and is<BR>not considered important at this time as no known operating system does this.</P>
<P>=========================================================================</P>
<P>3) TSC Hardware</P>
<P>The TSC or time stamp counter is relatively simple in theory; it counts<BR>instruction cycles issued by the processor, which can be used as a measure of<BR>time.&nbsp; In practice, due to a number of problems, it is the most complicated<BR>timekeeping device to use.</P>
<P>The TSC is represented internally as a 64-bit MSR which can be read with the<BR>RDMSR, RDTSC, or RDTSCP (when available) instructions.&nbsp; In the past, hardware<BR>limitations made it possible to write the TSC, but generally on old hardware it<BR>was only possible to write the low 32-bits of the 64-bit counter, and the upper<BR>32-bits of the counter were cleared.&nbsp; Now, however, on Intel processors family<BR>0Fh, for models 3, 4 and 6, and family 06h, models e and f, this restriction<BR>has been lifted and all 64-bits are writable.&nbsp; On AMD systems, the ability to<BR>write the TSC MSR is not an architectural guarantee.</P>
<P>The TSC is accessible from CPL-0 and conditionally, for CPL &gt; 0 software by<BR>means of the CR4.TSD bit, which when enabled, disables CPL &gt; 0 TSC access.</P>
<P>Some vendors have implemented an additional instruction, RDTSCP, which returns<BR>atomically not just the TSC, but an indicator which corresponds to the<BR>processor number.&nbsp; This can be used to index into an array of TSC variables to<BR>determine offset information in SMP systems where TSCs are not synchronized.<BR>The presence of this instruction must be determined by consulting CPUID feature<BR>bits.</P>
<P>Both VMX and SVM provide extension fields in the virtualization hardware which<BR>allows the guest visible TSC to be offset by a constant.&nbsp; Newer implementations<BR>promise to allow the TSC to additionally be scaled, but this hardware is not<BR>yet widely available.</P>
<P>3.1) TSC synchronization</P>
<P>The TSC is a CPU-local clock in most implementations.&nbsp; This means, on SMP<BR>platforms, the TSCs of different CPUs may start at different times depending<BR>on when the CPUs are powered on.&nbsp; Generally, CPUs on the same die will share<BR>the same clock, however, this is not always the case.</P>
<P>The BIOS may attempt to resynchronize the TSCs during the poweron process and<BR>the operating system or other system software may attempt to do this as well.<BR>Several hardware limitations make the problem worse - if it is not possible to<BR>write the full 64-bits of the TSC, it may be impossible to match the TSC in<BR>newly arriving CPUs to that of the rest of the system, resulting in<BR>unsynchronized TSCs.&nbsp; This may be done by BIOS or system software, but in<BR>practice, getting a perfectly synchronized TSC will not be possible unless all<BR>values are read from the same clock, which generally only is possible on single<BR>socket systems or those with special hardware support.</P>
<P>3.2) TSC and CPU hotplug</P>
<P>As touched on already, CPUs which arrive later than the boot time of the system<BR>may not have a TSC value that is synchronized with the rest of the system.<BR>Either system software, BIOS, or SMM code may actually try to establish the TSC<BR>to a value matching the rest of the system, but a perfect match is usually not<BR>a guarantee.&nbsp; This can have the effect of bringing a system from a state where<BR>TSC is synchronized back to a state where TSC synchronization flaws, however<BR>small, may be exposed to the OS and any virtualization environment.</P>
<P>3.3) TSC and multi-socket / NUMA</P>
<P>Multi-socket systems, especially large multi-socket systems are likely to have<BR>individual clocksources rather than a single, universally distributed clock.<BR>Since these clocks are driven by different crystals, they will not have<BR>perfectly matched frequency, and temperature and electrical variations will<BR>cause the CPU clocks, and thus the TSCs to drift over time.&nbsp; Depending on the<BR>exact clock and bus design, the drift may or may not be fixed in absolute<BR>error, and may accumulate over time.</P>
<P>In addition, very large systems may deliberately slew the clocks of individual<BR>cores.&nbsp; This technique, known as spread-spectrum clocking, reduces EMI at the<BR>clock frequency and harmonics of it, which may be required to pass FCC<BR>standards for telecommunications and computer equipment.</P>
<P>It is recommended not to trust the TSCs to remain synchronized on NUMA or<BR>multiple socket systems for these reasons.</P>
<P>3.4) TSC and C-states</P>
<P>C-states, or idling states of the processor, especially C1E and deeper sleep<BR>states may be problematic for TSC as well.&nbsp; The TSC may stop advancing in such<BR>a state, resulting in a TSC which is behind that of other CPUs when execution<BR>is resumed.&nbsp; Such CPUs must be detected and flagged by the operating system<BR>based on CPU and chipset identifications.</P>
<P>The TSC in such a case may be corrected by catching it up to a known external<BR>clocksource.</P>
<P>3.5) TSC frequency change / P-states</P>
<P>To make things slightly more interesting, some CPUs may change frequency.&nbsp; They<BR>may or may not run the TSC at the same rate, and because the frequency change<BR>may be staggered or slewed, at some points in time, the TSC rate may not be<BR>known other than falling within a range of values.&nbsp; In this case, the TSC will<BR>not be a stable time source, and must be calibrated against a known, stable,<BR>external clock to be a usable source of time.</P>
<P>Whether the TSC runs at a constant rate or scales with the P-state is model<BR>dependent and must be determined by inspecting CPUID, chipset or vendor<BR>specific MSR fields.</P>
<P>In addition, some vendors have known bugs where the P-state is actually<BR>compensated for properly during normal operation, but when the processor is<BR>inactive, the P-state may be raised temporarily to service cache misses from<BR>other processors.&nbsp; In such cases, the TSC on halted CPUs could advance faster<BR>than that of non-halted processors.&nbsp; AMD Turion processors are known to have<BR>this problem.</P>
<P>3.6) TSC and STPCLK / T-states</P>
<P>External signals given to the processor may also have the effect of stopping<BR>the TSC.&nbsp; This is typically done for thermal emergency power control to prevent<BR>an overheating condition, and typically, there is no way to detect that this<BR>condition has happened.</P>
<P>3.7) TSC virtualization - VMX</P>
<P>VMX provides conditional trapping of RDTSC, RDMSR, WRMSR and RDTSCP<BR>instructions, which is enough for full virtualization of TSC in any manner.&nbsp; In<BR>addition, VMX allows passing through the host TSC plus an additional TSC_OFFSET<BR>field specified in the VMCS.&nbsp; Special instructions must be used to read and<BR>write the VMCS field.</P>
<P>3.8) TSC virtualization - SVM</P>
<P>SVM provides conditional trapping of RDTSC, RDMSR, WRMSR and RDTSCP<BR>instructions, which is enough for full virtualization of TSC in any manner.&nbsp; In<BR>addition, SVM allows passing through the host TSC plus an additional offset<BR>field specified in the SVM control block.</P>
<P>3.9) TSC feature bits in Linux</P>
<P>In summary, there is no way to guarantee the TSC remains in perfect<BR>synchronization unless it is explicitly guaranteed by the architecture.&nbsp; Even<BR>if so, the TSCs in multi-sockets or NUMA systems may still run independently<BR>despite being locally consistent.</P>
<P>The following feature bits are used by Linux to signal various TSC attributes,<BR>but they can only be taken to be meaningful for UP or single node systems.</P>
<P>X86_FEATURE_TSC &nbsp;&nbsp;: The TSC is available in hardware<BR>X86_FEATURE_RDTSCP&nbsp;&nbsp;: The RDTSCP instruction is available<BR>X86_FEATURE_CONSTANT_TSC &nbsp;: The TSC rate is unchanged with P-states<BR>X86_FEATURE_NONSTOP_TSC&nbsp;&nbsp;: The TSC does not stop in C-states<BR>X86_FEATURE_TSC_RELIABLE&nbsp;: TSC sync checks are skipped (VMware)</P>
<P>4) Virtualization Problems</P>
<P>Timekeeping is especially problematic for virtualization because a number of<BR>challenges arise.&nbsp; The most obvious problem is that time is now shared between<BR>the host and, potentially, a number of virtual machines.&nbsp; Thus the virtual<BR>operating system does not run with 100% usage of the CPU, despite the fact that<BR>it may very well make that assumption.&nbsp; It may expect it to remain true to very<BR>exacting bounds when interrupt sources are disabled, but in reality only its<BR>virtual interrupt sources are disabled, and the machine may still be preempted<BR>at any time.&nbsp; This causes problems as the passage of real time, the injection<BR>of machine interrupts and the associated clock sources are no longer completely<BR>synchronized with real time.</P>
<P>This same problem can occur on native harware to a degree, as SMM mode may<BR>steal cycles from the naturally on X86 systems when SMM mode is used by the<BR>BIOS, but not in such an extreme fashion.&nbsp; However, the fact that SMM mode may<BR>cause similar problems to virtualization makes it a good justification for<BR>solving many of these problems on bare metal.</P>
<P>4.1) Interrupt clocking</P>
<P>One of the most immediate problems that occurs with legacy operating systems<BR>is that the system timekeeping routines are often designed to keep track of<BR>time by counting periodic interrupts.&nbsp; These interrupts may come from the PIT<BR>or the RTC, but the problem is the same: the host virtualization engine may not<BR>be able to deliver the proper number of interrupts per second, and so guest<BR>time may fall behind.&nbsp; This is especially problematic if a high interrupt rate<BR>is selected, such as 1000 HZ, which is unfortunately the default for many Linux<BR>guests.</P>
<P>There are three approaches to solving this problem; first, it may be possible<BR>to simply ignore it.&nbsp; Guests which have a separate time source for tracking<BR>'wall clock' or 'real time' may not need any adjustment of their interrupts to<BR>maintain proper time.&nbsp; If this is not sufficient, it may be necessary to inject<BR>additional interrupts into the guest in order to increase the effective<BR>interrupt rate.&nbsp; This approach leads to complications in extreme conditions,<BR>where host load or guest lag is too much to compensate for, and thus another<BR>solution to the problem has risen: the guest may need to become aware of lost<BR>ticks and compensate for them internally.&nbsp; Although promising in theory, the<BR>implementation of this policy in Linux has been extremely error prone, and a<BR>number of buggy variants of lost tick compensation are distributed across<BR>commonly used Linux systems.</P>
<P>Windows uses periodic RTC clocking as a means of keeping time internally, and<BR>thus requires interrupt slewing to keep proper time.&nbsp; It does use a low enough<BR>rate (ed: is it 18.2 Hz?) however that it has not yet been a problem in<BR>practice.</P>
<P>4.2) TSC sampling and serialization</P>
<P>As the highest precision time source available, the cycle counter of the CPU<BR>has aroused much interest from developers.&nbsp; As explained above, this timer has<BR>many problems unique to its nature as a local, potentially unstable and<BR>potentially unsynchronized source.&nbsp; One issue which is not unique to the TSC,<BR>but is highlighted because of its very precise nature is sampling delay.&nbsp; By<BR>definition, the counter, once read is already old.&nbsp; However, it is also<BR>possible for the counter to be read ahead of the actual use of the result.<BR>This is a consequence of the superscalar execution of the instruction stream,<BR>which may execute instructions out of order.&nbsp; Such execution is called<BR>non-serialized.&nbsp; Forcing serialized execution is necessary for precise<BR>measurement with the TSC, and requires a serializing instruction, such as CPUID<BR>or an MSR read.</P>
<P>Since CPUID may actually be virtualized by a trap and emulate mechanism, this<BR>serialization can pose a performance issue for hardware virtualization.&nbsp; An<BR>accurate time stamp counter reading may therefore not always be available, and<BR>it may be necessary for an implementation to guard against "backwards" reads of<BR>the TSC as seen from other CPUs, even in an otherwise perfectly synchronized<BR>system.</P>
<P>4.3) Timespec aliasing</P>
<P>Additionally, this lack of serialization from the TSC poses another challenge<BR>when using results of the TSC when measured against another time source.&nbsp; As<BR>the TSC is much higher precision, many possible values of the TSC may be read<BR>while another clock is still expressing the same value.</P>
<P>That is, you may read (T,T+10) while external clock C maintains the same value.<BR>Due to non-serialized reads, you may actually end up with a range which<BR>fluctuates - from (T-1.. T+10).&nbsp; Thus, any time calculated from a TSC, but<BR>calibrated against an external value may have a range of valid values.<BR>Re-calibrating this computation may actually cause time, as computed after the<BR>calibration, to go backwards, compared with time computed before the<BR>calibration.</P>
<P>This problem is particularly pronounced with an internal time source in Linux,<BR>the kernel time, which is expressed in the theoretically high resolution<BR>timespec - but which advances in much larger granularity intervals, sometimes<BR>at the rate of jiffies, and possibly in catchup modes, at a much larger step.</P>
<P>This aliasing requires care in the computation and recalibration of kvmclock<BR>and any other values derived from TSC computation (such as TSC virtualization<BR>itself).</P>
<P>4.4) Migration</P>
<P>Migration of a virtual machine raises problems for timekeeping in two ways.<BR>First, the migration itself may take time, during which interrupts cannot be<BR>delivered, and after which, the guest time may need to be caught up.&nbsp; NTP may<BR>be able to help to some degree here, as the clock correction required is<BR>typically small enough to fall in the NTP-correctable window.</P>
<P>An additional concern is that timers based off the TSC (or HPET, if the raw bus<BR>clock is exposed) may now be running at different rates, requiring compensation<BR>in some way in the hypervisor by virtualizing these timers.&nbsp; In addition,<BR>migrating to a faster machine may preclude the use of a passthrough TSC, as a<BR>faster clock cannot be made visible to a guest without the potential of time<BR>advancing faster than usual.&nbsp; A slower clock is less of a problem, as it can<BR>always be caught up to the original rate.&nbsp; KVM clock avoids these problems by<BR>simply storing multipliers and offsets against the TSC for the guest to convert<BR>back into nanosecond resolution values.</P>
<P>4.5) Scheduling</P>
<P>Since scheduling may be based on precise timing and firing of interrupts, the<BR>scheduling algorithms of an operating system may be adversely affected by<BR>virtualization.&nbsp; In theory, the effect is random and should be universally<BR>distributed, but in contrived as well as real scenarios (guest device access,<BR>causes of virtualization exits, possible context switch), this may not always<BR>be the case.&nbsp; The effect of this has not been well studied.</P>
<P>In an attempt to work around this, several implementations have provided a<BR>paravirtualized scheduler clock, which reveals the true amount of CPU time for<BR>which a virtual machine has been running.</P>
<P>4.6) Watchdogs</P>
<P>Watchdog timers, such as the lock detector in Linux may fire accidentally when<BR>running under hardware virtualization due to timer interrupts being delayed or<BR>misinterpretation of the passage of real time.&nbsp; Usually, these warnings are<BR>spurious and can be ignored, but in some circumstances it may be necessary to<BR>disable such detection.</P>
<P>4.7) Delays and precision timing</P>
<P>Precise timing and delays may not be possible in a virtualized system.&nbsp; This<BR>can happen if the system is controlling physical hardware, or issues delays to<BR>compensate for slower I/O to and from devices.&nbsp; The first issue is not solvable<BR>in general for a virtualized system; hardware control software can't be<BR>adequately virtualized without a full real-time operating system, which would<BR>require an RT aware virtualization platform.</P>
<P>The second issue may cause performance problems, but this is unlikely to be a<BR>significant issue.&nbsp; In many cases these delays may be eliminated through<BR>configuration or paravirtualization.</P>
<P>4.8) Covert channels and leaks</P>
<P>In addition to the above problems, time information will inevitably leak to the<BR>guest about the host in anything but a perfect implementation of virtualized<BR>time.&nbsp; This may allow the guest to infer the presence of a hypervisor (as in a<BR>red-pill type detection), and it may allow information to leak between guests<BR>by using CPU utilization itself as a signalling channel.&nbsp; Preventing such<BR>problems would require completely isolated virtual time which may not track<BR>real time any longer.&nbsp; This may be useful in certain security or QA contexts,<BR>but in general isn't recommended for real-world deployment scenarios.