# Documentation/fb/udlfb.txt 
<P></P>
<P>What is udlfb?<BR>===============</P>
<P></P>
<P>This is a driver for DisplayLink USB 2.0 era graphics chips.</P>
<P>DisplayLink chips provide simple hline/blit operations with some compression,<BR>pairing that with a hardware framebuffer (16MB) on the other end of the<BR>USB wire.&nbsp; That hardware framebuffer is able to drive the VGA, DVI, or HDMI<BR>monitor with no CPU involvement until a pixel has to change.</P>
<P>The CPU or other local resource does all the rendering; optinally compares the<BR>result with a local shadow of the remote hardware framebuffer to identify<BR>the minimal set of pixels that have changed; and compresses and sends those<BR>pixels line-by-line via USB bulk transfers.</P>
<P>Because of the efficiency of bulk transfers and a protocol on top that<BR>does not require any acks - the effect is very low latency that<BR>can support surprisingly high resolutions with good performance for<BR>non-gaming and non-video applications.</P>
<P>Mode setting, EDID read, etc are other bulk or control transfers. Mode<BR>setting is very flexible - able to set nearly arbitrary modes from any timing.</P>
<P>Advantages of USB graphics in general:</P>
<P>&nbsp;* Ability to add a nearly arbitrary number of displays to any USB 2.0<BR>&nbsp;&nbsp; capable system. On Linux, number of displays is limited by fbdev interface<BR>&nbsp;&nbsp; (FB_MAX is currently 32). Of course, all USB devices on the same<BR>&nbsp;&nbsp; host controller share the same 480Mbs USB 2.0 interface.</P>
<P>Advantages of supporting DisplayLink chips with kernel framebuffer interface:</P>
<P>&nbsp;* The actual hardware functionality of DisplayLink chips matches nearly<BR>&nbsp;&nbsp; one-to-one with the fbdev interface, making the driver quite small and<BR>&nbsp;&nbsp; tight relative to the functionality it provides.<BR>&nbsp;* X servers and other applications can use the standard fbdev interface<BR>&nbsp;&nbsp; from user mode to talk to the device, without needing to know anything<BR>&nbsp;&nbsp; about USB or DisplayLink's protocol at all. A "displaylink" X driver<BR>&nbsp;&nbsp; and a slightly modified "fbdev" X driver are among those that already do.</P>
<P>Disadvantages:</P>
<P>&nbsp;* Fbdev's mmap interface assumes a real hardware framebuffer is mapped.<BR>&nbsp;&nbsp; In the case of USB graphics, it is just an allocated (virtual) buffer.<BR>&nbsp;&nbsp; Writes need to be detected and encoded into USB bulk transfers by the CPU.<BR>&nbsp;&nbsp; Accurate damage/changed area notifications work around this problem.<BR>&nbsp;&nbsp; In the future, hopefully fbdev will be enhanced with an small standard<BR>&nbsp;&nbsp; interface to allow mmap clients to report damage, for the benefit<BR>&nbsp;&nbsp; of virtual or remote framebuffers.<BR>&nbsp;* Fbdev does not arbitrate client ownership of the framebuffer well.<BR>&nbsp;* Fbcon assumes the first framebuffer it finds should be consumed for console.<BR>&nbsp;* It's not clear what the future of fbdev is, given the rise of KMS/DRM.</P>
<P>How to use it?<BR>==============</P>
<P>Udlfb, when loaded as a module, will match against all USB 2.0 generation<BR>DisplayLink chips (Alex and Ollie family). It will then attempt to read the EDID<BR>of the monitor, and set the best common mode between the DisplayLink device<BR>and the monitor's capabilities.</P>
<P>If the DisplayLink device is successful, it will paint a "green screen" which<BR>means that from a hardware and fbdev software perspective, everything is good.</P>
<P>At that point, a /dev/fb? interface will be present for user-mode applications<BR>to open and begin writing to the framebuffer of the DisplayLink device using<BR>standard fbdev calls.&nbsp; Note that if mmap() is used, by default the user mode<BR>application must send down damage notifcations to trigger repaints of the<BR>changed regions.&nbsp; Alternatively, udlfb can be recompiled with experimental<BR>defio support enabled, to support a page-fault based detection mechanism<BR>that can work without explicit notifcation.</P>
<P>The most common client of udlfb is xf86-video-displaylink or a modified<BR>xf86-video-fbdev X server. These servers have no real DisplayLink specific<BR>code. They write to the standard framebuffer interface and rely on udlfb<BR>to do its thing.&nbsp; The one extra feature they have is the ability to report<BR>rectangles from the X DAMAGE protocol extension down to udlfb via udlfb's<BR>damage interface (which will hopefully be standardized for all virtual<BR>framebuffers that need damage info). These damage notifications allow<BR>udlfb to efficiently process the changed pixels.</P>
<P>Module Options<BR>==============</P>
<P>Special configuration for udlfb is usually unnecessary. There are a few<BR>options, however.</P>
<P>From the command line, pass options to modprobe<BR>modprobe udlfb fb_defio=0 console=1 shadow=1</P>
<P>Or modify options on the fly at /sys/module/udlfb/parameters directory via<BR>sudo nano fb_defio<BR>change the parameter in place, and save the file.</P>
<P>Unplug/replug USB device to apply with new settings</P>
<P>Or for permanent option, create file like /etc/modprobe.d/udlfb.conf with text<BR>options udlfb fb_defio=0 console=1 shadow=1</P>
<P>Accepted boolean options:</P>
<P>fb_defio&nbsp;Make use of the fb_defio (CONFIG_FB_DEFERRED_IO) kernel<BR>&nbsp;&nbsp;module to track changed areas of the framebuffer by page faults.<BR>&nbsp;&nbsp;Standard fbdev applications that use mmap but that do not<BR>&nbsp;&nbsp;report damage, should be able to work with this enabled.<BR>&nbsp;&nbsp;Disable when running with X server that supports reporting<BR>&nbsp;&nbsp;changed regions via ioctl, as this method is simpler,<BR>&nbsp;&nbsp;more stable, and higher performance.<BR>&nbsp;&nbsp;default: fb_defio=1</P>
<P>console&nbsp;Allow fbcon to attach to udlfb provided framebuffers.<BR>&nbsp;&nbsp;Can be disabled if fbcon and other clients<BR>&nbsp;&nbsp;(e.g. X with --shared-vt) are in conflict.<BR>&nbsp;&nbsp;default: console=1</P>
<P>shadow&nbsp;&nbsp;Allocate a 2nd framebuffer to shadow what's currently across<BR>&nbsp;&nbsp;the USB bus in device memory. If any pixels are unchanged,<BR>&nbsp;&nbsp;do not transmit. Spends host memory to save USB transfers.<BR>&nbsp;&nbsp;Enabled by default. Only disable on very low memory systems.<BR>&nbsp;&nbsp;default: shadow=1</P>
<P>Sysfs Attributes<BR>================</P>
<P>Udlfb creates several files in /sys/class/graphics/fb?<BR>Where ? is the sequential framebuffer id of the particular DisplayLink device</P>
<P>edid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;If a valid EDID blob is written to this file (typically<BR>&nbsp;&nbsp;&nbsp;by a udev rule), then udlfb will use this EDID as a<BR>&nbsp;&nbsp;&nbsp;backup in case reading the actual EDID of the monitor<BR>&nbsp;&nbsp;&nbsp;attached to the DisplayLink device fails. This is<BR>&nbsp;&nbsp;&nbsp;especially useful for fixed panels, etc. that cannot<BR>&nbsp;&nbsp;&nbsp;communicate their capabilities via EDID. Reading<BR>&nbsp;&nbsp;&nbsp;this file returns the current EDID of the attached<BR>&nbsp;&nbsp;&nbsp;monitor (or last backup value written). This is<BR>&nbsp;&nbsp;&nbsp;useful to get the EDID of the attached monitor,<BR>&nbsp;&nbsp;&nbsp;which can be passed to utilities like parse-edid.</P>
<P>metrics_bytes_rendered&nbsp;32-bit count of pixel bytes rendered</P>
<P>metrics_bytes_identical 32-bit count of how many of those bytes were found to be<BR>&nbsp;&nbsp;&nbsp;unchanged, based on a shadow framebuffer check</P>
<P>metrics_bytes_sent&nbsp;32-bit count of how many bytes were transferred over<BR>&nbsp;&nbsp;&nbsp;USB to communicate the resulting changed pixels to the<BR>&nbsp;&nbsp;&nbsp;hardware. Includes compression and protocol overhead</P>
<P>metrics_cpu_kcycles_used 32-bit count of CPU cycles used in processing the<BR>&nbsp;&nbsp;&nbsp;above pixels (in thousands of cycles).</P>
<P>metrics_reset&nbsp;&nbsp;Write-only. Any write to this file resets all metrics<BR>&nbsp;&nbsp;&nbsp;above to zero.&nbsp; Note that the 32-bit counters above<BR>&nbsp;&nbsp;&nbsp;roll over very quickly. To get reliable results, design<BR>&nbsp;&nbsp;&nbsp;performance tests to start and finish in a very short<BR>&nbsp;&nbsp;&nbsp;period of time (one minute or less is safe).</P>
<P>--<BR>Bernie Thompson &lt;<A href="mailto:bernie@plugable.com">bernie@plugable.com</A>&gt;