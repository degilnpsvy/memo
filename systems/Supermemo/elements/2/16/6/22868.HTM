# Documentation/fb/modedb.txt&nbsp; 
<P></P>
<P>&nbsp;&nbsp;&nbsp;modedb default video mode support</P>
<P><BR>Currently all frame buffer device drivers have their own video mode databases,<BR>which is a mess and a waste of resources. The main idea of modedb is to have</P>
<P>&nbsp; - one routine to probe for video modes, which can be used by all frame buffer<BR>&nbsp;&nbsp;&nbsp; devices<BR>&nbsp; - one generic video mode database with a fair amount of standard videomodes<BR>&nbsp;&nbsp;&nbsp; (taken from XFree86)<BR>&nbsp; - the possibility to supply your own mode database for graphics hardware that<BR>&nbsp;&nbsp;&nbsp; needs non-standard modes, like amifb and Mac frame buffer drivers (which<BR>&nbsp;&nbsp;&nbsp; use macmodes.c)</P>
<P>When a frame buffer device receives a video= option it doesn't know, it should<BR>consider that to be a video mode option. If no frame buffer device is specified<BR>in a video= option, fbmem considers that to be a global video mode option.</P>
<P>Valid mode specifiers (mode_option argument):</P>
<P>&nbsp;&nbsp;&nbsp; &lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m][eDd]<BR>&nbsp;&nbsp;&nbsp; &lt;name&gt;[-&lt;bpp&gt;][@&lt;refresh&gt;]</P>
<P>with &lt;xres&gt;, &lt;yres&gt;, &lt;bpp&gt; and &lt;refresh&gt; decimal numbers and &lt;name&gt; a string.<BR>Things between square brackets are optional.</P>
<P>If 'M' is specified in the mode_option argument (after &lt;yres&gt; and before<BR>&lt;bpp&gt; and &lt;refresh&gt;, if specified) the timings will be calculated using<BR>VESA(TM) Coordinated Video Timings instead of looking up the mode from a table.<BR>If 'R' is specified, do a 'reduced blanking' calculation for digital displays.<BR>If 'i' is specified, calculate for an interlaced mode.&nbsp; And if 'm' is<BR>specified, add margins to the calculation (1.8% of xres rounded down to 8<BR>pixels and 1.8% of yres).</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sample usage: <A href="mailto:1024x768M@60m">1024x768M@60m</A> - CVT timing with margins</P>
<P>DRM drivers also add options to enable or disable outputs:</P>
<P>'e' will force the display to be enabled, i.e. it will override the detection<BR>if a display is connected. 'D' will force the display to be enabled and use<BR>digital output. This is useful for outputs that have both analog and digital<BR>signals (e.g. HDMI and DVI-I). For other outputs it behaves like 'e'. If 'd'<BR>is specified the output is disabled.</P>
<P>You can additionally specify which output the options matches to.<BR>To force the VGA output to be enabled and drive a specific mode say:<BR>&nbsp;&nbsp;&nbsp; video=VGA-1:1280x1024@60me</P>
<P>Specifying the option multiple times for different ports is possible, e.g.:<BR>&nbsp;&nbsp;&nbsp; video=LVDS-1:d video=HDMI-1:D</P>
<P>***** oOo ***** oOo ***** oOo ***** oOo ***** oOo ***** oOo ***** oOo *****</P>
<P>What is the VESA(TM) Coordinated Video Timings (CVT)?</P>
<P>From the VESA(TM) Website:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; "The purpose of CVT is to provide a method for generating a consistent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and coordinated set of standard formats, display refresh rates, and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timing specifications for computer display products, both those<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; employing CRTs, and those using other display technologies. The<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intention of CVT is to give both source and display manufacturers a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common set of tools to enable new timings to be developed in a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consistent manner that ensures greater compatibility."</P>
<P>This is the third standard approved by VESA(TM) concerning video timings.&nbsp; The<BR>first was the Discrete Video Timings (DVT) which is&nbsp; a collection of<BR>pre-defined modes approved by VESA(TM).&nbsp; The second is the Generalized Timing<BR>Formula (GTF) which is an algorithm to calculate the timings, given the<BR>pixelclock, the horizontal sync frequency, or the vertical refresh rate.</P>
<P>The GTF is limited by the fact that it is designed mainly for CRT displays.<BR>It artificially increases the pixelclock because of its high blanking<BR>requirement. This is inappropriate for digital display interface with its high<BR>data rate which requires that it conserves the pixelclock as much as possible.<BR>Also, GTF does not take into account the aspect ratio of the display.</P>
<P>The CVT addresses these limitations.&nbsp; If used with CRT's, the formula used<BR>is a derivation of GTF with a few modifications.&nbsp; If used with digital<BR>displays, the "reduced blanking" calculation can be used.</P>
<P>From the framebuffer subsystem perspective, new formats need not be added<BR>to the global mode database whenever a new mode is released by display<BR>manufacturers. Specifying for CVT will work for most, if not all, relatively<BR>new CRT displays and probably with most flatpanels, if 'reduced blanking'<BR>calculation is specified.&nbsp; (The CVT compatibility of the display can be<BR>determined from its EDID. The version 1.3 of the EDID has extra 128-byte<BR>blocks where additional timing information is placed.&nbsp; As of this time, there<BR>is no support yet in the layer to parse this additional blocks.)</P>
<P>CVT also introduced a new naming convention (should be seen from dmesg output):</P>
<P>&nbsp;&nbsp;&nbsp; &lt;pix&gt;M&lt;a&gt;[-R]</P>
<P>&nbsp;&nbsp;&nbsp; where: pix = total amount of pixels in MB (xres x yres)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M&nbsp;&nbsp; = always present<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp; = aspect ratio (3 - 4:3; 4 - 5:4; 9 - 15:9, 16:9; A - 16:10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -R&nbsp;&nbsp; = reduced blanking</P>
<P>&nbsp;&nbsp; example:&nbsp; .48M3-R - 800x600 with reduced blanking</P>
<P>Note: VESA(TM) has restrictions on what is a standard CVT timing:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - aspect ratio can only be one of the above values<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - acceptable refresh rates are 50, 60, 70 or 85 Hz only<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - if reduced blanking, the refresh rate must be at 60Hz</P>
<P>If one of the above are not satisfied, the kernel will print a warning but the<BR>timings will still be calculated.</P>
<P>***** oOo ***** oOo ***** oOo ***** oOo ***** oOo ***** oOo ***** oOo *****</P>
<P>To find a suitable video mode, you just call</P>
<P>int __init fb_find_mode(struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_info *info, const char *mode_option,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct fb_videomode *db, unsigned int dbsize,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct fb_videomode *default_mode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int default_bpp)</P>
<P>with db/dbsize your non-standard video mode database, or NULL to use the<BR>standard video mode database.</P>
<P>fb_find_mode() first tries the specified video mode (or any mode that matches,<BR>e.g. there can be multiple 640x480 modes, each of them is tried). If that<BR>fails, the default mode is tried. If that fails, it walks over all modes.</P>
<P>To specify a video mode at bootup, use the following boot options:<BR>&nbsp;&nbsp;&nbsp; video=&lt;driver&gt;:&lt;xres&gt;x&lt;yres&gt;[-&lt;bpp&gt;][@refresh]</P>
<P>where &lt;driver&gt; is a name from the table below.&nbsp; Valid default modes can be<BR>found in linux/drivers/video/modedb.c.&nbsp; Check your driver's documentation.<BR>There may be more modes.</P>
<P>&nbsp;&nbsp;&nbsp; Drivers that support modedb boot options<BR>&nbsp;&nbsp;&nbsp; Boot Name&nbsp;&nbsp; Cards Supported</P>
<P>&nbsp;&nbsp;&nbsp; amifb&nbsp;- Amiga chipset frame buffer<BR>&nbsp;&nbsp;&nbsp; aty128fb&nbsp;- ATI Rage128 / Pro frame buffer<BR>&nbsp;&nbsp;&nbsp; atyfb&nbsp;- ATI Mach64 frame buffer<BR>&nbsp;&nbsp;&nbsp; pm2fb&nbsp;- Permedia 2/2V frame buffer<BR>&nbsp;&nbsp;&nbsp; pm3fb&nbsp;- Permedia 3 frame buffer<BR>&nbsp;&nbsp;&nbsp; sstfb&nbsp;- Voodoo 1/2 (SST1) chipset frame buffer<BR>&nbsp;&nbsp;&nbsp; tdfxfb&nbsp;- 3D Fx frame buffer<BR>&nbsp;&nbsp;&nbsp; tridentfb&nbsp;- Trident (Cyber)blade chipset frame buffer<BR>&nbsp;&nbsp;&nbsp; vt8623fb&nbsp;- VIA 8623 frame buffer</P>
<P>BTW, only a few fb drivers use this at the moment. Others are to follow<BR>(feel free to send patches). The DRM drivers also support this.