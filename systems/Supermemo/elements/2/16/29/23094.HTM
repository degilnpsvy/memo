<H3 id=-100000 class=docSection1Title>Console Drivers</H3>
<P class=docText><A name=iddle1589></A><A name=iddle1592></A><A name=iddle3637></A><A name=A></A>A <SPAN class=docEmphasis>console</SPAN><A name="device that"></A> is a device that displays <TT>printk()</TT><A name="generated by"></A> messages generated by the kernel. If you look at <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec2.html#ch12fig05">Figure 12.5</A><A name="a top"></A>, you can see that console drivers lie in two tiers: a top level constituting drivers such as the virtual terminal driver, the printer console driver, and the example <TT>USB_UART</TT><A name="are responsible"></A> console driver (discussed soon), and bottom-level drivers that are responsible for advanced operations. Consequently, there are two main interface definition structures used by console drivers. Top-level console drivers revolve around <TT>struct console</TT>, which defines basic operations such as <TT>setup()</TT> and <TT>write()</TT>. Bottom-level drivers center on <TT>struct consw</TT><A name="and setting"></A> that specifies advanced operations such as setting cursor properties, console switching, blanking, resizing, and setting palette information. These structures are defined in <SPAN class=docEmphasis>include/linux/console.h</SPAN> as follows:</P>
<DIV style="FONT-WEIGHT: bold">
<OL class=docList type=1>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>
<DIV class=docText><PRE>struct console {
  char  name[8];
  void  (*write)(struct console *, const char *, unsigned);
  int   (*read)(struct console *, char *, unsigned);
  /* ... */
  void  (*unblank)(void);
  int   (*setup)(struct console *, char *);
  /* ... */
};</PRE></DIV>
<P></P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>
<DIV class=docText><PRE>struct consw {
  struct module *owner;
  const char *(*con_startup)(void);
  void        (*con_init)(struct vc_data *, int);
  void        (*con_deinit)(struct vc_data *);
  void        (*con_clear)(struct vc_data *, int, int, int, int);
  void        (*con_putc)(struct vc_data *, int, int, int);
  void        (*con_putcs)(struct vc_data *,
                           const unsigned short *, int, int, int);
  void        (*con_cursor)(struct vc_data *, int);
  int         (*con_scroll)(struct vc_data *, int, int, int, int);
  /* ... */
};</PRE></DIV>
<P></P></DIV></LI></OL></DIV>
<P class=docText><A name=at></A>As you might have guessed by looking at <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec2.html#ch12fig05">Figure 12.5</A><A name=The></A>, most console devices need both levels of drivers working in tandem. The <SPAN class=docEmphasis>vt</SPAN><A name="console driver"></A> driver is the top-level console driver in many situations. On PC-compatible systems, the VGA console driver (<SPAN class=docEmphasis>vgacon</SPAN><A name="the bottom"></A>) is usually the bottom-level console driver; whereas on embedded devices, the frame buffer console driver (<SPAN class=docEmphasis>fbcon</SPAN><A name="is often"></A>) is often the bottom-level driver. Because of the indirection offered by the frame buffer abstraction, fbcon, unlike other bottom-level console drivers, is hardware-independent.</P>
<P class=docText><A name=iddle1389></A><A name=iddle1591></A><A name="at the"></A>Let's briefly look at the architecture of both levels of console drivers:</P>
<UL>
<LI>
<P class=docList><A name="driver populates"></A>The top-level driver populates a <TT>struct console</TT><A name="kernel using"></A> with prescribed entry points and registers it with the kernel using <TT>register_console()</TT>. Unregistering is accomplished using <TT>unregister_console()</TT><A name="interacts with"></A>. This is the driver that interacts with <TT>printk()</TT><A name="the services"></A>. The entry points belonging to this driver call on the services of the associated bottom-level console driver.</P></LI>
<LI>
<P class=docList>The bottom-level console driver populates a <TT>struct consw</TT><A name="with the"></A> with specified entry points and registers it with the kernel using <TT>register_con_driver()</TT>. Unregistering is done using <TT>unregister_con_driver()</TT><A name=invoke></A>. When the system supports multiple console drivers, the driver might instead invoke <TT>take_over_console()</TT><A name="and take"></A> to register itself and take over the existing console. <TT>give_up_console()</TT><A name="For conventional"></A> accomplishes the reverse. For conventional displays, bottom-level drivers interact with the top-level vt console driver and the <SPAN class=docEmphasis>vc_screen</SPAN><A name="character driver"></A> character driver that allows access to virtual console memory.</P></LI></UL>
<P class=docText><A name="such as"></A>Some simple consoles, such as line printers and the <TT>USB_UART</TT><A name="need only"></A> discussed next, need only a top-level console driver.</P>
<P class=docText><A name="Display panels"></A>The fbcon driver in the 2.6 kernel also supports console rotation. Display panels on PDAs and cell phones are usually mounted in portrait orientation, whereas automotive dashboards and IP phones are examples of systems where the display panel is likely to be in landscape mode. Sometimes, due to economics or other factors, an embedded device may require a landscape LCD to be mounted in portrait mode or vice versa. Console rotation support comes handy in such situations. Because fbcon is hardware-independent, the console rotation implementation is also generic. To enable console rotation, enable <TT>CONFIG_FRAMEBUFFER_CONSOLE_ROTATION</TT> during kernel configuration and add <TT>fbcon=rotate:X</TT> to the kernel command line, where <TT>X</TT><A name="and "></A> is 0 for normal orientation, 1 for 90-degree rotation, 2 for 180-degree rotation, and 3 for 270-degree rotation.</P><A name=ch12lev2sec2></A>
<H4 id=title-ID0E15PM class=docSection2Title>Device Example: Cell Phone Revisited</H4>
<P class=docText><A name="cell phone"></A>To learn how to write console drivers, let's revisit the Linux cell phone that we used in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06.html#ch06">Chapter 6</A><A name="develop a"></A>. Our task in this section is to develop a console driver that operates over the <TT>USB_UART</TT>s in the cell phone. For convenience, <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec6.html#ch12fig07">Figure 12.7</A> reproduces the cell phone from <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06lev1sec2.html#ch06fig05">Figure 6.5</A> in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06.html#ch06">Chapter 6</A>. Let's write a console driver that gets <TT>printk()</TT> messages out of the door via a <TT>USB_UART</TT><A name="displayed to"></A>. The messages are picked up by a PC host and displayed to the user via a terminal emulator session.</P><A name=ch12fig07></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 12.7. Console over <TT>USB_UART</TT>.</H5>
<P class=docText>
<DIV class=st1><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/ZTVyMWQ5OHB0Z2lzMC8vbWMzNWE5NC9yMzZnMjdhZy5wX2xjc2kwMXQvNzJoZmlnaWFm.jpg" target=_blank>[View full size image]</A></DIV><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/ZTVyMWQ5OHB0Z2lzMC8vbWMzNWE5NC9yMzZnMjdhZ3AuaWNzaTAxLzdmMmhpZ2Y-.jpg" width=500 height=275>
<P></P></CENTER>
<P></P><BR>
<P class=docText><A name=iddle4515></A><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec6.html#ch12ex03">Listing 12.3</A><A name="driver that"></A> develops the console driver that works over the <TT>USB_UART</TT>s. The <TT>usb_uart_port[]</TT><A name="a few"></A> structure and a few definitions used by the <TT>USB_UART</TT><A name="driver in"></A> driver in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06.html#ch06">Chapter 6</A><A name="in this"></A> are included in this listing, too, to create a complete driver. Comments associated with the listing explain the driver's operation.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec6.html#ch12fig07">Figure 12.7</A><A name="the position"></A> shows the position of our example <TT>USB_UART</TT> console driver within the Linux-Video subsystem. As you can see, the <TT>USB_UART</TT> is a simple device that needs only a top-level console driver.</P><A name=ch12ex03></A>
<H5 id=title-ID0EKCAO class=docExampleTitle>Listing 12.3. Console over <TT>USB_UART</TT></H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks>Code View:</DIV><PRE>#include <LINUX console.h="">
#include <LINUX serial_core.h="">
#include <ASM io.h="">

#define USB_UART_PORTS          2          /* The cell phone has 2
                                              USB_UART ports */
/* Each USB_UART has a 3-byte register set consisting of
   UU_STATUS_REGISTER at offset 0, UU_READ_DATA_REGISTER at
   offset 1, and UU_WRITE_DATA_REGISTER at offset 2, as shown
   in Table One of Chapter 6, "Serial Drivers" */
#define USB_UART1_BASE           0xe8000000 /* Memory base for USB_UART1 */
#define USB_UART2_BASE           0xe9000000 /* Memory base for USB_UART1 */
#define USB_UART_REGISTER_SPACE  0x3
/* Semantics of bits in the status register */
#define USB_UART_TX_FULL         0x20
#define USB_UART_RX_EMPTY        0x10
#define USB_UART_STATUS          0x0F

#define USB_UART1_IRQ            3
#define USB_UART2_IRQ            4
#define USB_UART_CLK_FREQ        16000000
#define USB_UART_FIFO_SIZE       32

/* Parameters of each supported USB_UART port */
static struct uart_port usb_uart_port[] = {
  {
    .mapbase  = (unsigned int)USB_UART1_BASE,
    .iotype   = UPIO_MEM,             /* Memory mapped */
    .irq      = USB_UART1_IRQ,        /* IRQ */
    .uartclk  = USB_UART_CLK_FREQ,    /* Clock HZ */
    .fifosize = USB_UART_FIFO_SIZE,   /* Size of the FIFO */
    .flags    = UPF_BOOT_AUTOCONF,    /* UART port flag */
    .line     = 0,                    /* UART Line number */
  },
  {
    .mapbase   = (unsigned int)USB_UART2_BASE,
    .iotype    = UPIO_MEM,            /* Memory mapped */
    .irq       = USB_UART2_IRQ,       /* IRQ */
    .uartclk   = USB_UART_CLK_FREQ,   /* CLock HZ */
    .fifosize  = USB_UART_FIFO_SIZE,  /* Size of the FIFO */
    .flags     = UPF_BOOT_AUTOCONF,   /* UART port flag */
    .line      = 1,                   /* UART Line number */
  }
};

/* Write a character to the USB_UART port */
static void
usb_uart_putc(struct uart_port *port, unsigned char c)
{
  /* Wait until there is space in the TX FIFO of the USB_UART.
     Sense this by looking at the USB_UART_TX_FULL
     bit in the status register */
  while (__raw_readb(port-&gt;membase) &amp; USB_UART_TX_FULL);

  /* Write the character to the data port*/
  __raw_writeb(c, (port-&gt;membase+1));
}

/* Console write */
static void
usb_uart_console_write(struct console *co, const char *s,
                            u_int count)
{
  int i;

  /* Write each character */
  for (i = 0; i &lt; count; i++, s++) {
    usb_uart_putc(&amp;usb_uart_port[co-&gt;index], *s);
  }
}

/* Get communication parameters */
static void __init
usb_uart_console_get_options(struct uart_port *port,
                             int *baud, int *parity, int *bits)
{
  /* Read the current settings (possibly set by a bootloader)
     or return default values for parity, number of data bits,
     and baud rate */
  *parity = 'n';
  *bits = 8;
  *baud = 115200;
}

/* Setup console communication parameters */
static int __init
usb_uart_console_setup(struct console *co, char *options)
{
  struct uart_port *port;
  int baud, bits, parity, flow;

  /* Validate port number and get a handle to the
     appropriate structure */
  if (co-&gt;index == -1 || co-&gt;index &gt;= USB_UART_PORTS) {
    co-&gt;index = 0;
  }
  port = &amp;usb_uart_port[co-&gt;index];

  /* Use functions offered by the serial layer to parse options */
  if (options) {
    uart_parse_options(options, &amp;baud, &amp;parity, &amp;bits, &amp;flow);
  } else {
    usb_uart_console_get_options(port, &amp;baud, &amp;parity, &amp;bits);
  }
  return uart_set_options(port, co, baud, parity, bits, flow);
}

/* Populate the console structure */
static struct console usb_uart_console = {
  .name    = "ttyUU",                 /* Console name */
  .write   = usb_uart_console_write,  /* How to printk to the
                                         console */
  .device  = uart_console_device,     /* Provided by the serial core */
  .setup   = usb_uart_console_setup,  /* How to setup the console */
  .flags   = CON_PRINTBUFFER,         /* Default flag */
  .index   = -1,                      /* Init to invalid value */
};


/* Console Initialization */
static int __init
usb_uart_console_init(void)
{
  /* ... */

  /* Register this console */
  register_console(&amp;usb_uart_console);

  return 0;
}

console_initcall(usb_uart_console_init); /* Mark console init */

					  </ASM></LINUX></LINUX></PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText>&nbsp;</P>
<P class=docText><A name="the kernel"></A>After this driver has been built as part of the kernel, you can activate it by appending <TT>console=ttyUUX</TT> (where <TT>X</TT><A name="command line"></A> is 0 or 1) to the kernel command line.</P><A name=ch12lev2sec3></A>
<H4 id=title-ID0ERDAO class=docSection2Title>Boot Logo</H4>
<P class=docText><A name=iddle1314></A><A name=iddle1491></A><A name=iddle1492></A><A name=iddle1590></A><A name=iddle1722></A><A name="is the"></A>A popular feature offered by the frame buffer subsystem is the boot logo. To display a logo, enable <TT>CONFIG_LOGO</TT><A name="You may"></A> during kernel configuration and select an available logo. You may also add a custom logo image in the <SPAN class=docEmphasis>drivers/video/logo/</SPAN> directory.</P>
<P class=docText><SPAN class=docEmphasis>CLUT224</SPAN><A name="The working"></A> is a commonly used boot logo image format that supports 224 colors. The working of this format is similar to pseudo palettes described in the section "<A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec5.html#ch12lev3sec3">Color Modes</A><A name="a C"></A>." A CLUT224 image is a C file containing two structures:</P>
<UL>
<LI>
<P class=docList>A CLUT (<SPAN class=docEmphasis><A name="Up Table"></A>Color Look Up Table</SPAN><A name="which is"></A>), which is a character array of 224 RGB tuples (thus having a size of 224*3 bytes). Each 3-byte CLUT element is a combination of red, green, and blue colors.</P></LI>
<LI>
<P class=docList><A name="array whose"></A>A data array whose each byte is an index into the CLUT. The indices start at 32 and extend until 255 (thus supporting 224 colors). Index 32 refers to the first element in the CLUT. The logo manipulation code (in <SPAN class=docEmphasis>drivers/video/fbmem.c</SPAN><A name="frame buffer"></A>) creates frame buffer pixel data from the CLUT tuple corresponding to each index in the data array. Image display is accomplished using the low-level frame buffer driver's <TT>fb_imageblit()</TT> method, as indicated in the section "<A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec5.html#ch12lev3sec5">Accelerated Methods</A>."</P></LI></UL>
<P class=docText>Other supported logo formats are the 16-color <SPAN class=docEmphasis>vga16</SPAN> and the black-and-white <SPAN class=docEmphasis>mono</SPAN>. Scripts are available in the top-level <SPAN class=docEmphasis>scripts/</SPAN> directory to convert standard <SPAN class=docEmphasis>Portable Pixel Map</SPAN> (PPM) files to the supported logo formats.</P>
<P class=docText><A name="messages scroll"></A>If the frame buffer device is also the console, boot messages scroll under the logo. You may prefer to disable console messages on production-level systems (by adding <TT>console=/dev/null</TT><A name="display a"></A> to the kernel command line) and display a customer-supplied CLUT224 "splash screen" image as the boot logo.