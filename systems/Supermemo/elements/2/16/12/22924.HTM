# Documentation/scheduler/sched-stats.txt
<P></P>
<P>Version 15 of schedstats dropped counters for some sched_yield:<BR>yld_exp_empty, yld_act_empty and yld_both_empty. Otherwise, it is<BR>identical to version 14.</P>
<P></P>
<P>Version 14 of schedstats includes support for sched_domains, which hit the<BR>mainline kernel in 2.6.20 although it is identical to the stats from version<BR>12 which was in the kernel from 2.6.13-2.6.19 (version 13 never saw a kernel<BR>release).&nbsp; Some counters make more sense to be per-runqueue; other to be<BR>per-domain.&nbsp; Note that domains (and their associated information) will only<BR>be pertinent and available on machines utilizing CONFIG_SMP.</P>
<P>In version 14 of schedstat, there is at least one level of domain<BR>statistics for each cpu listed, and there may well be more than one<BR>domain.&nbsp; Domains have no particular names in this implementation, but<BR>the highest numbered one typically arbitrates balancing across all the<BR>cpus on the machine, while domain0 is the most tightly focused domain,<BR>sometimes balancing only between pairs of cpus.&nbsp; At this time, there<BR>are no architectures which need more than three domain levels. The first<BR>field in the domain stats is a bit map indicating which cpus are affected<BR>by that domain.</P>
<P>These fields are counters, and only increment.&nbsp; Programs which make use<BR>of these will need to start with a baseline observation and then calculate<BR>the change in the counters at each subsequent observation.&nbsp; A perl script<BR>which does this for many of the fields is available at</P>
<P>&nbsp;&nbsp;&nbsp; <A href="http://eaglet.rain.com/rick/linux/schedstat/">http://eaglet.rain.com/rick/linux/schedstat/</A></P>
<P>Note that any such script will necessarily be version-specific, as the main<BR>reason to change versions is changes in the output format.&nbsp; For those wishing<BR>to write their own scripts, the fields are described here.</P>
<P>CPU statistics<BR>--------------<BR>cpu&lt;N&gt; 1 2 3 4 5 6 7 8 9</P>
<P>First field is a sched_yield() statistic:<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1) # of times sched_yield() was called</P>
<P>Next three are schedule() statistics:<BR>&nbsp;&nbsp;&nbsp;&nbsp; 2) This field is a legacy array expiration count field used in the O(1)<BR>&nbsp;scheduler. We kept it for ABI compatibility, but it is always set to zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3) # of times schedule() was called<BR>&nbsp;&nbsp;&nbsp;&nbsp; 4) # of times schedule() left the processor idle</P>
<P>Next two are try_to_wake_up() statistics:<BR>&nbsp;&nbsp;&nbsp;&nbsp; 5) # of times try_to_wake_up() was called<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6) # of times try_to_wake_up() was called to wake up the local cpu</P>
<P>Next three are statistics describing scheduling latency:<BR>&nbsp;&nbsp;&nbsp;&nbsp; 7) sum of all time spent running by tasks on this processor (in jiffies)<BR>&nbsp;&nbsp;&nbsp;&nbsp; 8) sum of all time spent waiting to run by tasks on this processor (in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jiffies)<BR>&nbsp;&nbsp;&nbsp;&nbsp; 9) # of timeslices run on this cpu</P>
<P><BR>Domain statistics<BR>-----------------<BR>One of these is produced per domain for each cpu described. (Note that if<BR>CONFIG_SMP is not defined, *no* domains are utilized and these lines<BR>will not appear in the output.)</P>
<P>domain&lt;N&gt; &lt;cpumask&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36</P>
<P>The first field is a bit mask indicating what cpus this domain operates over.</P>
<P>The next 24 are a variety of load_balance() statistics in grouped into types<BR>of idleness (idle, busy, and newly idle):</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 1) # of times in this domain load_balance() was called when the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu was idle<BR>&nbsp;&nbsp;&nbsp;&nbsp; 2) # of times in this domain load_balance() checked but found<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the load did not require balancing when the cpu was idle<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3) # of times in this domain load_balance() tried to move one or<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more tasks and failed, when the cpu was idle<BR>&nbsp;&nbsp;&nbsp;&nbsp; 4) sum of imbalances discovered (if any) with each call to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load_balance() in this domain when the cpu was idle<BR>&nbsp;&nbsp;&nbsp;&nbsp; 5) # of times in this domain pull_task() was called when the cpu<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; was idle<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6) # of times in this domain pull_task() was called even though<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the target task was cache-hot when idle<BR>&nbsp;&nbsp;&nbsp;&nbsp; 7) # of times in this domain load_balance() was called but did<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not find a busier queue while the cpu was idle<BR>&nbsp;&nbsp;&nbsp;&nbsp; 8) # of times in this domain a busier queue was found while the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu was idle but no busier group was found</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 9) # of times in this domain load_balance() was called when the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu was busy<BR>&nbsp;&nbsp;&nbsp; 10) # of times in this domain load_balance() checked but found the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load did not require balancing when busy<BR>&nbsp;&nbsp;&nbsp; 11) # of times in this domain load_balance() tried to move one or<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more tasks and failed, when the cpu was busy<BR>&nbsp;&nbsp;&nbsp; 12) sum of imbalances discovered (if any) with each call to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load_balance() in this domain when the cpu was busy<BR>&nbsp;&nbsp;&nbsp; 13) # of times in this domain pull_task() was called when busy<BR>&nbsp;&nbsp;&nbsp; 14) # of times in this domain pull_task() was called even though the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target task was cache-hot when busy<BR>&nbsp;&nbsp;&nbsp; 15) # of times in this domain load_balance() was called but did not<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find a busier queue while the cpu was busy<BR>&nbsp;&nbsp;&nbsp; 16) # of times in this domain a busier queue was found while the cpu<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; was busy but no busier group was found</P>
<P>&nbsp;&nbsp;&nbsp; 17) # of times in this domain load_balance() was called when the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu was just becoming idle<BR>&nbsp;&nbsp;&nbsp; 18) # of times in this domain load_balance() checked but found the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load did not require balancing when the cpu was just becoming idle<BR>&nbsp;&nbsp;&nbsp; 19) # of times in this domain load_balance() tried to move one or more<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tasks and failed, when the cpu was just becoming idle<BR>&nbsp;&nbsp;&nbsp; 20) sum of imbalances discovered (if any) with each call to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load_balance() in this domain when the cpu was just becoming idle<BR>&nbsp;&nbsp;&nbsp; 21) # of times in this domain pull_task() was called when newly idle<BR>&nbsp;&nbsp;&nbsp; 22) # of times in this domain pull_task() was called even though the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target task was cache-hot when just becoming idle<BR>&nbsp;&nbsp;&nbsp; 23) # of times in this domain load_balance() was called but did not<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find a busier queue while the cpu was just becoming idle<BR>&nbsp;&nbsp;&nbsp; 24) # of times in this domain a busier queue was found while the cpu<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; was just becoming idle but no busier group was found</P>
<P>&nbsp;&nbsp; Next three are active_load_balance() statistics:<BR>&nbsp;&nbsp;&nbsp; 25) # of times active_load_balance() was called<BR>&nbsp;&nbsp;&nbsp; 26) # of times active_load_balance() tried to move a task and failed<BR>&nbsp;&nbsp;&nbsp; 27) # of times active_load_balance() successfully moved a task</P>
<P>&nbsp;&nbsp; Next three are sched_balance_exec() statistics:<BR>&nbsp;&nbsp;&nbsp; 28) sbe_cnt is not used<BR>&nbsp;&nbsp;&nbsp; 29) sbe_balanced is not used<BR>&nbsp;&nbsp;&nbsp; 30) sbe_pushed is not used</P>
<P>&nbsp;&nbsp; Next three are sched_balance_fork() statistics:<BR>&nbsp;&nbsp;&nbsp; 31) sbf_cnt is not used<BR>&nbsp;&nbsp;&nbsp; 32) sbf_balanced is not used<BR>&nbsp;&nbsp;&nbsp; 33) sbf_pushed is not used</P>
<P>&nbsp;&nbsp; Next three are try_to_wake_up() statistics:<BR>&nbsp;&nbsp;&nbsp; 34) # of times in this domain try_to_wake_up() awoke a task that<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last ran on a different cpu in this domain<BR>&nbsp;&nbsp;&nbsp; 35) # of times in this domain try_to_wake_up() moved a task to the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waking cpu because it was cache-cold on its own cpu anyway<BR>&nbsp;&nbsp;&nbsp; 36) # of times in this domain try_to_wake_up() started passive balancing</P>
<P>/proc/&lt;pid&gt;/schedstat<BR>----------------<BR>schedstats also adds a new /proc/&lt;pid&gt;/schedstat file to include some of<BR>the same information on a per-process level.&nbsp; There are three fields in<BR>this file correlating for that process to:<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1) time spent on the cpu<BR>&nbsp;&nbsp;&nbsp;&nbsp; 2) time spent waiting on a runqueue<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3) # of timeslices run on this cpu</P>
<P>A program could be easily written to make use of these extra fields to<BR>report on how well a particular process or set of processes is faring<BR>under the scheduler's policies.&nbsp; A simple version of such a program is<BR>available at<BR>&nbsp;&nbsp;&nbsp; <A href="http://eaglet.rain.com/rick/linux/schedstat/v12/latency.c">http://eaglet.rain.com/rick/linux/schedstat/v12/latency.c</A>