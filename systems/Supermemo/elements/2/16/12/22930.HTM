# Documentation/remoteproc.txt
<P></P>
<P>Remote Processor Framework</P>
<P></P>
<P>1. Introduction</P>
<P>Modern SoCs typically have heterogeneous remote processor devices in asymmetric<BR>multiprocessing (AMP) configurations, which may be running different instances<BR>of operating system, whether it's Linux or any other flavor of real-time OS.</P>
<P>OMAP4, for example, has dual Cortex-A9, dual Cortex-M3 and a C64x+ DSP.<BR>In a typical configuration, the dual cortex-A9 is running Linux in a SMP<BR>configuration, and each of the other three cores (two M3 cores and a DSP)<BR>is running its own instance of RTOS in an AMP configuration.</P>
<P>The remoteproc framework allows different platforms/architectures to<BR>control (power on, load firmware, power off) those remote processors while<BR>abstracting the hardware differences, so the entire driver doesn't need to be<BR>duplicated. In addition, this framework also adds rpmsg virtio devices<BR>for remote processors that supports this kind of communication. This way,<BR>platform-specific remoteproc drivers only need to provide a few low-level<BR>handlers, and then all rpmsg drivers will then just work<BR>(for more information about the virtio-based rpmsg bus and its drivers,<BR>please read Documentation/rpmsg.txt).<BR>Registration of other types of virtio devices is now also possible. Firmwares<BR>just need to publish what kind of virtio devices do they support, and then<BR>remoteproc will add those devices. This makes it possible to reuse the<BR>existing virtio drivers with remote processor backends at a minimal development<BR>cost.</P>
<P>2. User API</P>
<P>&nbsp; int rproc_boot(struct rproc *rproc)<BR>&nbsp;&nbsp;&nbsp; - Boot a remote processor (i.e. load its firmware, power it on, ...).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the remote processor is already powered on, this function immediately<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returns (successfully).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns 0 on success, and an appropriate error value otherwise.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note: to use this function you should already have a valid rproc<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle. There are several ways to achieve that cleanly (devres, pdata,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the way remoteproc_rpmsg.c does this, or, if this becomes prevalent, we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; might also consider using dev_archdata for this).</P>
<P>&nbsp; void rproc_shutdown(struct rproc *rproc)<BR>&nbsp;&nbsp;&nbsp; - Power off a remote processor (previously booted with rproc_boot()).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In case @rproc is still being used by an additional user(s), then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this function will just decrement the power refcount and exit,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; without really powering off the device.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Every call to rproc_boot() must (eventually) be accompanied by a call<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to rproc_shutdown(). Calling rproc_shutdown() redundantly is a bug.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Notes:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - we're not decrementing the rproc's refcount, only the power refcount.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which means that the @rproc handle stays valid even after<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rproc_shutdown() returns, and users can still use it with a subsequent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rproc_boot(), if needed.</P>
<P>3. Typical usage</P>
<P>#include &lt;linux/remoteproc.h&gt;</P>
<P>/* in case we were given a valid 'rproc' handle */<BR>int dummy_rproc_example(struct rproc *my_rproc)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;/* let's power on and boot our remote processor */<BR>&nbsp;ret = rproc_boot(my_rproc);<BR>&nbsp;if (ret) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * something went wrong. handle it and leave.<BR>&nbsp;&nbsp; */<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * our remote processor is now powered on... give it some work<BR>&nbsp; */</P>
<P>&nbsp;/* let's shut it down now */<BR>&nbsp;rproc_shutdown(my_rproc);<BR>}</P>
<P>4. API for implementors</P>
<P>&nbsp; struct rproc *rproc_alloc(struct device *dev, const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct rproc_ops *ops,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const char *firmware, int len)<BR>&nbsp;&nbsp;&nbsp; - Allocate a new remote processor handle, but don't register<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it yet. Required parameters are the underlying device, the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name of this remote processor, platform-specific ops handlers,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the name of the firmware to boot this rproc with, and the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length of private data needed by the allocating rproc driver (in bytes).</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function should be used by rproc implementations during<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initialization of the remote processor.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; After creating an rproc handle using this function, and when ready,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implementations should then call rproc_add() to complete<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the registration of the remote processor.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On success, the new rproc is returned, and on failure, NULL.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note: _never_ directly deallocate @rproc, even if it was not registered<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yet. Instead, when you need to unroll rproc_alloc(), use rproc_put().</P>
<P>&nbsp; void rproc_put(struct rproc *rproc)<BR>&nbsp;&nbsp;&nbsp; - Free an rproc handle that was allocated by rproc_alloc.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function essentially unrolls rproc_alloc(), by decrementing the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rproc's refcount. It doesn't directly free rproc; that would happen<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; only if there are no other references to rproc and its refcount now<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dropped to zero.</P>
<P>&nbsp; int rproc_add(struct rproc *rproc)<BR>&nbsp;&nbsp;&nbsp; - Register @rproc with the remoteproc framework, after it has been<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocated with rproc_alloc().<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is called by the platform-specific rproc implementation, whenever<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a new remote processor device is probed.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns 0 on success and an appropriate error code otherwise.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note: this function initiates an asynchronous firmware loading<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context, which will look for virtio devices supported by the rproc's<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firmware.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If found, those virtio devices will be created and added, so as a result<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of registering this remote processor, additional virtio drivers might get<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; probed.</P>
<P>&nbsp; int rproc_del(struct rproc *rproc)<BR>&nbsp;&nbsp;&nbsp; - Unroll rproc_add().<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function should be called when the platform specific rproc<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implementation decides to remove the rproc device. it should<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _only_ be called if a previous invocation of rproc_add()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; has completed successfully.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; After rproc_del() returns, @rproc is still valid, and its<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last refcount should be decremented by calling rproc_put().</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns 0 on success and -EINVAL if @rproc isn't valid.</P>
<P>&nbsp; void rproc_report_crash(struct rproc *rproc, enum rproc_crash_type type)<BR>&nbsp;&nbsp;&nbsp; - Report a crash in a remoteproc<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function must be called every time a crash is detected by the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; platform specific rproc implementation. This should not be called from a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; non-remoteproc driver. This function can be called from atomic/interrupt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.</P>
<P>5. Implementation callbacks</P>
<P>These callbacks should be provided by platform-specific remoteproc<BR>drivers:</P>
<P>/**<BR>&nbsp;* struct rproc_ops - platform-specific device handlers<BR>&nbsp;* @start:&nbsp;power on the device and boot it<BR>&nbsp;* @stop:&nbsp;power off the device<BR>&nbsp;* @kick:&nbsp;kick a virtqueue (virtqueue id given as a parameter)<BR>&nbsp;*/<BR>struct rproc_ops {<BR>&nbsp;int (*start)(struct rproc *rproc);<BR>&nbsp;int (*stop)(struct rproc *rproc);<BR>&nbsp;void (*kick)(struct rproc *rproc, int vqid);<BR>};</P>
<P>Every remoteproc implementation should at least provide the -&gt;start and -&gt;stop<BR>handlers. If rpmsg/virtio functionality is also desired, then the -&gt;kick handler<BR>should be provided as well.</P>
<P>The -&gt;start() handler takes an rproc handle and should then power on the<BR>device and boot it (use rproc-&gt;priv to access platform-specific private data).<BR>The boot address, in case needed, can be found in rproc-&gt;bootaddr (remoteproc<BR>core puts there the ELF entry point).<BR>On success, 0 should be returned, and on failure, an appropriate error code.</P>
<P>The -&gt;stop() handler takes an rproc handle and powers the device down.<BR>On success, 0 is returned, and on failure, an appropriate error code.</P>
<P>The -&gt;kick() handler takes an rproc handle, and an index of a virtqueue<BR>where new message was placed in. Implementations should interrupt the remote<BR>processor and let it know it has pending messages. Notifying remote processors<BR>the exact virtqueue index to look in is optional: it is easy (and not<BR>too expensive) to go through the existing virtqueues and look for new buffers<BR>in the used rings.</P>
<P>6. Binary Firmware Structure</P>
<P>At this point remoteproc only supports ELF32 firmware binaries. However,<BR>it is quite expected that other platforms/devices which we'd want to<BR>support with this framework will be based on different binary formats.</P>
<P>When those use cases show up, we will have to decouple the binary format<BR>from the framework core, so we can support several binary formats without<BR>duplicating common code.</P>
<P>When the firmware is parsed, its various segments are loaded to memory<BR>according to the specified device address (might be a physical address<BR>if the remote processor is accessing memory directly).</P>
<P>In addition to the standard ELF segments, most remote processors would<BR>also include a special section which we call "the resource table".</P>
<P>The resource table contains system resources that the remote processor<BR>requires before it should be powered on, such as allocation of physically<BR>contiguous memory, or iommu mapping of certain on-chip peripherals.<BR>Remotecore will only power up the device after all the resource table's<BR>requirement are met.</P>
<P>In addition to system resources, the resource table may also contain<BR>resource entries that publish the existence of supported features<BR>or configurations by the remote processor, such as trace buffers and<BR>supported virtio devices (and their configurations).</P>
<P>The resource table begins with this header:</P>
<P>/**<BR>&nbsp;* struct resource_table - firmware resource table header<BR>&nbsp;* @ver: version number<BR>&nbsp;* @num: number of resource entries<BR>&nbsp;* @reserved: reserved (must be zero)<BR>&nbsp;* @offset: array of offsets pointing at the various resource entries<BR>&nbsp;*<BR>&nbsp;* The header of the resource table, as expressed by this structure,<BR>&nbsp;* contains a version number (should we need to change this format in the<BR>&nbsp;* future), the number of available resource entries, and their offsets<BR>&nbsp;* in the table.<BR>&nbsp;*/<BR>struct resource_table {<BR>&nbsp;u32 ver;<BR>&nbsp;u32 num;<BR>&nbsp;u32 reserved[2];<BR>&nbsp;u32 offset[0];<BR>} __packed;</P>
<P>Immediately following this header are the resource entries themselves,<BR>each of which begins with the following resource entry header:</P>
<P>/**<BR>&nbsp;* struct fw_rsc_hdr - firmware resource entry header<BR>&nbsp;* @type: resource type<BR>&nbsp;* @data: resource data<BR>&nbsp;*<BR>&nbsp;* Every resource entry begins with a 'struct fw_rsc_hdr' header providing<BR>&nbsp;* its @type. The content of the entry itself will immediately follow<BR>&nbsp;* this header, and it should be parsed according to the resource type.<BR>&nbsp;*/<BR>struct fw_rsc_hdr {<BR>&nbsp;u32 type;<BR>&nbsp;u8 data[0];<BR>} __packed;</P>
<P>Some resources entries are mere announcements, where the host is informed<BR>of specific remoteproc configuration. Other entries require the host to<BR>do something (e.g. allocate a system resource). Sometimes a negotiation<BR>is expected, where the firmware requests a resource, and once allocated,<BR>the host should provide back its details (e.g. address of an allocated<BR>memory region).</P>
<P>Here are the various resource types that are currently supported:</P>
<P>/**<BR>&nbsp;* enum fw_resource_type - types of resource entries<BR>&nbsp;*<BR>&nbsp;* @RSC_CARVEOUT:&nbsp;&nbsp; request for allocation of a physically contiguous<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memory region.<BR>&nbsp;* @RSC_DEVMEM:&nbsp;&nbsp;&nbsp;&nbsp; request to iommu_map a memory-based peripheral.<BR>&nbsp;* @RSC_TRACE:&nbsp;&nbsp;&nbsp;&nbsp; announces the availability of a trace buffer into which<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the remote processor will be writing logs.<BR>&nbsp;* @RSC_VDEV:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declare support for a virtio device, and serve as its<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtio header.<BR>&nbsp;* @RSC_LAST:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; just keep this one at the end<BR>&nbsp;*<BR>&nbsp;* Please note that these values are used as indices to the rproc_handle_rsc<BR>&nbsp;* lookup table, so please keep them sane. Moreover, @RSC_LAST is used to<BR>&nbsp;* check the validity of an index before the lookup table is accessed, so<BR>&nbsp;* please update it as needed.<BR>&nbsp;*/<BR>enum fw_resource_type {<BR>&nbsp;RSC_CARVEOUT&nbsp;= 0,<BR>&nbsp;RSC_DEVMEM&nbsp;= 1,<BR>&nbsp;RSC_TRACE&nbsp;= 2,<BR>&nbsp;RSC_VDEV&nbsp;= 3,<BR>&nbsp;RSC_LAST&nbsp;= 4,<BR>};</P>
<P>For more details regarding a specific resource type, please see its<BR>dedicated structure in include/linux/remoteproc.h.</P>
<P>We also expect that platform-specific resource entries will show up<BR>at some point. When that happens, we could easily add a new RSC_PLATFORM<BR>type, and hand those resources to the platform-specific rproc driver to handle.</P>
<P>7. Virtio and remoteproc</P>
<P>The firmware should provide remoteproc information about virtio devices<BR>that it supports, and their configurations: a RSC_VDEV resource entry<BR>should specify the virtio device id (as in virtio_ids.h), virtio features,<BR>virtio config space, vrings information, etc.</P>
<P>When a new remote processor is registered, the remoteproc framework<BR>will look for its resource table and will register the virtio devices<BR>it supports. A firmware may support any number of virtio devices, and<BR>of any type (a single remote processor can also easily support several<BR>rpmsg virtio devices this way, if desired).</P>
<P>Of course, RSC_VDEV resource entries are only good enough for static<BR>allocation of virtio devices. Dynamic allocations will also be made possible<BR>using the rpmsg bus (similar to how we already do dynamic allocations of<BR>rpmsg channels; read more about it in rpmsg.txt).