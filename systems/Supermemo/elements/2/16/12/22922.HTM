# Documentation/scheduler/sched-nice-design.txt&nbsp; 
<P></P>
<P>This document explains the thinking about the revamped and streamlined<BR>nice-levels implementation in the new Linux scheduler.</P>
<P></P>
<P>Nice levels were always pretty weak under Linux and people continuously<BR>pestered us to make nice +19 tasks use up much less CPU time.</P>
<P>Unfortunately that was not that easy to implement under the old<BR>scheduler, (otherwise we'd have done it long ago) because nice level<BR>support was historically coupled to timeslice length, and timeslice<BR>units were driven by the HZ tick, so the smallest timeslice was 1/HZ.</P>
<P>In the O(1) scheduler (in 2003) we changed negative nice levels to be<BR>much stronger than they were before in 2.4 (and people were happy about<BR>that change), and we also intentionally calibrated the linear timeslice<BR>rule so that nice +19 level would be _exactly_ 1 jiffy. To better<BR>understand it, the timeslice graph went like this (cheesy ASCII art<BR>alert!):</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; | [timeslice length]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \|___100msecs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |^ . _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ . _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ . _<BR>&nbsp;-*----------------------------------*-----&gt; [nice level]<BR>&nbsp;-20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +19<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</P>
<P>So that if someone wanted to really renice tasks, +19 would give a much<BR>bigger hit than the normal linear rule would do. (The solution of<BR>changing the ABI to extend priorities was discarded early on.)</P>
<P>This approach worked to some degree for some time, but later on with<BR>HZ=1000 it caused 1 jiffy to be 1 msec, which meant 0.1% CPU usage which<BR>we felt to be a bit excessive. Excessive _not_ because it's too small of<BR>a CPU utilization, but because it causes too frequent (once per<BR>millisec) rescheduling. (and would thus trash the cache, etc. Remember,<BR>this was long ago when hardware was weaker and caches were smaller, and<BR>people were running number crunching apps at nice +19.)</P>
<P>So for HZ=1000 we changed nice +19 to 5msecs, because that felt like the<BR>right minimal granularity - and this translates to 5% CPU utilization.<BR>But the fundamental HZ-sensitive property for nice+19 still remained,<BR>and we never got a single complaint about nice +19 being too _weak_ in<BR>terms of CPU utilization, we only got complaints about it (still) being<BR>too _strong_ :-)</P>
<P>To sum it up: we always wanted to make nice levels more consistent, but<BR>within the constraints of HZ and jiffies and their nasty design level<BR>coupling to timeslices and granularity it was not really viable.</P>
<P>The second (less frequent but still periodically occurring) complaint<BR>about Linux's nice level support was its assymetry around the origo<BR>(which you can see demonstrated in the picture above), or more<BR>accurately: the fact that nice level behavior depended on the _absolute_<BR>nice level as well, while the nice API itself is fundamentally<BR>"relative":</P>
<P>&nbsp;&nbsp; int nice(int inc);</P>
<P>&nbsp;&nbsp; asmlinkage long sys_nice(int increment)</P>
<P>(the first one is the glibc API, the second one is the syscall API.)<BR>Note that the 'inc' is relative to the current nice level. Tools like<BR>bash's "nice" command mirror this relative API.</P>
<P>With the old scheduler, if you for example started a niced task with +1<BR>and another task with +2, the CPU split between the two tasks would<BR>depend on the nice level of the parent shell - if it was at nice -10 the<BR>CPU split was different than if it was at +5 or +10.</P>
<P>A third complaint against Linux's nice level support was that negative<BR>nice levels were not 'punchy enough', so lots of people had to resort to<BR>run audio (and other multimedia) apps under RT priorities such as<BR>SCHED_FIFO. But this caused other problems: SCHED_FIFO is not starvation<BR>proof, and a buggy SCHED_FIFO app can also lock up the system for good.</P>
<P>The new scheduler in v2.6.23 addresses all three types of complaints:</P>
<P>To address the first complaint (of nice levels being not "punchy"<BR>enough), the scheduler was decoupled from 'time slice' and HZ concepts<BR>(and granularity was made a separate concept from nice levels) and thus<BR>it was possible to implement better and more consistent nice +19<BR>support: with the new scheduler nice +19 tasks get a HZ-independent<BR>1.5%, instead of the variable 3%-5%-9% range they got in the old<BR>scheduler.</P>
<P>To address the second complaint (of nice levels not being consistent),<BR>the new scheduler makes nice(1) have the same CPU utilization effect on<BR>tasks, regardless of their absolute nice levels. So on the new<BR>scheduler, running a nice +10 and a nice 11 task has the same CPU<BR>utilization "split" between them as running a nice -5 and a nice -4<BR>task. (one will get 55% of the CPU, the other 45%.) That is why nice<BR>levels were changed to be "multiplicative" (or exponential) - that way<BR>it does not matter which nice level you start out from, the 'relative<BR>result' will always be the same.</P>
<P>The third complaint (of negative nice levels not being "punchy" enough<BR>and forcing audio apps to run under the more dangerous SCHED_FIFO<BR>scheduling policy) is addressed by the new scheduler almost<BR>automatically: stronger negative nice levels are an automatic<BR>side-effect of the recalibrated dynamic range of nice levels.