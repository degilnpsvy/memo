# Documentation/xz.txt
<P></P>
<P>XZ data compression in Linux<BR>============================</P>
<P></P>
<P>Introduction</P>
<P>&nbsp;&nbsp;&nbsp; XZ is a general purpose data compression format with high compression<BR>&nbsp;&nbsp;&nbsp; ratio and relatively fast decompression. The primary compression<BR>&nbsp;&nbsp;&nbsp; algorithm (filter) is LZMA2. Additional filters can be used to improve<BR>&nbsp;&nbsp;&nbsp; compression ratio even further. E.g. Branch/Call/Jump (BCJ) filters<BR>&nbsp;&nbsp;&nbsp; improve compression ratio of executable data.</P>
<P>&nbsp;&nbsp;&nbsp; The XZ decompressor in Linux is called XZ Embedded. It supports<BR>&nbsp;&nbsp;&nbsp; the LZMA2 filter and optionally also BCJ filters. CRC32 is supported<BR>&nbsp;&nbsp;&nbsp; for integrity checking. The home page of XZ Embedded is at<BR>&nbsp;&nbsp;&nbsp; &lt;<A href="http://tukaani.org/xz/embedded.html">http://tukaani.org/xz/embedded.html</A>&gt;, where you can find the<BR>&nbsp;&nbsp;&nbsp; latest version and also information about using the code outside<BR>&nbsp;&nbsp;&nbsp; the Linux kernel.</P>
<P>&nbsp;&nbsp;&nbsp; For userspace, XZ Utils provide a zlib-like compression library<BR>&nbsp;&nbsp;&nbsp; and a gzip-like command line tool. XZ Utils can be downloaded from<BR>&nbsp;&nbsp;&nbsp; &lt;<A href="http://tukaani.org/xz/">http://tukaani.org/xz/</A>&gt;.</P>
<P>XZ related components in the kernel</P>
<P>&nbsp;&nbsp;&nbsp; The xz_dec module provides XZ decompressor with single-call (buffer<BR>&nbsp;&nbsp;&nbsp; to buffer) and multi-call (stateful) APIs. The usage of the xz_dec<BR>&nbsp;&nbsp;&nbsp; module is documented in include/linux/xz.h.</P>
<P>&nbsp;&nbsp;&nbsp; The xz_dec_test module is for testing xz_dec. xz_dec_test is not<BR>&nbsp;&nbsp;&nbsp; useful unless you are hacking the XZ decompressor. xz_dec_test<BR>&nbsp;&nbsp;&nbsp; allocates a char device major dynamically to which one can write<BR>&nbsp;&nbsp;&nbsp; .xz files from userspace. The decompressed output is thrown away.<BR>&nbsp;&nbsp;&nbsp; Keep an eye on dmesg to see diagnostics printed by xz_dec_test.<BR>&nbsp;&nbsp;&nbsp; See the xz_dec_test source code for the details.</P>
<P>&nbsp;&nbsp;&nbsp; For decompressing the kernel image, initramfs, and initrd, there<BR>&nbsp;&nbsp;&nbsp; is a wrapper function in lib/decompress_unxz.c. Its API is the<BR>&nbsp;&nbsp;&nbsp; same as in other decompress_*.c files, which is defined in<BR>&nbsp;&nbsp;&nbsp; include/linux/decompress/generic.h.</P>
<P>&nbsp;&nbsp;&nbsp; scripts/xz_wrap.sh is a wrapper for the xz command line tool found<BR>&nbsp;&nbsp;&nbsp; from XZ Utils. The wrapper sets compression options to values suitable<BR>&nbsp;&nbsp;&nbsp; for compressing the kernel image.</P>
<P>&nbsp;&nbsp;&nbsp; For kernel makefiles, two commands are provided for use with<BR>&nbsp;&nbsp;&nbsp; $(call if_needed). The kernel image should be compressed with<BR>&nbsp;&nbsp;&nbsp; $(call if_needed,xzkern) which will use a BCJ filter and a big LZMA2<BR>&nbsp;&nbsp;&nbsp; dictionary. It will also append a four-byte trailer containing the<BR>&nbsp;&nbsp;&nbsp; uncompressed size of the file, which is needed by the boot code.<BR>&nbsp;&nbsp;&nbsp; Other things should be compressed with $(call if_needed,xzmisc)<BR>&nbsp;&nbsp;&nbsp; which will use no BCJ filter and 1 MiB LZMA2 dictionary.</P>
<P>Notes on compression options</P>
<P>&nbsp;&nbsp;&nbsp; Since the XZ Embedded supports only streams with no integrity check or<BR>&nbsp;&nbsp;&nbsp; CRC32, make sure that you don't use some other integrity check type<BR>&nbsp;&nbsp;&nbsp; when encoding files that are supposed to be decoded by the kernel. With<BR>&nbsp;&nbsp;&nbsp; liblzma, you need to use either LZMA_CHECK_NONE or LZMA_CHECK_CRC32<BR>&nbsp;&nbsp;&nbsp; when encoding. With the xz command line tool, use --check=none or<BR>&nbsp;&nbsp;&nbsp; --check=crc32.</P>
<P>&nbsp;&nbsp;&nbsp; Using CRC32 is strongly recommended unless there is some other layer<BR>&nbsp;&nbsp;&nbsp; which will verify the integrity of the uncompressed data anyway.<BR>&nbsp;&nbsp;&nbsp; Double checking the integrity would probably be waste of CPU cycles.<BR>&nbsp;&nbsp;&nbsp; Note that the headers will always have a CRC32 which will be validated<BR>&nbsp;&nbsp;&nbsp; by the decoder; you can only change the integrity check type (or<BR>&nbsp;&nbsp;&nbsp; disable it) for the actual uncompressed data.</P>
<P>&nbsp;&nbsp;&nbsp; In userspace, LZMA2 is typically used with dictionary sizes of several<BR>&nbsp;&nbsp;&nbsp; megabytes. The decoder needs to have the dictionary in RAM, thus big<BR>&nbsp;&nbsp;&nbsp; dictionaries cannot be used for files that are intended to be decoded<BR>&nbsp;&nbsp;&nbsp; by the kernel. 1 MiB is probably the maximum reasonable dictionary<BR>&nbsp;&nbsp;&nbsp; size for in-kernel use (maybe more is OK for initramfs). The presets<BR>&nbsp;&nbsp;&nbsp; in XZ Utils may not be optimal when creating files for the kernel,<BR>&nbsp;&nbsp;&nbsp; so don't hesitate to use custom settings. Example:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xz --check=crc32 --lzma2=dict=512KiB inputfile</P>
<P>&nbsp;&nbsp;&nbsp; An exception to above dictionary size limitation is when the decoder<BR>&nbsp;&nbsp;&nbsp; is used in single-call mode. Decompressing the kernel itself is an<BR>&nbsp;&nbsp;&nbsp; example of this situation. In single-call mode, the memory usage<BR>&nbsp;&nbsp;&nbsp; doesn't depend on the dictionary size, and it is perfectly fine to<BR>&nbsp;&nbsp;&nbsp; use a big dictionary: for maximum compression, the dictionary should<BR>&nbsp;&nbsp;&nbsp; be at least as big as the uncompressed data itself.</P>
<P>Future plans</P>
<P>&nbsp;&nbsp;&nbsp; Creating a limited XZ encoder may be considered if people think it is<BR>&nbsp;&nbsp;&nbsp; useful. LZMA2 is slower to compress than e.g. Deflate or LZO even at<BR>&nbsp;&nbsp;&nbsp; the fastest settings, so it isn't clear if LZMA2 encoder is wanted<BR>&nbsp;&nbsp;&nbsp; into the kernel.</P>
<P>&nbsp;&nbsp;&nbsp; Support for limited random-access reading is planned for the<BR>&nbsp;&nbsp;&nbsp; decompression code. I don't know if it could have any use in the<BR>&nbsp;&nbsp;&nbsp; kernel, but I know that it would be useful in some embedded projects<BR>&nbsp;&nbsp;&nbsp; outside the Linux kernel.</P>
<P>Conformance to the .xz file format specification</P>
<P>&nbsp;&nbsp;&nbsp; There are a couple of corner cases where things have been simplified<BR>&nbsp;&nbsp;&nbsp; at expense of detecting errors as early as possible. These should not<BR>&nbsp;&nbsp;&nbsp; matter in practice all, since they don't cause security issues. But<BR>&nbsp;&nbsp;&nbsp; it is good to know this if testing the code e.g. with the test files<BR>&nbsp;&nbsp;&nbsp; from XZ Utils.</P>
<P>Reporting bugs</P>
<P>&nbsp;&nbsp;&nbsp; Before reporting a bug, please check that it's not fixed already<BR>&nbsp;&nbsp;&nbsp; at upstream. See &lt;<A href="http://tukaani.org/xz/embedded.html">http://tukaani.org/xz/embedded.html</A>&gt; to get the<BR>&nbsp;&nbsp;&nbsp; latest code.</P>
<P>&nbsp;&nbsp;&nbsp; Report bugs to &lt;<A href="mailto:lasse.collin@tukaani.org">lasse.collin@tukaani.org</A>&gt; or visit #tukaani on<BR>&nbsp;&nbsp;&nbsp; Freenode and talk to Larhzu. I don't actively read LKML or other<BR>&nbsp;&nbsp;&nbsp; kernel-related mailing lists, so if there's something I should know,<BR>&nbsp;&nbsp;&nbsp; you should email to me personally or use IRC.</P>
<P>&nbsp;&nbsp;&nbsp; Don't bother Igor Pavlov with questions about the XZ implementation<BR>&nbsp;&nbsp;&nbsp; in the kernel or about XZ Utils. While these two implementations<BR>&nbsp;&nbsp;&nbsp; include essential code that is directly based on Igor Pavlov's code,<BR>&nbsp;&nbsp;&nbsp; these implementations aren't maintained nor supported by him.