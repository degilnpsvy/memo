# Documentation/stable_api_nonsense.txt 
<P></P>
<P>The Linux Kernel Driver Interface<BR>(all of your questions answered and then some)</P>
<P></P>
<P>Greg Kroah-Hartman &lt;<A href="mailto:greg@kroah.com">greg@kroah.com</A>&gt;</P>
<P>This is being written to try to explain why Linux does not have a binary<BR>kernel interface, nor does it have a stable kernel interface.&nbsp; Please<BR>realize that this article describes the _in kernel_ interfaces, not the<BR>kernel to userspace interfaces.&nbsp; The kernel to userspace interface is<BR>the one that application programs use, the syscall interface.&nbsp; That<BR>interface is _very_ stable over time, and will not break.&nbsp; I have old<BR>programs that were built on a pre 0.9something kernel that still work<BR>just fine on the latest 2.6 kernel release.&nbsp; That interface is the one<BR>that users and application programmers can count on being stable.</P>
<P><BR>Executive Summary<BR>-----------------<BR>You think you want a stable kernel interface, but you really do not, and<BR>you don't even know it.&nbsp; What you want is a stable running driver, and<BR>you get that only if your driver is in the main kernel tree.&nbsp; You also<BR>get lots of other good benefits if your driver is in the main kernel<BR>tree, all of which has made Linux into such a strong, stable, and mature<BR>operating system which is the reason you are using it in the first<BR>place.</P>
<P><BR>Intro<BR>-----</P>
<P>It's only the odd person who wants to write a kernel driver that needs<BR>to worry about the in-kernel interfaces changing.&nbsp; For the majority of<BR>the world, they neither see this interface, nor do they care about it at<BR>all.</P>
<P>First off, I'm not going to address _any_ legal issues about closed<BR>source, hidden source, binary blobs, source wrappers, or any other term<BR>that describes kernel drivers that do not have their source code<BR>released under the GPL.&nbsp; Please consult a lawyer if you have any legal<BR>questions, I'm a programmer and hence, I'm just going to be describing<BR>the technical issues here (not to make light of the legal issues, they<BR>are real, and you do need to be aware of them at all times.)</P>
<P>So, there are two main topics here, binary kernel interfaces and stable<BR>kernel source interfaces.&nbsp; They both depend on each other, but we will<BR>discuss the binary stuff first to get it out of the way.</P>
<P><BR>Binary Kernel Interface<BR>-----------------------<BR>Assuming that we had a stable kernel source interface for the kernel, a<BR>binary interface would naturally happen too, right?&nbsp; Wrong.&nbsp; Please<BR>consider the following facts about the Linux kernel:<BR>&nbsp; - Depending on the version of the C compiler you use, different kernel<BR>&nbsp;&nbsp;&nbsp; data structures will contain different alignment of structures, and<BR>&nbsp;&nbsp;&nbsp; possibly include different functions in different ways (putting<BR>&nbsp;&nbsp;&nbsp; functions inline or not.)&nbsp; The individual function organization<BR>&nbsp;&nbsp;&nbsp; isn't that important, but the different data structure padding is<BR>&nbsp;&nbsp;&nbsp; very important.<BR>&nbsp; - Depending on what kernel build options you select, a wide range of<BR>&nbsp;&nbsp;&nbsp; different things can be assumed by the kernel:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - different structures can contain different fields<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Some functions may not be implemented at all, (i.e. some locks<BR>&nbsp;compile away to nothing for non-SMP builds.)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Memory within the kernel can be aligned in different ways,<BR>&nbsp;depending on the build options.<BR>&nbsp; - Linux runs on a wide range of different processor architectures.<BR>&nbsp;&nbsp;&nbsp; There is no way that binary drivers from one architecture will run<BR>&nbsp;&nbsp;&nbsp; on another architecture properly.</P>
<P>Now a number of these issues can be addressed by simply compiling your<BR>module for the exact specific kernel configuration, using the same exact<BR>C compiler that the kernel was built with.&nbsp; This is sufficient if you<BR>want to provide a module for a specific release version of a specific<BR>Linux distribution.&nbsp; But multiply that single build by the number of<BR>different Linux distributions and the number of different supported<BR>releases of the Linux distribution and you quickly have a nightmare of<BR>different build options on different releases.&nbsp; Also realize that each<BR>Linux distribution release contains a number of different kernels, all<BR>tuned to different hardware types (different processor types and<BR>different options), so for even a single release you will need to create<BR>multiple versions of your module.</P>
<P>Trust me, you will go insane over time if you try to support this kind<BR>of release, I learned this the hard way a long time ago...</P>
<P><BR>Stable Kernel Source Interfaces<BR>-------------------------------</P>
<P>This is a much more "volatile" topic if you talk to people who try to<BR>keep a Linux kernel driver that is not in the main kernel tree up to<BR>date over time.</P>
<P>Linux kernel development is continuous and at a rapid pace, never<BR>stopping to slow down.&nbsp; As such, the kernel developers find bugs in<BR>current interfaces, or figure out a better way to do things.&nbsp; If they do<BR>that, they then fix the current interfaces to work better.&nbsp; When they do<BR>so, function names may change, structures may grow or shrink, and<BR>function parameters may be reworked.&nbsp; If this happens, all of the<BR>instances of where this interface is used within the kernel are fixed up<BR>at the same time, ensuring that everything continues to work properly.</P>
<P>As a specific examples of this, the in-kernel USB interfaces have<BR>undergone at least three different reworks over the lifetime of this<BR>subsystem.&nbsp; These reworks were done to address a number of different<BR>issues:<BR>&nbsp; - A change from a synchronous model of data streams to an asynchronous<BR>&nbsp;&nbsp;&nbsp; one.&nbsp; This reduced the complexity of a number of drivers and<BR>&nbsp;&nbsp;&nbsp; increased the throughput of all USB drivers such that we are now<BR>&nbsp;&nbsp;&nbsp; running almost all USB devices at their maximum speed possible.<BR>&nbsp; - A change was made in the way data packets were allocated from the<BR>&nbsp;&nbsp;&nbsp; USB core by USB drivers so that all drivers now needed to provide<BR>&nbsp;&nbsp;&nbsp; more information to the USB core to fix a number of documented<BR>&nbsp;&nbsp;&nbsp; deadlocks.</P>
<P>This is in stark contrast to a number of closed source operating systems<BR>which have had to maintain their older USB interfaces over time.&nbsp; This<BR>provides the ability for new developers to accidentally use the old<BR>interfaces and do things in improper ways, causing the stability of the<BR>operating system to suffer.</P>
<P>In both of these instances, all developers agreed that these were<BR>important changes that needed to be made, and they were made, with<BR>relatively little pain.&nbsp; If Linux had to ensure that it will preserve a<BR>stable source interface, a new interface would have been created, and<BR>the older, broken one would have had to be maintained over time, leading<BR>to extra work for the USB developers.&nbsp; Since all Linux USB developers do<BR>their work on their own time, asking programmers to do extra work for no<BR>gain, for free, is not a possibility.</P>
<P>Security issues are also very important for Linux.&nbsp; When a<BR>security issue is found, it is fixed in a very short amount of time.&nbsp; A<BR>number of times this has caused internal kernel interfaces to be<BR>reworked to prevent the security problem from occurring.&nbsp; When this<BR>happens, all drivers that use the interfaces were also fixed at the<BR>same time, ensuring that the security problem was fixed and could not<BR>come back at some future time accidentally.&nbsp; If the internal interfaces<BR>were not allowed to change, fixing this kind of security problem and<BR>insuring that it could not happen again would not be possible.</P>
<P>Kernel interfaces are cleaned up over time.&nbsp; If there is no one using a<BR>current interface, it is deleted.&nbsp; This ensures that the kernel remains<BR>as small as possible, and that all potential interfaces are tested as<BR>well as they can be (unused interfaces are pretty much impossible to<BR>test for validity.)</P>
<P><BR>What to do<BR>----------</P>
<P>So, if you have a Linux kernel driver that is not in the main kernel<BR>tree, what are you, a developer, supposed to do?&nbsp; Releasing a binary<BR>driver for every different kernel version for every distribution is a<BR>nightmare, and trying to keep up with an ever changing kernel interface<BR>is also a rough job.</P>
<P>Simple, get your kernel driver into the main kernel tree (remember we<BR>are talking about GPL released drivers here, if your code doesn't fall<BR>under this category, good luck, you are on your own here, you leech<BR>&lt;insert link to leech comment from Andrew and Linus here&gt;.)&nbsp; If your<BR>driver is in the tree, and a kernel interface changes, it will be fixed<BR>up by the person who did the kernel change in the first place.&nbsp; This<BR>ensures that your driver is always buildable, and works over time, with<BR>very little effort on your part.</P>
<P>The very good side effects of having your driver in the main kernel tree<BR>are:<BR>&nbsp; - The quality of the driver will rise as the maintenance costs (to the<BR>&nbsp;&nbsp;&nbsp; original developer) will decrease.<BR>&nbsp; - Other developers will add features to your driver.<BR>&nbsp; - Other people will find and fix bugs in your driver.<BR>&nbsp; - Other people will find tuning opportunities in your driver.<BR>&nbsp; - Other people will update the driver for you when external interface<BR>&nbsp;&nbsp;&nbsp; changes require it.<BR>&nbsp; - The driver automatically gets shipped in all Linux distributions<BR>&nbsp;&nbsp;&nbsp; without having to ask the distros to add it.<BR>&nbsp;&nbsp;&nbsp; <BR>As Linux supports a larger number of different devices "out of the box"<BR>than any other operating system, and it supports these devices on more<BR>different processor architectures than any other operating system, this<BR>proven type of development model must be doing something right :)</P>
<P>&nbsp;</P>
<P>------</P>
<P>Thanks to Randy Dunlap, Andrew Morton, David Brownell, Hanna Linder,<BR>Robert Love, and Nishanth Aravamudan for their review and comments on<BR>early drafts of this paper.