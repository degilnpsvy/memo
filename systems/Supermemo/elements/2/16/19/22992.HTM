<HEAD></HEAD>
<BODY><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Preface</FONT></SPAN></B>
<P></P>
<P><A name=It_was></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>It was the late 1990s, and at IBM we were putting the Linux kernel on a wristwatch. The target device was tiny, but the task was turning out to be tough. The Memory Technology Devices subsystem didn't exist in the kernel, which meant that before a filesystem could start life on the watch's flash memory, we had to develop the necessary storage driver from scratch. Interfacing the watch's touch screen with user applications was complicated because the kernel's&nbsp;<I>input</I></FONT><A name=interface_hadn></A><FONT face=Calibri>&nbsp;event driver interface hadn't been conceived yet. Getting X Windows to run on the watch's LCD wasn't easy because it didn't work well with frame buffer drivers. Of what use is a waterproof Linux wristwatch if you can't stream stock quotes from your bathtub? Bluetooth integration with Linux was several years away, and months were spent porting a proprietary Bluetooth stack to Internet-enable the watch. Power management support was good enough only to squeeze a few hours of juice from the watch's battery; hence we had work cut out on that front, too. Linux-Infrared was still unstable, so we had to coax the stack before we could use an Infrared keyboard for data entry. And we had to compile the compiler and cross-compile a compact application-set because there were no accepted distributions in the consumer electronics space.</FONT></SPAN></P>
<P><A name=forward_to></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Fast forward to the present: The baby penguin has grown into a healthy teenager. What took thousands of lines of code and a year in development back then can be accomplished in a few days with the current kernels. But to become a versatile kernel engineer who can magically weave solutions, you need to understand the myriad features and facilities that Linux offers today.</FONT></SPAN></P>
<P><A name=pref03lev1sec1></A><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>About the Book</FONT></SPAN></B></P>
<P><A name=the></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Among the various subsystems residing in the kernel source tree, the&nbsp;<I>drivers/</I></FONT><A name=chunk_and></A><FONT face=Calibri>&nbsp;directory constitutes the single largest chunk and is several times bigger than the others. With new and diverse technologies arriving in popular form factors, the development of new device drivers in the kernel is accelerating steadily. The latest kernels support more than 70 device driver families.</FONT></SPAN></P>
<P><A name=the_design></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>This book is about writing Linux device drivers. It covers the design and development of major device classes supported by the kernel, including those I missed during my Linux-on-Watch days. The discussion of each driver family starts by looking at the corresponding technology, moves on to develop a practical example, and ends by looking at relevant kernel source files. Before foraying into the world of device drivers, however, this book introduces you to the kernel and discusses the important features of 2.6 Linux, emphasizing those portions that are of special interest to device driver writers.</FONT></SPAN></P>
<P><A name=pref03lev1sec2></A><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Audience</FONT></SPAN></B></P>
<P><A name=programmer_eager></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>This book is intended for the intermediate-level programmer eager to tweak the kernel to enable new devices. You should have a working knowledge of operating system concepts. For example, you should know what a system call is and why concurrency issues have to be factored in while writing kernel code. The book assumes that you have downloaded Linux on your system, poked through the kernel sources, and at least skimmed through some related documentation. And you should be pretty good in C.</FONT></SPAN></P>
<P><A name=pref03lev1sec3></A><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Summary of Chapters</FONT></SPAN></B></P>
<P><A name=rest_of></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>The first 4 chapters prepare you to digest the rest of the book. The next 16 chapters discuss drivers for different device families. A chapter that describes device driver debugging techniques comes next. The penultimate chapter provides perspective on maintenance and delivery. We shut down by walking through a checklist that summarizes how to set forth on your way to Linux-enablement when you get hold of a new device.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch01.html#ch01"><FONT color=#0000ff face=Calibri>Chapter 1</FONT></A><A name=our_tryst></A><FONT face=Calibri>, "Introduction," starts our tryst with Linux. It hurries you through downloading the kernel sources, making trivial code changes, and building a bootable kernel image.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02"><FONT color=#0000ff face=Calibri>Chapter 2</FONT></A><A name=of_the></A><FONT face=Calibri>, "A Peek Inside the Kernel," takes a brisk look into the innards of the Linux kernel and teaches you some must-know kernel concepts. It first takes you through the boot process and then describes kernel services particularly relevant to driver development, such as kernel timers, concurrency management, and memory allocation.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch03.html#ch03"><FONT color=#0000ff face=Calibri>Chapter 3</FONT></A><A name=examines_several></A><FONT face=Calibri>, "Kernel Facilities," examines several kernel services that are useful components in the toolbox of driver developers. The chapter starts by looking at kernel threads, which is a way to implement background tasks inside the kernel. It then moves on to helper interfaces such as linked lists, work queues, completion functions, and notifier chains. These helper facilities simplify your code, weed out redundancies from the kernel, and help long-term maintenance.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04.html#ch04"><FONT color=#0000ff face=Calibri>Chapter 4</FONT></A><A name=the_foundation></A><FONT face=Calibri>, "Laying the Groundwork," builds the foundation for mastering the art of writing Linux device drivers. It introduces devices and drivers by giving you a bird's-eye view of the architecture of a typical PC-compatible system and an embedded device. It then looks at basic driver concepts such as interrupt handling and the kernel's device model.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05"><FONT color=#0000ff face=Calibri>Chapter 5</FONT></A><A name=at_the></A><FONT face=Calibri>, "Character Drivers," looks at the architecture of character device drivers. Several concepts introduced in this chapter, such as polling, asynchronous notification, and I/O control, are relevant to subsequent chapters, too, because many device classes discussed in the rest of the book are "super" character devices.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06.html#ch06"><FONT color=#0000ff face=Calibri>Chapter 6</FONT></A><FONT face=Calibri>, "Serial Drivers," explains the kernel layer that handles serial devices.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch07.html#ch07"><FONT color=#0000ff face=Calibri>Chapter 7</FONT></A><A name=devices_such></A><FONT face=Calibri>, "Input Drivers," discusses the kernel's input subsystem that is responsible for servicing devices such as keyboards, mice, and touch-screen controllers.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08"><FONT color=#0000ff face=Calibri>Chapter 8</FONT></A><A name=such_as></A><FONT face=Calibri>, "The Inter-Integrated Circuit Protocol," dissects drivers for devices such as EEPROMs that are connected to a system's I<SUP>2</SUP></FONT><A name=serial_interfaces></A><FONT face=Calibri>C bus or SMBus. This chapter also looks at other serial interfaces such as SPI bus and 1-wire bus.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch09.html#ch09"><FONT color=#0000ff face=Calibri>Chapter 9</FONT></A><A name=It_teaches></A><FONT face=Calibri>, "PCMCIA and Compact Flash," delves into the PCMCIA subsystem. It teaches you to write drivers for devices having a PCMCIA or Compact Flash form factor.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch10.html#ch10"><FONT color=#0000ff face=Calibri>Chapter 10</FONT></A><A name=its_derivatives></A><FONT face=Calibri>, "Peripheral Component Interconnect," looks at kernel support for PCI and its derivatives.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch11.html#ch11"><FONT color=#0000ff face=Calibri>Chapter 11</FONT></A><A name=explores_USB></A><FONT face=Calibri>, "Universal Serial Bus," explores USB architecture and explains how you can use the services of the Linux-USB subsystem to write drivers for USB devices.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12.html#ch12"><FONT color=#0000ff face=Calibri>Chapter 12</FONT></A><A name=frame_buffer></A><FONT face=Calibri>, "Video Drivers," examines the Linux-Video subsystem. It finds out the advantages offered by the frame buffer abstraction and teaches you to write frame buffer drivers.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch13.html#ch13"><FONT color=#0000ff face=Calibri>Chapter 13</FONT></A><A name=describes_the><FONT face=Calibri>, "Audio Drivers," describes the Linux-Audio framework and explains how to implement audio drivers.</FONT></A></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch14.html#ch14"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 14</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=drivers_for></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Block Drivers," focuses on drivers for storage devices such as hard disks. In this chapter, you also learn about the different I/O schedulers supported by the Linux-Block subsystem.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch15.html#ch15"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 15</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=is_devoted></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Network Interface Cards," is devoted to network device drivers. You learn about kernel networking data structures and how to interface network drivers with protocol layers.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch16.html#ch16"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 16</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=and_cellular></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Linux Without Wires," looks at driving different wireless technologies such as Bluetooth, Infrared, WiFi, and cellular communication.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17.html#ch17"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 17</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=on_embedded></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Memory Technology Devices," discusses flash memory enablement on embedded devices. The chapter ends by examining drivers for the Firmware Hub found on PC systems.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18.html#ch18"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 18</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=through_the></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Embedding Linux," steps into the world of embedded Linux. It takes you through the main firmware components of an embedded solution such as bootloader, kernel, and device drivers. Given the soaring popularity of Linux in the embedded space, it's more likely that you will use the device driver skills that you acquire from this book to enable embedded systems.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch19.html#ch19"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 19</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=types_of></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Drivers in User Space," looks at driving different types of devices from user space. Some device drivers, especially ones that are heavy on policy and light on performance requirements, are better off residing in user land. This chapter also explains how the Linux process scheduler affects the response times of user mode drivers.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch20.html#ch20"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 20</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=of_driver></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "More Devices and Drivers," takes a tour of a potpourri of driver families not covered thus far, such as&nbsp;</FONT><A name=Detection_And></A><FONT face=Calibri><I>Error Detection And Correction</I>&nbsp;(EDAC), FireWire, and ACPI.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch21.html#ch21"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 21</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=use_to></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Debugging Device Drivers," teaches about different types of debuggers that you can use to debug kernel code. In this chapter, you also learn to use trace tools, kernel probes, crash-dump, and profilers. When you develop a driver, be armed with the driver debugging skills that you learn in this chapter.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch22.html#ch22"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 22</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=and_Delivery></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Maintenance and Delivery," provides perspective on the software development life cycle.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch23.html#ch23"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 23</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=through_a></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Shutting Down," takes you through a checklist of work items when you embark on Linux-enabling a new device. The book ends by pondering&nbsp;<I>What next?</I></FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=drivers_sometimes></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Device drivers sometimes need to implement code snippets in assembly, so&nbsp;</FONT></SPAN></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app01.html#app01"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Appendix A</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=programming_on></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Linux Assembly," takes a look at the different facets of assembly programming on Linux. Some device drivers on x86-based systems depend directly or indirectly on the BIOS, so</FONT></SPAN></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app02.html#app02"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Appendix B</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=Linux_interacts></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Linux and the BIOS," teaches you how Linux interacts with the BIOS.&nbsp;</FONT></SPAN></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Appendix C</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><A name=kernel_that></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Seq Files," describes seq files, a kernel helper interface introduced in the 2.6 kernel that device drivers can use to monitor and trend data points.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=to_device></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>The book is generally organized according to device and bus complexity, coupled with practical reasons of dependencies between chapters. So, we start off with basic device classes such as character, serial, and input. Next, we look at simple serial buses such as I<SUP>2</SUP></FONT><A name=and_network></A><FONT face=Calibri>C and SMBus. External I/O buses such as PCMCIA, PCI, and USB follow. Video, audio, block, and network devices usually interface with the processor via these I/O buses, so we look at them soon after. The next portions of the book are oriented toward embedded Linux and cover technologies such as wireless networking and flash memory. User-space drivers are discussed toward the end of the book.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=pref03lev1sec4></A><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Kernel Version</FONT></SPAN></B></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=book_is></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>This book is generally up to date as of the 2.6.23/2.6.24 kernel versions. Most code listings in this book have been tested on a 2.6.23 kernel. If you are using a later version, look at Linux websites such as lwn.net to learn about the kernel changes since 2.6.23/24.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=pref03lev1sec5></A><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Book Website</FONT></SPAN></B></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>I've set up a website at&nbsp;</FONT></SPAN></SPAN><A href="http://elinuxdd.com/" target=_blank><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">elinuxdd.com</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>&nbsp;to provide updates, errata, and other information related to this book.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=pref03lev1sec6></A><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Conventions Used</FONT></SPAN></B></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Source code, function names, and shell commands are written&nbsp;like this. The shell prompt used is&nbsp;<B>bash&gt;</B>. Filename are written in italics,&nbsp;<I>like this.</I>&nbsp;Italics are also used to introduce new terms.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=To_clearly></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Some chapters modify original kernel source files while implementing code examples. To clearly point out the changes, newly inserted code lines are prefixed with&nbsp;<B>+</B></FONT><A name=and_any></A><FONT face=Calibri>, and any deleted code lines with&nbsp;-.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=book_uses></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Sometimes, for simplicity, the book uses generic references. So if the text points you to the&nbsp;<I>arch/your-arch/</I></FONT><A name=should_be></A><FONT face=Calibri>&nbsp;directory, it should be translated, for example, to&nbsp;<I>arch/x86/</I></FONT><A name=mention_of></A><FONT face=Calibri>&nbsp;if you are compiling the kernel for the x86 architecture. Similarly, any mention of the<I>include/asm-your-arch/</I>&nbsp;directory should be read as&nbsp;<I>include/asm-arm/</I></FONT><A name=kernel_for></A><FONT face=Calibri>&nbsp;if you are, for instance, building the kernel for the ARM architecture. The * symbol and&nbsp;<I>X</I></FONT><A name=chapter_asks></A><FONT face=Calibri>&nbsp;are occasionally used as wildcard characters in filenames. So, if a chapter asks you to look at<I>include/linux/time*.h</I>, look at the header files,&nbsp;<I>time.h, timer.h, times.h</I>, and&nbsp;<I>timex.h</I>&nbsp;residing in the&nbsp;<I>include/linux/</I>&nbsp;directory. If a section talks about&nbsp;<I>/dev/input/eventX</I>&nbsp;or&nbsp;<I>/sys/devices/platform/i8042/serioX/, X</I></FONT><A name=kernel_assigns></A><FONT face=Calibri>&nbsp;is the interface number that the kernel assigns to your device in the context of your system configuration.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=kernel_output></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>The&nbsp;</FONT><SPAN style="mso-no-proof: yes"><?xml:namespace prefix = "v" /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><FONT face=Calibri> <v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = "o" /><o:lock v:ext="edit" aspectratio="t"></o:lock></FONT></v:shapetype><v:shape id=&#22270;&#29255;_x0020_1 style="HEIGHT: 9.75pt; WIDTH: 18.75pt; VISIBILITY: visible; mso-wrap-style: square" o:spid="_x0000_i1025" type="#_x0000_t75" alt="rightwards double arrow"><v:imagedata src="file:///C:\Users\DONPOP~1\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif" o:title="rightwards double arrow"></v:imagedata></v:shape></SPAN><FONT face=Calibri>&nbsp;symbol is sometimes inserted between command or kernel output to attach explanations.</FONT></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: describes_the"><A name=regular_expressions></A><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Simple regular expressions are occasionally used to compactly list function prototypes. For example, the section "</FONT></SPAN></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch10lev1sec4.html#ch10lev1sec4"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Direct Memory Access</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>" in&nbsp;</FONT></SPAN></SPAN><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch10.html#ch10"><FONT color=#0000ff><FONT face=Calibri><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt">Chapter 10</SPAN></SPAN><SPAN style="mso-bookmark: describes_the"></SPAN></FONT></FONT></A><SPAN style="mso-bookmark: describes_the"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, "Peripheral Component Interconnect," refers to&nbsp;pci_[map|unmap|dma_sync]_single()&nbsp;instead of explicitly citing&nbsp;pci_map_single(),&nbsp;pci_umap_single(), and&nbsp;pci_dma_sync_single().</FONT></SPAN></SPAN></P><SPAN style="mso-bookmark: describes_the"></SPAN>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Several chapters refer you to user-space configuration files. For example, the section that describes the boot process opens<I>/etc/rc.sysinit</I></FONT><A name=and_the></A><FONT face=Calibri>, and the chapter that discusses Bluetooth refers to&nbsp;<I>/etc/bluetooth/pin</I></FONT><A name=names_and></A><FONT face=Calibri>. The exact names and locations of such files might, however, vary according to the Linux distribution you use.</FONT></SPAN></P></BODY>