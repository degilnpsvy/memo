<H3 id=-100000 class=docSection1Title>Gadget Drivers</H3>
<P class=docText><A name="In a"></A>In a typical usage scenario, an embedded device connects to a PC host over USB. Embedded computers usually belong to the device side of USB, unlike PC systems that function as USB hosts. Because Linux runs on both embedded and PC systems, it needs support to run on either end of USB. The USB Gadget project brings USB device mode capability to embedded Linux systems. Bus 3 of the embedded Linux <A name=iddle1484></A><A name=iddle1610></A><A name=iddle1733></A><A name=iddle1774></A><A name=iddle2119></A><A name=iddle3561></A><A name=iddle4376></A><A name=iddle4495></A>device in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch11lev1sec1.html#ch11fig02">Figure 11.2</A><A name=a></A> can, for example, use a <SPAN class=docEmphasis>gadget driver</SPAN><A name="let the"></A> to let the device function as a mass storage drive when connected to a host computer.</P>
<P class=docText><A name="at the"></A>Before proceeding, let's briefly look at some related terminology. The USB controller at the device side is variously called a <SPAN class=docEmphasis>device controller</SPAN>, <SPAN class=docEmphasis>peripheral controller</SPAN>, <SPAN class=docEmphasis>client controller</SPAN>, or <SPAN class=docEmphasis>function controller</SPAN>. The terms <SPAN class=docEmphasis>gadget</SPAN> and <SPAN class=docEmphasis>gadget driver</SPAN><A name="the heavily"></A> are commonly used rather than the heavily overloaded words <SPAN class=docEmphasis>device</SPAN> and <SPAN class=docEmphasis>device driver</SPAN>.</P>
<P class=docText><A name="kernel and"></A>USB gadget support is now part of the mainline kernel and contains the following:</P>
<UL>
<LI>
<P class=docList><A name="SoC families"></A>Drivers for USB device controllers integrated into SoC families such as Intel PXA, Texas Instruments OMAP, and Atmel AT91. These drivers additionally provide a <SPAN class=docEmphasis>gadget API</SPAN> that gadget drivers can use.</P></LI>
<LI>
<P class=docList><A name="drivers answer"></A>Gadget drivers for device classes such as storage, networking, and serial converters. These drivers answer to their class when they receive enumeration requests from host-side software. A storage gadget driver, for example, identifies itself as a class <TT>0x08</TT><A name="exports a"></A> (mass storage class) device and exports a storage partition to the host. You can specify the associated block device node or filename via a module-insertion parameter. Because the exported region has to appear to the host as a mass storage device, the gadget driver implements the SCSI interactions required by the USB mass storage protocol. Gadget drivers are also available for Ethernet and serial devices.</P></LI>
<LI>
<P class=docList><A name="gadget driver"></A>A skeletal gadget driver, <SPAN class=docEmphasis>drivers/usb/gadget/zero.c</SPAN><A name="that you"></A>, that you may use to test device controller drivers.</P></LI></UL>
<P class=docText><A name="use the"></A>Gadget drivers use the services of the gadget API provided by device controller drivers. They populate a <TT>usb_gadget_driver</TT><A name="and register"></A> structure and register it with the kernel using <TT>usb_gadget_register_driver</TT><TT>()</TT><A name="offered by"></A>. Hardware specifics are hidden inside the gadget API implementation offered by individual device controller drivers, so the gadget drivers themselves are hardware independent.</P>
<P class=docText><SPAN class=docEmphasis>Documentation/DocBook/gadget.tmpl</SPAN><A name="gadget API"></A> provides an overview of the gadget API. Have a look at <A class=docLink href="http://linux-usb.org/gadget/" target=_blank>http://linux-usb.org/gadget/</A> for more on the gadget project.