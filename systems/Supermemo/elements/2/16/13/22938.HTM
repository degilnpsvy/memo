# Documentation/virtual/kvm/nested-vmx.txt
<P></P>
<P>Nested VMX<BR>==========</P>
<P></P>
<P>Overview<BR>---------</P>
<P>On Intel processors, KVM uses Intel's VMX (Virtual-Machine eXtensions)<BR>to easily and efficiently run guest operating systems. Normally, these guests<BR>*cannot* themselves be hypervisors running their own guests, because in VMX,<BR>guests cannot use VMX instructions.</P>
<P>The "Nested VMX" feature adds this missing capability - of running guest<BR>hypervisors (which use VMX) with their own nested guests. It does so by<BR>allowing a guest to use VMX instructions, and correctly and efficiently<BR>emulating them using the single level of VMX available in the hardware.</P>
<P>We describe in much greater detail the theory behind the nested VMX feature,<BR>its implementation and its performance characteristics, in the OSDI 2010 paper<BR>"The Turtles Project: Design and Implementation of Nested Virtualization",<BR>available at:</P>
<P>&nbsp;<A href="http://www.usenix.org/events/osdi10/tech/full_papers/Ben-Yehuda.pdf">http://www.usenix.org/events/osdi10/tech/full_papers/Ben-Yehuda.pdf</A></P>
<P><BR>Terminology<BR>-----------</P>
<P>Single-level virtualization has two levels - the host (KVM) and the guests.<BR>In nested virtualization, we have three levels: The host (KVM), which we call<BR>L0, the guest hypervisor, which we call L1, and its nested guest, which we<BR>call L2.</P>
<P><BR>Known limitations<BR>-----------------</P>
<P>The current code supports running Linux guests under KVM guests.<BR>Only 64-bit guest hypervisors are supported.</P>
<P>Additional patches for running Windows under guest KVM, and Linux under<BR>guest VMware server, and support for nested EPT, are currently running in<BR>the lab, and will be sent as follow-on patchsets.</P>
<P><BR>Running nested VMX<BR>------------------</P>
<P>The nested VMX feature is disabled by default. It can be enabled by giving<BR>the "nested=1" option to the kvm-intel module.</P>
<P>No modifications are required to user space (qemu). However, qemu's default<BR>emulated CPU type (qemu64) does not list the "VMX" CPU feature, so it must be<BR>explicitly enabled, by giving qemu one of the following options:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; -cpu host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (emulated CPU has all features of the real CPU)</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; -cpu qemu64,+vmx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (add just the vmx feature to a named CPU type)</P>
<P><BR>ABIs<BR>----</P>
<P>Nested VMX aims to present a standard and (eventually) fully-functional VMX<BR>implementation for the a guest hypervisor to use. As such, the official<BR>specification of the ABI that it provides is Intel's VMX specification,<BR>namely volume 3B of their "Intel 64 and IA-32 Architectures Software<BR>Developer's Manual". Not all of VMX's features are currently fully supported,<BR>but the goal is to eventually support them all, starting with the VMX features<BR>which are used in practice by popular hypervisors (KVM and others).</P>
<P>As a VMX implementation, nested VMX presents a VMCS structure to L1.<BR>As mandated by the spec, other than the two fields revision_id and abort,<BR>this structure is *opaque* to its user, who is not supposed to know or care<BR>about its internal structure. Rather, the structure is accessed through the<BR>VMREAD and VMWRITE instructions.<BR>Still, for debugging purposes, KVM developers might be interested to know the<BR>internals of this structure; This is struct vmcs12 from arch/x86/kvm/vmx.c.</P>
<P>The name "vmcs12" refers to the VMCS that L1 builds for L2. In the code we<BR>also have "vmcs01", the VMCS that L0 built for L1, and "vmcs02" is the VMCS<BR>which L0 builds to actually run L2 - how this is done is explained in the<BR>aforementioned paper.</P>
<P>For convenience, we repeat the content of struct vmcs12 here. If the internals<BR>of this structure changes, this can break live migration across KVM versions.<BR>VMCS12_REVISION (from vmx.c) should be changed if struct vmcs12 or its inner<BR>struct shadow_vmcs is ever changed.</P>
<P>&nbsp;typedef u64 natural_width;<BR>&nbsp;struct __packed vmcs12 {<BR>&nbsp;&nbsp;/* According to the Intel spec, a VMCS region must start with<BR>&nbsp;&nbsp; * these two user-visible fields */<BR>&nbsp;&nbsp;u32 revision_id;<BR>&nbsp;&nbsp;u32 abort;</P>
<P>&nbsp;&nbsp;u32 launch_state; /* set to 0 by VMCLEAR, to 1 by VMLAUNCH */<BR>&nbsp;&nbsp;u32 padding[7]; /* room for future expansion */</P>
<P>&nbsp;&nbsp;u64 io_bitmap_a;<BR>&nbsp;&nbsp;u64 io_bitmap_b;<BR>&nbsp;&nbsp;u64 msr_bitmap;<BR>&nbsp;&nbsp;u64 vm_exit_msr_store_addr;<BR>&nbsp;&nbsp;u64 vm_exit_msr_load_addr;<BR>&nbsp;&nbsp;u64 vm_entry_msr_load_addr;<BR>&nbsp;&nbsp;u64 tsc_offset;<BR>&nbsp;&nbsp;u64 virtual_apic_page_addr;<BR>&nbsp;&nbsp;u64 apic_access_addr;<BR>&nbsp;&nbsp;u64 ept_pointer;<BR>&nbsp;&nbsp;u64 guest_physical_address;<BR>&nbsp;&nbsp;u64 vmcs_link_pointer;<BR>&nbsp;&nbsp;u64 guest_ia32_debugctl;<BR>&nbsp;&nbsp;u64 guest_ia32_pat;<BR>&nbsp;&nbsp;u64 guest_ia32_efer;<BR>&nbsp;&nbsp;u64 guest_pdptr0;<BR>&nbsp;&nbsp;u64 guest_pdptr1;<BR>&nbsp;&nbsp;u64 guest_pdptr2;<BR>&nbsp;&nbsp;u64 guest_pdptr3;<BR>&nbsp;&nbsp;u64 host_ia32_pat;<BR>&nbsp;&nbsp;u64 host_ia32_efer;<BR>&nbsp;&nbsp;u64 padding64[8]; /* room for future expansion */<BR>&nbsp;&nbsp;natural_width cr0_guest_host_mask;<BR>&nbsp;&nbsp;natural_width cr4_guest_host_mask;<BR>&nbsp;&nbsp;natural_width cr0_read_shadow;<BR>&nbsp;&nbsp;natural_width cr4_read_shadow;<BR>&nbsp;&nbsp;natural_width cr3_target_value0;<BR>&nbsp;&nbsp;natural_width cr3_target_value1;<BR>&nbsp;&nbsp;natural_width cr3_target_value2;<BR>&nbsp;&nbsp;natural_width cr3_target_value3;<BR>&nbsp;&nbsp;natural_width exit_qualification;<BR>&nbsp;&nbsp;natural_width guest_linear_address;<BR>&nbsp;&nbsp;natural_width guest_cr0;<BR>&nbsp;&nbsp;natural_width guest_cr3;<BR>&nbsp;&nbsp;natural_width guest_cr4;<BR>&nbsp;&nbsp;natural_width guest_es_base;<BR>&nbsp;&nbsp;natural_width guest_cs_base;<BR>&nbsp;&nbsp;natural_width guest_ss_base;<BR>&nbsp;&nbsp;natural_width guest_ds_base;<BR>&nbsp;&nbsp;natural_width guest_fs_base;<BR>&nbsp;&nbsp;natural_width guest_gs_base;<BR>&nbsp;&nbsp;natural_width guest_ldtr_base;<BR>&nbsp;&nbsp;natural_width guest_tr_base;<BR>&nbsp;&nbsp;natural_width guest_gdtr_base;<BR>&nbsp;&nbsp;natural_width guest_idtr_base;<BR>&nbsp;&nbsp;natural_width guest_dr7;<BR>&nbsp;&nbsp;natural_width guest_rsp;<BR>&nbsp;&nbsp;natural_width guest_rip;<BR>&nbsp;&nbsp;natural_width guest_rflags;<BR>&nbsp;&nbsp;natural_width guest_pending_dbg_exceptions;<BR>&nbsp;&nbsp;natural_width guest_sysenter_esp;<BR>&nbsp;&nbsp;natural_width guest_sysenter_eip;<BR>&nbsp;&nbsp;natural_width host_cr0;<BR>&nbsp;&nbsp;natural_width host_cr3;<BR>&nbsp;&nbsp;natural_width host_cr4;<BR>&nbsp;&nbsp;natural_width host_fs_base;<BR>&nbsp;&nbsp;natural_width host_gs_base;<BR>&nbsp;&nbsp;natural_width host_tr_base;<BR>&nbsp;&nbsp;natural_width host_gdtr_base;<BR>&nbsp;&nbsp;natural_width host_idtr_base;<BR>&nbsp;&nbsp;natural_width host_ia32_sysenter_esp;<BR>&nbsp;&nbsp;natural_width host_ia32_sysenter_eip;<BR>&nbsp;&nbsp;natural_width host_rsp;<BR>&nbsp;&nbsp;natural_width host_rip;<BR>&nbsp;&nbsp;natural_width paddingl[8]; /* room for future expansion */<BR>&nbsp;&nbsp;u32 pin_based_vm_exec_control;<BR>&nbsp;&nbsp;u32 cpu_based_vm_exec_control;<BR>&nbsp;&nbsp;u32 exception_bitmap;<BR>&nbsp;&nbsp;u32 page_fault_error_code_mask;<BR>&nbsp;&nbsp;u32 page_fault_error_code_match;<BR>&nbsp;&nbsp;u32 cr3_target_count;<BR>&nbsp;&nbsp;u32 vm_exit_controls;<BR>&nbsp;&nbsp;u32 vm_exit_msr_store_count;<BR>&nbsp;&nbsp;u32 vm_exit_msr_load_count;<BR>&nbsp;&nbsp;u32 vm_entry_controls;<BR>&nbsp;&nbsp;u32 vm_entry_msr_load_count;<BR>&nbsp;&nbsp;u32 vm_entry_intr_info_field;<BR>&nbsp;&nbsp;u32 vm_entry_exception_error_code;<BR>&nbsp;&nbsp;u32 vm_entry_instruction_len;<BR>&nbsp;&nbsp;u32 tpr_threshold;<BR>&nbsp;&nbsp;u32 secondary_vm_exec_control;<BR>&nbsp;&nbsp;u32 vm_instruction_error;<BR>&nbsp;&nbsp;u32 vm_exit_reason;<BR>&nbsp;&nbsp;u32 vm_exit_intr_info;<BR>&nbsp;&nbsp;u32 vm_exit_intr_error_code;<BR>&nbsp;&nbsp;u32 idt_vectoring_info_field;<BR>&nbsp;&nbsp;u32 idt_vectoring_error_code;<BR>&nbsp;&nbsp;u32 vm_exit_instruction_len;<BR>&nbsp;&nbsp;u32 vmx_instruction_info;<BR>&nbsp;&nbsp;u32 guest_es_limit;<BR>&nbsp;&nbsp;u32 guest_cs_limit;<BR>&nbsp;&nbsp;u32 guest_ss_limit;<BR>&nbsp;&nbsp;u32 guest_ds_limit;<BR>&nbsp;&nbsp;u32 guest_fs_limit;<BR>&nbsp;&nbsp;u32 guest_gs_limit;<BR>&nbsp;&nbsp;u32 guest_ldtr_limit;<BR>&nbsp;&nbsp;u32 guest_tr_limit;<BR>&nbsp;&nbsp;u32 guest_gdtr_limit;<BR>&nbsp;&nbsp;u32 guest_idtr_limit;<BR>&nbsp;&nbsp;u32 guest_es_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_cs_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_ss_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_ds_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_fs_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_gs_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_ldtr_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_tr_ar_bytes;<BR>&nbsp;&nbsp;u32 guest_interruptibility_info;<BR>&nbsp;&nbsp;u32 guest_activity_state;<BR>&nbsp;&nbsp;u32 guest_sysenter_cs;<BR>&nbsp;&nbsp;u32 host_ia32_sysenter_cs;<BR>&nbsp;&nbsp;u32 padding32[8]; /* room for future expansion */<BR>&nbsp;&nbsp;u16 virtual_processor_id;<BR>&nbsp;&nbsp;u16 guest_es_selector;<BR>&nbsp;&nbsp;u16 guest_cs_selector;<BR>&nbsp;&nbsp;u16 guest_ss_selector;<BR>&nbsp;&nbsp;u16 guest_ds_selector;<BR>&nbsp;&nbsp;u16 guest_fs_selector;<BR>&nbsp;&nbsp;u16 guest_gs_selector;<BR>&nbsp;&nbsp;u16 guest_ldtr_selector;<BR>&nbsp;&nbsp;u16 guest_tr_selector;<BR>&nbsp;&nbsp;u16 host_es_selector;<BR>&nbsp;&nbsp;u16 host_cs_selector;<BR>&nbsp;&nbsp;u16 host_ss_selector;<BR>&nbsp;&nbsp;u16 host_ds_selector;<BR>&nbsp;&nbsp;u16 host_fs_selector;<BR>&nbsp;&nbsp;u16 host_gs_selector;<BR>&nbsp;&nbsp;u16 host_tr_selector;<BR>&nbsp;};</P>
<P><BR>Authors<BR>-------</P>
<P>These patches were written by:<BR>&nbsp;&nbsp;&nbsp;&nbsp; Abel Gordon, abelg &lt;at&gt; il.ibm.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Nadav Har'El, nyh &lt;at&gt; il.ibm.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Orit Wasserman, oritw &lt;at&gt; il.ibm.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Ben-Ami Yassor, benami &lt;at&gt; il.ibm.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Muli Ben-Yehuda, muli &lt;at&gt; il.ibm.com</P>
<P>With contributions by:<BR>&nbsp;&nbsp;&nbsp;&nbsp; Anthony Liguori, aliguori &lt;at&gt; us.ibm.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Mike Day, mdday &lt;at&gt; us.ibm.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Michael Factor, factor &lt;at&gt; il.ibm.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Zvi Dubitzky, dubi &lt;at&gt; il.ibm.com</P>
<P>And valuable reviews by:<BR>&nbsp;&nbsp;&nbsp;&nbsp; Avi Kivity, avi &lt;at&gt; redhat.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Gleb Natapov, gleb &lt;at&gt; redhat.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Marcelo Tosatti, mtosatti &lt;at&gt; redhat.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; Kevin Tian, kevin.tian &lt;at&gt; intel.com<BR>&nbsp;&nbsp;&nbsp;&nbsp; and others.