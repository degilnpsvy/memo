# Documentation/virtual/kvm/hypercalls.txt
<P></P>
<P>Linux KVM Hypercall:<BR>===================<BR>X86:<BR>&nbsp;KVM Hypercalls have a three-byte sequence of either the vmcall or the vmmcall<BR>&nbsp;instruction. The hypervisor can replace it with instructions that are<BR>&nbsp;guaranteed to be supported.</P>
<P></P>
<P>&nbsp;Up to four arguments may be passed in rbx, rcx, rdx, and rsi respectively.<BR>&nbsp;The hypercall number should be placed in rax and the return value will be<BR>&nbsp;placed in rax.&nbsp; No other registers will be clobbered unless explicitly stated<BR>&nbsp;by the particular hypercall.</P>
<P>S390:<BR>&nbsp; R2-R7 are used for parameters 1-6. In addition, R1 is used for hypercall<BR>&nbsp; number. The return value is written to R2.</P>
<P>&nbsp; S390 uses diagnose instruction as hypercall (0x500) along with hypercall<BR>&nbsp; number in R1.</P>
<P>&nbsp;PowerPC:<BR>&nbsp; It uses R3-R10 and hypercall number in R11. R4-R11 are used as output registers.<BR>&nbsp; Return value is placed in R3.</P>
<P>&nbsp; KVM hypercalls uses 4 byte opcode, that are patched with 'hypercall-instructions'<BR>&nbsp; property inside the device tree's /hypervisor node.<BR>&nbsp; For more information refer to Documentation/virtual/kvm/ppc-pv.txt</P>
<P>KVM Hypercalls Documentation<BR>===========================<BR>The template for each hypercall is:<BR>1. Hypercall name.<BR>2. Architecture(s)<BR>3. Status (deprecated, obsolete, active)<BR>4. Purpose</P>
<P>1. KVM_HC_VAPIC_POLL_IRQ<BR>------------------------<BR>Architecture: x86<BR>Status: active<BR>Purpose: Trigger guest exit so that the host can check for pending<BR>interrupts on reentry.</P>
<P>2. KVM_HC_MMU_OP<BR>------------------------<BR>Architecture: x86<BR>Status: deprecated.<BR>Purpose: Support MMU operations such as writing to PTE,<BR>flushing TLB, release PT.</P>
<P>3. KVM_HC_FEATURES<BR>------------------------<BR>Architecture: PPC<BR>Status: active<BR>Purpose: Expose hypercall availability to the guest. On x86 platforms, cpuid<BR>used to enumerate which hypercalls are available. On PPC, either device tree<BR>based lookup ( which is also what EPAPR dictates) OR KVM specific enumeration<BR>mechanism (which is this hypercall) can be used.</P>
<P>4. KVM_HC_PPC_MAP_MAGIC_PAGE<BR>------------------------<BR>Architecture: PPC<BR>Status: active<BR>Purpose: To enable communication between the hypervisor and guest there is a<BR>shared page that contains parts of supervisor visible register state.<BR>The guest can map this shared page to access its supervisor register through<BR>memory using this hypercall.