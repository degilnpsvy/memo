# Documentation/virtual/kvm/mmu.txt
<P></P>
<P>The x86 kvm shadow mmu<BR>======================</P>
<P></P>
<P>The mmu (in arch/x86/kvm, files mmu.[ch] and paging_tmpl.h) is responsible<BR>for presenting a standard x86 mmu to the guest, while translating guest<BR>physical addresses to host physical addresses.</P>
<P>The mmu code attempts to satisfy the following requirements:</P>
<P>- correctness: the guest should not be able to determine that it is running<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on an emulated mmu except for timing (we attempt to comply<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with the specification, not emulate the characteristics of<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a particular implementation such as tlb size)<BR>- security:&nbsp;&nbsp;&nbsp; the guest must not be able to touch host memory not assigned<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to it<BR>- performance: minimize the performance penalty imposed by the mmu<BR>- scaling:&nbsp;&nbsp;&nbsp;&nbsp; need to scale to large memory and large vcpu guests<BR>- hardware:&nbsp;&nbsp;&nbsp; support the full range of x86 virtualization hardware<BR>- integration: Linux memory management code must be in control of guest memory<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; so that swapping, page migration, page merging, transparent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hugepages, and similar features work without change<BR>- dirty tracking: report writes to guest memory to enable live migration<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and framebuffer-based displays<BR>- footprint:&nbsp;&nbsp; keep the amount of pinned kernel memory low (most memory<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; should be shrinkable)<BR>- reliability:&nbsp; avoid multipage or GFP_ATOMIC allocations</P>
<P>Acronyms<BR>========</P>
<P>pfn&nbsp;&nbsp; host page frame number<BR>hpa&nbsp;&nbsp; host physical address<BR>hva&nbsp;&nbsp; host virtual address<BR>gfn&nbsp;&nbsp; guest frame number<BR>gpa&nbsp;&nbsp; guest physical address<BR>gva&nbsp;&nbsp; guest virtual address<BR>ngpa&nbsp; nested guest physical address<BR>ngva&nbsp; nested guest virtual address<BR>pte&nbsp;&nbsp; page table entry (used also to refer generically to paging structure<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entries)<BR>gpte&nbsp; guest pte (referring to gfns)<BR>spte&nbsp; shadow pte (referring to pfns)<BR>tdp&nbsp;&nbsp; two dimensional paging (vendor neutral term for NPT and EPT)</P>
<P>Virtual and real hardware supported<BR>===================================</P>
<P>The mmu supports first-generation mmu hardware, which allows an atomic switch<BR>of the current paging mode and cr3 during guest entry, as well as<BR>two-dimensional paging (AMD's NPT and Intel's EPT).&nbsp; The emulated hardware<BR>it exposes is the traditional 2/3/4 level x86 mmu, with support for global<BR>pages, pae, pse, pse36, cr0.wp, and 1GB pages.&nbsp; Work is in progress to support<BR>exposing NPT capable hardware on NPT capable hosts.</P>
<P>Translation<BR>===========</P>
<P>The primary job of the mmu is to program the processor's mmu to translate<BR>addresses for the guest.&nbsp; Different translations are required at different<BR>times:</P>
<P>- when guest paging is disabled, we translate guest physical addresses to<BR>&nbsp; host physical addresses (gpa-&gt;hpa)<BR>- when guest paging is enabled, we translate guest virtual addresses, to<BR>&nbsp; guest physical addresses, to host physical addresses (gva-&gt;gpa-&gt;hpa)<BR>- when the guest launches a guest of its own, we translate nested guest<BR>&nbsp; virtual addresses, to nested guest physical addresses, to guest physical<BR>&nbsp; addresses, to host physical addresses (ngva-&gt;ngpa-&gt;gpa-&gt;hpa)</P>
<P>The primary challenge is to encode between 1 and 3 translations into hardware<BR>that support only 1 (traditional) and 2 (tdp) translations.&nbsp; When the<BR>number of required translations matches the hardware, the mmu operates in<BR>direct mode; otherwise it operates in shadow mode (see below).</P>
<P>Memory<BR>======</P>
<P>Guest memory (gpa) is part of the user address space of the process that is<BR>using kvm.&nbsp; Userspace defines the translation between guest addresses and user<BR>addresses (gpa-&gt;hva); note that two gpas may alias to the same hva, but not<BR>vice versa.</P>
<P>These hvas may be backed using any method available to the host: anonymous<BR>memory, file backed memory, and device memory.&nbsp; Memory might be paged by the<BR>host at any time.</P>
<P>Events<BR>======</P>
<P>The mmu is driven by events, some from the guest, some from the host.</P>
<P>Guest generated events:<BR>- writes to control registers (especially cr3)<BR>- invlpg/invlpga instruction execution<BR>- access to missing or protected translations</P>
<P>Host generated events:<BR>- changes in the gpa-&gt;hpa translation (either through gpa-&gt;hva changes or<BR>&nbsp; through hva-&gt;hpa changes)<BR>- memory pressure (the shrinker)</P>
<P>Shadow pages<BR>============</P>
<P>The principal data structure is the shadow page, 'struct kvm_mmu_page'.&nbsp; A<BR>shadow page contains 512 sptes, which can be either leaf or nonleaf sptes.&nbsp; A<BR>shadow page may contain a mix of leaf and nonleaf sptes.</P>
<P>A nonleaf spte allows the hardware mmu to reach the leaf pages and<BR>is not related to a translation directly.&nbsp; It points to other shadow pages.</P>
<P>A leaf spte corresponds to either one or two translations encoded into<BR>one paging structure entry.&nbsp; These are always the lowest level of the<BR>translation stack, with optional higher level translations left to NPT/EPT.<BR>Leaf ptes point at guest pages.</P>
<P>The following table shows translations encoded by leaf ptes, with higher-level<BR>translations in parentheses:</P>
<P>&nbsp;Non-nested guests:<BR>&nbsp; nonpaging:&nbsp;&nbsp;&nbsp;&nbsp; gpa-&gt;hpa<BR>&nbsp; paging:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gva-&gt;gpa-&gt;hpa<BR>&nbsp; paging, tdp:&nbsp;&nbsp; (gva-&gt;)gpa-&gt;hpa<BR>&nbsp;Nested guests:<BR>&nbsp; non-tdp:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ngva-&gt;gpa-&gt;hpa&nbsp; (*)<BR>&nbsp; tdp:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ngva-&gt;)ngpa-&gt;gpa-&gt;hpa</P>
<P>(*) the guest hypervisor will encode the ngva-&gt;gpa translation into its page<BR>&nbsp;&nbsp;&nbsp; tables if npt is not present</P>
<P>Shadow pages contain the following information:<BR>&nbsp; role.level:<BR>&nbsp;&nbsp;&nbsp; The level in the shadow paging hierarchy that this shadow page belongs to.<BR>&nbsp;&nbsp;&nbsp; 1=4k sptes, 2=2M sptes, 3=1G sptes, etc.<BR>&nbsp; role.direct:<BR>&nbsp;&nbsp;&nbsp; If set, leaf sptes reachable from this page are for a linear range.<BR>&nbsp;&nbsp;&nbsp; Examples include real mode translation, large guest pages backed by small<BR>&nbsp;&nbsp;&nbsp; host pages, and gpa-&gt;hpa translations when NPT or EPT is active.<BR>&nbsp;&nbsp;&nbsp; The linear range starts at (gfn &lt;&lt; PAGE_SHIFT) and its size is determined<BR>&nbsp;&nbsp;&nbsp; by role.level (2MB for first level, 1GB for second level, 0.5TB for third<BR>&nbsp;&nbsp;&nbsp; level, 256TB for fourth level)<BR>&nbsp;&nbsp;&nbsp; If clear, this page corresponds to a guest page table denoted by the gfn<BR>&nbsp;&nbsp;&nbsp; field.<BR>&nbsp; role.quadrant:<BR>&nbsp;&nbsp;&nbsp; When role.cr4_pae=0, the guest uses 32-bit gptes while the host uses 64-bit<BR>&nbsp;&nbsp;&nbsp; sptes.&nbsp; That means a guest page table contains more ptes than the host,<BR>&nbsp;&nbsp;&nbsp; so multiple shadow pages are needed to shadow one guest page.<BR>&nbsp;&nbsp;&nbsp; For first-level shadow pages, role.quadrant can be 0 or 1 and denotes the<BR>&nbsp;&nbsp;&nbsp; first or second 512-gpte block in the guest page table.&nbsp; For second-level<BR>&nbsp;&nbsp;&nbsp; page tables, each 32-bit gpte is converted to two 64-bit sptes<BR>&nbsp;&nbsp;&nbsp; (since each first-level guest page is shadowed by two first-level<BR>&nbsp;&nbsp;&nbsp; shadow pages) so role.quadrant takes values in the range 0..3.&nbsp; Each<BR>&nbsp;&nbsp;&nbsp; quadrant maps 1GB virtual address space.<BR>&nbsp; role.access:<BR>&nbsp;&nbsp;&nbsp; Inherited guest access permissions in the form uwx.&nbsp; Note execute<BR>&nbsp;&nbsp;&nbsp; permission is positive, not negative.<BR>&nbsp; role.invalid:<BR>&nbsp;&nbsp;&nbsp; The page is invalid and should not be used.&nbsp; It is a root page that is<BR>&nbsp;&nbsp;&nbsp; currently pinned (by a cpu hardware register pointing to it); once it is<BR>&nbsp;&nbsp;&nbsp; unpinned it will be destroyed.<BR>&nbsp; role.cr4_pae:<BR>&nbsp;&nbsp;&nbsp; Contains the value of cr4.pae for which the page is valid (e.g. whether<BR>&nbsp;&nbsp;&nbsp; 32-bit or 64-bit gptes are in use).<BR>&nbsp; role.nxe:<BR>&nbsp;&nbsp;&nbsp; Contains the value of efer.nxe for which the page is valid.<BR>&nbsp; role.cr0_wp:<BR>&nbsp;&nbsp;&nbsp; Contains the value of cr0.wp for which the page is valid.<BR>&nbsp; role.smep_andnot_wp:<BR>&nbsp;&nbsp;&nbsp; Contains the value of cr4.smep &amp;&amp; !cr0.wp for which the page is valid<BR>&nbsp;&nbsp;&nbsp; (pages for which this is true are different from other pages; see the<BR>&nbsp;&nbsp;&nbsp; treatment of cr0.wp=0 below).<BR>&nbsp; gfn:<BR>&nbsp;&nbsp;&nbsp; Either the guest page table containing the translations shadowed by this<BR>&nbsp;&nbsp;&nbsp; page, or the base page frame for linear translations.&nbsp; See role.direct.<BR>&nbsp; spt:<BR>&nbsp;&nbsp;&nbsp; A pageful of 64-bit sptes containing the translations for this page.<BR>&nbsp;&nbsp;&nbsp; Accessed by both kvm and hardware.<BR>&nbsp;&nbsp;&nbsp; The page pointed to by spt will have its page-&gt;private pointing back<BR>&nbsp;&nbsp;&nbsp; at the shadow page structure.<BR>&nbsp;&nbsp;&nbsp; sptes in spt point either at guest pages, or at lower-level shadow pages.<BR>&nbsp;&nbsp;&nbsp; Specifically, if sp1 and sp2 are shadow pages, then sp1-&gt;spt[n] may point<BR>&nbsp;&nbsp;&nbsp; at __pa(sp2-&gt;spt).&nbsp; sp2 will point back at sp1 through parent_pte.<BR>&nbsp;&nbsp;&nbsp; The spt array forms a DAG structure with the shadow page as a node, and<BR>&nbsp;&nbsp;&nbsp; guest pages as leaves.<BR>&nbsp; gfns:<BR>&nbsp;&nbsp;&nbsp; An array of 512 guest frame numbers, one for each present pte.&nbsp; Used to<BR>&nbsp;&nbsp;&nbsp; perform a reverse map from a pte to a gfn. When role.direct is set, any<BR>&nbsp;&nbsp;&nbsp; element of this array can be calculated from the gfn field when used, in<BR>&nbsp;&nbsp;&nbsp; this case, the array of gfns is not allocated. See role.direct and gfn.<BR>&nbsp; root_count:<BR>&nbsp;&nbsp;&nbsp; A counter keeping track of how many hardware registers (guest cr3 or<BR>&nbsp;&nbsp;&nbsp; pdptrs) are now pointing at the page.&nbsp; While this counter is nonzero, the<BR>&nbsp;&nbsp;&nbsp; page cannot be destroyed.&nbsp; See role.invalid.<BR>&nbsp; multimapped:<BR>&nbsp;&nbsp;&nbsp; Whether there exist multiple sptes pointing at this page.<BR>&nbsp; parent_pte/parent_ptes:<BR>&nbsp;&nbsp;&nbsp; If multimapped is zero, parent_pte points at the single spte that points at<BR>&nbsp;&nbsp;&nbsp; this page's spt.&nbsp; Otherwise, parent_ptes points at a data structure<BR>&nbsp;&nbsp;&nbsp; with a list of parent_ptes.<BR>&nbsp; unsync:<BR>&nbsp;&nbsp;&nbsp; If true, then the translations in this page may not match the guest's<BR>&nbsp;&nbsp;&nbsp; translation.&nbsp; This is equivalent to the state of the tlb when a pte is<BR>&nbsp;&nbsp;&nbsp; changed but before the tlb entry is flushed.&nbsp; Accordingly, unsync ptes<BR>&nbsp;&nbsp;&nbsp; are synchronized when the guest executes invlpg or flushes its tlb by<BR>&nbsp;&nbsp;&nbsp; other means.&nbsp; Valid for leaf pages.<BR>&nbsp; unsync_children:<BR>&nbsp;&nbsp;&nbsp; How many sptes in the page point at pages that are unsync (or have<BR>&nbsp;&nbsp;&nbsp; unsynchronized children).<BR>&nbsp; unsync_child_bitmap:<BR>&nbsp;&nbsp;&nbsp; A bitmap indicating which sptes in spt point (directly or indirectly) at<BR>&nbsp;&nbsp;&nbsp; pages that may be unsynchronized.&nbsp; Used to quickly locate all unsychronized<BR>&nbsp;&nbsp;&nbsp; pages reachable from a given page.</P>
<P>Reverse map<BR>===========</P>
<P>The mmu maintains a reverse mapping whereby all ptes mapping a page can be<BR>reached given its gfn.&nbsp; This is used, for example, when swapping out a page.</P>
<P>Synchronized and unsynchronized pages<BR>=====================================</P>
<P>The guest uses two events to synchronize its tlb and page tables: tlb flushes<BR>and page invalidations (invlpg).</P>
<P>A tlb flush means that we need to synchronize all sptes reachable from the<BR>guest's cr3.&nbsp; This is expensive, so we keep all guest page tables write<BR>protected, and synchronize sptes to gptes when a gpte is written.</P>
<P>A special case is when a guest page table is reachable from the current<BR>guest cr3.&nbsp; In this case, the guest is obliged to issue an invlpg instruction<BR>before using the translation.&nbsp; We take advantage of that by removing write<BR>protection from the guest page, and allowing the guest to modify it freely.<BR>We synchronize modified gptes when the guest invokes invlpg.&nbsp; This reduces<BR>the amount of emulation we have to do when the guest modifies multiple gptes,<BR>or when the a guest page is no longer used as a page table and is used for<BR>random guest data.</P>
<P>As a side effect we have to resynchronize all reachable unsynchronized shadow<BR>pages on a tlb flush.</P>
<P><BR>Reaction to events<BR>==================</P>
<P>- guest page fault (or npt page fault, or ept violation)</P>
<P>This is the most complicated event.&nbsp; The cause of a page fault can be:</P>
<P>&nbsp; - a true guest fault (the guest translation won't allow the access) (*)<BR>&nbsp; - access to a missing translation<BR>&nbsp; - access to a protected translation<BR>&nbsp;&nbsp;&nbsp; - when logging dirty pages, memory is write protected<BR>&nbsp;&nbsp;&nbsp; - synchronized shadow pages are write protected (*)<BR>&nbsp; - access to untranslatable memory (mmio)</P>
<P>&nbsp; (*) not applicable in direct mode</P>
<P>Handling a page fault is performed as follows:</P>
<P>&nbsp;- if needed, walk the guest page tables to determine the guest translation<BR>&nbsp;&nbsp; (gva-&gt;gpa or ngpa-&gt;gpa)<BR>&nbsp;&nbsp; - if permissions are insufficient, reflect the fault back to the guest<BR>&nbsp;- determine the host page<BR>&nbsp;&nbsp; - if this is an mmio request, there is no host page; call the emulator<BR>&nbsp;&nbsp;&nbsp;&nbsp; to emulate the instruction instead<BR>&nbsp;- walk the shadow page table to find the spte for the translation,<BR>&nbsp;&nbsp; instantiating missing intermediate page tables as necessary<BR>&nbsp;- try to unsynchronize the page<BR>&nbsp;&nbsp; - if successful, we can let the guest continue and modify the gpte<BR>&nbsp;- emulate the instruction<BR>&nbsp;&nbsp; - if failed, unshadow the page and let the guest continue<BR>&nbsp;- update any translations that were modified by the instruction</P>
<P>invlpg handling:</P>
<P>&nbsp; - walk the shadow page hierarchy and drop affected translations<BR>&nbsp; - try to reinstantiate the indicated translation in the hope that the<BR>&nbsp;&nbsp;&nbsp; guest will use it in the near future</P>
<P>Guest control register updates:</P>
<P>- mov to cr3<BR>&nbsp; - look up new shadow roots<BR>&nbsp; - synchronize newly reachable shadow pages</P>
<P>- mov to cr0/cr4/efer<BR>&nbsp; - set up mmu context for new paging mode<BR>&nbsp; - look up new shadow roots<BR>&nbsp; - synchronize newly reachable shadow pages</P>
<P>Host translation updates:</P>
<P>&nbsp; - mmu notifier called with updated hva<BR>&nbsp; - look up affected sptes through reverse map<BR>&nbsp; - drop (or update) translations</P>
<P>Emulating cr0.wp<BR>================</P>
<P>If tdp is not enabled, the host must keep cr0.wp=1 so page write protection<BR>works for the guest kernel, not guest guest userspace.&nbsp; When the guest<BR>cr0.wp=1, this does not present a problem.&nbsp; However when the guest cr0.wp=0,<BR>we cannot map the permissions for gpte.u=1, gpte.w=0 to any spte (the<BR>semantics require allowing any guest kernel access plus user read access).</P>
<P>We handle this by mapping the permissions to two possible sptes, depending<BR>on fault type:</P>
<P>- kernel write fault: spte.u=0, spte.w=1 (allows full kernel access,<BR>&nbsp; disallows user access)<BR>- read fault: spte.u=1, spte.w=0 (allows full read access, disallows kernel<BR>&nbsp; write access)</P>
<P>(user write faults generate a #PF)</P>
<P>In the first case there is an additional complication if CR4.SMEP is<BR>enabled: since we've turned the page into a kernel page, the kernel may now<BR>execute it.&nbsp; We handle this by also setting spte.nx.&nbsp; If we get a user<BR>fetch or read fault, we'll change spte.u=1 and spte.nx=gpte.nx back.</P>
<P>To prevent an spte that was converted into a kernel page with cr0.wp=0<BR>from being written by the kernel after cr0.wp has changed to 1, we make<BR>the value of cr0.wp part of the page role.&nbsp; This means that an spte created<BR>with one value of cr0.wp cannot be used when cr0.wp has a different value -<BR>it will simply be missed by the shadow page lookup code.&nbsp; A similar issue<BR>exists when an spte created with cr0.wp=0 and cr4.smep=0 is used after<BR>changing cr4.smep to 1.&nbsp; To avoid this, the value of !cr0.wp &amp;&amp; cr4.smep<BR>is also made a part of the page role.</P>
<P>Large pages<BR>===========</P>
<P>The mmu supports all combinations of large and small guest and host pages.<BR>Supported page sizes include 4k, 2M, 4M, and 1G.&nbsp; 4M pages are treated as<BR>two separate 2M pages, on both guest and host, since the mmu always uses PAE<BR>paging.</P>
<P>To instantiate a large spte, four constraints must be satisfied:</P>
<P>- the spte must point to a large host page<BR>- the guest pte must be a large pte of at least equivalent size (if tdp is<BR>&nbsp; enabled, there is no guest pte and this condition is satisfied)<BR>- if the spte will be writeable, the large page frame may not overlap any<BR>&nbsp; write-protected pages<BR>- the guest page must be wholly contained by a single memory slot</P>
<P>To check the last two conditions, the mmu maintains a -&gt;write_count set of<BR>arrays for each memory slot and large page size.&nbsp; Every write protected page<BR>causes its write_count to be incremented, thus preventing instantiation of<BR>a large spte.&nbsp; The frames at the end of an unaligned memory slot have<BR>artificially inflated -&gt;write_counts so they can never be instantiated.</P>
<P>Further reading<BR>===============</P>
<P>- NPT presentation from KVM Forum 2008<BR>&nbsp; <A href="http://www.linux-kvm.org/wiki/images/c/c8/KvmForum2008%24kdf2008_21.pdf">http://www.linux-kvm.org/wiki/images/c/c8/KvmForum2008%24kdf2008_21.pdf</A></P>
<P>&nbsp;