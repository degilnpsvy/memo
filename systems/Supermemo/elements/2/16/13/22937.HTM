# Documentation/virtual/kvm/msr.txt
<P></P>
<P>KVM-specific MSRs.<BR>Glauber Costa &lt;<A href="mailto:glommer@redhat.com">glommer@redhat.com</A>&gt;, Red Hat Inc, 2010<BR>=====================================================</P>
<P></P>
<P>KVM makes use of some custom MSRs to service some requests.</P>
<P>Custom MSRs have a range reserved for them, that goes from<BR>0x4b564d00 to 0x4b564dff. There are MSRs outside this area,<BR>but they are deprecated and their use is discouraged.</P>
<P>Custom MSR list<BR>--------</P>
<P>The current supported Custom MSR list is:</P>
<P>MSR_KVM_WALL_CLOCK_NEW:&nbsp;&nbsp; 0x4b564d00</P>
<P>&nbsp;data: 4-byte alignment physical address of a memory area which must be<BR>&nbsp;in guest RAM. This memory is expected to hold a copy of the following<BR>&nbsp;structure:</P>
<P>&nbsp;struct pvclock_wall_clock {<BR>&nbsp;&nbsp;u32&nbsp;&nbsp; version;<BR>&nbsp;&nbsp;u32&nbsp;&nbsp; sec;<BR>&nbsp;&nbsp;u32&nbsp;&nbsp; nsec;<BR>&nbsp;} __attribute__((__packed__));</P>
<P>&nbsp;whose data will be filled in by the hypervisor. The hypervisor is only<BR>&nbsp;guaranteed to update this data at the moment of MSR write.<BR>&nbsp;Users that want to reliably query this information more than once have<BR>&nbsp;to write more than once to this MSR. Fields have the following meanings:</P>
<P>&nbsp;&nbsp;version: guest has to check version before and after grabbing<BR>&nbsp;&nbsp;time information and check that they are both equal and even.<BR>&nbsp;&nbsp;An odd version indicates an in-progress update.</P>
<P>&nbsp;&nbsp;sec: number of seconds for wallclock at time of boot.</P>
<P>&nbsp;&nbsp;nsec: number of nanoseconds for wallclock at time of boot.</P>
<P>&nbsp;In order to get the current wallclock time, the system_time from<BR>&nbsp;MSR_KVM_SYSTEM_TIME_NEW needs to be added.</P>
<P>&nbsp;Note that although MSRs are per-CPU entities, the effect of this<BR>&nbsp;particular MSR is global.</P>
<P>&nbsp;Availability of this MSR must be checked via bit 3 in 0x4000001 cpuid<BR>&nbsp;leaf prior to usage.</P>
<P>MSR_KVM_SYSTEM_TIME_NEW:&nbsp; 0x4b564d01</P>
<P>&nbsp;data: 4-byte aligned physical address of a memory area which must be in<BR>&nbsp;guest RAM, plus an enable bit in bit 0. This memory is expected to hold<BR>&nbsp;a copy of the following structure:</P>
<P>&nbsp;struct pvclock_vcpu_time_info {<BR>&nbsp;&nbsp;u32&nbsp;&nbsp; version;<BR>&nbsp;&nbsp;u32&nbsp;&nbsp; pad0;<BR>&nbsp;&nbsp;u64&nbsp;&nbsp; tsc_timestamp;<BR>&nbsp;&nbsp;u64&nbsp;&nbsp; system_time;<BR>&nbsp;&nbsp;u32&nbsp;&nbsp; tsc_to_system_mul;<BR>&nbsp;&nbsp;s8&nbsp;&nbsp;&nbsp; tsc_shift;<BR>&nbsp;&nbsp;u8&nbsp;&nbsp;&nbsp; flags;<BR>&nbsp;&nbsp;u8&nbsp;&nbsp;&nbsp; pad[2];<BR>&nbsp;} __attribute__((__packed__)); /* 32 bytes */</P>
<P>&nbsp;whose data will be filled in by the hypervisor periodically. Only one<BR>&nbsp;write, or registration, is needed for each VCPU. The interval between<BR>&nbsp;updates of this structure is arbitrary and implementation-dependent.<BR>&nbsp;The hypervisor may update this structure at any time it sees fit until<BR>&nbsp;anything with bit0 == 0 is written to it.</P>
<P>&nbsp;Fields have the following meanings:</P>
<P>&nbsp;&nbsp;version: guest has to check version before and after grabbing<BR>&nbsp;&nbsp;time information and check that they are both equal and even.<BR>&nbsp;&nbsp;An odd version indicates an in-progress update.</P>
<P>&nbsp;&nbsp;tsc_timestamp: the tsc value at the current VCPU at the time<BR>&nbsp;&nbsp;of the update of this structure. Guests can subtract this value<BR>&nbsp;&nbsp;from current tsc to derive a notion of elapsed time since the<BR>&nbsp;&nbsp;structure update.</P>
<P>&nbsp;&nbsp;system_time: a host notion of monotonic time, including sleep<BR>&nbsp;&nbsp;time at the time this structure was last updated. Unit is<BR>&nbsp;&nbsp;nanoseconds.</P>
<P>&nbsp;&nbsp;tsc_to_system_mul: multiplier to be used when converting<BR>&nbsp;&nbsp;tsc-related quantity to nanoseconds</P>
<P>&nbsp;&nbsp;tsc_shift: shift to be used when converting tsc-related<BR>&nbsp;&nbsp;quantity to nanoseconds. This shift will ensure that<BR>&nbsp;&nbsp;multiplication with tsc_to_system_mul does not overflow.<BR>&nbsp;&nbsp;A positive value denotes a left shift, a negative value<BR>&nbsp;&nbsp;a right shift.</P>
<P>&nbsp;&nbsp;The conversion from tsc to nanoseconds involves an additional<BR>&nbsp;&nbsp;right shift by 32 bits. With this information, guests can<BR>&nbsp;&nbsp;derive per-CPU time by doing:</P>
<P>&nbsp;&nbsp;&nbsp;time = (current_tsc - tsc_timestamp)<BR>&nbsp;&nbsp;&nbsp;if (tsc_shift &gt;= 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;time &lt;&lt;= tsc_shift;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;time &gt;&gt;= -tsc_shift;<BR>&nbsp;&nbsp;&nbsp;time = (time * tsc_to_system_mul) &gt;&gt; 32<BR>&nbsp;&nbsp;&nbsp;time = time + system_time</P>
<P>&nbsp;&nbsp;flags: bits in this field indicate extended capabilities<BR>&nbsp;&nbsp;coordinated between the guest and the hypervisor. Availability<BR>&nbsp;&nbsp;of specific flags has to be checked in 0x40000001 cpuid leaf.<BR>&nbsp;&nbsp;Current flags are:</P>
<P>&nbsp;&nbsp; flag bit&nbsp;&nbsp; | cpuid bit&nbsp;&nbsp;&nbsp; | meaning<BR>&nbsp;&nbsp;-------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | time measures taken across<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; 24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | multiple cpus are guaranteed to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | be monotonic<BR>&nbsp;&nbsp;-------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | guest vcpu has been paused by<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; N/A&nbsp;&nbsp;&nbsp; | the host<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | See 4.70 in api.txt<BR>&nbsp;&nbsp;-------------------------------------------------------------</P>
<P>&nbsp;Availability of this MSR must be checked via bit 3 in 0x4000001 cpuid<BR>&nbsp;leaf prior to usage.</P>
<P><BR>MSR_KVM_WALL_CLOCK:&nbsp; 0x11</P>
<P>&nbsp;data and functioning: same as MSR_KVM_WALL_CLOCK_NEW. Use that instead.</P>
<P>&nbsp;This MSR falls outside the reserved KVM range and may be removed in the<BR>&nbsp;future. Its usage is deprecated.</P>
<P>&nbsp;Availability of this MSR must be checked via bit 0 in 0x4000001 cpuid<BR>&nbsp;leaf prior to usage.</P>
<P>MSR_KVM_SYSTEM_TIME: 0x12</P>
<P>&nbsp;data and functioning: same as MSR_KVM_SYSTEM_TIME_NEW. Use that instead.</P>
<P>&nbsp;This MSR falls outside the reserved KVM range and may be removed in the<BR>&nbsp;future. Its usage is deprecated.</P>
<P>&nbsp;Availability of this MSR must be checked via bit 0 in 0x4000001 cpuid<BR>&nbsp;leaf prior to usage.</P>
<P>&nbsp;The suggested algorithm for detecting kvmclock presence is then:</P>
<P>&nbsp;&nbsp;if (!kvm_para_available())&nbsp;&nbsp;&nbsp; /* refer to cpuid.txt */<BR>&nbsp;&nbsp;&nbsp;return NON_PRESENT;</P>
<P>&nbsp;&nbsp;flags = cpuid_eax(0x40000001);<BR>&nbsp;&nbsp;if (flags &amp; 3) {<BR>&nbsp;&nbsp;&nbsp;msr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;<BR>&nbsp;&nbsp;&nbsp;msr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;<BR>&nbsp;&nbsp;&nbsp;return PRESENT;<BR>&nbsp;&nbsp;} else if (flags &amp; 0) {<BR>&nbsp;&nbsp;&nbsp;msr_kvm_system_time = MSR_KVM_SYSTEM_TIME;<BR>&nbsp;&nbsp;&nbsp;msr_kvm_wall_clock = MSR_KVM_WALL_CLOCK;<BR>&nbsp;&nbsp;&nbsp;return PRESENT;<BR>&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;return NON_PRESENT;</P>
<P>MSR_KVM_ASYNC_PF_EN: 0x4b564d02<BR>&nbsp;data: Bits 63-6 hold 64-byte aligned physical address of a<BR>&nbsp;64 byte memory area which must be in guest RAM and must be<BR>&nbsp;zeroed. Bits 5-2 are reserved and should be zero. Bit 0 is 1<BR>&nbsp;when asynchronous page faults are enabled on the vcpu 0 when<BR>&nbsp;disabled. Bit 2 is 1 if asynchronous page faults can be injected<BR>&nbsp;when vcpu is in cpl == 0.</P>
<P>&nbsp;First 4 byte of 64 byte memory location will be written to by<BR>&nbsp;the hypervisor at the time of asynchronous page fault (APF)<BR>&nbsp;injection to indicate type of asynchronous page fault. Value<BR>&nbsp;of 1 means that the page referred to by the page fault is not<BR>&nbsp;present. Value 2 means that the page is now available. Disabling<BR>&nbsp;interrupt inhibits APFs. Guest must not enable interrupt<BR>&nbsp;before the reason is read, or it may be overwritten by another<BR>&nbsp;APF. Since APF uses the same exception vector as regular page<BR>&nbsp;fault guest must reset the reason to 0 before it does<BR>&nbsp;something that can generate normal page fault.&nbsp; If during page<BR>&nbsp;fault APF reason is 0 it means that this is regular page<BR>&nbsp;fault.</P>
<P>&nbsp;During delivery of type 1 APF cr2 contains a token that will<BR>&nbsp;be used to notify a guest when missing page becomes<BR>&nbsp;available. When page becomes available type 2 APF is sent with<BR>&nbsp;cr2 set to the token associated with the page. There is special<BR>&nbsp;kind of token 0xffffffff which tells vcpu that it should wake<BR>&nbsp;up all processes waiting for APFs and no individual type 2 APFs<BR>&nbsp;will be sent.</P>
<P>&nbsp;If APF is disabled while there are outstanding APFs, they will<BR>&nbsp;not be delivered.</P>
<P>&nbsp;Currently type 2 APF will be always delivered on the same vcpu as<BR>&nbsp;type 1 was, but guest should not rely on that.</P>
<P>MSR_KVM_STEAL_TIME: 0x4b564d03</P>
<P>&nbsp;data: 64-byte alignment physical address of a memory area which must be<BR>&nbsp;in guest RAM, plus an enable bit in bit 0. This memory is expected to<BR>&nbsp;hold a copy of the following structure:</P>
<P>&nbsp;struct kvm_steal_time {<BR>&nbsp;&nbsp;__u64 steal;<BR>&nbsp;&nbsp;__u32 version;<BR>&nbsp;&nbsp;__u32 flags;<BR>&nbsp;&nbsp;__u32 pad[12];<BR>&nbsp;}</P>
<P>&nbsp;whose data will be filled in by the hypervisor periodically. Only one<BR>&nbsp;write, or registration, is needed for each VCPU. The interval between<BR>&nbsp;updates of this structure is arbitrary and implementation-dependent.<BR>&nbsp;The hypervisor may update this structure at any time it sees fit until<BR>&nbsp;anything with bit0 == 0 is written to it. Guest is required to make sure<BR>&nbsp;this structure is initialized to zero.</P>
<P>&nbsp;Fields have the following meanings:</P>
<P>&nbsp;&nbsp;version: a sequence counter. In other words, guest has to check<BR>&nbsp;&nbsp;this field before and after grabbing time information and make<BR>&nbsp;&nbsp;sure they are both equal and even. An odd version indicates an<BR>&nbsp;&nbsp;in-progress update.</P>
<P>&nbsp;&nbsp;flags: At this point, always zero. May be used to indicate<BR>&nbsp;&nbsp;changes in this structure in the future.</P>
<P>&nbsp;&nbsp;steal: the amount of time in which this vCPU did not run, in<BR>&nbsp;&nbsp;nanoseconds. Time during which the vcpu is idle, will not be<BR>&nbsp;&nbsp;reported as steal time.</P>
<P>MSR_KVM_EOI_EN: 0x4b564d04<BR>&nbsp;data: Bit 0 is 1 when PV end of interrupt is enabled on the vcpu; 0<BR>&nbsp;when disabled.&nbsp; Bit 1 is reserved and must be zero.&nbsp; When PV end of<BR>&nbsp;interrupt is enabled (bit 0 set), bits 63-2 hold a 4-byte aligned<BR>&nbsp;physical address of a 4 byte memory area which must be in guest RAM and<BR>&nbsp;must be zeroed.</P>
<P>&nbsp;The first, least significant bit of 4 byte memory location will be<BR>&nbsp;written to by the hypervisor, typically at the time of interrupt<BR>&nbsp;injection.&nbsp; Value of 1 means that guest can skip writing EOI to the apic<BR>&nbsp;(using MSR or MMIO write); instead, it is sufficient to signal<BR>&nbsp;EOI by clearing the bit in guest memory - this location will<BR>&nbsp;later be polled by the hypervisor.<BR>&nbsp;Value of 0 means that the EOI write is required.</P>
<P>&nbsp;It is always safe for the guest to ignore the optimization and perform<BR>&nbsp;the APIC EOI write anyway.</P>
<P>&nbsp;Hypervisor is guaranteed to only modify this least<BR>&nbsp;significant bit while in the current VCPU context, this means that<BR>&nbsp;guest does not need to use either lock prefix or memory ordering<BR>&nbsp;primitives to synchronise with the hypervisor.</P>
<P>&nbsp;However, hypervisor can set and clear this memory bit at any time:<BR>&nbsp;therefore to make sure hypervisor does not interrupt the<BR>&nbsp;guest and clear the least significant bit in the memory area<BR>&nbsp;in the window between guest testing it to detect<BR>&nbsp;whether it can skip EOI apic write and between guest<BR>&nbsp;clearing it to signal EOI to the hypervisor,<BR>&nbsp;guest must both read the least significant bit in the memory area and<BR>&nbsp;clear it using a single CPU instruction, such as test and clear, or<BR>&nbsp;compare and exchange.