<H3 id=-100000 class=docSection1Title>Tying the Pieces Together</H3>
<P class=docText><A name=iddle1661></A><A name=iddle3509></A><A name=iddle3545></A><A name="As you"></A>As you saw in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch09lev1sec2.html#ch09fig03">Figure 9.3</A><A name="layer consists"></A>, the PCMCIA layer consists of various components. The data-flow path between the components can sometimes get complicated. Let's trace the code path from the time you insert a PCMCIA card until an application starts transferring data to the card. Assume that a Cisco Aironet PCMCIA card is inserted onto a laptop having an 82365-compatible PCMCIA host controller:</P><A name=ch09pro02></A>
<TABLE class=docText border=0>
<TBODY>
<TR>
<TD vAlign=top width=25>
<DIV class=docText><B>1. </B></DIV></TD>
<TD>
<DIV class=docText>The PCMCIA host controller driver (<SPAN class=docEmphasis>drivers/pcmcia/yenta_socket.c</SPAN>) detects the insertion event via its interrupt service routine and makes note of it using suitable data structures.<BR><BR></DIV></TD></TR>
<TR>
<TD vAlign=top width=25>
<DIV class=docText><B>2. </B></DIV></TD>
<TD>
<DIV class=docText>The pccardd kernel thread that is part of Card Services (<SPAN class=docEmphasis>drivers/pcmcia/cs.c</SPAN>) sleeps on a wait queue until the host controller driver wakes it up when it detects the card insertion in Step 1.<BR><BR></DIV></TD></TR>
<TR>
<TD vAlign=top width=25>
<DIV class=docText><B>3. </B></DIV></TD>
<TD>
<DIV class=docText>Card Services dispatches an insertion event to Driver Services (<SPAN class=docEmphasis>drivers/pcmcia/ds.c</SPAN>). This triggers execution of the event handler registered by Driver Services during initialization.<BR><BR></DIV></TD></TR>
<TR>
<TD vAlign=top width=25>
<DIV class=docText><B>4. </B></DIV></TD>
<TD>
<DIV class=docText>Driver Services validates the card's CIS space, determines information about the inserted device such as its manufacturer ID and card ID, and registers the device with the kernel. The appropriate client device driver (<SPAN class=docEmphasis>drivers/net/wireless/airo_cs.c</SPAN>) is then loaded. Revisit our previous discussion on <TT>MODULE_DEVICE_TABLE()</TT> to see how this is accomplished.<BR><BR></DIV></TD></TR>
<TR>
<TD vAlign=top width=25>
<DIV class=docText><B>5. </B></DIV></TD>
<TD>
<DIV class=docText>The client driver (<SPAN class=docEmphasis>airo_cs.c</SPAN>) loaded in Step 4 initializes and registers itself using <TT>pcmcia_register_driver()</TT>, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch09lev1sec6.html#ch09ex01">Listing 9.1</A>. This registration interface internally sets the bus type of the device to <TT>pcmcia_bus_type</TT>. PCMCIA bus operations such as <TT>probe()</TT> and <TT>remove()</TT>, defined by Driver Services (<SPAN class=docEmphasis>ds.c</SPAN>), are also internally registered.<BR><BR></DIV></TD></TR>
<TR>
<TD vAlign=top width=25>
<DIV class=docText><B>6. </B></DIV></TD>
<TD>
<DIV class=docText>The kernel invokes the bus <TT>probe()</TT> operation registered by Driver Services in Step 5. This in turn, invokes the <TT>probe()</TT> method owned by the matching client driver (<TT>airo_probe()</TT>), also registered in Step 5. The client <TT>probe()</TT> routine populates settings, such as I/O windows and interrupt lines, and configures the generic chipset-specific driver (<SPAN class=docEmphasis>drivers/net/wireless/airo.c</SPAN>), as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch09lev1sec6.html#ch09ex02">Listing 9.2</A>.<BR><BR></DIV></TD></TR>
<TR>
<TD></TD>
<TD></TD></TR>
<TR>
<TD vAlign=top width=25>
<DIV class=docText><B>7. </B></DIV></TD>
<TD>
<DIV class=docText><A name=iddle1406></A><A name=iddle2973></A><A name=iddle2990></A><A name=iddle3530></A><A name=iddle3532></A><A name=iddle3972></A><A name=iddle4161></A>The chipset driver (<SPAN class=docEmphasis>airo.c</SPAN>) creates a network interface (ethX) and is responsible for normal operation from this point onward. It's this driver that handles interrupts generated by the card in response to packet reception and transmit completion. The form factor of the device (for example, whether it's a PCMCIA or a PCI card) is transparent to the chipset driver as well as to the applications that operate over ethX.<BR></DIV></TD></TR></TBODY></TABLE>