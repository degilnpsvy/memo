#Documentation/volatile-considered-harmful.txt 
<P></P>
<P>Why the "volatile" type class should not be used<BR>------------------------------------------------</P>
<P></P>
<P>C programmers have often taken volatile to mean that the variable could be<BR>changed outside of the current thread of execution; as a result, they are<BR>sometimes tempted to use it in kernel code when shared data structures are<BR>being used.&nbsp; In other words, they have been known to treat volatile types<BR>as a sort of easy atomic variable, which they are not.&nbsp; The use of volatile in<BR>kernel code is almost never correct; this document describes why.</P>
<P>The key point to understand with regard to volatile is that its purpose is<BR>to suppress optimization, which is almost never what one really wants to<BR>do.&nbsp; In the kernel, one must protect shared data structures against<BR>unwanted concurrent access, which is very much a different task.&nbsp; <FONT class=extract>The<BR>process of protecting against unwanted concurrency will also avoid almost<BR>all optimization-related problems in a more efficient way.</FONT></P>
<P><FONT class=extract>Like volatile, the kernel primitives which make concurrent access to data<BR>safe (spinlocks, mutexes, memory barriers, etc.) are designed to prevent<BR>unwanted optimization.&nbsp; If they are being used properly, there will be no<BR>need to use volatile as well.&nbsp; If volatile is still necessary, there is<BR>almost certainly a bug in the code somewhere.&nbsp; In properly-written kernel<BR>code, volatile can only serve to slow things down.</FONT></P>
<P><FONT class=extract>Consider a typical block of kernel code:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; spin_lock(&amp;the_lock);<BR>&nbsp;&nbsp;&nbsp; do_something_on(&amp;shared_data);<BR>&nbsp;&nbsp;&nbsp; do_something_else_with(&amp;shared_data);<BR>&nbsp;&nbsp;&nbsp; spin_unlock(&amp;the_lock);</FONT></P>
<P><FONT class=extract>If all the code follows the locking rules, the value of shared_data cannot<BR>change unexpectedly while the_lock is held.&nbsp; Any other code which might<BR>want to play with that data will be waiting on the lock.&nbsp; The spinlock<BR>primitives act as memory barriers - they are explicitly written to do so -<BR>meaning that data accesses will not be optimized across them.&nbsp; So the<BR>compiler might think it knows what will be in shared_data, but the<BR>spin_lock() call, since it acts as a memory barrier, will force it to<BR>forget anything it knows.&nbsp; There will be no optimization problems with<BR>accesses to that data.</FONT></P>
<P><FONT class=extract>If shared_data were declared volatile, the locking would still be<BR>necessary.&nbsp; But the compiler would also be prevented from optimizing access<BR>to shared_data _within_ the critical section, when we know that nobody else<BR>can be working with it.&nbsp; While the lock is held, shared_data is not<BR>volatile.&nbsp; When dealing with shared data, proper locking makes volatile<BR>unnecessary - and potentially harmful.</FONT></P>
<P><FONT class=extract>The volatile storage class was originally meant for memory-mapped I/O<BR>registers.&nbsp; Within the kernel, register accesses, too, should be protected<BR>by locks, but one also does not want the compiler "optimizing" register<BR>accesses within a critical section.&nbsp; But, within the kernel, I/O memory<BR>accesses are always done through accessor functions; accessing I/O memory<BR>directly through pointers is frowned upon and does not work on all<BR>architectures.&nbsp; Those accessors are written to prevent unwanted<BR>optimization, so, once again, volatile is unnecessary.</FONT></P>
<P><FONT class=extract>Another situation where one might be tempted to use volatile is<BR>when the processor is busy-waiting on the value of a variable.&nbsp; The right<BR>way to perform a busy wait is:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; while (my_variable != what_i_want)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_relax();</FONT></P>
<P><FONT class=extract>The cpu_relax() call can lower CPU power consumption or yield to a<BR>hyperthreaded twin processor; it also happens to serve as a compiler<BR>barrier, so, once again, volatile is unnecessary.&nbsp; Of course, busy-<BR>waiting is generally an anti-social act to begin with.</FONT></P>
<P><FONT class=extract>There are still a few rare situations where volatile makes sense in the<BR>kernel:</FONT></P>
<P><FONT class=extract>&nbsp; - The above-mentioned accessor functions might use volatile on<BR>&nbsp;&nbsp;&nbsp; architectures where direct I/O memory access does work.&nbsp; Essentially,<BR>&nbsp;&nbsp;&nbsp; each accessor call becomes a little critical section on its own and<BR>&nbsp;&nbsp;&nbsp; ensures that the access happens as expected by the programmer.</FONT></P>
<P><FONT class=extract>&nbsp; - Inline assembly code which changes memory, but which has no other<BR>&nbsp;&nbsp;&nbsp; visible side effects, risks being deleted by GCC.&nbsp; Adding the volatile<BR>&nbsp;&nbsp;&nbsp; keyword to asm statements will prevent this removal.</FONT></P>
<P><FONT class=extract>&nbsp; - The jiffies variable is special in that it can have a different value<BR>&nbsp;&nbsp;&nbsp; every time it is referenced, but it can be read without any special<BR>&nbsp;&nbsp;&nbsp; locking.&nbsp; So jiffies can be volatile, but the addition of other<BR>&nbsp;&nbsp;&nbsp; variables of this type is strongly frowned upon.&nbsp; Jiffies is considered<BR>&nbsp;&nbsp;&nbsp; to be a "stupid legacy" issue (Linus's words) in this regard; fixing it<BR>&nbsp;&nbsp;&nbsp; would be more trouble than it is worth.</FONT></P>
<P><FONT class=extract>&nbsp; - Pointers to data structures in coherent memory which might be modified<BR>&nbsp;&nbsp;&nbsp; by I/O devices can, sometimes, legitimately be volatile.&nbsp; A ring buffer<BR>&nbsp;&nbsp;&nbsp; used by a network adapter, where that adapter changes pointers to<BR>&nbsp;&nbsp;&nbsp; indicate which descriptors have been processed, is an example of this<BR>&nbsp;&nbsp;&nbsp; type of situation.</FONT></P>
<P><FONT class=extract>For most code, none of the above justifications for volatile apply.&nbsp; As a<BR>result, the use of volatile is likely to be seen as a bug and will bring<BR>additional scrutiny to the code.&nbsp; Developers who are tempted to use<BR>volatile should take a step back and think about what they are truly trying<BR>to accomplish.</FONT></P>
<P>Patches to remove volatile variables are generally welcome - as long as<BR>they come with a justification which shows that the concurrency issues have<BR>been properly thought through.</P>
<P><BR>NOTES<BR>-----</P>
<P>[1] <A href="http://lwn.net/Articles/233481/">http://lwn.net/Articles/233481/</A><BR>[2] <A href="http://lwn.net/Articles/233482/">http://lwn.net/Articles/233482/</A></P>
<P>CREDITS<BR>-------</P>
<P>Original impetus and research by Randy Dunlap<BR>Written by Jonathan Corbet<BR>Improvements via comments from Satyam Sharma, Johannes Stezenbach, Jesper<BR>&nbsp;Juhl, Heikki Orsila, H. Peter Anvin, Philipp Hahn, and Stefan<BR>&nbsp;Richter.