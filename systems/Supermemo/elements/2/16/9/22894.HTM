#/Documentation/vgaarbiter.txt 
<P></P>
<P>VGA Arbiter<BR>=========== </P>
<P></P>
<P><FONT class=extract>Graphic devices are accessed through ranges in I/O or memory space. While most<BR>modern devices allow relocation of such ranges</FONT>, some "Legacy" VGA devices<BR>implemented on PCI will typically have the same "hard-decoded" addresses as<BR>they did on ISA. For more details see "PCI Bus Binding to IEEE Std 1275-1994<BR>Standard for Boot (Initialization Configuration) Firmware Revision 2.1"<BR>Section 7, Legacy Devices.</P>
<P>The Resource Access Control (RAC) module inside the X server [0] existed for<BR>the legacy VGA arbitration task (besides other bus management tasks) when more<BR>than one legacy device co-exists on the same machine. But the problem happens<BR>when these devices are trying to be accessed by different userspace clients<BR>(e.g. two server in parallel). Their address assignments conflict. Moreover,<BR>ideally, being a userspace application, it is not the role of the X server to<BR>control bus resources. Therefore an arbitration scheme outside of the X server<BR>is needed to control the sharing of these resources. This document introduces<BR>the operation of the VGA arbiter implemented for the Linux kernel.</P>
<P>----------------------------------------------------------------------------</P>
<P>I.&nbsp; Details and Theory of Operation<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I.1 vgaarb<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I.2 libpciaccess<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I.3 xf86VGAArbiter (X server implementation)<BR>II. Credits<BR>III.References</P>
<P><BR>I. Details and Theory of Operation<BR>==================================</P>
<P>I.1 vgaarb<BR>----------</P>
<P>The vgaarb is a module of the Linux Kernel. When it is initially loaded, it<BR>scans all PCI devices and adds the VGA ones inside the arbitration. The<BR>arbiter then enables/disables the decoding on different devices of the VGA<BR>legacy instructions. Devices which do not want/need to use the arbiter may<BR>explicitly tell it by calling vga_set_legacy_decoding().</P>
<P>The kernel exports a char device interface (/dev/vga_arbiter) to the clients,<BR>which has the following semantics:</P>
<P>&nbsp;open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : open user instance of the arbiter. By default, it's attached to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the default VGA device of the system.</P>
<P>&nbsp;close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : close user instance. Release locks made by the user</P>
<P>&nbsp;read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : return a string indicating the status of the target like:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;card_ID&gt;,decodes=&lt;io_state&gt;,owns=&lt;io_state&gt;,locks=&lt;io_state&gt; (ic,mc)"</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An IO state string is of the form {io,mem,io+mem,none}, mc and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ic are respectively mem and io lock counts (for debugging/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diagnostic only). "decodes" indicate what the card currently<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decodes, "owns" indicates what is currently enabled on it, and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "locks" indicates what is locked by this card. If the card is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unplugged, we get "invalid" then for card_ID and an -ENODEV<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error is returned for any command until a new card is targeted.</P>
<P><BR>&nbsp;write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : write a command to the arbiter. List of commands:</P>
<P>&nbsp; target &lt;card_ID&gt;&nbsp;&nbsp; : switch target to card &lt;card_ID&gt; (see below)<BR>&nbsp; lock &lt;io_state&gt;&nbsp;&nbsp;&nbsp; : acquires locks on target ("none" is an invalid io_state)<BR>&nbsp; trylock &lt;io_state&gt; : non-blocking acquire locks on target (returns EBUSY if<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsuccessful)<BR>&nbsp; unlock &lt;io_state&gt;&nbsp; : release locks on target<BR>&nbsp; unlock all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : release all locks on target held by this user (not<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implemented yet)<BR>&nbsp; decodes &lt;io_state&gt; : set the legacy decoding attributes for the card</P>
<P>&nbsp; poll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : event if something changes on any card (not just the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target)</P>
<P>&nbsp; card_ID is of the form "PCI:domain:bus:dev.fn". It can be set to "default"<BR>&nbsp; to go back to the system default card (TODO: not implemented yet). Currently,<BR>&nbsp; only PCI is supported as a prefix, but the userland API may support other bus<BR>&nbsp; types in the future, even if the current kernel implementation doesn't.</P>
<P>Note about locks:</P>
<P>The driver keeps track of which user has which locks on which card. It<BR>supports stacking, like the kernel one. This complexifies the implementation<BR>a bit, but makes the arbiter more tolerant to user space problems and able<BR>to properly cleanup in all cases when a process dies.<BR>Currently, a max of 16 cards can have locks simultaneously issued from<BR>user space for a given user (file descriptor instance) of the arbiter.</P>
<P>In the case of devices hot-{un,}plugged, there is a hook - pci_notify() - to<BR>notify them being added/removed in the system and automatically added/removed<BR>in the arbiter.</P>
<P>There is also an in-kernel API of the arbiter in case DRM, vgacon, or other<BR>drivers want to use it.</P>
<P><BR>I.2 libpciaccess<BR>----------------</P>
<P>To use the vga arbiter char device it was implemented an API inside the<BR>libpciaccess library. One field was added to struct pci_device (each device<BR>on the system):</P>
<P>&nbsp;&nbsp;&nbsp; /* the type of resource decoded by the device */<BR>&nbsp;&nbsp;&nbsp; int vgaarb_rsrc;</P>
<P>Besides it, in pci_system were added:</P>
<P>&nbsp;&nbsp;&nbsp; int vgaarb_fd;<BR>&nbsp;&nbsp;&nbsp; int vga_count;<BR>&nbsp;&nbsp;&nbsp; struct pci_device *vga_target;<BR>&nbsp;&nbsp;&nbsp; struct pci_device *vga_default_dev;</P>
<P><BR>The vga_count is used to track how many cards are being arbitrated, so for<BR>instance, if there is only one card, then it can completely escape arbitration.</P>
<P><BR>These functions below acquire VGA resources for the given card and mark those<BR>resources as locked. If the resources requested are "normal" (and not legacy)<BR>resources, the arbiter will first check whether the card is doing legacy<BR>decoding for that type of resource. If yes, the lock is "converted" into a<BR>legacy resource lock. The arbiter will first look for all VGA cards that<BR>might conflict and disable their IOs and/or Memory access, including VGA<BR>forwarding on P2P bridges if necessary, so that the requested resources can<BR>be used. Then, the card is marked as locking these resources and the IO and/or<BR>Memory access is enabled on the card (including VGA forwarding on parent<BR>P2P bridges if any). In the case of vga_arb_lock(), the function will block<BR>if some conflicting card is already locking one of the required resources (or<BR>any resource on a different bus segment, since P2P bridges don't differentiate<BR>VGA memory and IO afaik). If the card already owns the resources, the function<BR>succeeds.&nbsp; vga_arb_trylock() will return (-EBUSY) instead of blocking. Nested<BR>calls are supported (a per-resource counter is maintained).</P>
<P><BR>Set the target device of this client.<BR>&nbsp;&nbsp;&nbsp; int&nbsp; pci_device_vgaarb_set_target&nbsp;&nbsp; (struct pci_device *dev);</P>
<P><BR>For instance, in x86 if two devices on the same bus want to lock different<BR>resources, both will succeed (lock). If devices are in different buses and<BR>trying to lock different resources, only the first who tried succeeds.<BR>&nbsp;&nbsp;&nbsp; int&nbsp; pci_device_vgaarb_lock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void);<BR>&nbsp;&nbsp;&nbsp; int&nbsp; pci_device_vgaarb_trylock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void);</P>
<P>Unlock resources of device.<BR>&nbsp;&nbsp;&nbsp; int&nbsp; pci_device_vgaarb_unlock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void);</P>
<P>Indicates to the arbiter if the card decodes legacy VGA IOs, legacy VGA<BR>Memory, both, or none. All cards default to both, the card driver (fbdev for<BR>example) should tell the arbiter if it has disabled legacy decoding, so the<BR>card can be left out of the arbitration process (and can be safe to take<BR>interrupts at any time.<BR>&nbsp;&nbsp;&nbsp; int&nbsp; pci_device_vgaarb_decodes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int new_vgaarb_rsrc);</P>
<P>Connects to the arbiter device, allocates the struct<BR>&nbsp;&nbsp;&nbsp; int&nbsp; pci_device_vgaarb_init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void);</P>
<P>Close the connection<BR>&nbsp;&nbsp;&nbsp; void pci_device_vgaarb_fini&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void);</P>
<P><BR>I.3 xf86VGAArbiter (X server implementation)<BR>--------------------------------------------</P>
<P>(TODO)</P>
<P>X server basically wraps all the functions that touch VGA registers somehow.</P>
<P><BR>II. Credits<BR>===========</P>
<P>Benjamin Herrenschmidt (IBM?) started this work when he discussed such design<BR>with the Xorg community in 2005 [1, 2]. In the end of 2007, Paulo Zanoni and<BR>Tiago Vignatti (both of C3SL/Federal University of Paran&#225;) proceeded his work<BR>enhancing the kernel code to adapt as a kernel module and also did the<BR>implementation of the user space side [3]. Now (2009) Tiago Vignatti and Dave<BR>Airlie finally put this work in shape and queued to Jesse Barnes' PCI tree.</P>
<P><BR>III. References<BR>==============</P>
<P>[0] <A href="http://cgit.freedesktop.org/xorg/xserver/commit/?id=4b42448a2388d40f257774fbffdccaea87bd0347">http://cgit.freedesktop.org/xorg/xserver/commit/?id=4b42448a2388d40f257774fbffdccaea87bd0347</A><BR>[1] <A href="http://lists.freedesktop.org/archives/xorg/2005-March/006663.html">http://lists.freedesktop.org/archives/xorg/2005-March/006663.html</A><BR>[2] <A href="http://lists.freedesktop.org/archives/xorg/2005-March/006745.html">http://lists.freedesktop.org/archives/xorg/2005-March/006745.html</A><BR>[3] <A href="http://lists.freedesktop.org/archives/xorg/2007-October/029507.html">http://lists.freedesktop.org/archives/xorg/2007-October/029507.html</A>