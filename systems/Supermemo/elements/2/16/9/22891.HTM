#/Documentation/static-keys.txt 
<P></P>
<P>&nbsp;&nbsp;&nbsp;Static Keys<BR>&nbsp;&nbsp;&nbsp;-----------</P>
<P></P>
<P>By: Jason Baron &lt;<A href="mailto:jbaron@redhat.com">jbaron@redhat.com</A>&gt;</P>
<P>0) Abstract</P>
<P>Static keys allows the inclusion of seldom used features in<BR>performance-sensitive fast-path kernel code, via a GCC feature and a code<BR>patching technique. A quick example:</P>
<P>&nbsp;struct static_key key = STATIC_KEY_INIT_FALSE;</P>
<P>&nbsp;...</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (static_key_false(&amp;key))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do unlikely code<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do likely code</P>
<P>&nbsp;...<BR>&nbsp;static_key_slow_inc();<BR>&nbsp;...<BR>&nbsp;static_key_slow_inc();<BR>&nbsp;...</P>
<P>The static_key_false() branch will be generated into the code with as little<BR>impact to the likely code path as possible.</P>
<P><BR>1) Motivation</P>
<P><BR>Currently, tracepoints are implemented using a conditional branch. The<BR>conditional check requires checking a global variable for each tracepoint.<BR>Although the overhead of this check is small, it increases when the memory<BR>cache comes under pressure (memory cache lines for these global variables may<BR>be shared with other memory accesses). As we increase the number of tracepoints<BR>in the kernel this overhead may become more of an issue. In addition,<BR>tracepoints are often dormant (disabled) and provide no direct kernel<BR>functionality. Thus, it is highly desirable to reduce their impact as much as<BR>possible. Although tracepoints are the original motivation for this work, other<BR>kernel code paths should be able to make use of the static keys facility.</P>
<P><BR>2) Solution</P>
<P><BR>gcc (v4.5) adds a new 'asm goto' statement that allows branching to a label:</P>
<P><A href="http://gcc.gnu.org/ml/gcc-patches/2009-07/msg01556.html">http://gcc.gnu.org/ml/gcc-patches/2009-07/msg01556.html</A></P>
<P>Using the 'asm goto', we can create branches that are either taken or not taken<BR>by default, without the need to check memory. Then, at run-time, we can patch<BR>the branch site to change the branch direction.</P>
<P>For example, if we have a simple branch that is disabled by default:</P>
<P>&nbsp;if (static_key_false(&amp;key))<BR>&nbsp;&nbsp;printk("I am the true branch\n");</P>
<P>Thus, by default the 'printk' will not be emitted. And the code generated will<BR>consist of a single atomic 'no-op' instruction (5 bytes on x86), in the<BR>straight-line code path. When the branch is 'flipped', we will patch the<BR>'no-op' in the straight-line codepath with a 'jump' instruction to the<BR>out-of-line true branch. Thus, changing branch direction is expensive but<BR>branch selection is basically 'free'. That is the basic tradeoff of this<BR>optimization.</P>
<P>This lowlevel patching mechanism is called 'jump label patching', and it gives<BR>the basis for the static keys facility.</P>
<P>3) Static key label API, usage and examples:</P>
<P><BR>In order to make use of this optimization you must first define a key:</P>
<P>&nbsp;struct static_key key;</P>
<P>Which is initialized as:</P>
<P>&nbsp;struct static_key key = STATIC_KEY_INIT_TRUE;</P>
<P>or:</P>
<P>&nbsp;struct static_key key = STATIC_KEY_INIT_FALSE;</P>
<P>If the key is not initialized, it is default false. The 'struct static_key',<BR>must be a 'global'. That is, it can't be allocated on the stack or dynamically<BR>allocated at run-time.</P>
<P>The key is then used in code as:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (static_key_false(&amp;key))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do unlikely code<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do likely code</P>
<P>Or:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (static_key_true(&amp;key))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do likely code<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do unlikely code</P>
<P>A key that is initialized via 'STATIC_KEY_INIT_FALSE', must be used in a<BR>'static_key_false()' construct. Likewise, a key initialized via<BR>'STATIC_KEY_INIT_TRUE' must be used in a 'static_key_true()' construct. A<BR>single key can be used in many branches, but all the branches must match the<BR>way that the key has been initialized.</P>
<P>The branch(es) can then be switched via:</P>
<P>&nbsp;static_key_slow_inc(&amp;key);<BR>&nbsp;...<BR>&nbsp;static_key_slow_dec(&amp;key);</P>
<P>Thus, 'static_key_slow_inc()' means 'make the branch true', and<BR>'static_key_slow_dec()' means 'make the the branch false' with appropriate<BR>reference counting. For example, if the key is initialized true, a<BR>static_key_slow_dec(), will switch the branch to false. And a subsequent<BR>static_key_slow_inc(), will change the branch back to true. Likewise, if the<BR>key is initialized false, a 'static_key_slow_inc()', will change the branch to<BR>true. And then a 'static_key_slow_dec()', will again make the branch false.</P>
<P>An example usage in the kernel is the implementation of tracepoints:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static inline void trace_##name(proto)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (static_key_false(&amp;__tracepoint_##name.key))&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __DO_TRACE(&amp;__tracepoint_##name,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TP_PROTO(data_proto),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TP_ARGS(data_args),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TP_CONDITION(cond));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>Tracepoints are disabled by default, and can be placed in performance critical<BR>pieces of the kernel. Thus, by using a static key, the tracepoints can have<BR>absolutely minimal impact when not in use.</P>
<P><BR>4) Architecture level code patching interface, 'jump labels'</P>
<P><BR>There are a few functions and macros that architectures must implement in order<BR>to take advantage of this optimization. If there is no architecture support, we<BR>simply fall back to a traditional, load, test, and jump sequence.</P>
<P>* select HAVE_ARCH_JUMP_LABEL, see: arch/x86/Kconfig</P>
<P>* #define JUMP_LABEL_NOP_SIZE, see: arch/x86/include/asm/jump_label.h</P>
<P>* __always_inline bool arch_static_branch(struct static_key *key), see:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arch/x86/include/asm/jump_label.h</P>
<P>* void arch_jump_label_transform(struct jump_entry *entry, enum jump_label_type type),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;see: arch/x86/kernel/jump_label.c</P>
<P>* __init_or_module void arch_jump_label_transform_static(struct jump_entry *entry, enum jump_label_type type),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;see: arch/x86/kernel/jump_label.c</P>
<P><BR>* struct jump_entry, see: arch/x86/include/asm/jump_label.h</P>
<P><BR>5) Static keys / jump label analysis, results (x86_64):</P>
<P><BR>As an example, let's add the following branch to 'getppid()', such that the<BR>system call now looks like:</P>
<P>SYSCALL_DEFINE0(getppid)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pid;</P>
<P>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (static_key_false(&amp;key))<BR>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk("I am the true branch\n");</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_lock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pid = task_tgid_vnr(rcu_dereference(current-&gt;real_parent));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_unlock();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pid;<BR>}</P>
<P>The resulting instructions with jump labels generated by GCC is:</P>
<P>ffffffff81044290 &lt;sys_getppid&gt;:<BR>ffffffff81044290:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %rbp<BR>ffffffff81044291:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 89 e5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %rsp,%rbp<BR>ffffffff81044294:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e9 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmpq&nbsp;&nbsp; ffffffff81044299 &lt;sys_getppid+0x9&gt;<BR>ffffffff81044299:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65 48 8b 04 25 c0 b6&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %gs:0xb6c0,%rax<BR>ffffffff810442a0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 00<BR>ffffffff810442a2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 8b 80 80 02 00 00&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x280(%rax),%rax<BR>ffffffff810442a9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 8b 80 b0 02 00 00&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x2b0(%rax),%rax<BR>ffffffff810442b0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 8b b8 e8 02 00 00&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x2e8(%rax),%rdi<BR>ffffffff810442b7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e8 f4 d9 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callq&nbsp; ffffffff81051cb0 &lt;pid_vnr&gt;<BR>ffffffff810442bc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp; %rbp<BR>ffffffff810442bd:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cltq<BR>ffffffff810442bf:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retq<BR>ffffffff810442c0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 c7 c7 e3 54 98 81&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; $0xffffffff819854e3,%rdi<BR>ffffffff810442c7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31 c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp; %eax,%eax<BR>ffffffff810442c9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e8 71 13 6d 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callq&nbsp; ffffffff8171563f &lt;printk&gt;<BR>ffffffff810442ce:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eb c9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; ffffffff81044299 &lt;sys_getppid+0x9&gt;</P>
<P>Without the jump label optimization it looks like:</P>
<P>ffffffff810441f0 &lt;sys_getppid&gt;:<BR>ffffffff810441f0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8b 05 8a 52 d8 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0xd8528a(%rip),%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # ffffffff81dc9480 &lt;key&gt;<BR>ffffffff810441f6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %rbp<BR>ffffffff810441f7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 89 e5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %rsp,%rbp<BR>ffffffff810441fa:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 85 c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp; %eax,%eax<BR>ffffffff810441fc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 75 27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne&nbsp;&nbsp;&nbsp; ffffffff81044225 &lt;sys_getppid+0x35&gt;<BR>ffffffff810441fe:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65 48 8b 04 25 c0 b6&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %gs:0xb6c0,%rax<BR>ffffffff81044205:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 00<BR>ffffffff81044207:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 8b 80 80 02 00 00&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x280(%rax),%rax<BR>ffffffff8104420e:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 8b 80 b0 02 00 00&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x2b0(%rax),%rax<BR>ffffffff81044215:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 8b b8 e8 02 00 00&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x2e8(%rax),%rdi<BR>ffffffff8104421c:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e8 2f da 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callq&nbsp; ffffffff81051c50 &lt;pid_vnr&gt;<BR>ffffffff81044221:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp; %rbp<BR>ffffffff81044222:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cltq<BR>ffffffff81044224:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retq<BR>ffffffff81044225:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 c7 c7 13 53 98 81&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; $0xffffffff81985313,%rdi<BR>ffffffff8104422c:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31 c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp; %eax,%eax<BR>ffffffff8104422e:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e8 60 0f 6d 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callq&nbsp; ffffffff81715193 &lt;printk&gt;<BR>ffffffff81044233:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eb c9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; ffffffff810441fe &lt;sys_getppid+0xe&gt;<BR>ffffffff81044235:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 66 66 2e 0f 1f 84 00&nbsp;&nbsp;&nbsp; data32 nopw %cs:0x0(%rax,%rax,1)<BR>ffffffff8104423c:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 00 00 00</P>
<P>Thus, the disable jump label case adds a 'mov', 'test' and 'jne' instruction<BR>vs. the jump label case just has a 'no-op' or 'jmp 0'. (The jmp 0, is patched<BR>to a 5 byte atomic no-op instruction at boot-time.) Thus, the disabled jump<BR>label case adds:</P>
<P>6 (mov) + 2 (test) + 2 (jne) = 10 - 5 (5 byte jump 0) = 5 addition bytes.</P>
<P>If we then include the padding bytes, the jump label code saves, 16 total bytes<BR>of instruction memory for this small function. In this case the non-jump label<BR>function is 80 bytes long. Thus, we have have saved 20% of the instruction<BR>footprint. We can in fact improve this even further, since the 5-byte no-op<BR>really can be a 2-byte no-op since we can reach the branch with a 2-byte jmp.<BR>However, we have not yet implemented optimal no-op sizes (they are currently<BR>hard-coded).</P>
<P>Since there are a number of static key API uses in the scheduler paths,<BR>'pipe-test' (also known as 'perf bench sched pipe') can be used to show the<BR>performance improvement. Testing done on 3.3.0-rc2:</P>
<P>jump label disabled:</P>
<P>&nbsp;Performance counter stats for 'bash -c /tmp/pipe-test' (50 runs):</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 855.700314 task-clock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.534 CPUs utilized&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.11% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,003 context-switches&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.234 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.00% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 CPU-migrations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.000 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +- 39.58% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 487 page-faults&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.001 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.02% )<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1,474,374,262 cycles&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 1.723 GHz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.17% )<BR>&nbsp;&nbsp; &lt;not supported&gt; stalled-cycles-frontend<BR>&nbsp;&nbsp; &lt;not supported&gt; stalled-cycles-backend<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1,178,049,567 instructions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.80&nbsp; insns per cycle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.06% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 208,368,926 branches&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; 243.507 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.06% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5,569,188 branch-misses&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 2.67% of all branches&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.54% )</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.601607384 seconds time elapsed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.07% )</P>
<P>jump label enabled:</P>
<P>&nbsp;Performance counter stats for 'bash -c /tmp/pipe-test' (50 runs):</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 841.043185 task-clock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.533 CPUs utilized&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.12% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200,004 context-switches&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.238 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.00% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 CPU-migrations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.000 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +- 40.87% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 487 page-faults&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.001 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.05% )<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1,432,559,428 cycles&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 1.703 GHz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.18% )<BR>&nbsp;&nbsp; &lt;not supported&gt; stalled-cycles-frontend<BR>&nbsp;&nbsp; &lt;not supported&gt; stalled-cycles-backend<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1,175,363,994 instructions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 0.82&nbsp; insns per cycle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.04% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 206,859,359 branches&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; 245.956 M/sec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.04% )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4,884,119 branch-misses&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 2.36% of all branches&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +-&nbsp; 0.85% )</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.579384366 seconds time elapsed</P>
<P>The percentage of saved branches is .7%, and we've saved 12% on<BR>'branch-misses'. This is where we would expect to get the most savings, since<BR>this optimization is about reducing the number of branches. In addition, we've<BR>saved .2% on instructions, and 2.8% on cycles and 1.4% on elapsed time.