#include/linux/fb.h
<P></P>
<P>#ifndef _LINUX_FB_H<BR>#define _LINUX_FB_H</P>
<P></P>
<P>#include &lt;linux/kgdb.h&gt;<BR>#include &lt;uapi/linux/fb.h&gt;</P>
<P>#define FBIO_CURSOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IOWR('F', 0x08, struct fb_cursor_user)</P>
<P>#include &lt;linux/fs.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/workqueue.h&gt;<BR>#include &lt;linux/notifier.h&gt;<BR>#include &lt;linux/list.h&gt;<BR>#include &lt;linux/backlight.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;asm/io.h&gt;</P>
<P>struct vm_area_struct;<BR>struct fb_info;<BR>struct device;<BR>struct file;<BR>struct dma_buf;<BR>struct videomode;<BR>struct device_node;</P>
<P>/* Definitions below are used in the parsed monitor specs */<BR>#define FB_DPMS_ACTIVE_OFF&nbsp;1<BR>#define FB_DPMS_SUSPEND&nbsp;&nbsp;2<BR>#define FB_DPMS_STANDBY&nbsp;&nbsp;4</P>
<P>#define FB_DISP_DDI&nbsp;&nbsp;1<BR>#define FB_DISP_ANA_700_300&nbsp;2<BR>#define FB_DISP_ANA_714_286&nbsp;4<BR>#define FB_DISP_ANA_1000_400&nbsp;8<BR>#define FB_DISP_ANA_700_000&nbsp;16</P>
<P>#define FB_DISP_MONO&nbsp;&nbsp;32<BR>#define FB_DISP_RGB&nbsp;&nbsp;64<BR>#define FB_DISP_MULTI&nbsp;&nbsp;128<BR>#define FB_DISP_UNKNOWN&nbsp;&nbsp;256</P>
<P>#define FB_SIGNAL_NONE&nbsp;&nbsp;0<BR>#define FB_SIGNAL_BLANK_BLANK&nbsp;1<BR>#define FB_SIGNAL_SEPARATE&nbsp;2<BR>#define FB_SIGNAL_COMPOSITE&nbsp;4<BR>#define FB_SIGNAL_SYNC_ON_GREEN&nbsp;8<BR>#define FB_SIGNAL_SERRATION_ON&nbsp;16</P>
<P>#define FB_MISC_PRIM_COLOR&nbsp;1<BR>#define FB_MISC_1ST_DETAIL&nbsp;2&nbsp;/* First Detailed Timing is preferred */<BR>struct fb_chroma {<BR>&nbsp;__u32 redx;&nbsp;/* in fraction of 1024 */<BR>&nbsp;__u32 greenx;<BR>&nbsp;__u32 bluex;<BR>&nbsp;__u32 whitex;<BR>&nbsp;__u32 redy;<BR>&nbsp;__u32 greeny;<BR>&nbsp;__u32 bluey;<BR>&nbsp;__u32 whitey;<BR>};</P>
<P>struct fb_monspecs {<BR>&nbsp;struct fb_chroma chroma;<BR>&nbsp;struct fb_videomode *modedb;&nbsp;/* mode database */<BR>&nbsp;__u8&nbsp; manufacturer[4];&nbsp;&nbsp;/* Manufacturer */<BR>&nbsp;__u8&nbsp; monitor[14];&nbsp;&nbsp;/* Monitor String */<BR>&nbsp;__u8&nbsp; serial_no[14];&nbsp;&nbsp;/* Serial Number */<BR>&nbsp;__u8&nbsp; ascii[14];&nbsp;&nbsp;/* ? */<BR>&nbsp;__u32 modedb_len;&nbsp;&nbsp;/* mode database length */<BR>&nbsp;__u32 model;&nbsp;&nbsp;&nbsp;/* Monitor Model */<BR>&nbsp;__u32 serial;&nbsp;&nbsp;&nbsp;/* Serial Number - Integer */<BR>&nbsp;__u32 year;&nbsp;&nbsp;&nbsp;/* Year manufactured */<BR>&nbsp;__u32 week;&nbsp;&nbsp;&nbsp;/* Week Manufactured */<BR>&nbsp;__u32 hfmin;&nbsp;&nbsp;&nbsp;/* hfreq lower limit (Hz) */<BR>&nbsp;__u32 hfmax;&nbsp;&nbsp;&nbsp;/* hfreq upper limit (Hz) */<BR>&nbsp;__u32 dclkmin;&nbsp;&nbsp;&nbsp;/* pixelclock lower limit (Hz) */<BR>&nbsp;__u32 dclkmax;&nbsp;&nbsp;&nbsp;/* pixelclock upper limit (Hz) */<BR>&nbsp;__u16 input;&nbsp;&nbsp;&nbsp;/* display type - see FB_DISP_* */<BR>&nbsp;__u16 dpms;&nbsp;&nbsp;&nbsp;/* DPMS support - see FB_DPMS_ */<BR>&nbsp;__u16 signal;&nbsp;&nbsp;&nbsp;/* Signal Type - see FB_SIGNAL_* */<BR>&nbsp;__u16 vfmin;&nbsp;&nbsp;&nbsp;/* vfreq lower limit (Hz) */<BR>&nbsp;__u16 vfmax;&nbsp;&nbsp;&nbsp;/* vfreq upper limit (Hz) */<BR>&nbsp;__u16 gamma;&nbsp;&nbsp;&nbsp;/* Gamma - in fractions of 100 */<BR>&nbsp;__u16 gtf&nbsp;: 1;&nbsp;&nbsp;/* supports GTF */<BR>&nbsp;__u16 misc;&nbsp;&nbsp;&nbsp;/* Misc flags - see FB_MISC_* */<BR>&nbsp;__u8&nbsp; version;&nbsp;&nbsp;&nbsp;/* EDID version... */<BR>&nbsp;__u8&nbsp; revision;&nbsp;&nbsp;&nbsp;/* ...and revision */<BR>&nbsp;__u8&nbsp; max_x;&nbsp;&nbsp;&nbsp;/* Maximum horizontal size (cm) */<BR>&nbsp;__u8&nbsp; max_y;&nbsp;&nbsp;&nbsp;/* Maximum vertical size (cm) */<BR>};</P>
<P>struct fb_cmap_user {<BR>&nbsp;__u32 start;&nbsp;&nbsp;&nbsp;/* First entry&nbsp;*/<BR>&nbsp;__u32 len;&nbsp;&nbsp;&nbsp;/* Number of entries */<BR>&nbsp;__u16 __user *red;&nbsp;&nbsp;/* Red values&nbsp;*/<BR>&nbsp;__u16 __user *green;<BR>&nbsp;__u16 __user *blue;<BR>&nbsp;__u16 __user *transp;&nbsp;&nbsp;/* transparency, can be NULL */<BR>};</P>
<P>struct fb_image_user {<BR>&nbsp;__u32 dx;&nbsp;&nbsp;&nbsp;/* Where to place image */<BR>&nbsp;__u32 dy;<BR>&nbsp;__u32 width;&nbsp;&nbsp;&nbsp;/* Size of image */<BR>&nbsp;__u32 height;<BR>&nbsp;__u32 fg_color;&nbsp;&nbsp;&nbsp;/* Only used when a mono bitmap */<BR>&nbsp;__u32 bg_color;<BR>&nbsp;__u8&nbsp; depth;&nbsp;&nbsp;&nbsp;/* Depth of the image */<BR>&nbsp;const char __user *data;&nbsp;/* Pointer to image data */<BR>&nbsp;struct fb_cmap_user cmap;&nbsp;/* color map info */<BR>};</P>
<P>struct fb_cursor_user {<BR>&nbsp;__u16 set;&nbsp;&nbsp;&nbsp;/* what to set */<BR>&nbsp;__u16 enable;&nbsp;&nbsp;&nbsp;/* cursor on/off */<BR>&nbsp;__u16 rop;&nbsp;&nbsp;&nbsp;/* bitop operation */<BR>&nbsp;const char __user *mask;&nbsp;/* cursor mask bits */<BR>&nbsp;struct fbcurpos hot;&nbsp;&nbsp;/* cursor hot spot */<BR>&nbsp;struct fb_image_user image;&nbsp;/* Cursor image */<BR>};</P>
<P>/*<BR>&nbsp;* Register/unregister for framebuffer events<BR>&nbsp;*/</P>
<P>/*&nbsp;The resolution of the passed in fb_info about to change */ <BR>#define FB_EVENT_MODE_CHANGE&nbsp;&nbsp;0x01<BR>/*&nbsp;The display on this fb_info is beeing suspended, no access to the<BR>&nbsp;*&nbsp;framebuffer is allowed any more after that call returns<BR>&nbsp;*/<BR>#define FB_EVENT_SUSPEND&nbsp;&nbsp;0x02<BR>/*&nbsp;The display on this fb_info was resumed, you can restore the display<BR>&nbsp;*&nbsp;if you own it<BR>&nbsp;*/<BR>#define FB_EVENT_RESUME&nbsp;&nbsp;&nbsp;0x03<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An entry from the modelist was removed */<BR>#define FB_EVENT_MODE_DELETE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x04<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A driver registered itself */<BR>#define FB_EVENT_FB_REGISTERED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x05<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A driver unregistered itself */<BR>#define FB_EVENT_FB_UNREGISTERED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x06<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONSOLE-SPECIFIC: get console to framebuffer mapping */<BR>#define FB_EVENT_GET_CONSOLE_MAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x07<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONSOLE-SPECIFIC: set console to framebuffer mapping */<BR>#define FB_EVENT_SET_CONSOLE_MAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A hardware display blank change occurred */<BR>#define FB_EVENT_BLANK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x09<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Private modelist is to be replaced */<BR>#define FB_EVENT_NEW_MODELIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0A<BR>/*&nbsp;The resolution of the passed in fb_info about to change and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all vc's should be changed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>#define FB_EVENT_MODE_CHANGE_ALL&nbsp;0x0B<BR>/*&nbsp;A software display blank change occurred */<BR>#define FB_EVENT_CONBLANK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0C<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get drawing requirements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>#define FB_EVENT_GET_REQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0D<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unbind from the console if possible */<BR>#define FB_EVENT_FB_UNBIND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0E<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONSOLE-SPECIFIC: remap all consoles to new fb - for vga switcheroo */<BR>#define FB_EVENT_REMAP_ALL_CONSOLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0F<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A hardware display blank early change occured */<BR>#define FB_EARLY_EVENT_BLANK&nbsp;&nbsp;0x10<BR>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A hardware display blank revert early change occured */<BR>#define FB_R_EARLY_EVENT_BLANK&nbsp;&nbsp;0x11</P>
<P>struct fb_event {<BR>&nbsp;struct fb_info *info;<BR>&nbsp;void *data;<BR>};</P>
<P>struct fb_blit_caps {<BR>&nbsp;u32 x;<BR>&nbsp;u32 y;<BR>&nbsp;u32 len;<BR>&nbsp;u32 flags;<BR>};</P>
<P>extern int fb_register_client(struct notifier_block *nb);<BR>extern int fb_unregister_client(struct notifier_block *nb);<BR>extern int fb_notifier_call_chain(unsigned long val, void *v);<BR>/*<BR>&nbsp;* Pixmap structure definition<BR>&nbsp;*<BR>&nbsp;* The purpose of this structure is to translate data<BR>&nbsp;* from the hardware independent format of fbdev to what<BR>&nbsp;* format the hardware needs.<BR>&nbsp;*/</P>
<P>#define FB_PIXMAP_DEFAULT 1&nbsp;&nbsp;&nbsp;&nbsp; /* used internally by fbcon */<BR>#define FB_PIXMAP_SYSTEM&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; /* memory is in system RAM&nbsp; */<BR>#define FB_PIXMAP_IO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; /* memory is iomapped&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>#define FB_PIXMAP_SYNC&nbsp;&nbsp;&nbsp; 256&nbsp;&nbsp; /* set if GPU can DMA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>struct fb_pixmap {<BR>&nbsp;u8&nbsp; *addr;&nbsp;&nbsp;/* pointer to memory&nbsp;&nbsp;&nbsp;*/<BR>&nbsp;u32 size;&nbsp;&nbsp;/* size of buffer in bytes&nbsp;&nbsp;*/<BR>&nbsp;u32 offset;&nbsp;&nbsp;/* current offset to buffer&nbsp;&nbsp;*/<BR>&nbsp;u32 buf_align;&nbsp;&nbsp;/* byte alignment of each bitmap&nbsp;*/<BR>&nbsp;u32 scan_align;&nbsp;&nbsp;/* alignment per scanline&nbsp;&nbsp;*/<BR>&nbsp;u32 access_align;&nbsp;/* alignment per read/write (bits)&nbsp;*/<BR>&nbsp;u32 flags;&nbsp;&nbsp;/* see FB_PIXMAP_*&nbsp;&nbsp;&nbsp;*/<BR>&nbsp;u32 blit_x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* supported bit block dimensions (1-32)*/<BR>&nbsp;u32 blit_y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Format: blit_x = 1 &lt;&lt; (width - 1)&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blit_y = 1 &lt;&lt; (height - 1)&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* if 0, will be set to 0xffffffff (all)*/<BR>&nbsp;/* access methods */<BR>&nbsp;void (*writeio)(struct fb_info *info, void __iomem *dst, void *src, unsigned int size);<BR>&nbsp;void (*readio) (struct fb_info *info, void *dst, void __iomem *src, unsigned int size);<BR>};</P>
<P>#ifdef CONFIG_FB_DEFERRED_IO<BR>struct fb_deferred_io {<BR>&nbsp;/* delay between mkwrite and deferred handler */<BR>&nbsp;unsigned long delay;<BR>&nbsp;struct mutex lock; /* mutex that protects the page list */<BR>&nbsp;struct list_head pagelist; /* list of touched pages */<BR>&nbsp;/* callback */<BR>&nbsp;void (*first_io)(struct fb_info *info);<BR>&nbsp;void (*deferred_io)(struct fb_info *info, struct list_head *pagelist);<BR>};<BR>#endif</P>
<P>/*<BR>&nbsp;* Frame buffer operations<BR>&nbsp;*<BR>&nbsp;* LOCKING NOTE: those functions must _ALL_ be called with the console<BR>&nbsp;* semaphore held, this is the only suitable locking mechanism we have<BR>&nbsp;* in 2.6. Some may be called at interrupt time at this point though.<BR>&nbsp;*<BR>&nbsp;* The exception to this is the debug related hooks.&nbsp; Putting the fb<BR>&nbsp;* into a debug state (e.g. flipping to the kernel console) and restoring<BR>&nbsp;* it must be done in a lock-free manner, so low level drivers should<BR>&nbsp;* keep track of the initial console (if applicable) and may need to<BR>&nbsp;* perform direct, unlocked hardware writes in these hooks.<BR>&nbsp;*/</P>
<P>struct fb_ops {<BR>&nbsp;/* open/release and usage marking */<BR>&nbsp;struct module *owner;<BR>&nbsp;int (*fb_open)(struct fb_info *info, int user);<BR>&nbsp;int (*fb_release)(struct fb_info *info, int user);</P>
<P>&nbsp;/* For framebuffers with strange non linear layouts or that do not<BR>&nbsp; * work with normal memory mapped access<BR>&nbsp; */<BR>&nbsp;ssize_t (*fb_read)(struct fb_info *info, char __user *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count, loff_t *ppos);<BR>&nbsp;ssize_t (*fb_write)(struct fb_info *info, const char __user *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count, loff_t *ppos);</P>
<P>&nbsp;/* checks var and eventually tweaks it to something supported,<BR>&nbsp; * DO NOT MODIFY PAR */<BR>&nbsp;int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);</P>
<P>&nbsp;/* set the video mode according to info-&gt;var */<BR>&nbsp;int (*fb_set_par)(struct fb_info *info);</P>
<P>&nbsp;/* set color register */<BR>&nbsp;int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned blue, unsigned transp, struct fb_info *info);</P>
<P>&nbsp;/* set color registers in batch */<BR>&nbsp;int (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info);</P>
<P>&nbsp;/* blank display */<BR>&nbsp;int (*fb_blank)(int blank, struct fb_info *info);</P>
<P>&nbsp;/* pan display */<BR>&nbsp;int (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info);</P>
<P>&nbsp;/* Draws a rectangle */<BR>&nbsp;void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect);<BR>&nbsp;/* Copy data from area to another */<BR>&nbsp;void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region);<BR>&nbsp;/* Draws a image to the display */<BR>&nbsp;void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image);</P>
<P>&nbsp;/* Draws cursor */<BR>&nbsp;int (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor);</P>
<P>&nbsp;/* Rotates the display */<BR>&nbsp;void (*fb_rotate)(struct fb_info *info, int angle);</P>
<P>&nbsp;/* wait for blit idle, optional */<BR>&nbsp;int (*fb_sync)(struct fb_info *info);</P>
<P>&nbsp;/* perform fb specific ioctl (optional) */<BR>&nbsp;int (*fb_ioctl)(struct fb_info *info, unsigned int cmd,<BR>&nbsp;&nbsp;&nbsp;unsigned long arg);</P>
<P>&nbsp;/* Handle 32bit compat ioctl (optional) */<BR>&nbsp;int (*fb_compat_ioctl)(struct fb_info *info, unsigned cmd,<BR>&nbsp;&nbsp;&nbsp;unsigned long arg);</P>
<P>&nbsp;/* perform fb specific mmap */<BR>&nbsp;int (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma);</P>
<P>&nbsp;/* get capability given var */<BR>&nbsp;void (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_var_screeninfo *var);</P>
<P>&nbsp;/* teardown any resources to do with this framebuffer */<BR>&nbsp;void (*fb_destroy)(struct fb_info *info);</P>
<P>&nbsp;/* called at KDB enter and leave time to prepare the console */<BR>&nbsp;int (*fb_debug_enter)(struct fb_info *info);<BR>&nbsp;int (*fb_debug_leave)(struct fb_info *info);</P>
<P>#ifdef CONFIG_DMA_SHARED_BUFFER<BR>&nbsp;/* Export the frame buffer as a dmabuf object */<BR>&nbsp;struct dma_buf *(*fb_dmabuf_export)(struct fb_info *info);<BR>#endif<BR>};</P>
<P>#ifdef CONFIG_FB_TILEBLITTING<BR>#define FB_TILE_CURSOR_NONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define FB_TILE_CURSOR_UNDERLINE&nbsp;&nbsp; 1<BR>#define FB_TILE_CURSOR_LOWER_THIRD 2<BR>#define FB_TILE_CURSOR_LOWER_HALF&nbsp; 3<BR>#define FB_TILE_CURSOR_TWO_THIRDS&nbsp; 4<BR>#define FB_TILE_CURSOR_BLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5</P>
<P>struct fb_tilemap {<BR>&nbsp;__u32 width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* width of each tile in pixels */<BR>&nbsp;__u32 height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* height of each tile in scanlines */<BR>&nbsp;__u32 depth;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* color depth of each tile */<BR>&nbsp;__u32 length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles in the map */<BR>&nbsp;const __u8 *data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* actual tile map: a bitmap array, packed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to the nearest byte */<BR>};</P>
<P>struct fb_tilerect {<BR>&nbsp;__u32 sx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* origin in the x-axis */<BR>&nbsp;__u32 sy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* origin in the y-axis */<BR>&nbsp;__u32 width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles in the x-axis */<BR>&nbsp;__u32 height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles in the y-axis */<BR>&nbsp;__u32 index;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* what tile to use: index to tile map */<BR>&nbsp;__u32 fg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* foreground color */<BR>&nbsp;__u32 bg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* background color */<BR>&nbsp;__u32 rop;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* raster operation */<BR>};</P>
<P>struct fb_tilearea {<BR>&nbsp;__u32 sx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* source origin in the x-axis */<BR>&nbsp;__u32 sy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* source origin in the y-axis */<BR>&nbsp;__u32 dx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* destination origin in the x-axis */<BR>&nbsp;__u32 dy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* destination origin in the y-axis */<BR>&nbsp;__u32 width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles in the x-axis */<BR>&nbsp;__u32 height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles in the y-axis */<BR>};</P>
<P>struct fb_tileblit {<BR>&nbsp;__u32 sx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* origin in the x-axis */<BR>&nbsp;__u32 sy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* origin in the y-axis */<BR>&nbsp;__u32 width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles in the x-axis */<BR>&nbsp;__u32 height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles in the y-axis */<BR>&nbsp;__u32 fg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* foreground color */<BR>&nbsp;__u32 bg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* background color */<BR>&nbsp;__u32 length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tiles to draw */<BR>&nbsp;__u32 *indices;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* array of indices to tile map */<BR>};</P>
<P>struct fb_tilecursor {<BR>&nbsp;__u32 sx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* cursor position in the x-axis */<BR>&nbsp;__u32 sy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* cursor position in the y-axis */<BR>&nbsp;__u32 mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0 = erase, 1 = draw */<BR>&nbsp;__u32 shape;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* see FB_TILE_CURSOR_* */<BR>&nbsp;__u32 fg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* foreground color */<BR>&nbsp;__u32 bg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* background color */<BR>};</P>
<P>struct fb_tile_ops {<BR>&nbsp;/* set tile characteristics */<BR>&nbsp;void (*fb_settile)(struct fb_info *info, struct fb_tilemap *map);</P>
<P>&nbsp;/* all dimensions from hereon are in terms of tiles */</P>
<P>&nbsp;/* move a rectangular region of tiles from one area to another*/<BR>&nbsp;void (*fb_tilecopy)(struct fb_info *info, struct fb_tilearea *area);<BR>&nbsp;/* fill a rectangular region with a tile */<BR>&nbsp;void (*fb_tilefill)(struct fb_info *info, struct fb_tilerect *rect);<BR>&nbsp;/* copy an array of tiles */<BR>&nbsp;void (*fb_tileblit)(struct fb_info *info, struct fb_tileblit *blit);<BR>&nbsp;/* cursor */<BR>&nbsp;void (*fb_tilecursor)(struct fb_info *info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_tilecursor *cursor);<BR>&nbsp;/* get maximum length of the tile map */<BR>&nbsp;int (*fb_get_tilemax)(struct fb_info *info);<BR>};<BR>#endif /* CONFIG_FB_TILEBLITTING */</P>
<P>/* FBINFO_* = fb_info.flags bit flags */<BR>#define FBINFO_MODULE&nbsp;&nbsp;0x0001&nbsp;/* Low-level driver is a module */<BR>#define FBINFO_HWACCEL_DISABLED&nbsp;0x0002<BR>&nbsp;/* When FBINFO_HWACCEL_DISABLED is set:<BR>&nbsp; *&nbsp; Hardware acceleration is turned off.&nbsp; Software implementations<BR>&nbsp; *&nbsp; of required functions (copyarea(), fillrect(), and imageblit())<BR>&nbsp; *&nbsp; takes over; acceleration engine should be in a quiescent state */</P>
<P>/* hints */<BR>#define FBINFO_VIRTFB&nbsp;&nbsp;0x0004 /* FB is System RAM, not device. */<BR>#define FBINFO_PARTIAL_PAN_OK&nbsp;0x0040 /* otw use pan only for double-buffering */<BR>#define FBINFO_READS_FAST&nbsp;0x0080 /* soft-copy faster than rendering */</P>
<P>/* hardware supported ops */<BR>/*&nbsp; semantics: when a bit is set, it indicates that the operation is<BR>&nbsp;*&nbsp;&nbsp; accelerated by hardware.<BR>&nbsp;*&nbsp; required functions will still work even if the bit is not set.<BR>&nbsp;*&nbsp; optional functions may not even exist if the flag bit is not set.<BR>&nbsp;*/<BR>#define FBINFO_HWACCEL_NONE&nbsp;&nbsp;0x0000<BR>#define FBINFO_HWACCEL_COPYAREA&nbsp;&nbsp;0x0100 /* required */<BR>#define FBINFO_HWACCEL_FILLRECT&nbsp;&nbsp;0x0200 /* required */<BR>#define FBINFO_HWACCEL_IMAGEBLIT&nbsp;0x0400 /* required */<BR>#define FBINFO_HWACCEL_ROTATE&nbsp;&nbsp;0x0800 /* optional */<BR>#define FBINFO_HWACCEL_XPAN&nbsp;&nbsp;0x1000 /* optional */<BR>#define FBINFO_HWACCEL_YPAN&nbsp;&nbsp;0x2000 /* optional */<BR>#define FBINFO_HWACCEL_YWRAP&nbsp;&nbsp;0x4000 /* optional */</P>
<P>#define FBINFO_MISC_USEREVENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10000 /* event request<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from userspace */<BR>#define FBINFO_MISC_TILEBLITTING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x20000 /* use tile blitting */</P>
<P>/* A driver may set this flag to indicate that it does want a set_par to be<BR>&nbsp;* called every time when fbcon_switch is executed. The advantage is that with<BR>&nbsp;* this flag set you can really be sure that set_par is always called before<BR>&nbsp;* any of the functions dependent on the correct hardware state or altering<BR>&nbsp;* that state, even if you are using some broken X releases. The disadvantage<BR>&nbsp;* is that it introduces unwanted delays to every console switch if set_par<BR>&nbsp;* is slow. It is a good idea to try this flag in the drivers initialization<BR>&nbsp;* code whenever there is a bug report related to switching between X and the<BR>&nbsp;* framebuffer console.<BR>&nbsp;*/<BR>#define FBINFO_MISC_ALWAYS_SETPAR&nbsp;&nbsp; 0x40000</P>
<P>/* where the fb is a firmware driver, and can be replaced with a proper one */<BR>#define FBINFO_MISC_FIRMWARE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80000<BR>/*<BR>&nbsp;* Host and GPU endianness differ.<BR>&nbsp;*/<BR>#define FBINFO_FOREIGN_ENDIAN&nbsp;0x100000<BR>/*<BR>&nbsp;* Big endian math. This is the same flags as above, but with different<BR>&nbsp;* meaning, it is set by the fb subsystem depending FOREIGN_ENDIAN flag<BR>&nbsp;* and host endianness. Drivers should not use this flag.<BR>&nbsp;*/<BR>#define FBINFO_BE_MATH&nbsp; 0x100000</P>
<P>/* report to the VT layer that this fb driver can accept forced console<BR>&nbsp;&nbsp; output like oopses */<BR>#define FBINFO_CAN_FORCE_OUTPUT&nbsp;&nbsp;&nbsp;&nbsp; 0x200000</P>
<P>struct fb_info {<BR>&nbsp;atomic_t count;<BR>&nbsp;int node;<BR>&nbsp;int flags;<BR>&nbsp;struct mutex lock;&nbsp;&nbsp;/* Lock for open/release/ioctl funcs */<BR>&nbsp;struct mutex mm_lock;&nbsp;&nbsp;/* Lock for fb_mmap and smem_* fields */<BR>&nbsp;struct fb_var_screeninfo var;&nbsp;/* Current var */<BR>&nbsp;struct fb_fix_screeninfo fix;&nbsp;/* Current fix */<BR>&nbsp;struct fb_monspecs monspecs;&nbsp;/* Current Monitor specs */<BR>&nbsp;struct work_struct queue;&nbsp;/* Framebuffer event queue */<BR>&nbsp;struct fb_pixmap pixmap;&nbsp;/* Image hardware mapper */<BR>&nbsp;struct fb_pixmap sprite;&nbsp;/* Cursor hardware mapper */<BR>&nbsp;struct fb_cmap cmap;&nbsp;&nbsp;/* Current cmap */<BR>&nbsp;struct list_head modelist;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mode list */<BR>&nbsp;struct fb_videomode *mode;&nbsp;/* current mode */</P>
<P>#ifdef CONFIG_FB_BACKLIGHT<BR>&nbsp;/* assigned backlight device */<BR>&nbsp;/* set before framebuffer registration, <BR>&nbsp;&nbsp;&nbsp; remove after unregister */<BR>&nbsp;struct backlight_device *bl_dev;</P>
<P>&nbsp;/* Backlight level curve */<BR>&nbsp;struct mutex bl_curve_mutex;&nbsp;<BR>&nbsp;u8 bl_curve[FB_BACKLIGHT_LEVELS];<BR>#endif<BR>#ifdef CONFIG_FB_DEFERRED_IO<BR>&nbsp;struct delayed_work deferred_work;<BR>&nbsp;struct fb_deferred_io *fbdefio;<BR>#endif</P>
<P>&nbsp;struct fb_ops *fbops;<BR>&nbsp;struct device *device;&nbsp;&nbsp;/* This is the parent */<BR>&nbsp;struct device *dev;&nbsp;&nbsp;/* This is this fb device */<BR>&nbsp;int class_flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* private sysfs flags */<BR>#ifdef CONFIG_FB_TILEBLITTING<BR>&nbsp;struct fb_tile_ops *tileops;&nbsp;&nbsp;&nbsp; /* Tile Blitting */<BR>#endif<BR>&nbsp;char __iomem *screen_base;&nbsp;/* Virtual address */<BR>&nbsp;unsigned long screen_size;&nbsp;/* Amount of ioremapped VRAM or 0 */ <BR>&nbsp;void *pseudo_palette;&nbsp;&nbsp;/* Fake palette of 16 colors */ <BR>#define FBINFO_STATE_RUNNING&nbsp;0<BR>#define FBINFO_STATE_SUSPENDED&nbsp;1<BR>&nbsp;u32 state;&nbsp;&nbsp;&nbsp;/* Hardware state i.e suspend */<BR>&nbsp;void *fbcon_par;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fbcon use-only private area */<BR>&nbsp;/* From here on everything is device dependent */<BR>&nbsp;void *par;<BR>&nbsp;/* we need the PCI or similar aperture base/size not<BR>&nbsp;&nbsp;&nbsp; smem_start/size as smem_start may just be an object<BR>&nbsp;&nbsp;&nbsp; allocated inside the aperture so may not actually overlap */<BR>&nbsp;struct apertures_struct {<BR>&nbsp;&nbsp;unsigned int count;<BR>&nbsp;&nbsp;struct aperture {<BR>&nbsp;&nbsp;&nbsp;resource_size_t base;<BR>&nbsp;&nbsp;&nbsp;resource_size_t size;<BR>&nbsp;&nbsp;} ranges[0];<BR>&nbsp;} *apertures;</P>
<P>&nbsp;bool skip_vt_switch; /* no VT switch on suspend/resume required */<BR>};</P>
<P>static inline struct apertures_struct *alloc_apertures(unsigned int max_num) {<BR>&nbsp;struct apertures_struct *a = kzalloc(sizeof(struct apertures_struct)<BR>&nbsp;&nbsp;&nbsp;+ max_num * sizeof(struct aperture), GFP_KERNEL);<BR>&nbsp;if (!a)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;a-&gt;count = max_num;<BR>&nbsp;return a;<BR>}</P>
<P>#ifdef MODULE<BR>#define FBINFO_DEFAULT&nbsp;FBINFO_MODULE<BR>#else<BR>#define FBINFO_DEFAULT&nbsp;0<BR>#endif</P>
<P>// This will go away<BR>#define FBINFO_FLAG_MODULE&nbsp;FBINFO_MODULE<BR>#define FBINFO_FLAG_DEFAULT&nbsp;FBINFO_DEFAULT</P>
<P>/* This will go away<BR>&nbsp;* fbset currently hacks in FB_ACCELF_TEXT into var.accel_flags<BR>&nbsp;* when it wants to turn the acceleration engine on.&nbsp; This is<BR>&nbsp;* really a separate operation, and should be modified via sysfs.<BR>&nbsp;*&nbsp; But for now, we leave it broken with the following define<BR>&nbsp;*/<BR>#define STUPID_ACCELF_TEXT_SHIT</P>
<P>// This will go away<BR>#if defined(__sparc__)</P>
<P>/* We map all of our framebuffers such that big-endian accesses<BR>&nbsp;* are what we want, so the following is sufficient.<BR>&nbsp;*/</P>
<P>// This will go away<BR>#define fb_readb sbus_readb<BR>#define fb_readw sbus_readw<BR>#define fb_readl sbus_readl<BR>#define fb_readq sbus_readq<BR>#define fb_writeb sbus_writeb<BR>#define fb_writew sbus_writew<BR>#define fb_writel sbus_writel<BR>#define fb_writeq sbus_writeq<BR>#define fb_memset sbus_memset_io<BR>#define fb_memcpy_fromfb sbus_memcpy_fromio<BR>#define fb_memcpy_tofb sbus_memcpy_toio</P>
<P>#elif defined(__i386__) || defined(__alpha__) || defined(__x86_64__) || defined(__hppa__) || defined(__sh__) || defined(__powerpc__) || defined(__avr32__) || defined(__bfin__)</P>
<P>#define fb_readb __raw_readb<BR>#define fb_readw __raw_readw<BR>#define fb_readl __raw_readl<BR>#define fb_readq __raw_readq<BR>#define fb_writeb __raw_writeb<BR>#define fb_writew __raw_writew<BR>#define fb_writel __raw_writel<BR>#define fb_writeq __raw_writeq<BR>#define fb_memset memset_io<BR>#define fb_memcpy_fromfb memcpy_fromio<BR>#define fb_memcpy_tofb memcpy_toio</P>
<P>#else</P>
<P>#define fb_readb(addr) (*(volatile u8 *) (addr))<BR>#define fb_readw(addr) (*(volatile u16 *) (addr))<BR>#define fb_readl(addr) (*(volatile u32 *) (addr))<BR>#define fb_readq(addr) (*(volatile u64 *) (addr))<BR>#define fb_writeb(b,addr) (*(volatile u8 *) (addr) = (b))<BR>#define fb_writew(b,addr) (*(volatile u16 *) (addr) = (b))<BR>#define fb_writel(b,addr) (*(volatile u32 *) (addr) = (b))<BR>#define fb_writeq(b,addr) (*(volatile u64 *) (addr) = (b))<BR>#define fb_memset memset<BR>#define fb_memcpy_fromfb memcpy<BR>#define fb_memcpy_tofb memcpy</P>
<P>#endif</P>
<P>#define FB_LEFT_POS(p, bpp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (fb_be_math(p) ? (32 - (bpp)) : 0)<BR>#define FB_SHIFT_HIGH(p, val, bits)&nbsp; (fb_be_math(p) ? (val) &gt;&gt; (bits) : \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (val) &lt;&lt; (bits))<BR>#define FB_SHIFT_LOW(p, val, bits)&nbsp;&nbsp; (fb_be_math(p) ? (val) &lt;&lt; (bits) : \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (val) &gt;&gt; (bits))</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; `Generic' versions of the frame buffer device operations<BR>&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>extern int fb_set_var(struct fb_info *info, struct fb_var_screeninfo *var); <BR>extern int fb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var); <BR>extern int fb_blank(struct fb_info *info, int blank);<BR>extern void cfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect); <BR>extern void cfb_copyarea(struct fb_info *info, const struct fb_copyarea *area); <BR>extern void cfb_imageblit(struct fb_info *info, const struct fb_image *image);<BR>/*<BR>&nbsp;* Drawing operations where framebuffer is in system RAM<BR>&nbsp;*/<BR>extern void sys_fillrect(struct fb_info *info, const struct fb_fillrect *rect);<BR>extern void sys_copyarea(struct fb_info *info, const struct fb_copyarea *area);<BR>extern void sys_imageblit(struct fb_info *info, const struct fb_image *image);<BR>extern ssize_t fb_sys_read(struct fb_info *info, char __user *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count, loff_t *ppos);<BR>extern ssize_t fb_sys_write(struct fb_info *info, const char __user *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count, loff_t *ppos);</P>
<P>/* drivers/video/fbmem.c */<BR>extern int register_framebuffer(struct fb_info *fb_info);<BR>extern int unregister_framebuffer(struct fb_info *fb_info);<BR>extern int unlink_framebuffer(struct fb_info *fb_info);<BR>extern void remove_conflicting_framebuffers(struct apertures_struct *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const char *name, bool primary);<BR>extern int fb_prepare_logo(struct fb_info *fb_info, int rotate);<BR>extern int fb_show_logo(struct fb_info *fb_info, int rotate);<BR>extern char* fb_get_buffer_offset(struct fb_info *info, struct fb_pixmap *buf, u32 size);<BR>extern void fb_pad_unaligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;u32 height, u32 shift_high, u32 shift_low, u32 mod);<BR>extern void fb_pad_aligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 s_pitch, u32 height);<BR>extern void fb_set_suspend(struct fb_info *info, int state);<BR>extern int fb_get_color_depth(struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_fix_screeninfo *fix);<BR>extern int fb_get_options(char *name, char **option);<BR>extern int fb_new_modelist(struct fb_info *info);</P>
<P>extern struct fb_info *registered_fb[FB_MAX];<BR>extern int num_registered_fb;<BR>extern struct class *fb_class;</P>
<P>extern int lock_fb_info(struct fb_info *info);</P>
<P>static inline void unlock_fb_info(struct fb_info *info)<BR>{<BR>&nbsp;mutex_unlock(&amp;info-&gt;lock);<BR>}</P>
<P>static inline void __fb_pad_aligned_buffer(u8 *dst, u32 d_pitch,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u8 *src, u32 s_pitch, u32 height)<BR>{<BR>&nbsp;int i, j;</P>
<P>&nbsp;d_pitch -= s_pitch;</P>
<P>&nbsp;for (i = height; i--; ) {<BR>&nbsp;&nbsp;/* s_pitch is a few bytes at the most, memcpy is suboptimal */<BR>&nbsp;&nbsp;for (j = 0; j &lt; s_pitch; j++)<BR>&nbsp;&nbsp;&nbsp;*dst++ = *src++;<BR>&nbsp;&nbsp;dst += d_pitch;<BR>&nbsp;}<BR>}</P>
<P>/* drivers/video/fb_defio.c */<BR>extern void fb_deferred_io_init(struct fb_info *info);<BR>extern void fb_deferred_io_open(struct fb_info *info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct inode *inode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct file *file);<BR>extern void fb_deferred_io_cleanup(struct fb_info *info);<BR>extern int fb_deferred_io_fsync(struct file *file, loff_t start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;loff_t end, int datasync);</P>
<P>static inline bool fb_be_math(struct fb_info *info)<BR>{<BR>#ifdef CONFIG_FB_FOREIGN_ENDIAN<BR>#if defined(CONFIG_FB_BOTH_ENDIAN)<BR>&nbsp;return info-&gt;flags &amp; FBINFO_BE_MATH;<BR>#elif defined(CONFIG_FB_BIG_ENDIAN)<BR>&nbsp;return true;<BR>#elif defined(CONFIG_FB_LITTLE_ENDIAN)<BR>&nbsp;return false;<BR>#endif /* CONFIG_FB_BOTH_ENDIAN */<BR>#else<BR>#ifdef __BIG_ENDIAN<BR>&nbsp;return true;<BR>#else<BR>&nbsp;return false;<BR>#endif /* __BIG_ENDIAN */<BR>#endif /* CONFIG_FB_FOREIGN_ENDIAN */<BR>}</P>
<P>/* drivers/video/fbsysfs.c */<BR>extern struct fb_info *framebuffer_alloc(size_t size, struct device *dev);<BR>extern void framebuffer_release(struct fb_info *info);<BR>extern int fb_init_device(struct fb_info *fb_info);<BR>extern void fb_cleanup_device(struct fb_info *head);<BR>extern void fb_bl_default_curve(struct fb_info *fb_info, u8 off, u8 min, u8 max);</P>
<P>/* drivers/video/fbmon.c */<BR>#define FB_MAXTIMINGS&nbsp;&nbsp;0<BR>#define FB_VSYNCTIMINGS&nbsp;&nbsp;1<BR>#define FB_HSYNCTIMINGS&nbsp;&nbsp;2<BR>#define FB_DCLKTIMINGS&nbsp;&nbsp;3<BR>#define FB_IGNOREMON&nbsp;&nbsp;0x100</P>
<P>#define FB_MODE_IS_UNKNOWN&nbsp;0<BR>#define FB_MODE_IS_DETAILED&nbsp;1<BR>#define FB_MODE_IS_STANDARD&nbsp;2<BR>#define FB_MODE_IS_VESA&nbsp;&nbsp;4<BR>#define FB_MODE_IS_CALCULATED&nbsp;8<BR>#define FB_MODE_IS_FIRST&nbsp;16<BR>#define FB_MODE_IS_FROM_VAR&nbsp;&nbsp;&nbsp;&nbsp; 32</P>
<P>extern int fbmon_dpms(const struct fb_info *fb_info);<BR>extern int fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_info *info);<BR>extern int fb_validate_mode(const struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_info *info);<BR>extern int fb_parse_edid(unsigned char *edid, struct fb_var_screeninfo *var);<BR>extern const unsigned char *fb_firmware_edid(struct device *device);<BR>extern void fb_edid_to_monspecs(unsigned char *edid,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct fb_monspecs *specs);<BR>extern void fb_edid_add_monspecs(unsigned char *edid,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct fb_monspecs *specs);<BR>extern void fb_destroy_modedb(struct fb_videomode *modedb);<BR>extern int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb);<BR>extern unsigned char *fb_ddc_read(struct i2c_adapter *adapter);</P>
<P>extern int of_get_fb_videomode(struct device_node *np,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_videomode *fb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index);<BR>extern int fb_videomode_from_videomode(const struct videomode *vm,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct fb_videomode *fbmode);</P>
<P>/* drivers/video/modedb.c */<BR>#define VESA_MODEDB_SIZE 34<BR>extern void fb_var_to_videomode(struct fb_videomode *mode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct fb_var_screeninfo *var);<BR>extern void fb_videomode_to_var(struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct fb_videomode *mode);<BR>extern int fb_mode_is_equal(const struct fb_videomode *mode1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct fb_videomode *mode2);<BR>extern int fb_add_videomode(const struct fb_videomode *mode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head);<BR>extern void fb_delete_videomode(const struct fb_videomode *mode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *head);<BR>extern const struct fb_videomode *fb_match_mode(const struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *head);<BR>extern const struct fb_videomode *fb_find_best_mode(const struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head);<BR>extern const struct fb_videomode *fb_find_nearest_mode(const struct fb_videomode *mode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head);<BR>extern void fb_destroy_modelist(struct list_head *head);<BR>extern void fb_videomode_to_modelist(const struct fb_videomode *modedb, int num,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head);<BR>extern const struct fb_videomode *fb_find_best_display(const struct fb_monspecs *specs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head);</P>
<P>/* drivers/video/fbcmap.c */<BR>extern int fb_alloc_cmap(struct fb_cmap *cmap, int len, int transp);<BR>extern int fb_alloc_cmap_gfp(struct fb_cmap *cmap, int len, int transp, gfp_t flags);<BR>extern void fb_dealloc_cmap(struct fb_cmap *cmap);<BR>extern int fb_copy_cmap(const struct fb_cmap *from, struct fb_cmap *to);<BR>extern int fb_cmap_to_user(const struct fb_cmap *from, struct fb_cmap_user *to);<BR>extern int fb_set_cmap(struct fb_cmap *cmap, struct fb_info *fb_info);<BR>extern int fb_set_user_cmap(struct fb_cmap_user *cmap, struct fb_info *fb_info);<BR>extern const struct fb_cmap *fb_default_cmap(int len);<BR>extern void fb_invert_cmaps(void);</P>
<P>struct fb_videomode {<BR>&nbsp;const char *name;&nbsp;/* optional */<BR>&nbsp;u32 refresh;&nbsp;&nbsp;/* optional */<BR>&nbsp;u32 xres;<BR>&nbsp;u32 yres;<BR>&nbsp;u32 pixclock;<BR>&nbsp;u32 left_margin;<BR>&nbsp;u32 right_margin;<BR>&nbsp;u32 upper_margin;<BR>&nbsp;u32 lower_margin;<BR>&nbsp;u32 hsync_len;<BR>&nbsp;u32 vsync_len;<BR>&nbsp;u32 sync;<BR>&nbsp;u32 vmode;<BR>&nbsp;u32 flag;<BR>};</P>
<P>extern const char *fb_mode_option;<BR>extern const struct fb_videomode vesa_modes[];<BR>extern const struct fb_videomode cea_modes[64];</P>
<P>struct fb_modelist {<BR>&nbsp;struct list_head list;<BR>&nbsp;struct fb_videomode mode;<BR>};</P>
<P>extern int fb_find_mode(struct fb_var_screeninfo *var,<BR>&nbsp;&nbsp;&nbsp;struct fb_info *info, const char *mode_option,<BR>&nbsp;&nbsp;&nbsp;const struct fb_videomode *db,<BR>&nbsp;&nbsp;&nbsp;unsigned int dbsize,<BR>&nbsp;&nbsp;&nbsp;const struct fb_videomode *default_mode,<BR>&nbsp;&nbsp;&nbsp;unsigned int default_bpp);</P>
<P>#endif /* _LINUX_FB_H */