#/Documentation/unaligned-memory-access.txt 
<P></P>
<P>UNALIGNED MEMORY ACCESSES<BR>=========================</P>
<P></P>
<P>Linux runs on a wide variety of architectures which have varying behaviour<BR>when it comes to memory access. This document presents some details about<BR>unaligned accesses, why you need to write code that doesn't cause them,<BR>and how to write such code!</P>
<P><BR>The definition of an unaligned access<BR>=====================================</P>
<P>Unaligned memory accesses occur when you try to read N bytes of data starting<BR>from an address that is not evenly divisible by N (i.e. addr % N != 0).<BR>For example, reading 4 bytes of data from address 0x10004 is fine, but<BR>reading 4 bytes of data from address 0x10005 would be an unaligned memory<BR>access.</P>
<P>The above may seem a little vague, as memory access can happen in different<BR>ways. The context here is at the machine code level: certain instructions read<BR>or write a number of bytes to or from memory (e.g. movb, movw, movl in x86<BR>assembly). As will become clear, it is relatively easy to spot C statements<BR>which will compile to multiple-byte memory access instructions, namely when<BR>dealing with types such as u16, u32 and u64.</P>
<P><BR>Natural alignment<BR>=================</P>
<P>The rule mentioned above forms what we refer to as natural alignment:<BR>When accessing N bytes of memory, the base memory address must be evenly<BR>divisible by N, i.e. addr % N == 0.</P>
<P>When writing code, assume the target architecture has natural alignment<BR>requirements.</P>
<P>In reality, only a few architectures require natural alignment on all sizes<BR>of memory access. However, we must consider ALL supported architectures;<BR>writing code that satisfies natural alignment requirements is the easiest way<BR>to achieve full portability.</P>
<P><BR>Why unaligned access is bad<BR>===========================</P>
<P>The effects of performing an unaligned memory access vary from architecture<BR>to architecture. It would be easy to write a whole document on the differences<BR>here; a summary of the common scenarios is presented below:</P>
<P>&nbsp;- Some architectures are able to perform unaligned memory accesses<BR>&nbsp;&nbsp; transparently, but there is usually a significant performance cost.<BR>&nbsp;- Some architectures raise processor exceptions when unaligned accesses<BR>&nbsp;&nbsp; happen. The exception handler is able to correct the unaligned access,<BR>&nbsp;&nbsp; at significant cost to performance.<BR>&nbsp;- Some architectures raise processor exceptions when unaligned accesses<BR>&nbsp;&nbsp; happen, but the exceptions do not contain enough information for the<BR>&nbsp;&nbsp; unaligned access to be corrected.<BR>&nbsp;- Some architectures are not capable of unaligned memory access, but will<BR>&nbsp;&nbsp; silently perform a different memory access to the one that was requested,<BR>&nbsp;&nbsp; resulting in a subtle code bug that is hard to detect!</P>
<P>It should be obvious from the above that if your code causes unaligned<BR>memory accesses to happen, your code will not work correctly on certain<BR>platforms and will cause performance problems on others.</P>
<P><BR>Code that does not cause unaligned access<BR>=========================================</P>
<P>At first, the concepts above may seem a little hard to relate to actual<BR>coding practice. After all, you don't have a great deal of control over<BR>memory addresses of certain variables, etc.</P>
<P>Fortunately things are not too complex, as in most cases, the compiler<BR>ensures that things will work for you. For example, take the following<BR>structure:</P>
<P>&nbsp;struct foo {<BR>&nbsp;&nbsp;u16 field1;<BR>&nbsp;&nbsp;u32 field2;<BR>&nbsp;&nbsp;u8 field3;<BR>&nbsp;};</P>
<P>Let us assume that an instance of the above structure resides in memory<BR>starting at address 0x10000. With a basic level of understanding, it would<BR>not be unreasonable to expect that accessing field2 would cause an unaligned<BR>access. You'd be expecting field2 to be located at offset 2 bytes into the<BR>structure, i.e. address 0x10002, but that address is not evenly divisible<BR>by 4 (remember, we're reading a 4 byte value here).</P>
<P>Fortunately, the compiler understands the alignment constraints, so in the<BR>above case it would insert 2 bytes of padding in between field1 and field2.<BR>Therefore, for standard structure types you can always rely on the compiler<BR>to pad structures so that accesses to fields are suitably aligned (assuming<BR>you do not cast the field to a type of different length).</P>
<P>Similarly, you can also rely on the compiler to align variables and function<BR>parameters to a naturally aligned scheme, based on the size of the type of<BR>the variable.</P>
<P>At this point, it should be clear that accessing a single byte (u8 or char)<BR>will never cause an unaligned access, because all memory addresses are evenly<BR>divisible by one.</P>
<P>On a related topic, with the above considerations in mind you may observe<BR>that you could reorder the fields in the structure in order to place fields<BR>where padding would otherwise be inserted, and hence reduce the overall<BR>resident memory size of structure instances. The optimal layout of the<BR>above example is:</P>
<P>&nbsp;struct foo {<BR>&nbsp;&nbsp;u32 field2;<BR>&nbsp;&nbsp;u16 field1;<BR>&nbsp;&nbsp;u8 field3;<BR>&nbsp;};</P>
<P>For a natural alignment scheme, the compiler would only have to add a single<BR>byte of padding at the end of the structure. This padding is added in order<BR>to satisfy alignment constraints for arrays of these structures.</P>
<P>Another point worth mentioning is the use of __attribute__((packed)) on a<BR>structure type. This GCC-specific attribute tells the compiler never to<BR>insert any padding within structures, useful when you want to use a C struct<BR>to represent some data that comes in a fixed arrangement 'off the wire'.</P>
<P>You might be inclined to believe that usage of this attribute can easily<BR>lead to unaligned accesses when accessing fields that do not satisfy<BR>architectural alignment requirements. However, again, the compiler is aware<BR>of the alignment constraints and will generate extra instructions to perform<BR>the memory access in a way that does not cause unaligned access. Of course,<BR>the extra instructions obviously cause a loss in performance compared to the<BR>non-packed case, so the packed attribute should only be used when avoiding<BR>structure padding is of importance.</P>
<P><BR>Code that causes unaligned access<BR>=================================</P>
<P>With the above in mind, let's move onto a real life example of a function<BR>that can cause an unaligned memory access. The following function adapted<BR>from include/linux/etherdevice.h is an optimized routine to compare two<BR>ethernet MAC addresses for equality.</P>
<P>unsigned int compare_ether_addr(const u8 *addr1, const u8 *addr2)<BR>{<BR>&nbsp;const u16 *a = (const u16 *) addr1;<BR>&nbsp;const u16 *b = (const u16 *) addr2;<BR>&nbsp;return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) != 0;<BR>}</P>
<P>In the above function, the reference to a[0] causes 2 bytes (16 bits) to<BR>be read from memory starting at address addr1. Think about what would happen<BR>if addr1 was an odd address such as 0x10003. (Hint: it'd be an unaligned<BR>access.)</P>
<P>Despite the potential unaligned access problems with the above function, it<BR>is included in the kernel anyway but is understood to only work on<BR>16-bit-aligned addresses. It is up to the caller to ensure this alignment or<BR>not use this function at all. This alignment-unsafe function is still useful<BR>as it is a decent optimization for the cases when you can ensure alignment,<BR>which is true almost all of the time in ethernet networking context.</P>
<P><BR>Here is another example of some code that could cause unaligned accesses:<BR>&nbsp;void myfunc(u8 *data, u32 value)<BR>&nbsp;{<BR>&nbsp;&nbsp;[...]<BR>&nbsp;&nbsp;*((u32 *) data) = cpu_to_le32(value);<BR>&nbsp;&nbsp;[...]<BR>&nbsp;}</P>
<P>This code will cause unaligned accesses every time the data parameter points<BR>to an address that is not evenly divisible by 4.</P>
<P>In summary, the 2 main scenarios where you may run into unaligned access<BR>problems involve:<BR>&nbsp;1. Casting variables to types of different lengths<BR>&nbsp;2. Pointer arithmetic followed by access to at least 2 bytes of data</P>
<P><BR>Avoiding unaligned accesses<BR>===========================</P>
<P>The easiest way to avoid unaligned access is to use the get_unaligned() and<BR>put_unaligned() macros provided by the &lt;asm/unaligned.h&gt; header file.</P>
<P>Going back to an earlier example of code that potentially causes unaligned<BR>access:</P>
<P>&nbsp;void myfunc(u8 *data, u32 value)<BR>&nbsp;{<BR>&nbsp;&nbsp;[...]<BR>&nbsp;&nbsp;*((u32 *) data) = cpu_to_le32(value);<BR>&nbsp;&nbsp;[...]<BR>&nbsp;}</P>
<P>To avoid the unaligned memory access, you would rewrite it as follows:</P>
<P>&nbsp;void myfunc(u8 *data, u32 value)<BR>&nbsp;{<BR>&nbsp;&nbsp;[...]<BR>&nbsp;&nbsp;value = cpu_to_le32(value);<BR>&nbsp;&nbsp;put_unaligned(value, (u32 *) data);<BR>&nbsp;&nbsp;[...]<BR>&nbsp;}</P>
<P>The get_unaligned() macro works similarly. Assuming 'data' is a pointer to<BR>memory and you wish to avoid unaligned access, its usage is as follows:</P>
<P>&nbsp;u32 value = get_unaligned((u32 *) data);</P>
<P>These macros work for memory accesses of any length (not just 32 bits as<BR>in the examples above). Be aware that when compared to standard access of<BR>aligned memory, using these macros to access unaligned memory can be costly in<BR>terms of performance.</P>
<P>If use of such macros is not convenient, another option is to use memcpy(),<BR>where the source or destination (or both) are of type u8* or unsigned char*.<BR>Due to the byte-wise nature of this operation, unaligned accesses are avoided.</P>
<P><BR>Alignment vs. Networking<BR>========================</P>
<P>On architectures that require aligned loads, networking requires that the IP<BR>header is aligned on a four-byte boundary to optimise the IP stack. For<BR>regular ethernet hardware, the constant NET_IP_ALIGN is used. On most<BR>architectures this constant has the value 2 because the normal ethernet<BR>header is 14 bytes long, so in order to get proper alignment one needs to<BR>DMA to an address which can be expressed as 4*n + 2. One notable exception<BR>here is powerpc which defines NET_IP_ALIGN to 0 because DMA to unaligned<BR>addresses can be very expensive and dwarf the cost of unaligned loads.</P>
<P>For some ethernet hardware that cannot DMA to unaligned addresses like<BR>4*n+2 or non-ethernet hardware, this can be a problem, and it is then<BR>required to copy the incoming frame into an aligned buffer. Because this is<BR>unnecessary on architectures that can do unaligned accesses, the code can be<BR>made dependent on CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS like so:</P>
<P>#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS<BR>&nbsp;skb = original skb<BR>#else<BR>&nbsp;skb = copy skb<BR>#endif</P>
<P>--<BR>Authors: Daniel Drake &lt;<A href="mailto:dsd@gentoo.org">dsd@gentoo.org</A>&gt;,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Johannes Berg &lt;<A href="mailto:johannes@sipsolutions.net">johannes@sipsolutions.net</A>&gt;<BR>With help from: Alan Cox, Avuton Olrich, Heikki Orsila, Jan Engelhardt,<BR>Kyle McMartin, Kyle Moffett, Randy Dunlap, Robert Hancock, Uli Kunitz,<BR>Vadim Lobanov</P>
<P>&nbsp;