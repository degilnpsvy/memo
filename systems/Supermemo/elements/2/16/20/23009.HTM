<H3 id=-100000 class=docSection1Title>Kernel Timers</H3>
<P class=docText><A name="The working"></A>The working of many parts of the kernel is critically dependent on the passage of time. <FONT class=extract>The Linux kernel makes use of different timers provided by the hardware to provide time-dependent services such as busy-waiting and sleep-waiting. The processor wastes cycles while it busy-waits but relinquishes the CPU when it sleep-waits. Naturally, the former is done only when the latter is not feasible.</FONT> The kernel also facilitates scheduling of functions that desire to run after a specified time duration has elapsed.</P>
<P class=docText><A name="the semantics"></A>Let's first discuss the semantics of some important kernel timer variables such as <TT>jiffies</TT>, <TT>HZ</TT>, and <TT>xtime</TT><A name="execution times"></A>. Next, let's measure execution times on a Pentium-based system using the Pentium <SPAN class=docEmphasis>Time Stamp Counter</SPAN> (TSC). Let's also see how Linux uses the <SPAN class=docEmphasis>Real Time Clock</SPAN> (RTC).</P><A name=ch02lev2sec12></A>
<H4 id=title-ID0ENFOM class=docSection2Title>HZ and Jiffies</H4>
<P class=docText><A name="the number"></A><FONT class=extract>System timers interrupt the processor (or "pop") at programmable frequencies. This frequency, or the number of timer ticks per second, is contained in the kernel variable <TT>HZ</TT>. Choosing a value for <TT>HZ</TT> is a trade-off. A large <TT>HZ</TT></FONT><A name="hence better"></A><FONT class=extract> results in finer timer granularity, and hence better scheduling resolution. However, bigger values of <TT>HZ</TT></FONT><A name="more cycles"></A><FONT class=extract> also result in larger overhead and higher power consumption, because more cycles are burnt in the timer interrupt context.</FONT></P><A name=ch02note01></A>
<DIV class=docNote>
<P><FONT class=extract></FONT>
<P class=docText><FONT class=extract>The value of <TT>HZ</TT> is architecture-dependent. On x86 systems, <TT>HZ</TT></FONT><A name="kernels by"></A><FONT class=extract> used to be set to 100 in 2.4 kernels by default. With 2.6, this value changed to 1000, but with 2.6.13, it was lowered to 250. On ARM-based platforms, 2.6 kernels set <TT>HZ</TT></FONT><A name=for></A><FONT class=extract> to 100. With current kernels, you can choose a value for <TT>HZ</TT></FONT><A name="build time"></A><FONT class=extract> at build time through the configuration menu. The default setting for this option depends on your distribution.</FONT></P>
<P class=docText><FONT class=extract>The 2.6.21 kernel introduced support for a tickless kernel (<TT>CONFIG_NO_HZ</TT></FONT><A name="system implementation"></A><FONT class=extract>), which dynamically triggers timer interrupts depending on system load. The tickless system implementation is outside the scope of this chapter.</FONT></P>
<P></P></DIV><BR>
<P class=docText><TT><FONT class=extract>jiffies</FONT></TT><A name="holds the"></A><FONT class=extract> holds the number of times the system timer has popped since the system booted. The kernel increments the <TT>jiffies</TT> variable, <TT>HZ</TT></FONT><A name="on a"></A><FONT class=extract> times every second. Thus, on a kernel with a <TT>HZ</TT></FONT><A name="of "></A><FONT class=extract> value of 100, a jiffy is a 10-millisecond duration, whereas on a kernel with <TT>HZ</TT> set to 1000, a jiffy is only 1-millisecond long.</FONT></P>
<P class=docText><FONT class=extract>To better understand <TT>HZ</TT> and <TT>jiffies</TT>, consider the following code snippet from the IDE driver (<SPAN class=docEmphasis>drivers/ide/ide.c</SPAN>) that polls disk drives for busy status:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>unsigned long timeout = jiffies + (3*HZ);
while (hwgroup-&gt;busy) {
  /* ... */
  if (time_after(jiffies, timeout)) {
    return -EBUSY;
  }
  /* ... */
}
return SUCCESS;</FONT></PRE></DIV><BR>
<P class=docText><FONT class=extract>The preceding code returns <TT>SUCCESS</TT></FONT><A name=and></A><FONT class=extract> if the busy condition gets cleared in less than 3 seconds, and <TT>-EBUSY</TT> otherwise. <TT>3*HZ</TT> is the number of <TT>jiffies</TT> present in 3 seconds. The calculated timeout, (<TT>jiffies + 3*HZ</TT></FONT><A name=of></A><FONT class=extract>), is thus the new value of <TT>jiffies</TT> after the 3-second timeout elapses. The <TT>time_after()</TT> macro compares the current value of <TT>jiffies</TT></FONT><A name="due to"></A><FONT class=extract> with the requested timeout, taking care to account for wraparound due to overflows. Related functions available for doing similar comparisons are <TT>time_before()</TT>, <TT>time_before_eq()</TT>, and <TT>time_after_eq()</TT>.</FONT></P>
<P class=docText><FONT class=extract><TT>jiffies</TT> is defined as <SPAN class=docEmphasis>volatile</SPAN></FONT><A name="optimize access"></A><FONT class=extract>, which asks the compiler not to optimize access to the variable. This ensures that <TT>jiffies</TT></FONT><A name="during each"></A><FONT class=extract>, which is updated by the timer interrupt handler during each tick, is reread during each pass through the loop.</FONT></P>
<P class=docText><A name=iddle1746></A><A name=iddle2612></A><A name=iddle2640></A><A name=iddle2850></A><A name=iddle4268></A><A name="the reverse"></A><FONT class=extract>For the reverse conversion from <TT>jiffies</TT></FONT><A name="host controller"></A><FONT class=extract> to seconds, take a look at this snippet from the USB host controller driver, <SPAN class=docEmphasis>drivers/usb/host/ehci-sched.c</SPAN>:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>if (stream-&gt;rescheduled) {
  ehci_info(ehci, "ep%ds-iso rescheduled " "%lu times in %lu
            seconds\n", stream-&gt;bEndpointAddress, is_in? "in":
            "out", stream-&gt;rescheduled,
            <SPAN class=docEmphStrong>((jiffies - stream-&gt;start)/HZ));</SPAN>
}</FONT></PRE></DIV><BR>
<P class=docText><A name="The preceding"></A><FONT class=extract>The preceding debug statement calculates the amount of time in seconds within which this USB endpoint stream (we discuss USB in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch11.html#ch11"><FONT class=extract>Chapter 11</FONT></A><A name=rescheduled></A><FONT class=extract>, "Universal Serial Bus") was rescheduled <TT>stream-&gt;rescheduled</TT> times. (<TT>jiffies-stream-&gt;start</TT></FONT><A name="the number"></A><FONT class=extract>) is the number of <TT>jiffies</TT> that elapsed since the rescheduling started. The division by <TT>HZ</TT> converts that value into seconds.</FONT></P>
<P class=docText><FONT class=extract>The 32-bit <TT>jiffies</TT> variable overflows in approximately 50 days, assuming a <TT>HZ</TT></FONT><A name="that duration"></A><FONT class=extract> value of 1000. Because system uptimes can be many times that duration, the kernel provides a variable called <TT>jiffies_64</TT> to hold 64-bit (<TT>u64</TT>) <TT>jiffies</TT>. The linker positions <TT>jiffies_64</TT></FONT><A name="collocate with"></A><FONT class=extract> such that its bottom 32 bits collocate with <TT>jiffies</TT>. On 32-bit machines, the compiler needs two instructions to assign one <TT>u64</TT> variable to another, so reading <TT>jiffies_64</TT></FONT><A name="a function"></A><FONT class=extract> is not atomic. To get around this problem, the kernel provides a function, <TT>get_jiffies_64()</TT>. Look at <TT>cpufreq_stats_update()</TT> defined in <SPAN class=docEmphasis>drivers/cpufreq/cpufreq_stats.c</SPAN> for a usage example.</FONT></P><A name=ch02lev2sec13></A>
<H4 id=title-ID0EIMOM class=docSection2Title><FONT class=extract>Long Delays</FONT></H4>
<P class=docText><A name=of></A><FONT class=extract>In kernel terms, delays in the order of <TT>jiffies</TT></FONT><A name="long delays"></A><FONT class=extract> are considered long durations. A possible, but nonoptimal, way to accomplish long delays is by busy-looping. A function that busy-waits has a dog-in-the-manger attitude. It neither uses the processor for doing useful work nor lets others use it. The following code hogs the processor for 1 second:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>unsigned long timeout = jiffies + HZ;
while (time_before(jiffies, timeout)) continue;</FONT></PRE></DIV><BR>
<P class=docText><A name=iddle1742></A><A name=iddle2353></A><A name=iddle3080></A><A name=iddle3884></A><A name=iddle4616></A><A name="better approach"></A><FONT class=extract>A better approach is to sleep-wait, instead of busy-wait. Your code yields the processor to others, while waiting for the time delay to elapse. This is done using <TT>schedule_timeout</TT><TT>()</TT>:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>unsigned long timeout = jiffies + HZ;
schedule_timeout(timeout);  /* Allow other parts of the
                               kernel to run */</FONT></PRE></DIV><BR>
<P class=docText><A name="the timeout"></A><FONT class=extract>The delay guarantee is only on the lower bound of the timeout. Whether from kernel space or from user space, it's difficult to get more precise control over timeouts than the granularity of <TT>HZ</TT></FONT><A name="because process"></A><FONT class=extract> because process time slices are updated by the kernel scheduler only during timer ticks. Also, even if your process is scheduled to run after the specified timeout, the scheduler can decide to pick another process from the run queue based on priorities.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02lev1sec4.html#ch02fn03">[3]</A></SUP></FONT></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn03><FONT class=extract>[3]</FONT></A></SUP><A name="properties have"></A><FONT class=extract> These scheduler properties have changed with the advent of the CFS scheduler in the 2.6.23 kernel. Linux process schedulers are discussed in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch19.html#ch19"><FONT class=extract>Chapter 19</FONT></A><A name="User Space"></A><FONT class=extract>, "Drivers in User Space."</FONT></P></BLOCKQUOTE>
<P class=docText><FONT class=extract>Two other functions that facilitate sleep-waiting are <TT>wait_event_timeout()</TT> and <TT>msleep()</TT>. Both of them are implemented with the help of <TT>schedule_timeout()</TT>. <TT>wait_event_timeout()</TT></FONT><A name="if a"></A><FONT class=extract> is used when your code desires to resume execution if a specified condition becomes true or if a timeout occurs. <TT>msleep()</TT></FONT><A name="of milliseconds"></A><FONT class=extract> sleeps for the specified number of milliseconds.</FONT></P>
<P class=docText><A name="cannot be"></A><FONT class=extract>Such long-delay techniques are suitable for use only from process context. Sleep-waiting cannot be done from interrupt context because interrupt handlers are not allowed to <TT>schedule()</TT> or sleep. (See "</FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04lev1sec2.html#ch04lev1sec2"><FONT class=extract>Interrupt Handling</FONT></A><FONT class=extract>" in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04.html#ch04"><FONT class=extract>Chapter 4</FONT></A><A name="code executing"></A><FONT class=extract> for a list of do's and don'ts for code executing in interrupt context.) Busy-waiting for a short duration is possible from interrupt context, but long busy-waiting in that context is considered a mortal sin. Equally taboo is long busy-waiting with interrupts disabled.</FONT></P>
<P class=docText><A name="a function"></A><FONT class=extract>The kernel also provides timer APIs to execute a function at a point of time in the future. You can dynamically define a timer using <TT>init_timer()</TT></FONT><A name="statically create"></A><FONT class=extract> or statically create one with <TT>DEFINE_TIMER()</TT>. After this is done, populate a <TT>timer_list</TT> </FONT><A name=iddle1047></A><A name=iddle1487></A><A name=iddle1489></A><A name=iddle1744></A><A name=iddle3021></A><A name=iddle3989></A><A name=iddle4262></A><A name=iddle4264></A><A name="it using"></A><FONT class=extract>with the address and parameters of your handler function, and register it using <TT>add_timer()</TT>:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>#include <LINUX timer.h="">

struct timer_list my_timer;

init_timer(&amp;my_timer);            /* Also see setup_timer() */
my_timer.expire = jiffies + n*HZ; /* n is the timeout in number
                                     of seconds */
my_timer.function = timer_func;   /* Function to execute
                                     after n seconds */
my_timer.data = func_parameter;   /* Parameter to be passed
                                     to timer_func */
add_timer(&amp;my_timer);             /* Start the timer */</LINUX></FONT></PRE></DIV><BR>
<P class=docText><A name="Note that"></A><FONT class=extract>Note that this is a one-shot timer. If you want to run <TT>timer_func()</TT></FONT><A name="need to"></A><FONT class=extract> periodically, you also need to add the preceding code inside <TT>timer_func()</TT></FONT><A name="schedule itself"></A><FONT class=extract> to schedule itself after the next timeout:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>static void timer_func(unsigned long func_parameter)
{
  /* Do work to be done periodically */
  /* ... */

  init_timer(&amp;my_timer);
  my_timer.expire   = jiffies + n*HZ;
  my_timer.data     = func_parameter;
  my_timer.function = timer_func;
  add_timer(&amp;my_timer);
}</FONT></PRE></DIV><BR>
<P class=docText><FONT class=extract>You may use <TT>mod_timer()</TT> to change the expiration of <TT>my_timer, del_timer()</TT> to cancel <TT>my_timer</TT>, and <TT>timer_pending()</TT> to see whether <TT>my_timer</TT> is pending at the moment. If you look at <SPAN class=docEmphasis>kernel/timer.c</SPAN>, you will find that <TT>schedule_timeout()</TT> internally uses these same APIs.</FONT></P>
<P class=docText><FONT class=extract>User-space functions such as <TT>clock_settime()</TT> and <TT>clock_gettime()</TT></FONT><A name="A user"></A><FONT class=extract> are used to access kernel timer services from user space. A user application may use <TT>setitimer()</TT> </FONT><A name=iddle1621></A><A name=iddle1747></A><A name=iddle2142></A><A name=iddle2615></A><A name=iddle2616></A><A name=iddle2643></A><A name=iddle2644></A><A name=iddle2853></A><A name=iddle2919></A><A name=iddle3208></A><A name=iddle3553></A><A name=iddle3995></A><A name=iddle4271></A><A name=iddle4272></A><A name=iddle4274></A><A name=iddle4310></A><A name=iddle4377></A><A name=iddle4570></A><FONT class=extract>and <TT>getitimer()</TT></FONT><A name="an alarm"></A><FONT class=extract> to control the delivery of an alarm signal when a specified timeout expires.</FONT></P><A name=ch02lev2sec14></A>
<H4 id=title-ID0EMZOM class=docSection2Title><FONT class=extract>Short Delays</FONT></H4>
<P class=docText><A name="commonly requested"></A><FONT class=extract>In kernel terms, sub-jiffy delays qualify as short durations. Such delays are commonly requested from both process and interrupt contexts. Because it is not possible to use jiffy-based methods to implement sub-jiffy delays, the methods discussed in the previous section to sleep-wait cannot be used for small timeouts. The only solution is to busy-wait.</FONT></P>
<P class=docText><A name=are></A><FONT class=extract>Kernel APIs that implement short delays are <TT>mdelay()</TT>, <TT>udelay()</TT>, and <TT>ndelay()</TT></FONT><A name="these functions"></A><FONT class=extract>, which support millisecond, microsecond, and nanosecond delays, respectively. The actual implementations of these functions are architecture-specific and may not be available on all platforms.</FONT></P>
<P class=docText><A name="short durations"></A><FONT class=extract>Busy-waiting for short durations is accomplished by measuring the time the processor takes to execute an instruction and looping for the necessary number of iterations. As discussed earlier in this chapter, the kernel performs this measurement during boot and stores the value in a variable called <TT>loops_per_jiffy</TT>. The short-delay APIs use <TT>loops_per_jiffy</TT></FONT><A name="achieve a"></A><FONT class=extract> to decide the number of times they need to busy-loop. To achieve a 1-microsecond delay during a handshake process, the USB host controller driver, <SPAN class=docEmphasis>drivers/usb/host/ehci-hcd.c</SPAN></FONT><A name=calls></A><FONT class=extract>, calls <TT>udelay()</TT></FONT><A name=uses></A><FONT class=extract>, which internally uses <TT>loops_per_jiffy</TT>:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>do {
  result = ehci_readl(ehci, ptr);
  /* ... */
  if (result == done) return 0;
  <SPAN class=docEmphStrong>udelay(1);     /* Internally uses loops_per_jiffy */</SPAN>
  usec--;
} while (usec &gt; 0);</FONT></PRE></DIV><BR><A name=ch02lev2sec15></A>
<H4 id=title-ID0EY1OM class=docSection2Title><FONT class=extract>Pentium Time Stamp Counter</FONT></H4>
<P class=docText><FONT class=extract>The <SPAN class=docEmphasis><A name="Stamp Counter"></A>Time Stamp Counter</SPAN></FONT><A name="number of"></A><FONT class=extract> (TSC) is a 64-bit register present in Pentium-compatible processors that counts the number of clock cycles consumed by the processor since startup. Because the TSC gets incremented at the rate of the processor cycle speed, it provides a high-resolution timer. The TSC is commonly used for profiling and </FONT><A name=iddle2614></A><A name=iddle2642></A><A name=iddle2930></A><A name=iddle3194></A><A name=iddle3751></A><A name=iddle3851></A><A name=iddle4270></A><A name=the></A><FONT class=extract>instrumenting code. It is accessed using the <TT>rdtsc</TT></FONT><A name="microsecond precision"></A><FONT class=extract> instruction to measure execution time of intervening code with microsecond precision. TSC ticks can be converted to seconds by dividing by the CPU clock speed, which can be read from the kernel variable, <TT>cpu_khz</TT>.</FONT></P>
<P class=docText><FONT class=extract>In the following snippet, <TT>low_tsc_ticks</TT></FONT><A name=while></A><FONT class=extract> contains the lower 32 bits of the TSC, while <TT>high_tsc_ticks</TT></FONT><A name="a few"></A><FONT class=extract> contains the higher 32 bits. The lower 32 bits overflow in a few seconds depending on your processor speed but is sufficient for many code instrumentation purposes as shown here:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>unsigned long low_tsc_ticks0, high_tsc_ticks0;
unsigned long low_tsc_ticks1, high_tsc_ticks1;
unsigned long exec_time;
rdtsc(low_tsc_ticks0, high_tsc_ticks0); /* Timestamp
                                           before */
printk("Hello World\n");                /* Code to be
                                           profiled */
rdtsc(low_tsc_ticks1, high_tsc_ticks1); /* Timestamp after */
exec_time = low_tsc_ticks1 - low_tsc_ticks0;</FONT></PRE></DIV><BR>
<P class=docText><TT><FONT class=extract>exec_time</FONT></TT><A name="half a"></A><FONT class=extract> measured 871 (or half a microsecond) on a 1.8GHz Pentium box.</FONT></P><A name=ch02note02></A>
<DIV class=docNote>
<P><FONT class=extract></FONT>
<P class=docText><FONT class=extract>Support for high-resolution timers (<TT>CONFIG_HIGH_RES_TIMERS</TT></FONT><A name="to provide"></A><FONT class=extract>) has been merged with the 2.6.21 kernel. It makes use of hardware-specific high-speed timers to provide high-precision capabilities to APIs such as <TT>nanosleep()</TT></FONT><A name="On Pentium"></A><FONT class=extract>. On Pentium-class machines, the kernel leverages the TSC to offer this capability.</FONT></P>
<P></P></DIV><BR><A name=ch02lev2sec16></A>
<H4 id=title-ID0EP5OM class=docSection2Title><FONT class=extract>Real Time Clock</FONT></H4>
<P class=docText><A name="tracks absolute"></A><FONT class=extract>The RTC tracks absolute time in nonvolatile memory. On x86 PCs, RTC registers constitute the top few locations of a small chunk of battery-powered<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02lev1sec4.html#ch02fn04">[4]</A></SUP> <SPAN class=docEmphasis><A name="metal oxide"></A>complementary metal oxide semiconductor</SPAN> (CMOS) memory. Look at </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05lev1sec2.html#ch05fig01"><FONT class=extract>Figure 5.1</FONT></A><FONT class=extract> in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05"><FONT class=extract>Chapter 5</FONT></A><A name="PC architecture"></A><FONT class=extract>, "Character Drivers," for the location of the CMOS in the legacy PC architecture. On embedded </FONT><A name=iddle1835></A><A name=iddle2143></A><A name=iddle2843></A><A name=iddle3011></A><A name=iddle4257></A><A name=iddle4572></A><A name=iddle4625></A><A name=iddle4669></A><A name="to the"></A><FONT class=extract>systems, the RTC might be internal to the processor, or externally connected via the I<SUP>2</SUP>C or SPI buses discussed in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08"><FONT class=extract>Chapter 8</FONT></A><FONT class=extract>, "The Inter-Integrated Circuit Protocol."</FONT></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn04><FONT class=extract>[4]</FONT></A></SUP><A name="the life"></A><FONT class=extract> RTC batteries last for many years and usually outlive the life span of computers, so you should never have to replace them.</FONT></P></BLOCKQUOTE>
<P class=docText><A name="do the"></A><FONT class=extract>You may use the RTC to do the following:</FONT></P><A name=ch08pro01></A>
<UL class=doclist start="">
<LI><FONT class=extract>Read and set the absolute clock, and generate interrupts during clock updates.<BR><BR></FONT>
<LI><FONT class=extract>Generate periodic interrupts with frequencies ranging from 2HZ to 8192HZ.<BR><BR></FONT>
<LI><FONT class=extract>Set alarms<BR><BR></FONT></LI></UL>
<P class=docText><A name=or></A><FONT class=extract>Many applications need the concept of absolute time or <SPAN class=docEmphasis>wall time.</SPAN> Because <TT>jiffies</TT></FONT><A name="relative to"></A><FONT class=extract> is relative to the time when the system booted, it does not contain wall time. The kernel maintains wall time in a variable called <TT>xtime</TT>. During boot, <TT>xtime</TT></FONT><A name="When the"></A><FONT class=extract> is initialized to the current wall time by reading the RTC. When the system halts, the wall time is written back to the RTC. You can use <TT>do_gettimeofday()</TT></FONT><A name="to read"></A><FONT class=extract> to read wall time with the highest resolution supported by the hardware:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>#include <LINUX time.h="">
static struct timeval curr_time;
do_gettimeofday(&amp;curr_time);
my_timestamp = cpu_to_le32(curr_time.tv_sec); /* Record timestamp */</LINUX></FONT></PRE></DIV><BR>
<P class=docText><A name="also a"></A><FONT class=extract>There are also a bunch of functions available to user-space code to access wall time. They include the following:</FONT></P>
<UL>
<LI>
<P class=docList><FONT class=extract><TT>time</TT><TT>()</TT></FONT><A name="returns the"></A><FONT class=extract>, which returns the calendar time, or the number of seconds since Epoch (00:00:00 on January 1, 1970)</FONT></P>
<LI>
<P class=docList><FONT class=extract><TT>localtime()</TT>, which returns the calendar time in broken-down format</FONT></P>
<LI>
<P class=docList><FONT class=extract><TT>mktime()</TT>, which does the reverse of <TT>localtime()</TT></FONT></P>
<LI>
<P class=docList><TT><FONT class=extract>gettimeofday()</FONT></TT><A name="your platform"></A><FONT class=extract>, which returns the calendar time with microsecond precision if your platform supports it</FONT></P></LI></UL>
<P class=docText><A name="RTC from"></A><FONT class=extract>Another way to use the RTC from user space is via the character device, <SPAN class=docEmphasis>/dev/rtc.</SPAN></FONT><A name="at a"></A><FONT class=extract> Only one process is allowed to access this device at a time.</FONT></P>
<P class=docText><A name=in></A><FONT class=extract>We discuss more about RTC drivers in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05"><FONT class=extract>Chapter 5</FONT></A><FONT class=extract> and </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08"><FONT class=extract>Chapter 8</FONT></A><FONT class=extract>. In </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch19.html#ch19"><FONT class=extract>Chapter 19</FONT></A><FONT class=extract>, we develop an example user application that uses <SPAN class=docEmphasis>/dev/rtc</SPAN> to perform periodic work with microsecond precision.</FONT>