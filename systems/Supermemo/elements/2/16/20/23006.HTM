<H3 id=-100000 class=docSection1Title>Booting Up</H3>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02fig01">Figure 2.1</A><A name="the Linux"></A> shows the Linux boot sequence on an x86-based computer. Linux boot on x86-based hardware is set into motion when the BIOS loads the <SPAN class=docEmphasis>Master Boot Record</SPAN><A name="at the"></A> (MBR) from the boot device. Code resident in the MBR looks at the partition table and reads a Linux bootloader such as GRUB, LILO, or SYSLINUX from the active partition. The final stage of the bootloader loads the compressed kernel image and passes control to it. The kernel uncompresses itself and turns on the ignition.</P><A name=ch02fig01></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 2.1. Linux boot sequence on x86-based hardware.</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/YTNyaWQ3ODBzOS9jL2VnbXRwNjQ5NWEzMi9yZzE1ZmkwcGdmaS4wLzFoaWcyc2M-.jpg" width=500 height=490></P></CENTER>
<P></P><BR>
<P class=docText>x86-based processors have two modes of operation, <SPAN class=docEmphasis>real</SPAN> mode and <SPAN class=docEmphasis>protected</SPAN><A name="only the"></A> mode. In real mode, you can access only the first 1MB of memory, that too without any protection. Protected mode is sophisticated and lets you tap into many advanced features of the processor such as paging. The CPU has to pass through real mode en route to protected mode. This road is a one-way street, however. You can't switch back to real mode from protected mode.</P>
<P class=docText><A name="startup is"></A><FONT class=extract>The first-level kernel initializations are done in real mode assembly. Subsequent startup is performed in protected mode by the function <TT>start_kernel()</TT> defined in <SPAN class=docEmphasis>init/main.c</SPAN></FONT><A name="the previous"></A><FONT class=extract>, the source file you modified in the previous chapter. <TT>start_kernel()</TT></FONT><A name="management are"></A><FONT class=extract> begins by initializing the CPU subsystem. Memory and process management are put in place soon after. Peripheral buses and I/O devices are started next.</FONT> As the last step in the boot sequence, the <SPAN class=docEmphasis>init</SPAN><A name="parent of"></A> program, the parent of all Linux processes, is invoked. Init executes user-space scripts that start necessary kernel services. It finally spawns terminals on consoles and displays the login prompt.</P>
<P class=docText><A name=iddle1218></A><A name=iddle1219></A><A name=iddle1317></A><A name=iddle1325></A><A name=iddle2541></A><A name=iddle2549></A>Each following section header is a message from <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02tab01">Figure 2.2</A><A name="messages may"></A> generated during boot progression on an x86-based laptop. The semantics and the messages may change if you are booting the kernel on other architectures. If some explanations in this section sound rather cryptic, don't worry; the intent here is only to give you a picture from 100 feet above and to let you savor a first taste of the kernel's flavor. Many concepts mentioned here in passing are covered in depth later on.</P><A name=ch02tab01></A>
<H5 id=title-ID0ENUOM class=docExampleTitle>Figure 2.2. Kernel boot messages.</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks><A name="Code View"></A>Code View:</DIV><PRE><SPAN class=docEmphStrong>Linux version 2.6.23.1y (root@localhost.localdomain) (gcc version 4.1.1 20061011 (Red</SPAN>
<SPAN class=docEmphStrong>Hat 4.1.1-30)) #7 SMP PREEMPT Thu Nov 1 11:39:30 IST 2007</SPAN>
<SPAN class=docEmphStrong>BIOS-provided physical RAM map:</SPAN>
 <SPAN class=docEmphStrong>BIOS-e820: 0000000000000000 - 000000000009f000 (usable)</SPAN>
 <SPAN class=docEmphStrong>BIOS-e820: 000000000009f000 - 00000000000a0000 (reserved)</SPAN>
 <SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>758MB LOWMEM available.</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Kernel command line: ro root=/dev/hda1</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Console: colour VGA+ 80x25</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Calibrating delay using timer specific routine.. 1197.46 BogoMIPS (lpj=2394935)</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>CPU: L1 I cache: 32K, L1 D cache: 32K</SPAN>
<SPAN class=docEmphStrong>CPU: L2 cache: 1024K</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Checking 'hlt' instruction... OK.</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
Setting up standard PCI resources
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>NET: Registered protocol family 2</SPAN>
<SPAN class=docEmphStrong>IP route cache hash table entries: 32768 (order: 5, 131072 bytes)</SPAN>
<SPAN class=docEmphStrong>TCP established hash table entries: 131072 (order: 9, 2097152 bytes)</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>checking if image is initramfs... it is</SPAN>
<SPAN class=docEmphStrong>Freeing initrd memory: 387k freed</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
io scheduler noop registered
<SPAN class=docEmphStrong>io scheduler anticipatory registered (default)</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>00:0a: ttyS0 at I/O 0x3f8 (irq = 4) is a NS16550A</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Uniform Multi-Platform E-IDE driver Revision: 7.00alpha2</SPAN>
<SPAN class=docEmphStrong>ide: Assuming 33MHz system bus speed for PIO modes; override with idebus=xx</SPAN>
<SPAN class=docEmphStrong>ICH4: IDE controller at PCI slot 0000:00:1f.1</SPAN>
<SPAN class=docEmphStrong>Probing IDE interface ide0...</SPAN>
<SPAN class=docEmphStrong>hda: HTS541010G9AT00, ATA DISK drive</SPAN>
<SPAN class=docEmphStrong>hdc: HL-DT-STCD-RW/DVD DRIVE GCC-4241N, ATAPI CD/DVD-ROM drive</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>serio: i8042 KBD port at 0x60,0x64 irq 1</SPAN>
<SPAN class=docEmphStrong>mice: PS/2 mouse device common for all mice</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Synaptics Touchpad, model: 1, fw: 5.9, id: 0x2c6ab1, caps: 0x884793/0x0</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>agpgart: Detected an Intel 855GM Chipset.</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Intel(R) PRO/1000 Network Driver - version 7.3.20-k2</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>ehci_hcd 0000:00:1d.7: EHCI Host Controller</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Yenta: CardBus bridge found at 0000:02:00.0 [1014:0560]</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>Non-volatile memory driver v1.2</SPAN>
<SPAN class=docEmphStrong>...</SPAN>
<SPAN class=docEmphStrong>kjournald starting. Commit interval 5 seconds</SPAN>
<SPAN class=docEmphStrong>EXT3 FS on hda2, internal journal</SPAN>
EXT3-fs: mounted filesystem with ordered data mode.
...
INIT: version 2.85 booting
...

					  </PRE><BR></TD></TR></TBODY></TABLE></P><A name=ch02lev2sec1></A>
<H4 id=title-ID0E6ZOM class=docSection2Title><FONT class=extract>BIOS-Provided Physical RAM Map</FONT></H4>
<P class=docText><A name="assembles the"></A><FONT class=extract>The kernel assembles the system memory map from the BIOS, and this is one of the first boot messages you will see:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>BIOS-provided physical RAM map:
BIOS-e820: 0000000000000000 - 000000000009f000 (usable)
...
BIOS-e820: 00000000ff800000 - 0000000100000000 (reserved)</FONT></PRE></DIV><BR>
<P class=docText><A name="mode initialization"></A><FONT class=extract>Real mode initialization code uses the BIOS <TT>int 0x15</TT> service with function number <TT>0xe820</TT>(hence the string <TT>BIOS-e820</TT></FONT><A name="memory map"></A><FONT class=extract> in the preceding message) to obtain the system memory map. The memory map indicates reserved and usable memory ranges, which is subsequently used by the kernel to create its free memory pool. We discuss </FONT><A name=iddle1324></A><A name=iddle1326></A><A name=iddle2220></A><A name=iddle2548></A><A name=iddle2550></A><A name=iddle2664></A><A name=iddle2857></A><A name=iddle2948></A><A name=iddle2950></A><A name="in the"></A><FONT class=extract>more on the BIOS-supplied memory map in the section "</FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app02lev1sec1.html#app02lev1sec1"><FONT class=extract>Real Mode Calls</FONT></A><FONT class=extract>" in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app02.html#app02"><FONT class=extract>Appendix B</FONT></A><FONT class=extract>, "Linux and the BIOS."</FONT></P><A name=ch02lev2sec2></A>
<H4 id=title-ID0EJ5OM class=docSection2Title><FONT class=extract>758MB LOWMEM Available</FONT></H4>
<P class=docText><FONT class=extract>The normally addressable kernel memory region (&lt; 896MB) is called <SPAN class=docEmphasis>low memory.</SPAN> The kernel memory allocator, <TT>kmalloc()</TT>, returns memory from this region. Memory beyond 896MB (called <SPAN class=docEmphasis>high memory</SPAN>) can be accessed only using special mappings.</FONT></P>
<P class=docText><A name="present in"></A><FONT class=extract>During boot, the kernel calculates and displays the total pages present in these memory zones. We take a deeper look at memory zones later in this chapter.</FONT></P><A name=ch02lev2sec3></A>
<H4 id=title-ID0E45OM class=docSection2Title><FONT class=extract>Kernel Command Line: ro root=/dev/hda1</FONT></H4>
<P class=docText><A name="line to"></A><FONT class=extract>Linux bootloaders usually pass a command line to the kernel. Arguments in the command line are similar to the <TT>argv[]</TT> list passed to the <TT>main()</TT></FONT><A name="to the"></A><FONT class=extract> function in C programs, except that they are passed to the kernel instead. You may add command-line arguments to the bootloader configuration file or supply them from the bootloader prompt at runtime.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02fn01">[1]</A></SUP></FONT><A name="you are"></A><FONT class=extract> If you are using the GRUB bootloader, the configuration file is either <SPAN class=docEmphasis>/boot/grub/grub.conf</SPAN> or <SPAN class=docEmphasis>/boot/grub/menu.lst</SPAN></FONT><A name="file is"></A><FONT class=extract> depending on your distribution. If you are a LILO user, the configuration file is <SPAN class=docEmphasis>/etc/lilo.conf.</SPAN></FONT><A name="An example"></A><FONT class=extract> An example <SPAN class=docEmphasis>grub.conf</SPAN></FONT><A name="is listed"></A><FONT class=extract> file (with comments added) is listed here. You can figure out the genesis of the preceding boot message if you look at the line following <TT><A name="kernel "></A>title kernel 2.6.23</TT>:</FONT></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn01><FONT class=extract>[1]</FONT></A></SUP><A name="support configuration"></A><FONT class=extract> Bootloaders on embedded devices are usually "slim" and do not support configuration files or equivalent mechanisms. Because of this, many non-x86 architectures support a kernel configuration option called <TT>CONFIG_CMDLINE</TT></FONT><A name="supply the"></A><FONT class=extract> that you can use to supply the kernel command line at build time.</FONT></P></BLOCKQUOTE>
<DIV class=docText><PRE><FONT class=extract>default 0  #Boot the 2.6.23 kernel by default
timeout 5  #5 second to alter boot order or parameters

title kernel 2.6.23     #Boot Option 1
  #The boot image resides in the first partition of the first disk
  #under the /boot/ directory and is named vmlinuz-2.6.23. 'ro'
  #indicates that the root partition should be mounted read-only.
  kernel (hd0,0)/boot/vmlinuz-2.6.23 <SPAN class=docEmphStrong>ro root=/dev/hda1</SPAN>

  #Look under section "Freeing initrd memory:387k freed"
  initrd (hd0,0)/boot/initrd

#...</FONT></PRE></DIV><BR>
<P class=docText><A name="simple example"></A><FONT class=extract>Command-line arguments affect the code path traversed during boot. As a simple example, assume that the command-line argument of interest is called <TT>bootmode</TT>. If this parameter is set to <TT>1</TT></FONT><A name="debug messages"></A><FONT class=extract>, you would like to print some debug messages during boot and switch to a runlevel of <TT>3</TT></FONT><A name="messages are"></A><FONT class=extract> at the end of the boot. (Wait until the boot messages are printed out by the init process to learn the semantics of runlevels.) If <TT>bootmode</TT></FONT><A name="instead set"></A><FONT class=extract> is instead set to <TT>0</TT></FONT><A name="runlevel set"></A><FONT class=extract>, you would prefer the boot to be relatively laconic, and the runlevel set to <TT>2</TT></FONT><A name="Because you"></A><FONT class=extract>. Because you are already familiar with <SPAN class=docEmphasis>init/main.c</SPAN></FONT><A name="following modification"></A><FONT class=extract>, let's add the following modification to it:</FONT></P>
<DIV class=docText>
<DIV class=codeSegmentsExpansionLinks><FONT class=extract>Code View:</FONT></DIV><PRE><FONT class=extract>static unsigned int bootmode = 1;
static int __init
is_bootmode_setup(char *str)
{
  get_option(&amp;str, &amp;bootmode);
  return 1;
}

/* Handle parameter "bootmode=" */
__setup("bootmode=", is_bootmode_setup);

if (bootmode) {
  /* Print verbose output */
  /* ... */
}

/* ... */

/* If bootmode is 1, choose an init runlevel of 3, else
   switch to a run level of 2 */
if (bootmode) {
  argv_init[++args] = "3";
} else {
  argv_init[++args] = "2";
}

/* ... */

					  </FONT></PRE></DIV><BR>
<P class=docText><A name="the kernel"></A><FONT class=extract>Rebuild the kernel as you did earlier and try out the change. We discuss more about kernel command-line arguments in the section "</FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec5.html#ch18lev1sec5"><FONT class=extract>Memory Layout</FONT></A><FONT class=extract>" in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18.html#ch18"><FONT class=extract>Chapter 18</FONT></A><FONT class=extract>, "Embedding Linux."</FONT></P><A name=ch02lev2sec4></A>
<H4 id=title-ID0EVBPM class=docSection2Title><FONT class=extract>Calibrating Delay...1197.46 BogoMIPS (lpj=2394935)</FONT></H4>
<P class=docText><A name=iddle1318></A><A name=iddle1360></A><A name=iddle1745></A><A name=iddle2503></A><A name=iddle2542></A><A name=iddle2852></A><A name=iddle4569></A><A name="processor can"></A><FONT class=extract>During boot, the kernel calculates the number of times the processor can execute an internal delay loop in one <SPAN class=docEmphasis>jiffy</SPAN></FONT><A name="between two"></A><FONT class=extract>, which is the time interval between two consecutive ticks of the system timer. As you would expect, the calculation has to be calibrated to the processing speed of your CPU. The result of this calibration is stored in a kernel variable called <TT>loops_per_jiffy</TT>. One place where the kernel makes use of <TT>loops_per_jiffy</TT></FONT><A name="for small"></A><FONT class=extract> is when a device driver desires to delay execution for small durations in the order of microseconds.</FONT></P>
<P class=docText><A name="peek inside"></A><FONT class=extract>To understand the delay-loop calibration code, let's take a peek inside <TT>calibrate_delay</TT><TT>()</TT>, defined in <SPAN class=docEmphasis>init/calibrate.c.</SPAN></FONT><A name="The following"></A><FONT class=extract> This function cleverly derives floating-point precision using the integer kernel. The following snippet (with some comments added) shows the initial portion of the function that carves out a coarse value for <TT>loops_per_jiffy</TT>:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>loops_per_jiffy = (1 &lt;&lt; 12); /* Initial approximation = 4096 */
printk(KERN_DEBUG "Calibrating delay loop... ");
while ((loops_per_jiffy &lt;&lt;= 1) != 0) {
ticks = jiffies;  /* As you will find out in the section, "Kernel
                     Timers," the jiffies variable contains the
                     number of timer ticks since the kernel
                     started, and is incremented in the timer
                     interrupt handler */

  while (ticks == jiffies); /* Wait until the start
                               of the next jiffy */
  ticks = jiffies;
  /* Delay */
  __delay(loops_per_jiffy);

  /* Did the wait outlast the current jiffy? Continue if
     it didn't */
  ticks = jiffies - ticks;
  if (ticks) break;
}

loops_per_jiffy &gt;&gt;= 1; /* This fixes the most significant bit and is
                          the lower-bound of loops_per_jiffy */</FONT></PRE></DIV><BR>
<P class=docText><A name=iddle1301></A><A name=iddle2994></A><A name=iddle2999></A><A name=iddle3041></A><A name=iddle3079></A><A name="preceding code"></A><FONT class=extract>The preceding code begins by assuming that <TT>loops_per_jiffy</TT> is greater than <TT>4096</TT>, which translates to a processor speed of roughly one <SPAN class=docEmphasis>million instructions per second</SPAN></FONT><A name="executes the"></A><FONT class=extract> (MIPS). It then waits for a fresh jiffy to start and executes the delay loop, <TT>__delay(loops_per_jiffy)</TT></FONT><A name="If the"></A><FONT class=extract>. If the delay loop outlasts the jiffy, the previous value of <TT>loops_per_jiffy</TT></FONT><A name="it by"></A><FONT class=extract> (obtained by bitwise right-shifting it by one) fixes its <SPAN class=docEmphasis><A name="significant bit"></A>most significant bit</SPAN></FONT><A name="the MSB"></A><FONT class=extract> (MSB). Otherwise, the function continues by checking whether it will obtain the MSB by bitwise left-shifting <TT>loops_per_jiffy</TT></FONT><A name="out the"></A><FONT class=extract>. When the kernel thus figures out the MSB of <TT>loops_per_jiffy</TT>, it works on the lower-order bits and fine-tunes its precision as follows:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>loopbit = loops_per_jiffy;

/* Gradually work on the lower-order bits */
while (lps_precision-- &amp;&amp; (loopbit &gt;&gt;= 1)) {
  loops_per_jiffy |= loopbit;
  ticks = jiffies;
  while (ticks == jiffies); /* Wait until the start
                               of the next jiffy */
ticks = jiffies;

  /* Delay */
  __delay(loops_per_jiffy);

  if (jiffies != ticks)        /* longer than 1 tick */
    loops_per_jiffy &amp;= ~loopbit;
}</FONT></PRE></DIV><BR>
<P class=docText><A name="the lower"></A><FONT class=extract>The preceding snippet figures out the exact combination of the lower bits of <TT>loops_per_jiffy</TT></FONT><A name="jiffy boundary"></A><FONT class=extract> when the delay loop crosses a jiffy boundary. This calibrated value is used to derive an unscientific measure of the processor speed, known as <SPAN class=docEmphasis>BogoMIPS.</SPAN></FONT><A name="relative measurement"></A><FONT class=extract> You can use the BogoMIPS rating as a relative measurement of how fast a CPU can run. On a 1.6GHz Pentium M-based laptop, the delay-loop calibration yielded a value of <TT>2394935</TT> for <TT>loops_per_jiffy</TT></FONT><A name="announced by"></A><FONT class=extract> as announced by the preceding boot message. The BogoMIPS value is obtained as follows:</FONT></P>
<P>
<TABLE cellSpacing=0 cellPadding=5 rules=none frame=void>
<COLGROUP span=2 align=left><FONT class=extract>
<COL width=70>
<COL width=450></FONT></COLGROUP>
<THEAD><FONT class=extract></FONT></THEAD>
<TBODY>
<TR>
<TD class=docTableCell vAlign=top colSpan=2 align=left><FONT class=extract>BogoMIPS = <TT>loops_per_jiffy</TT></FONT><A name="the internal"></A><FONT class=extract> * Number of jiffies in 1 second * Number of instructions consumed by the internal delay loop in units of 1 million</FONT></TD></TR>
<TR>
<TD class=docTableCell vAlign=top align=left><FONT class=extract>&nbsp;</FONT></TD>
<TD class=docTableCell vAlign=top align=left><A name="HZ "></A><FONT class=extract>= (2394935 * HZ * 2) / (1 million)</FONT></TD></TR>
<TR>
<TD class=docTableCell vAlign=top align=left><FONT class=extract>&nbsp;</FONT></TD>
<TD class=docTableCell vAlign=top align=left><FONT class=extract>= (2394935 * 250 * 2) / (1000000)</FONT></TD></TR>
<TR>
<TD class=docTableCell vAlign=top align=left><FONT class=extract>&nbsp;</FONT></TD>
<TD class=docTableCell vAlign=top align=left><A name="the preceding"></A><FONT class=extract>= 1197.46 (as displayed in the preceding boot message)</FONT></TD></TR></TBODY></TABLE></P><BR>
<P class=docText><A name=iddle1051></A><A name=iddle1061></A><A name=iddle1070></A><A name=iddle1071></A><A name=iddle1072></A><A name=iddle1125></A><A name=iddle1320></A><A name=iddle1323></A><A name=iddle1328></A><A name=iddle1448></A><A name=iddle2169></A><A name=iddle2226></A><A name=iddle2363></A><A name=iddle2544></A><A name=iddle2547></A><A name=iddle2552></A><A name=iddle2949></A><A name=iddle3241></A><A name=iddle3771></A><A name=iddle4075></A><A name=iddle4076></A><A name=iddle4393></A><A name="further discuss"></A><FONT class=extract>We further discuss <TT>jiffies</TT>, <TT>HZ</TT>, and <TT>loops_per_jiffy</TT> in the section "</FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02lev1sec4.html#ch02lev1sec4"><FONT class=extract>Kernel Timers</FONT></A><FONT class=extract>" later in this chapter.</FONT></P><A name=ch02lev2sec5></A>
<H4 id=title-ID0EUQPM class=docSection2Title><FONT class=extract>Checking HLT Instruction</FONT></H4>
<P class=docText><A name="of hardware"></A><FONT class=extract>Because the Linux kernel is supported on a variety of hardware platforms, the boot code checks for architecture-dependent bugs. Verifying the sanity of the <SPAN class=docEmphasis>halt</SPAN> (HLT) instruction is one such check.</FONT></P>
<P class=docText><A name="processors puts"></A><FONT class=extract>The HLT instruction supported by x86 processors puts the CPU into a low-power sleep mode that continues until the next hardware interrupt occurs. The kernel uses the HLT instruction when it wants to put the CPU in the idle state (see function <TT>cpu_idle()</TT> defined in <SPAN class=docEmphasis>arch/x86/kernel/process_32.c</SPAN>).</FONT></P>
<P class=docText><FONT class=extract>For problematic CPUs, the <TT>no-hlt</TT></FONT><A name=If></A><FONT class=extract> kernel command-line argument can be used to disable the HLT instruction. If <TT>no-hlt</TT></FONT><A name="than keep"></A><FONT class=extract> is turned on, the kernel busy-waits while it's idle, rather than keep the CPU cool by putting it in the HLT state.</FONT></P>
<P class=docText><A name="startup code"></A><FONT class=extract>The preceding boot message is generated when the startup code in <SPAN class=docEmphasis>init/main.c</SPAN> calls <TT>check_bugs()</TT></FONT><A name=in></A><FONT class=extract> defined in <SPAN class=docEmphasis>include/asm-your-arch/bugs.h</SPAN>.</FONT></P><A name=ch02lev2sec6></A>
<H4 id=title-ID0EZRPM class=docSection2Title><FONT class=extract>NET: Registered Protocol Family 2</FONT></H4>
<P class=docText><A name="user applications"></A><FONT class=extract>The Linux socket layer is a uniform interface through which user applications access various networking protocols. Each protocol registers itself with the socket layer using a unique family number (defined in <SPAN class=docEmphasis>include/linux/socket.h</SPAN></FONT><A name="assigned to"></A><FONT class=extract>) assigned to it. Family 2 in the preceding message stands for <TT>AF_INET</TT> (Internet Protocol).</FONT></P>
<P class=docText><A name="protocol family"></A><FONT class=extract>Another registered protocol family often found in boot messages is <TT>AF_NETLINK</TT></FONT><A name="sockets offer"></A><FONT class=extract> (Family 16). Netlink sockets offer a method to communicate between user processes and the kernel. Functionalities accomplished via netlink sockets include accessing the routing table and the <SPAN class=docEmphasis>Address Resolution Protocol</SPAN> (ARP) table (see <SPAN class=docEmphasis>include/linux/netlink.h</SPAN></FONT><A name="than system"></A><FONT class=extract> for the full usage list). Netlink sockets are more suitable than system calls to accomplish such tasks because they are asynchronous, simpler to implement, and dynamically linkable.</FONT></P>
<P class=docText><A name="in the"></A><FONT class=extract>Another protocol family commonly enabled in the kernel is <TT>AF_UNIX</TT></FONT><A name="interprocess communication"></A><FONT class=extract> or UNIX-domain sockets. Programs such as X Windows use them for interprocess communication on the same system.</FONT></P><A name=ch02lev2sec7></A>
<H4 id=title-ID0EXSPM class=docSection2Title><FONT class=extract>Freeing Initrd Memory: 387k Freed</FONT></H4>
<P class=docText><SPAN class=docEmphasis><FONT class=extract>Initrd</FONT></SPAN><A name="by the"></A><FONT class=extract> is a memory-resident virtual disk image loaded by the bootloader. It's mounted as the initial root filesystem after the kernel boots, to hold additional dynamically </FONT><A name=iddle1319></A><A name=iddle2036></A><A name=iddle2060></A><A name=iddle2067></A><A name=iddle2319></A><A name=iddle2362></A><A name=iddle2543></A><A name=iddle3009></A><A name=iddle3010></A><A name=iddle3841></A><A name="that holds"></A><FONT class=extract>loadable modules required to mount the disk partition that holds the actual root filesystem. Because the kernel runs on different hardware platforms that use diverse storage controllers, it's not feasible for distributions to enable device drivers for all possible disk drives in the base kernel image. Drivers specific to your system's storage device are packed inside initrd and loaded after the kernel boots, but before the root filesystem is mounted. To create an initrd image, use the <TT>mkinitrd</TT> command.</FONT></P>
<P class=docText><A name="kernel includes"></A><FONT class=extract>The 2.6 kernel includes a feature called <SPAN class=docEmphasis>initramfs</SPAN></FONT><A name="disk "></A><FONT class=extract> that bring several benefits over initrd. Whereas the latter emulates a disk (hence called <SPAN class=docEmphasis>initramdisk</SPAN></FONT><A name=or></A><FONT class=extract> or <SPAN class=docEmphasis>initrd</SPAN></FONT><A name="the overheads"></A><FONT class=extract>) and suffers the overheads associated with the Linux block I/O subsystem such as caching, the former essentially gets the cache itself mounted like a filesystem (hence called <SPAN class=docEmphasis>initramfs</SPAN>).</FONT></P>
<P class=docText><A name="the page"></A><FONT class=extract>Initramfs, like the page cache over which it's built, grows and shrinks dynamically unlike initrd and, hence, reduces memory wastage. Also, unlike initrd, which requires you to include the associated filesystem driver (e.g., EXT2 drivers if you have an EXT2 filesystem on your initrd), initramfs needs no filesystem support. The initramfs code is tiny because it's just a small layer on top of the page cache.</FONT></P>
<P class=docText><A name=compressed></A><FONT class=extract>You can pack your initial root filesystem into a compressed <SPAN class=docEmphasis>cpio</SPAN> archive<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02fn02">[2]</A></SUP></FONT><A name="kernel command"></A><FONT class=extract> and pass it to the kernel command line using the <TT>initrd=</TT></FONT><A name="image using"></A><FONT class=extract> argument or build it as part of the kernel image using the <TT>INITRAMFS_SOURCE</TT></FONT><A name="you may"></A><FONT class=extract> menu option during kernel configuration. With the latter, you may either provide the filename of a cpio archive or the path name to a directory tree containing your initramfs layout. During boot, the kernel extracts the files into an initramfs root filesystem (also called <SPAN class=docEmphasis>rootfs</SPAN>) and executes a top-level <SPAN class=docEmphasis>/init</SPAN></FONT><A name="an initial"></A><FONT class=extract> program if it finds one. This method of obtaining an initial rootfs is especially useful for embedded platforms, where all system resources are at a premium. To create an initramfs image, use <TT>mkinitramfs</TT></FONT><A name=at></A><FONT class=extract>. Look at <SPAN class=docEmphasis>Documentation/filesystems/ramfs-rootfs-initramfs.txt</SPAN> for more documentation.</FONT></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn02><FONT class=extract>[2]</FONT></A></SUP><A name=from></A><FONT class=extract> cpio is a UNIX file archival format. You can download it from </FONT><A class=docLink href="http://www.gnu.org/software/cpio" target=_blank><FONT class=extract>www.gnu.org/software/cpio</FONT></A><FONT class=extract>.</FONT></P></BLOCKQUOTE>
<P class=docText><A name="In this"></A><FONT class=extract>In this case, we are using initramfs by supplying a compressed cpio archive of the initial root filesystem to the kernel using the <TT>initrd=</TT></FONT><A name="the contents"></A><FONT class=extract> command-line argument. After unpacking the contents of the archive into rootfs, the kernel frees the memory where the archive resides (387K in this case) and announces the above boot message. The freed pages are then doled out to other parts of the kernel that request memory.</FONT></P>
<P class=docText><A name="discussed in"></A><FONT class=extract>As discussed in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18.html#ch18"><FONT class=extract>Chapter 18</FONT></A><A name="actual root"></A><FONT class=extract>, initrd and initramfs are sometimes used to hold the actual root filesystem on embedded devices during development.</FONT></P><A name=ch02lev2sec8></A>
<H4 id=title-ID0EEYPM class=docSection2Title><FONT class=extract>IO Scheduler Anticipatory Registered (Default)</FONT></H4>
<P class=docText><A name=iddle1109></A><A name=iddle1321></A><A name=iddle1327></A><A name=iddle1411></A><A name=iddle1540></A><A name=iddle1582></A><A name=iddle1674></A><A name=iddle2247></A><A name=iddle2545></A><A name=iddle2551></A><A name=iddle3292></A><A name=iddle3441></A><A name="scheduler is"></A><FONT class=extract>The main goal of an I/O scheduler is to increase system throughput by minimizing disk seek times, which is the latency to move the disk head from its existing position to the disk sector of interest. The 2.6 kernel provides four different I/O schedulers: <SPAN class=docEmphasis>Deadline</SPAN><SPAN class=docEmphasis>, Anticipatory, Complete Fair Queuing</SPAN>, and <SPAN class=docEmphasis>Noop.</SPAN> As the preceding kernel message indicates, the kernel sets <SPAN class=docEmphasis>Anticipatory</SPAN> as the default I/O scheduler. We look at I/O scheduling in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch14.html#ch14"><FONT class=extract>Chapter 14</FONT></A><FONT class=extract>, "Block Drivers."</FONT></P><A name=ch02lev2sec9></A>
<H4 id=title-ID0EU3PM class=docSection2Title><FONT class=extract>Setting Up Standard PCI Resources</FONT></H4>
<P class=docText><A name="initializes I"></A><FONT class=extract>The next phase of the boot process probes and initializes I/O buses and peripheral controllers. The kernel probes PCI hardware by walking the PCI bus, and then initializes other I/O subsystems. Take a look at the boot messages in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02tab02"><FONT class=extract>Figure 2.3</FONT></A><A name="of the"></A><FONT class=extract> to see announcements regarding the initialization of the SCSI subsystem, the USB controller, the video chip (part of the 855 North Bridge chipset in the messages below), the serial port (8250 UART in this case), PS/2 keyboard and mouse, floppy drives, ramdisk, the loopback device, the IDE controller (part of the ICH4 South Bridge chipset in this example), the touchpad, the Ethernet controller (e1000 in this case), and the PCMCIA controller. The identity of the corresponding I/O device is labeled against <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF">.</FONT></P><A name=ch02tab02></A>
<H5 id=title-ID0EJ4PM class=docExampleTitle><FONT class=extract>Figure 2.3. Initializing buses and peripheral controllers during boot.</FONT></H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks><FONT class=extract>Code View:</FONT></DIV><PRE><FONT class=extract>SCSI subsystem initialized                  <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>SCSI</SPAN>
usbcore: registered new driver hub          <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>USB</SPAN>
agpgart: Detected an Intel 855 Chipset.     <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Video</SPAN>
[drm] Initialized drm 1.0.0 20040925
PS/2 Controller [PNP0303:KBD,PNP0f13:MOU]
at 0x60,0x64 irq 1,12 serio: i8042 KBD port <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Keyboard</SPAN>
serial8250: ttyS0 at I/O 0x3f8 (irq = 4)
is a NS16550A                               <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Serial Port</SPAN>
Floppy drive(s): fd0 is 1.44M               <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Floppy</SPAN>
RAMDISK driver initialized: 16 RAM disks
of 4096K size 1024 blocksize                <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Ramdisk</SPAN>
loop: loaded (max 8 devices)                <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Loop back</SPAN>
ICH4: IDE controller at PCI slot
0000:00:1f.1                                <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Hard Disk</SPAN>
...
input: SynPS/2 Synaptics TouchPad as
/class/input/input1                         <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Touchpad</SPAN>
e1000: eth0: e1000_probe: Intel&#24208; PRO/1000
Network Connection                          <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>Ethernet</SPAN>
Yenta: CardBus bridge found at
0000:02:00.0 [1014:0560]                    <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF"> <SPAN class=docEmphStrong>PCMCIA/CardBus</SPAN>
...

					  </FONT></PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name="in separate"></A><FONT class=extract>This book discusses many of these driver subsystems in separate chapters. Note that some of these messages might manifest only later on in the boot process if the drivers are dynamically linked to the kernel as loadable modules.</FONT></P><A name=ch02lev2sec10></A>
<H4 id=title-ID0E55PM class=docSection2Title><FONT class=extract>EXT3-fs: Mounted Filesystem</FONT></H4>
<P class=docText><A name="filesystem has"></A><FONT class=extract>The EXT3 filesystem has become the de facto filesystem on Linux. It adds a journaling layer on top of the veteran EXT2 filesystem to facilitate quick recovery after a crash. The aim is to regain a consistent filesystem state without having to go through a time-consuming filesystem check (<TT>fsck</TT></FONT><A name="on a"></A><FONT class=extract>) operation. EXT2 remains the work engine, while the EXT3 layer additionally logs file transactions on a memory area called <SPAN class=docEmphasis>journal</SPAN></FONT><A name="before committing"></A><FONT class=extract> before committing the actual changes to disk. EXT3 is backward-compatible with EXT2, so you can add an EXT3 coating to your existing EXT2 filesystem or peel off the EXT3 to get back your original EXT2 filesystem.</FONT></P>
<P class=docText><FONT class=extract></FONT></P><A name=ch02sb02></A>
<P>
<TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
<TBODY>
<TR>
<TD>
<H2 class=docSidebarTitle><FONT class=extract>EXT4</FONT></H2>
<P class=docText><A name=iddle1322></A><A name=iddle2037></A><A name=iddle2061></A><A name=iddle2361></A><A name=iddle2546></A><A name=iddle2598></A><A name=iddle2626></A><A name=iddle2663></A><A name=iddle3650></A><A name="version in"></A><FONT class=extract>The latest version in the EXT filesystem series is EXT4, which has been included in the mainline kernel starting with the 2.6.19 release, with a tag of "experimental" and a name of ext4dev. EXT4 is largely backward-compatible with EXT3. The home page of the EXT4 project is at </FONT><A class=docLink href="http://www.bullopensource.org/ext4" target=_blank><FONT class=extract>www.bullopensource.org/ext4</FONT></A><FONT class=extract>.</FONT></P></TD></TR></TBODY></TABLE></P><BR>
<P class=docText><A name="a kernel"></A><FONT class=extract>EXT3 starts a kernel helper thread (we will have an in-depth discussion on kernel threads in the next chapter) called <SPAN class=docEmphasis>kjournald</SPAN></FONT><A name="root filesystem"></A><FONT class=extract> to assist in journaling. When EXT3 is operational, the kernel mounts the root filesystem and gets ready for business:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>EXT3-fs: mounted filesystem with ordered data mode
kjournald starting. Commit interval 5 seconds
VFS: Mounted root (ext3 filesystem).</FONT></PRE></DIV><BR><A name=ch02lev2sec11></A>
<H4 id=title-ID0EKDAO class=docSection2Title><FONT class=extract>INIT: Version 2.85 Booting</FONT></H4>
<P class=docText><SPAN class=docEmphasis><FONT class=extract>Init</FONT></SPAN><A name="is the"></A><FONT class=extract>, the parent of all Linux processes, is the first program to run after the kernel finishes its boot sequence. In the last few lines of <SPAN class=docEmphasis>init/main.c</SPAN></FONT><A name="locate init"></A><FONT class=extract>, the kernel searches different locations in its attempt to locate init:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>if (ramdisk_execute_command) { /* Look for <SPAN class=docEmphasis>/init</SPAN> in <SPAN class=docEmphasis>initramfs</SPAN> */
  run_init_process(ramdisk_execute_command);
}

if (execute_command) { /* You may override init and ask the kernel
                          to execute a custom program using the
                          "init=" kernel command-line argument. If
                          you do that, <SPAN class=docEmphasis>execute_command</SPAN> points to the
                          specified program */
  run_init_process(execute_command);
}

/* Else search for <SPAN class=docEmphasis>init</SPAN> or <SPAN class=docEmphasis>sh</SPAN> in the usual places .. */
run_init_process("/sbin/init");
run_init_process("/etc/init");
run_init_process("/bin/init");
run_init_process("/bin/sh");
panic("No init found. Try passing init= option to kernel.");</FONT></PRE></DIV><BR>
<P class=docText><A name=iddle2000></A><A name=iddle2001></A><A name=iddle2364></A><A name=iddle3390></A><A name=iddle3718></A><A name=iddle4181></A><FONT class=extract>Init receives directions from <SPAN class=docEmphasis>/etc/inittab</SPAN></FONT><A name="present in"></A><FONT class=extract>. It first executes system initialization scripts present in <SPAN class=docEmphasis>/etc/rc.sysinit.</SPAN></FONT><A name="is to"></A><FONT class=extract> One of the important responsibilities of this script is to activate the swap partition, which triggers a boot message such as this:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>Adding 1552384k swap on /dev/hda6</FONT></PRE></DIV><BR>
<P class=docText><A name="a closer"></A><FONT class=extract>Let's take a closer look at what this means. Linux user processes own a virtual address space of 3GB (see the section "</FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02lev1sec7.html#ch02lev1sec7"><FONT class=extract>Allocating Memory</FONT></A><A name="there are"></A><FONT class=extract>"). Out of this, the pages constituting the "working set" are kept in RAM. However, when there are too many programs demanding memory resources, the kernel frees up some used RAM pages by storing them in a disk partition called <SPAN class=docEmphasis><A name="swap space"></A>swap space.</SPAN></FONT><A name="a rule"></A><FONT class=extract> According to a rule of thumb, the size of the swap partition should be twice the amount of RAM. In this case, the swap space lives in the disk partition <SPAN class=docEmphasis>/dev/hda6</SPAN></FONT><A name="has a"></A><FONT class=extract> and has a size of 1552384K bytes.</FONT></P>
<P class=docText><A name=the></A><FONT class=extract>Init then goes on to run scripts present in the <SPAN class=docEmphasis>/etc/rc.d/rcX.d/</SPAN> directory, where <SPAN class=docEmphasis>X</SPAN></FONT><A name="A runlevel"></A><FONT class=extract> is the runlevel specified in inittab. A runlevel is an execution state corresponding to the desired boot mode. For example, multiuser text mode corresponds to a runlevel of 3, while X Windows associates with a runlevel of 5. So, if you see the message, <TT>INIT: Entering runlevel 3</TT>, init has started executing scripts in the <SPAN class=docEmphasis>/etc/rc.d/rc3.d/</SPAN> directory. These scripts start the dynamic device-naming subsystem udev (which we discuss </FONT><A name=iddle2421></A><A name=iddle2535></A><A name=iddle2576></A><A name=iddle2579></A><A name=iddle2585></A><A name=iddle2618></A><A name=iddle3025></A><A name=iddle3028></A><A name=iddle3649></A><A name=iddle4533></A><A name=iddle4560></A><FONT class=extract>in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04.html#ch04"><FONT class=extract>Chapter 4</FONT></A><A name="so on"></A><FONT class=extract>, "Laying the Groundwork") and load kernel modules responsible for driving networking, audio, storage, and so on:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>Starting udev: [ OK ]
Initializing hardware... network audio storage [Done]
...</FONT></PRE></DIV><BR>
<P class=docText><A name="You can"></A><FONT class=extract>Init finally spawns terminals on virtual consoles. You can now log in.</FONT>