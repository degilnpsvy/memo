There are still a few rare situations where volatile makes sense in the<BR>kernel:</P>
<P>&nbsp; - The above-mentioned accessor functions might use volatile on<BR>&nbsp;&nbsp;&nbsp; architectures where direct I/O memory access does work.&nbsp; Essentially,<BR>&nbsp;&nbsp;&nbsp; each accessor call becomes a little critical section on its own and<BR>&nbsp;&nbsp;&nbsp; ensures that the access happens as expected by the programmer.</P>
<P>&nbsp; - Inline assembly code which changes memory, but which has no other<BR>&nbsp;&nbsp;&nbsp; visible side effects, risks being deleted by GCC.&nbsp; Adding the volatile<BR>&nbsp;&nbsp;&nbsp; keyword to asm statements will prevent this removal.</P>
<P>&nbsp; - The jiffies variable is special in that it can have a different value<BR>&nbsp;&nbsp;&nbsp; every time it is referenced, but it can be read without any special<BR>&nbsp;&nbsp;&nbsp; locking.&nbsp; So jiffies can be volatile, but the addition of other<BR>&nbsp;&nbsp;&nbsp; variables of this type is strongly frowned upon.&nbsp; Jiffies is considered<BR>&nbsp;&nbsp;&nbsp; to be a "stupid legacy" issue (Linus's words) in this regard; fixing it<BR>&nbsp;&nbsp;&nbsp; would be more trouble than it is worth.</P>
<P>&nbsp; - Pointers to data structures in coherent memory which might be modified<BR>&nbsp;&nbsp;&nbsp; by I/O devices can, sometimes, legitimately be volatile.&nbsp; A ring buffer<BR>&nbsp;&nbsp;&nbsp; used by a network adapter, where that adapter changes pointers to<BR>&nbsp;&nbsp;&nbsp; indicate which descriptors have been processed, is an example of this<BR>&nbsp;&nbsp;&nbsp; type of situation.</P>
<P>For most code, none of the above justifications for volatile apply.&nbsp; As a<BR>result, the use of volatile is likely to be seen as a bug and will bring<BR>additional scrutiny to the code.&nbsp; Developers who are tempted to use<BR>volatile should take a step back and think about what they are truly trying<BR>to accomplish.