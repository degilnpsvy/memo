Like volatile, the kernel primitives which make concurrent access to data<BR>safe (spinlocks, mutexes, memory barriers, etc.) are designed to prevent<BR>unwanted optimization.&nbsp; If they are being used properly, there will be no<BR>need to use volatile as well.&nbsp; If volatile is still necessary, there is<BR><SPAN class=cloze>[...]</SPAN>.&nbsp; In properly-written kernel<BR>code, volatile can only serve to slow things down.