# linux-3.17/include/linux/compiler-gcc.h 
<P>&nbsp;</P>
<P>#ifndef __LINUX_COMPILER_H<BR>#error "Please don't include &lt;linux/compiler-gcc.h&gt; directly, include &lt;linux/compiler.h&gt; instead."<BR>#endif</P>
<P></P>
<P>/*<BR>&nbsp;* Common definitions for all gcc versions go here.<BR>&nbsp;*/<BR>#define GCC_VERSION (__GNUC__ * 10000&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + __GNUC_MINOR__ * 100&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + __GNUC_PATCHLEVEL__)</P>
<P>/* Optimization barrier */</P>
<P>/* The "volatile" is due to gcc bugs */<BR>#define barrier() __asm__ __volatile__("": : :"memory")<BR>/*<BR>&nbsp;* This version is i.e. to prevent dead stores elimination on @ptr<BR>&nbsp;* where gcc and llvm may behave differently when otherwise using<BR>&nbsp;* normal barrier(): while gcc behavior gets along with a normal<BR>&nbsp;* barrier(), llvm needs an explicit input variable to be assumed<BR>&nbsp;* clobbered. The issue is as follows: while the inline asm might<BR>&nbsp;* access any memory it wants, the compiler could have fit all of<BR>&nbsp;* @ptr into memory registers instead, and since @ptr never escaped<BR>&nbsp;* from that, it proofed that the inline asm wasn't touching any of<BR>&nbsp;* it. This version works well with both compilers, i.e. we're telling<BR>&nbsp;* the compiler that the inline asm absolutely may see the contents<BR>&nbsp;* of @ptr. See also: <A href="https://llvm.org/bugs/show_bug.cgi?id=15495">https://llvm.org/bugs/show_bug.cgi?id=15495</A><BR>&nbsp;*/<BR>#define barrier_data(ptr) __asm__ __volatile__("": :"r"(ptr) :"memory")</P>
<P>/*<BR>&nbsp;* This macro obfuscates arithmetic on a variable address so that gcc<BR>&nbsp;* shouldn't recognize the original var, and make assumptions about it.<BR>&nbsp;*<BR>&nbsp;* This is needed because the C standard makes it undefined to do<BR>&nbsp;* pointer arithmetic on "objects" outside their boundaries and the<BR>&nbsp;* gcc optimizers assume this is the case. In particular they<BR>&nbsp;* assume such arithmetic does not wrap.<BR>&nbsp;*<BR>&nbsp;* A miscompilation has been observed because of this on PPC.<BR>&nbsp;* To work around it we hide the relationship of the pointer and the object<BR>&nbsp;* using this macro.<BR>&nbsp;*<BR>&nbsp;* Versions of the ppc64 compiler before 4.1 had a bug where use of<BR>&nbsp;* RELOC_HIDE could trash r30. The bug can be worked around by changing<BR>&nbsp;* the inline assembly constraint from =g to =r, in this particular<BR>&nbsp;* case either is valid.<BR>&nbsp;*/<BR>#define RELOC_HIDE(ptr, off)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;unsigned long __ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__asm__ ("" : "=r"(__ptr) : "0"(ptr));&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(typeof(ptr)) (__ptr + (off));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>/* Make the optimizer believe the variable can be manipulated arbitrarily. */<BR>#define OPTIMIZER_HIDE_VAR(var)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__asm__ ("" : "=r" (var) : "0" (var))</P>
<P>#ifdef __CHECKER__<BR>#define __must_be_array(a)&nbsp;0<BR>#else<BR>/* &amp;a[0] degrades to a pointer: a different type from an array */<BR>#define __must_be_array(a)&nbsp;BUILD_BUG_ON_ZERO(__same_type((a), &amp;(a)[0]))<BR>#endif</P>
<P>/*<BR>&nbsp;* Force always-inline if the user requests it so via the .config,<BR>&nbsp;* or if gcc is too old:<BR>&nbsp;*/<BR>#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) ||&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp; !defined(CONFIG_OPTIMIZE_INLINING) || (__GNUC__ &lt; 4)<BR>#define inline&nbsp;&nbsp;inline&nbsp;&nbsp;__attribute__((always_inline)) notrace<BR>#define __inline__&nbsp;__inline__&nbsp;__attribute__((always_inline)) notrace<BR>#define __inline&nbsp;__inline&nbsp;__attribute__((always_inline)) notrace<BR>#else<BR>/* A lot of inline functions can cause havoc with function tracing */<BR>#define inline&nbsp;&nbsp;inline&nbsp;&nbsp;notrace<BR>#define __inline__&nbsp;__inline__&nbsp;notrace<BR>#define __inline&nbsp;__inline&nbsp;notrace<BR>#endif</P>
<P>#define __always_inline&nbsp;inline __attribute__((always_inline))<BR>#define&nbsp; noinline&nbsp;__attribute__((noinline))</P>
<P>#define __deprecated&nbsp;__attribute__((deprecated))<BR>#define __packed&nbsp;__attribute__((packed))<BR>#define __weak&nbsp;&nbsp;__attribute__((weak))<BR>#define __alias(symbol)&nbsp;__attribute__((alias(#symbol)))</P>
<P>/*<BR>&nbsp;* it doesn't make sense on ARM (currently the only user of __naked)<BR>&nbsp;* to trace naked functions because then mcount is called without<BR>&nbsp;* stack and frame pointer being set up and there is no chance to<BR>&nbsp;* restore the lr register to the value before mcount was called.<BR>&nbsp;*<BR>&nbsp;* The asm() bodies of naked functions often depend on standard calling<BR>&nbsp;* conventions, therefore they must be noinline and noclone.<BR>&nbsp;*<BR>&nbsp;* GCC 4.[56] currently fail to enforce this, so we must do so ourselves.<BR>&nbsp;* See GCC PR44290.<BR>&nbsp;*/<BR>#define __naked&nbsp;&nbsp;__attribute__((naked)) noinline __noclone notrace</P>
<P>#define __noreturn&nbsp;__attribute__((noreturn))</P>
<P>/*<BR>&nbsp;* From the GCC manual:<BR>&nbsp;*<BR>&nbsp;* Many functions have no effects except the return value and their<BR>&nbsp;* return value depends only on the parameters and/or global<BR>&nbsp;* variables.&nbsp; Such a function can be subject to common subexpression<BR>&nbsp;* elimination and loop optimization just as an arithmetic operator<BR>&nbsp;* would be.<BR>&nbsp;* [...]<BR>&nbsp;*/<BR>#define __pure&nbsp;&nbsp;&nbsp;__attribute__((pure))<BR>#define __aligned(x)&nbsp;&nbsp;__attribute__((aligned(x)))<BR>#define __printf(a, b)&nbsp;&nbsp;__attribute__((format(printf, a, b)))<BR>#define __scanf(a, b)&nbsp;&nbsp;__attribute__((format(scanf, a, b)))<BR>#define __attribute_const__&nbsp;__attribute__((__const__))<BR>#define __maybe_unused&nbsp;&nbsp;__attribute__((unused))<BR>#define __always_unused&nbsp;&nbsp;__attribute__((unused))</P>
<P>/* gcc version specific checks */</P>
<P>#if GCC_VERSION &lt; 30200<BR># error Sorry, your compiler is too old - please upgrade it.<BR>#endif</P>
<P>#if GCC_VERSION &lt; 30300<BR># define __used&nbsp;&nbsp;&nbsp;__attribute__((__unused__))<BR>#else<BR># define __used&nbsp;&nbsp;&nbsp;__attribute__((__used__))<BR>#endif</P>
<P>#ifdef CONFIG_GCOV_KERNEL<BR># if GCC_VERSION &lt; 30400<BR>#&nbsp;&nbsp; error "GCOV profiling support for gcc versions below 3.4 not included"<BR># endif /* __GNUC_MINOR__ */<BR>#endif /* CONFIG_GCOV_KERNEL */</P>
<P>#if GCC_VERSION &gt;= 30400<BR>#define __must_check&nbsp;&nbsp;__attribute__((warn_unused_result))<BR>#endif</P>
<P>#if GCC_VERSION &gt;= 40000</P>
<P>/* GCC 4.1.[01] miscompiles __weak */<BR>#ifdef __KERNEL__<BR># if GCC_VERSION &gt;= 40100 &amp;&amp;&nbsp; GCC_VERSION &lt;= 40101<BR>#&nbsp; error Your version of gcc miscompiles the __weak directive<BR># endif<BR>#endif</P>
<P>#define __used&nbsp;&nbsp;&nbsp;__attribute__((__used__))<BR>#define __compiler_offsetof(a, b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__builtin_offsetof(a, b)</P>
<P>#if GCC_VERSION &gt;= 40100 &amp;&amp; GCC_VERSION &lt; 40600<BR># define __compiletime_object_size(obj) __builtin_object_size(obj, 0)<BR>#endif</P>
<P>#if GCC_VERSION &gt;= 40300<BR>/* Mark functions as cold. gcc will assume any path leading to a call<BR>&nbsp;* to them will be unlikely.&nbsp; This means a lot of manual unlikely()s<BR>&nbsp;* are unnecessary now for any paths leading to the usual suspects<BR>&nbsp;* like BUG(), printk(), panic() etc. [but let's keep them for now for<BR>&nbsp;* older compilers]<BR>&nbsp;*<BR>&nbsp;* Early snapshots of gcc 4.3 don't support this and we can't detect this<BR>&nbsp;* in the preprocessor, but we can live with this because they're unreleased.<BR>&nbsp;* Maketime probing would be overkill here.<BR>&nbsp;*<BR>&nbsp;* gcc also has a __attribute__((__hot__)) to move hot functions into<BR>&nbsp;* a special section, but I don't see any sense in this right now in<BR>&nbsp;* the kernel context<BR>&nbsp;*/<BR>#define __cold&nbsp;&nbsp;&nbsp;__attribute__((__cold__))</P>
<P>#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)</P>
<P>#ifndef __CHECKER__<BR># define __compiletime_warning(message) __attribute__((warning(message)))<BR># define __compiletime_error(message) __attribute__((error(message)))<BR>#endif /* __CHECKER__ */<BR>#endif /* GCC_VERSION &gt;= 40300 */</P>
<P>#if GCC_VERSION &gt;= 40500<BR>/*<BR>&nbsp;* Mark a position in code as unreachable.&nbsp; This can be used to<BR>&nbsp;* suppress control flow warnings after asm blocks that transfer<BR>&nbsp;* control elsewhere.<BR>&nbsp;*<BR>&nbsp;* Early snapshots of gcc 4.5 don't support this and we can't detect<BR>&nbsp;* this in the preprocessor, but we can live with this because they're<BR>&nbsp;* unreleased.&nbsp; Really, we need to have autoconf for the kernel.<BR>&nbsp;*/<BR>#define unreachable() __builtin_unreachable()</P>
<P>/* Mark a function definition as prohibited from being cloned. */<BR>#define __noclone&nbsp;__attribute__((__noclone__))</P>
<P>#endif /* GCC_VERSION &gt;= 40500 */</P>
<P>#if GCC_VERSION &gt;= 40600<BR>/*<BR>&nbsp;* Tell the optimizer that something else uses this function or variable.<BR>&nbsp;*/<BR>#define __visible&nbsp;__attribute__((externally_visible))<BR>#endif</P>
<P>/*<BR>&nbsp;* GCC 'asm goto' miscompiles certain code sequences:<BR>&nbsp;*<BR>&nbsp;*&nbsp;&nbsp; <A href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670</A><BR>&nbsp;*<BR>&nbsp;* Work it around via a compiler barrier quirk suggested by Jakub Jelinek.<BR>&nbsp;*<BR>&nbsp;* (asm goto is automatically volatile - the naming reflects this.)<BR>&nbsp;*/<BR>#define asm_volatile_goto(x...)&nbsp;do { asm goto(x); asm (""); } while (0)</P>
<P>#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP<BR>#if GCC_VERSION &gt;= 40400<BR>#define __HAVE_BUILTIN_BSWAP32__<BR>#define __HAVE_BUILTIN_BSWAP64__<BR>#endif<BR>#if GCC_VERSION &gt;= 40800 || (defined(__powerpc__) &amp;&amp; GCC_VERSION &gt;= 40600)<BR>#define __HAVE_BUILTIN_BSWAP16__<BR>#endif<BR>#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */</P>
<P>#if GCC_VERSION &gt;= 50000<BR>#define KASAN_ABI_VERSION 4<BR>#elif GCC_VERSION &gt;= 40902<BR>#define KASAN_ABI_VERSION 3<BR>#endif</P>
<P>#endif&nbsp;/* gcc version &gt;= 40000 specific checks */</P>
<P>#if !defined(__noclone)<BR>#define __noclone&nbsp;/* not needed */<BR>#endif</P>
<P>/*<BR>&nbsp;* A trick to suppress uninitialized variable warning without generating any<BR>&nbsp;* code<BR>&nbsp;*/<BR>#define uninitialized_var(x) x = x