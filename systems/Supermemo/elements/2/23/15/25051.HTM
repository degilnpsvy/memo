kernel/notifier.c 
<P></P>
<P>&nbsp;</P>
<P>#include &lt;linux/kdebug.h&gt;<BR>#include &lt;linux/kprobes.h&gt;<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/notifier.h&gt;<BR>#include &lt;linux/rcupdate.h&gt;<BR>#include &lt;linux/vmalloc.h&gt;<BR>#include &lt;linux/reboot.h&gt;</P>
<P></P>
<P><FONT class=extract>/*<BR>&nbsp;*&nbsp;Notifier list for kernel code which wants to be called<BR>&nbsp;*&nbsp;at shutdown. This is used to stop any idling DMA operations<BR>&nbsp;*&nbsp;and the like.<BR>&nbsp;*/<BR>BLOCKING_NOTIFIER_HEAD(reboot_notifier_list);</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;*&nbsp;Notifier chain core routines.&nbsp; The exported routines below<BR>&nbsp;*&nbsp;are layered on top of these, with appropriate locking added.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>static int notifier_chain_register(struct notifier_block **nl,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;while ((*nl) != NULL) {<BR>&nbsp;&nbsp;if (n-&gt;priority &gt; (*nl)-&gt;priority)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;nl = &amp;((*nl)-&gt;next);<BR>&nbsp;}<BR>&nbsp;n-&gt;next = *nl;<BR>&nbsp;rcu_assign_pointer(*nl, n);<BR>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>static int notifier_chain_cond_register(struct notifier_block **nl,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;while ((*nl) != NULL) {<BR>&nbsp;&nbsp;if ((*nl) == n)<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;if (n-&gt;priority &gt; (*nl)-&gt;priority)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;nl = &amp;((*nl)-&gt;next);<BR>&nbsp;}<BR>&nbsp;n-&gt;next = *nl;<BR>&nbsp;rcu_assign_pointer(*nl, n);<BR>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>static int notifier_chain_unregister(struct notifier_block **nl,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;while ((*nl) != NULL) {<BR>&nbsp;&nbsp;if ((*nl) == n) {<BR>&nbsp;&nbsp;&nbsp;rcu_assign_pointer(*nl, n-&gt;next);<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;nl = &amp;((*nl)-&gt;next);<BR>&nbsp;}<BR>&nbsp;return -ENOENT;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* notifier_call_chain - Informs the registered notifiers about an event.<BR>&nbsp;*&nbsp;@nl:&nbsp;&nbsp;Pointer to head of the blocking notifier chain<BR>&nbsp;*&nbsp;@val:&nbsp;&nbsp;Value passed unmodified to notifier function<BR>&nbsp;*&nbsp;@v:&nbsp;&nbsp;Pointer passed unmodified to notifier function<BR>&nbsp;*&nbsp;@nr_to_call:&nbsp;Number of notifier functions to be called. Don't care<BR>&nbsp;*&nbsp;&nbsp;&nbsp;value of this parameter is -1.<BR>&nbsp;*&nbsp;@nr_calls:&nbsp;Records the number of notifications sent. Don't care<BR>&nbsp;*&nbsp;&nbsp;&nbsp;value of this field is NULL.<BR>&nbsp;*&nbsp;@returns:&nbsp;notifier_call_chain returns the value returned by the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;last notifier function called.<BR>&nbsp;*/<BR>static int notifier_call_chain(struct notifier_block **nl,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_to_call, int *nr_calls)<BR>{<BR>&nbsp;int ret = NOTIFY_DONE;<BR>&nbsp;struct notifier_block *nb, *next_nb;</FONT></P>
<P><FONT class=extract>&nbsp;nb = rcu_dereference_raw(*nl);</FONT></P>
<P><FONT class=extract>&nbsp;while (nb &amp;&amp; nr_to_call) {<BR>&nbsp;&nbsp;next_nb = rcu_dereference_raw(nb-&gt;next);</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_DEBUG_NOTIFIERS<BR>&nbsp;&nbsp;if (unlikely(!func_ptr_is_kernel_text(nb-&gt;notifier_call))) {<BR>&nbsp;&nbsp;&nbsp;WARN(1, "Invalid notifier called!");<BR>&nbsp;&nbsp;&nbsp;nb = next_nb;<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;}<BR>#endif<BR>&nbsp;&nbsp;ret = nb-&gt;notifier_call(nb, val, v);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (nr_calls)<BR>&nbsp;&nbsp;&nbsp;(*nr_calls)++;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if ((ret &amp; NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;nb = next_nb;<BR>&nbsp;&nbsp;nr_to_call--;<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}<BR>NOKPROBE_SYMBOL(notifier_call_chain);</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;*&nbsp;Atomic notifier chain routines.&nbsp; Registration and unregistration<BR>&nbsp;*&nbsp;use a spinlock, and call_chain is synchronized by RCU (no locks).<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;atomic_notifier_chain_register - Add notifier to an atomic notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the atomic notifier chain<BR>&nbsp;*&nbsp;@n: New entry in notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Adds a notifier to an atomic notifier chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Currently always returns zero.<BR>&nbsp;*/<BR>int atomic_notifier_chain_register(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock_irqsave(&amp;nh-&gt;lock, flags);<BR>&nbsp;ret = notifier_chain_register(&amp;nh-&gt;head, n);<BR>&nbsp;spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(atomic_notifier_chain_register);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;atomic_notifier_chain_unregister - Remove notifier from an atomic notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the atomic notifier chain<BR>&nbsp;*&nbsp;@n: Entry to remove from notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Removes a notifier from an atomic notifier chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Returns zero on success or %-ENOENT on failure.<BR>&nbsp;*/<BR>int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock_irqsave(&amp;nh-&gt;lock, flags);<BR>&nbsp;ret = notifier_chain_unregister(&amp;nh-&gt;head, n);<BR>&nbsp;spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);<BR>&nbsp;synchronize_rcu();<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(atomic_notifier_chain_unregister);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;__atomic_notifier_call_chain - Call functions in an atomic notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the atomic notifier chain<BR>&nbsp;*&nbsp;@val: Value passed unmodified to notifier function<BR>&nbsp;*&nbsp;@v: Pointer passed unmodified to notifier function<BR>&nbsp;*&nbsp;@nr_to_call: See the comment for notifier_call_chain.<BR>&nbsp;*&nbsp;@nr_calls: See the comment for notifier_call_chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Calls each function in a notifier chain in turn.&nbsp; The functions<BR>&nbsp;*&nbsp;run in an atomic context, so they must not block.<BR>&nbsp;*&nbsp;This routine uses RCU to synchronize with changes to the chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If the return value of the notifier can be and'ed<BR>&nbsp;*&nbsp;with %NOTIFY_STOP_MASK then atomic_notifier_call_chain()<BR>&nbsp;*&nbsp;will return immediately, with the return value of<BR>&nbsp;*&nbsp;the notifier function which halted execution.<BR>&nbsp;*&nbsp;Otherwise the return value is the return value<BR>&nbsp;*&nbsp;of the last notifier function called.<BR>&nbsp;*/<BR>int __atomic_notifier_call_chain(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int nr_to_call, int *nr_calls)<BR>{<BR>&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;rcu_read_lock();<BR>&nbsp;ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call, nr_calls);<BR>&nbsp;rcu_read_unlock();<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(__atomic_notifier_call_chain);<BR>NOKPROBE_SYMBOL(__atomic_notifier_call_chain);</FONT></P>
<P><FONT class=extract>int atomic_notifier_call_chain(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v)<BR>{<BR>&nbsp;return __atomic_notifier_call_chain(nh, val, v, -1, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(atomic_notifier_call_chain);<BR>NOKPROBE_SYMBOL(atomic_notifier_call_chain);</FONT></P>
<P>/*<BR>&nbsp;*&nbsp;Blocking notifier chain routines.&nbsp; All access to the chain is<BR>&nbsp;*&nbsp;synchronized by an rwsem.<BR>&nbsp;*/</P>
<P>/**<BR>&nbsp;*&nbsp;blocking_notifier_chain_register - Add notifier to a blocking notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the blocking notifier chain<BR>&nbsp;*&nbsp;@n: New entry in notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Adds a notifier to a blocking notifier chain.<BR>&nbsp;*&nbsp;Must be called in process context.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Currently always returns zero.<BR>&nbsp;*/<BR>int blocking_notifier_chain_register(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;/*<BR>&nbsp; * This code gets used during boot-up, when task switching is<BR>&nbsp; * not yet working and interrupts must remain disabled.&nbsp; At<BR>&nbsp; * such times we must not call down_write().<BR>&nbsp; */<BR>&nbsp;if (unlikely(system_state == SYSTEM_BOOTING))<BR>&nbsp;&nbsp;return notifier_chain_register(&amp;nh-&gt;head, n);</P>
<P>&nbsp;down_write(&amp;nh-&gt;rwsem);<BR>&nbsp;ret = notifier_chain_register(&amp;nh-&gt;head, n);<BR>&nbsp;up_write(&amp;nh-&gt;rwsem);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(blocking_notifier_chain_register);</P>
<P>/**<BR>&nbsp;*&nbsp;blocking_notifier_chain_cond_register - Cond add notifier to a blocking notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the blocking notifier chain<BR>&nbsp;*&nbsp;@n: New entry in notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Adds a notifier to a blocking notifier chain, only if not already<BR>&nbsp;*&nbsp;present in the chain.<BR>&nbsp;*&nbsp;Must be called in process context.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Currently always returns zero.<BR>&nbsp;*/<BR>int blocking_notifier_chain_cond_register(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;down_write(&amp;nh-&gt;rwsem);<BR>&nbsp;ret = notifier_chain_cond_register(&amp;nh-&gt;head, n);<BR>&nbsp;up_write(&amp;nh-&gt;rwsem);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(blocking_notifier_chain_cond_register);</P>
<P>/**<BR>&nbsp;*&nbsp;blocking_notifier_chain_unregister - Remove notifier from a blocking notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the blocking notifier chain<BR>&nbsp;*&nbsp;@n: Entry to remove from notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Removes a notifier from a blocking notifier chain.<BR>&nbsp;*&nbsp;Must be called from process context.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Returns zero on success or %-ENOENT on failure.<BR>&nbsp;*/<BR>int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;/*<BR>&nbsp; * This code gets used during boot-up, when task switching is<BR>&nbsp; * not yet working and interrupts must remain disabled.&nbsp; At<BR>&nbsp; * such times we must not call down_write().<BR>&nbsp; */<BR>&nbsp;if (unlikely(system_state == SYSTEM_BOOTING))<BR>&nbsp;&nbsp;return notifier_chain_unregister(&amp;nh-&gt;head, n);</P>
<P>&nbsp;down_write(&amp;nh-&gt;rwsem);<BR>&nbsp;ret = notifier_chain_unregister(&amp;nh-&gt;head, n);<BR>&nbsp;up_write(&amp;nh-&gt;rwsem);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(blocking_notifier_chain_unregister);</P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;__blocking_notifier_call_chain - Call functions in a blocking notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the blocking notifier chain<BR>&nbsp;*&nbsp;@val: Value passed unmodified to notifier function<BR>&nbsp;*&nbsp;@v: Pointer passed unmodified to notifier function<BR>&nbsp;*&nbsp;@nr_to_call: See comment for notifier_call_chain.<BR>&nbsp;*&nbsp;@nr_calls: See comment for notifier_call_chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Calls each function in a notifier chain in turn.&nbsp; The functions<BR>&nbsp;*&nbsp;run in a process context, so they are allowed to block.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If the return value of the notifier can be and'ed<BR>&nbsp;*&nbsp;with %NOTIFY_STOP_MASK then blocking_notifier_call_chain()<BR>&nbsp;*&nbsp;will return immediately, with the return value of<BR>&nbsp;*&nbsp;the notifier function which halted execution.<BR>&nbsp;*&nbsp;Otherwise the return value is the return value<BR>&nbsp;*&nbsp;of the last notifier function called.<BR>&nbsp;*/<BR>int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_to_call, int *nr_calls)<BR>{<BR>&nbsp;int ret = NOTIFY_DONE;</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * We check the head outside the lock, but if this access is<BR>&nbsp; * racy then it does not matter what the result of the test<BR>&nbsp; * is, we re-check the list after having taken the lock anyway:<BR>&nbsp; */<BR>&nbsp;if (rcu_access_pointer(nh-&gt;head)) {<BR>&nbsp;&nbsp;down_read(&amp;nh-&gt;rwsem);<BR>&nbsp;&nbsp;ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_calls);<BR>&nbsp;&nbsp;up_read(&amp;nh-&gt;rwsem);<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(__blocking_notifier_call_chain);</FONT></P>
<P>int blocking_notifier_call_chain(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;unsigned long val, void *v)<BR>{<BR>&nbsp;return __blocking_notifier_call_chain(nh, val, v, -1, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(blocking_notifier_call_chain);</P>
<P>/*<BR>&nbsp;*&nbsp;Raw notifier chain routines.&nbsp; There is no protection;<BR>&nbsp;*&nbsp;the caller must provide it.&nbsp; Use at your own risk!<BR>&nbsp;*/</P>
<P>/**<BR>&nbsp;*&nbsp;raw_notifier_chain_register - Add notifier to a raw notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the raw notifier chain<BR>&nbsp;*&nbsp;@n: New entry in notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Adds a notifier to a raw notifier chain.<BR>&nbsp;*&nbsp;All locking must be provided by the caller.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Currently always returns zero.<BR>&nbsp;*/<BR>int raw_notifier_chain_register(struct raw_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;return notifier_chain_register(&amp;nh-&gt;head, n);<BR>}<BR>EXPORT_SYMBOL_GPL(raw_notifier_chain_register);</P>
<P>/**<BR>&nbsp;*&nbsp;raw_notifier_chain_unregister - Remove notifier from a raw notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the raw notifier chain<BR>&nbsp;*&nbsp;@n: Entry to remove from notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Removes a notifier from a raw notifier chain.<BR>&nbsp;*&nbsp;All locking must be provided by the caller.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Returns zero on success or %-ENOENT on failure.<BR>&nbsp;*/<BR>int raw_notifier_chain_unregister(struct raw_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;return notifier_chain_unregister(&amp;nh-&gt;head, n);<BR>}<BR>EXPORT_SYMBOL_GPL(raw_notifier_chain_unregister);</P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;__raw_notifier_call_chain - Call functions in a raw notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the raw notifier chain<BR>&nbsp;*&nbsp;@val: Value passed unmodified to notifier function<BR>&nbsp;*&nbsp;@v: Pointer passed unmodified to notifier function<BR>&nbsp;*&nbsp;@nr_to_call: See comment for notifier_call_chain.<BR>&nbsp;*&nbsp;@nr_calls: See comment for notifier_call_chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Calls each function in a notifier chain in turn.&nbsp; The functions<BR>&nbsp;*&nbsp;run in an undefined context.<BR>&nbsp;*&nbsp;All locking must be provided by the caller.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If the return value of the notifier can be and'ed<BR>&nbsp;*&nbsp;with %NOTIFY_STOP_MASK then raw_notifier_call_chain()<BR>&nbsp;*&nbsp;will return immediately, with the return value of<BR>&nbsp;*&nbsp;the notifier function which halted execution.<BR>&nbsp;*&nbsp;Otherwise the return value is the return value<BR>&nbsp;*&nbsp;of the last notifier function called.<BR>&nbsp;*/<BR>int __raw_notifier_call_chain(struct raw_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_to_call, int *nr_calls)<BR>{<BR>&nbsp;return notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call, nr_calls);<BR>}<BR>EXPORT_SYMBOL_GPL(__raw_notifier_call_chain);</FONT></P>
<P>int raw_notifier_call_chain(struct raw_notifier_head *nh,<BR>&nbsp;&nbsp;unsigned long val, void *v)<BR>{<BR>&nbsp;return __raw_notifier_call_chain(nh, val, v, -1, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(raw_notifier_call_chain);</P>
<P>#ifdef CONFIG_SRCU<BR>/*<BR>&nbsp;*&nbsp;SRCU notifier chain routines.&nbsp;&nbsp;&nbsp; Registration and unregistration<BR>&nbsp;*&nbsp;use a mutex, and call_chain is synchronized by SRCU (no locks).<BR>&nbsp;*/</P>
<P>/**<BR>&nbsp;*&nbsp;srcu_notifier_chain_register - Add notifier to an SRCU notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the SRCU notifier chain<BR>&nbsp;*&nbsp;@n: New entry in notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Adds a notifier to an SRCU notifier chain.<BR>&nbsp;*&nbsp;Must be called in process context.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Currently always returns zero.<BR>&nbsp;*/<BR>int srcu_notifier_chain_register(struct srcu_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;/*<BR>&nbsp; * This code gets used during boot-up, when task switching is<BR>&nbsp; * not yet working and interrupts must remain disabled.&nbsp; At<BR>&nbsp; * such times we must not call mutex_lock().<BR>&nbsp; */<BR>&nbsp;if (unlikely(system_state == SYSTEM_BOOTING))<BR>&nbsp;&nbsp;return notifier_chain_register(&amp;nh-&gt;head, n);</P>
<P>&nbsp;mutex_lock(&amp;nh-&gt;mutex);<BR>&nbsp;ret = notifier_chain_register(&amp;nh-&gt;head, n);<BR>&nbsp;mutex_unlock(&amp;nh-&gt;mutex);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(srcu_notifier_chain_register);</P>
<P>/**<BR>&nbsp;*&nbsp;srcu_notifier_chain_unregister - Remove notifier from an SRCU notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the SRCU notifier chain<BR>&nbsp;*&nbsp;@n: Entry to remove from notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Removes a notifier from an SRCU notifier chain.<BR>&nbsp;*&nbsp;Must be called from process context.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Returns zero on success or %-ENOENT on failure.<BR>&nbsp;*/<BR>int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *n)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;/*<BR>&nbsp; * This code gets used during boot-up, when task switching is<BR>&nbsp; * not yet working and interrupts must remain disabled.&nbsp; At<BR>&nbsp; * such times we must not call mutex_lock().<BR>&nbsp; */<BR>&nbsp;if (unlikely(system_state == SYSTEM_BOOTING))<BR>&nbsp;&nbsp;return notifier_chain_unregister(&amp;nh-&gt;head, n);</P>
<P>&nbsp;mutex_lock(&amp;nh-&gt;mutex);<BR>&nbsp;ret = notifier_chain_unregister(&amp;nh-&gt;head, n);<BR>&nbsp;mutex_unlock(&amp;nh-&gt;mutex);<BR>&nbsp;synchronize_srcu(&amp;nh-&gt;srcu);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(srcu_notifier_chain_unregister);</P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;__srcu_notifier_call_chain - Call functions in an SRCU notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the SRCU notifier chain<BR>&nbsp;*&nbsp;@val: Value passed unmodified to notifier function<BR>&nbsp;*&nbsp;@v: Pointer passed unmodified to notifier function<BR>&nbsp;*&nbsp;@nr_to_call: See comment for notifier_call_chain.<BR>&nbsp;*&nbsp;@nr_calls: See comment for notifier_call_chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Calls each function in a notifier chain in turn.&nbsp; The functions<BR>&nbsp;*&nbsp;run in a process context, so they are allowed to block.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If the return value of the notifier can be and'ed<BR>&nbsp;*&nbsp;with %NOTIFY_STOP_MASK then srcu_notifier_call_chain()<BR>&nbsp;*&nbsp;will return immediately, with the return value of<BR>&nbsp;*&nbsp;the notifier function which halted execution.<BR>&nbsp;*&nbsp;Otherwise the return value is the return value<BR>&nbsp;*&nbsp;of the last notifier function called.<BR>&nbsp;*/<BR>int __srcu_notifier_call_chain(struct srcu_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_to_call, int *nr_calls)<BR>{<BR>&nbsp;int ret;<BR>&nbsp;int idx;</FONT></P>
<P><FONT class=extract>&nbsp;idx = srcu_read_lock(&amp;nh-&gt;srcu);<BR>&nbsp;ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call, nr_calls);<BR>&nbsp;srcu_read_unlock(&amp;nh-&gt;srcu, idx);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(__srcu_notifier_call_chain);</FONT></P>
<P>int srcu_notifier_call_chain(struct srcu_notifier_head *nh,<BR>&nbsp;&nbsp;unsigned long val, void *v)<BR>{<BR>&nbsp;return __srcu_notifier_call_chain(nh, val, v, -1, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(srcu_notifier_call_chain);</P>
<P>/**<BR>&nbsp;*&nbsp;srcu_init_notifier_head - Initialize an SRCU notifier head<BR>&nbsp;*&nbsp;@nh: Pointer to head of the srcu notifier chain<BR>&nbsp;*<BR>&nbsp;*&nbsp;Unlike other sorts of notifier heads, SRCU notifier heads require<BR>&nbsp;*&nbsp;dynamic initialization.&nbsp; Be sure to call this routine before<BR>&nbsp;*&nbsp;calling any of the other SRCU notifier routines for this head.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If an SRCU notifier head is deallocated, it must first be cleaned<BR>&nbsp;*&nbsp;up by calling srcu_cleanup_notifier_head().&nbsp; Otherwise the head's<BR>&nbsp;*&nbsp;per-cpu data (used by the SRCU mechanism) will leak.<BR>&nbsp;*/<BR>void srcu_init_notifier_head(struct srcu_notifier_head *nh)<BR>{<BR>&nbsp;mutex_init(&amp;nh-&gt;mutex);<BR>&nbsp;if (init_srcu_struct(&amp;nh-&gt;srcu) &lt; 0)<BR>&nbsp;&nbsp;BUG();<BR>&nbsp;nh-&gt;head = NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(srcu_init_notifier_head);</P>
<P>#endif /* CONFIG_SRCU */</P>
<P>static ATOMIC_NOTIFIER_HEAD(die_chain);</P>
<P>int notrace notify_die(enum die_val val, const char *str,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct pt_regs *regs, long err, int trap, int sig)<BR>{<BR>&nbsp;struct die_args args = {<BR>&nbsp;&nbsp;.regs&nbsp;= regs,<BR>&nbsp;&nbsp;.str&nbsp;= str,<BR>&nbsp;&nbsp;.err&nbsp;= err,<BR>&nbsp;&nbsp;.trapnr&nbsp;= trap,<BR>&nbsp;&nbsp;.signr&nbsp;= sig,</P>
<P>&nbsp;};<BR>&nbsp;return atomic_notifier_call_chain(&amp;die_chain, val, &amp;args);<BR>}<BR>NOKPROBE_SYMBOL(notify_die);</P>
<P>int register_die_notifier(struct notifier_block *nb)<BR>{<BR>&nbsp;vmalloc_sync_all();<BR>&nbsp;return atomic_notifier_chain_register(&amp;die_chain, nb);<BR>}<BR>EXPORT_SYMBOL_GPL(register_die_notifier);</P>
<P>int unregister_die_notifier(struct notifier_block *nb)<BR>{<BR>&nbsp;return atomic_notifier_chain_unregister(&amp;die_chain, nb);<BR>}<BR>EXPORT_SYMBOL_GPL(unregister_die_notifier);