The last rule (rule 3) is the nastiest one to handle.&nbsp; Say, for<BR>instance, you have a list of items that are each kref-ed, and you wish<BR>to get the first one.&nbsp; You can't just pull the first item off the list<BR>and kref_get() it.&nbsp; That violates rule 3 because you are not already<BR>holding a valid pointer.&nbsp; You must add a mutex (or some other lock).<BR>For instance: 
<P><FONT class=clozed></FONT></P>
<P><FONT class=clozed>static DEFINE_MUTEX(mutex);<BR>static LIST_HEAD(q);<BR>struct my_data<BR>{<BR>&nbsp;struct kref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; refcount;<BR>&nbsp;struct list_head link;<BR>};</FONT></P>
<P><FONT class=clozed>static struct my_data *get_entry()<BR>{<BR>&nbsp;struct my_data *entry = NULL;<BR>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;if (!list_empty(&amp;q)) {<BR>&nbsp;&nbsp;entry = container_of(q.next, struct my_data, link);<BR>&nbsp;&nbsp;kref_get(&amp;entry-&gt;refcount);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;return entry;<BR>}</FONT></P>
<P><FONT class=clozed>static void release_entry(struct kref *ref)<BR>{<BR>&nbsp;struct my_data *entry = container_of(ref, struct my_data, refcount);</FONT></P>
<P><FONT class=clozed>&nbsp;list_del(&amp;entry-&gt;link);<BR>&nbsp;kfree(entry);<BR>}</FONT></P>
<P><FONT class=clozed>static void put_entry(struct my_data *entry)<BR>{<BR>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;kref_put(&amp;entry-&gt;refcount, release_entry);<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>}</FONT></P>
<P><FONT class=clozed>The kref_put() return value is useful if you do not want to hold the<BR>lock during the whole release operation.&nbsp; Say you didn't want to call<BR>kfree() with the lock held in the example above (since it is kind of<BR>pointless to do so).&nbsp; You could use kref_put() as follows:</FONT></P>
<P><FONT class=clozed>static void release_entry(struct kref *ref)<BR>{<BR>&nbsp;/* All work is done after the return from kref_put(). */<BR>}</FONT></P>
<P><FONT class=clozed>static void put_entry(struct my_data *entry)<BR>{<BR>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;if (kref_put(&amp;entry-&gt;refcount, release_entry)) {<BR>&nbsp;&nbsp;list_del(&amp;entry-&gt;link);<BR>&nbsp;&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;&nbsp;kfree(entry);<BR>&nbsp;} else<BR>&nbsp;&nbsp;mutex_unlock(&amp;mutex);<BR>}</FONT></P>
<P>This is really more useful if you have to call other routines as part<BR>of the free operations that could take a long time or might claim the<BR>same lock.&nbsp; Note that doing everything in the release routine is still<BR>preferred as it is a little neater.