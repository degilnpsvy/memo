Once you have an initialized kref, you must follow the following<BR>rules: 
<P></P>
<P>1) If you make a non-temporary copy of a pointer, especially if<BR>&nbsp;&nbsp; it can be passed to another thread of execution, you must<BR>&nbsp;&nbsp; increment the refcount with kref_get() before passing it off:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kref_get(&amp;data-&gt;refcount);<BR>&nbsp;&nbsp; If you already have a valid pointer to a kref-ed structure (the<BR>&nbsp;&nbsp; refcount cannot go to zero) you may do this without a lock.</P>
<P>2) When you are done with a pointer, you must call kref_put():<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kref_put(&amp;data-&gt;refcount, data_release);<BR>&nbsp;&nbsp; If this is the last reference to the pointer, the release<BR>&nbsp;&nbsp; routine will be called.&nbsp; If the code never tries to get<BR>&nbsp;&nbsp; a valid pointer to a kref-ed structure without already<BR>&nbsp;&nbsp; holding a valid pointer, it is safe to do this without<BR>&nbsp;&nbsp; a lock.</P>
<P>3) If the code attempts to gain a reference to a kref-ed structure<BR>&nbsp;&nbsp; without already holding a valid pointer, it must<FONT class=clozed> serialize access<BR>&nbsp;&nbsp; where a kref_put() cannot occur during the kref_get(), and the<BR>&nbsp;&nbsp; structure must remain valid during the kref_get(</FONT>).