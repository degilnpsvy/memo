/**<BR>&nbsp;* kobject_init - initialize a kobject structure<BR>&nbsp;* @kobj: pointer to the kobject to initialize<BR>&nbsp;* @ktype: pointer to the ktype for this kobject.<BR>&nbsp;*<BR>&nbsp;* This function will properly initialize a kobject such that it can then<BR>&nbsp;* be passed to the kobject_add() call.<BR>&nbsp;*<BR>&nbsp;* After this function is called, the kobject MUST be cleaned up by a call<BR>&nbsp;* to kobject_put(), not by a call to kfree directly to ensure that all of<BR>&nbsp;* the memory is cleaned up properly.<BR>&nbsp;*/<BR>void kobject_init(struct kobject *kobj, struct kobj_type *ktype)<BR>{<BR>&nbsp;char *err_str; 
<P></P>
<P>&nbsp;if (!kobj) {<BR>&nbsp;&nbsp;err_str = "invalid kobject pointer!";<BR>&nbsp;&nbsp;goto error;<BR>&nbsp;}<BR>&nbsp;if (!ktype) {<BR>&nbsp;&nbsp;err_str = "must have a ktype to be initialized properly!\n";<BR>&nbsp;&nbsp;goto error;<BR>&nbsp;}<BR>&nbsp;if (kobj-&gt;state_initialized) {<BR>&nbsp;&nbsp;/* do not error out as sometimes we can recover */<BR>&nbsp;&nbsp;printk(KERN_ERR "kobject (%p): tried to init an initialized "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "object, something is seriously wrong.\n", kobj);<BR>&nbsp;&nbsp;dump_stack();<BR>&nbsp;}</P>
<P><FONT class=clozed>&nbsp;kobject_init_internal(kobj);<BR>&nbsp;kobj-&gt;ktype = ktype;</FONT><BR>&nbsp;return;</P>
<P>error:<BR>&nbsp;printk(KERN_ERR "kobject (%p): %s\n", kobj, err_str);<BR>&nbsp;dump_stack();<BR>}<BR>EXPORT_SYMBOL(kobject_init);