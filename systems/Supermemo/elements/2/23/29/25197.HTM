lib/kobject_uevent.c 
<P></P>
<P>&nbsp;</P>
<P>/*<BR>&nbsp;* kernel userspace event delivery<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2004 Red Hat, Inc.&nbsp; All rights reserved.<BR>&nbsp;* Copyright (C) 2004 Novell, Inc.&nbsp; All rights reserved.<BR>&nbsp;* Copyright (C) 2004 IBM, Inc. All rights reserved.<BR>&nbsp;*<BR>&nbsp;* Licensed under the GNU GPL v2.<BR>&nbsp;*<BR>&nbsp;* Authors:<BR>&nbsp;*&nbsp;Robert Love&nbsp;&nbsp;&lt;<A href="mailto:rml@novell.com">rml@novell.com</A>&gt;<BR>&nbsp;*&nbsp;Kay Sievers&nbsp;&nbsp;&lt;<A href="mailto:kay.sievers@vrfy.org">kay.sievers@vrfy.org</A>&gt;<BR>&nbsp;*&nbsp;Arjan van de Ven&nbsp;&lt;<A href="mailto:arjanv@redhat.com">arjanv@redhat.com</A>&gt;<BR>&nbsp;*&nbsp;Greg Kroah-Hartman&nbsp;&lt;<A href="mailto:greg@kroah.com">greg@kroah.com</A>&gt;<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/spinlock.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/kobject.h&gt;<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/kmod.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/socket.h&gt;<BR>#include &lt;linux/skbuff.h&gt;<BR>#include &lt;linux/netlink.h&gt;<BR>#include &lt;net/sock.h&gt;<BR>#include &lt;net/net_namespace.h&gt;</P>
<P><BR>u64 uevent_seqnum;<BR>#ifdef CONFIG_UEVENT_HELPER<BR>char uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;<BR>#endif<BR>#ifdef CONFIG_NET<BR>struct uevent_sock {<BR>&nbsp;struct list_head list;<BR>&nbsp;struct sock *sk;<BR>};<BR>static LIST_HEAD(uevent_sock_list);<BR>#endif</P>
<P>/* This lock protects uevent_seqnum and uevent_sock_list */<BR>static DEFINE_MUTEX(uevent_sock_mutex);</P>
<P><FONT class=extract>/* the strings here must match the enum in include/linux/kobject.h */<BR>static const char *kobject_actions[] = {<BR>&nbsp;[KOBJ_ADD] =&nbsp;&nbsp;"add",<BR>&nbsp;[KOBJ_REMOVE] =&nbsp;&nbsp;"remove",<BR>&nbsp;[KOBJ_CHANGE] =&nbsp;&nbsp;"change",<BR>&nbsp;[KOBJ_MOVE] =&nbsp;&nbsp;"move",<BR>&nbsp;[KOBJ_ONLINE] =&nbsp;&nbsp;"online",<BR>&nbsp;[KOBJ_OFFLINE] =&nbsp;"offline",<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_action_type - translate action string to numeric type<BR>&nbsp;*<BR>&nbsp;* @buf: buffer containing the action string, newline is ignored<BR>&nbsp;* @len: length of buffer<BR>&nbsp;* @type: pointer to the location to store the action type<BR>&nbsp;*<BR>&nbsp;* Returns 0 if the action string was recognized.<BR>&nbsp;*/<BR>int kobject_action_type(const char *buf, size_t count,<BR>&nbsp;&nbsp;&nbsp;enum kobject_action *type)<BR>{<BR>&nbsp;enum kobject_action action;<BR>&nbsp;int ret = -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;if (count &amp;&amp; (buf[count-1] == '\n' || buf[count-1] == '\0'))<BR>&nbsp;&nbsp;count--;</FONT></P>
<P><FONT class=extract>&nbsp;if (!count)<BR>&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;for (action = 0; action &lt; ARRAY_SIZE(kobject_actions); action++) {<BR>&nbsp;&nbsp;if (strncmp(kobject_actions[action], buf, count) != 0)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (kobject_actions[action][count] != '\0')<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;*type = action;<BR>&nbsp;&nbsp;ret = 0;<BR>&nbsp;&nbsp;break;<BR>&nbsp;}<BR>out:<BR>&nbsp;return ret;<BR>}</FONT></P>
<P>#ifdef CONFIG_NET<BR>static int kobj_bcast_filter(struct sock *dsk, struct sk_buff *skb, void *data)<BR>{<BR>&nbsp;struct kobject *kobj = data, *ksobj;<BR>&nbsp;const struct kobj_ns_type_operations *ops;</P>
<P>&nbsp;ops = kobj_ns_ops(kobj);<BR>&nbsp;if (!ops &amp;&amp; kobj-&gt;kset) {<BR>&nbsp;&nbsp;ksobj = &amp;kobj-&gt;kset-&gt;kobj;<BR>&nbsp;&nbsp;if (ksobj-&gt;parent != NULL)<BR>&nbsp;&nbsp;&nbsp;ops = kobj_ns_ops(ksobj-&gt;parent);<BR>&nbsp;}</P>
<P>&nbsp;if (ops &amp;&amp; ops-&gt;netlink_ns &amp;&amp; kobj-&gt;ktype-&gt;namespace) {<BR>&nbsp;&nbsp;const void *sock_ns, *ns;<BR>&nbsp;&nbsp;ns = kobj-&gt;ktype-&gt;namespace(kobj);<BR>&nbsp;&nbsp;sock_ns = ops-&gt;netlink_ns(dsk);<BR>&nbsp;&nbsp;return sock_ns != ns;<BR>&nbsp;}</P>
<P>&nbsp;return 0;<BR>}<BR>#endif</P>
<P><FONT class=extract>#ifdef CONFIG_UEVENT_HELPER<BR>static int kobj_usermode_filter(struct kobject *kobj)<BR>{<BR>&nbsp;const struct kobj_ns_type_operations *ops;</FONT></P>
<P><FONT class=extract>&nbsp;ops = kobj_ns_ops(kobj);<BR>&nbsp;if (ops) {<BR>&nbsp;&nbsp;const void *init_ns, *ns;<BR>&nbsp;&nbsp;ns = kobj-&gt;ktype-&gt;namespace(kobj);<BR>&nbsp;&nbsp;init_ns = ops-&gt;initial_ns();<BR>&nbsp;&nbsp;return ns != init_ns;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>static int init_uevent_argv(struct kobj_uevent_env *env, const char *subsystem)<BR>{<BR>&nbsp;int len;</FONT></P>
<P><FONT class=extract>&nbsp;len = strlcpy(&amp;env-&gt;buf[env-&gt;buflen], subsystem,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(env-&gt;buf) - env-&gt;buflen);<BR>&nbsp;if (len &gt;= (sizeof(env-&gt;buf) - env-&gt;buflen)) {<BR>&nbsp;&nbsp;WARN(1, KERN_ERR "init_uevent_argv: buffer size too small\n");<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;env-&gt;argv[0] = uevent_helper;<BR>&nbsp;env-&gt;argv[1] = &amp;env-&gt;buf[env-&gt;buflen];<BR>&nbsp;env-&gt;argv[2] = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;env-&gt;buflen += len + 1;<BR>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>static void cleanup_uevent_env(struct subprocess_info *info)<BR>{<BR>&nbsp;kfree(info-&gt;data);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_uevent_env - send an uevent with environmental data<BR>&nbsp;*<BR>&nbsp;* @action: action that is happening<BR>&nbsp;* @kobj: struct kobject that the action is happening to<BR>&nbsp;* @envp_ext: pointer to environmental data<BR>&nbsp;*<BR>&nbsp;* Returns 0 if kobject_uevent_env() is completed with success or the<BR>&nbsp;* corresponding error when it fails.<BR>&nbsp;*/<BR>int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *envp_ext[])<BR>{<BR>&nbsp;struct kobj_uevent_env *env;<BR>&nbsp;const char *action_string = kobject_actions[action];<BR>&nbsp;const char *devpath = NULL;<BR>&nbsp;const char *subsystem;<BR>&nbsp;struct kobject *top_kobj;<BR>&nbsp;struct kset *kset;<BR>&nbsp;const struct kset_uevent_ops *uevent_ops;<BR>&nbsp;int i = 0;<BR>&nbsp;int retval = 0;<BR>#ifdef CONFIG_NET<BR>&nbsp;struct uevent_sock *ue_sk;<BR>#endif</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("kobject: '%s' (%p): %s\n",<BR>&nbsp;&nbsp; kobject_name(kobj), kobj, __func__);</FONT></P>
<P><FONT class=extract>&nbsp;/* search the kset we belong to */<BR>&nbsp;top_kobj = kobj;<BR>&nbsp;while (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)<BR>&nbsp;&nbsp;top_kobj = top_kobj-&gt;parent;</FONT></P>
<P><FONT class=extract>&nbsp;if (!top_kobj-&gt;kset) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: attempted to send uevent "<BR>&nbsp;&nbsp;&nbsp; "without kset!\n", kobject_name(kobj), kobj,<BR>&nbsp;&nbsp;&nbsp; __func__);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;kset = top_kobj-&gt;kset;<BR>&nbsp;uevent_ops = kset-&gt;uevent_ops;</FONT></P>
<P><FONT class=extract>&nbsp;/* skip the event, if uevent_suppress is set*/<BR>&nbsp;if (kobj-&gt;uevent_suppress) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: uevent_suppress "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "caused the event to drop!\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj, __func__);<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}<BR>&nbsp;/* skip the event, if the filter returns zero. */<BR>&nbsp;if (uevent_ops &amp;&amp; uevent_ops-&gt;filter)<BR>&nbsp;&nbsp;if (!uevent_ops-&gt;filter(kset, kobj)) {<BR>&nbsp;&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: filter function "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "caused the event to drop!\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj, __func__);<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* originating subsystem */<BR>&nbsp;if (uevent_ops &amp;&amp; uevent_ops-&gt;name)<BR>&nbsp;&nbsp;subsystem = uevent_ops-&gt;name(kset, kobj);<BR>&nbsp;else<BR>&nbsp;&nbsp;subsystem = kobject_name(&amp;kset-&gt;kobj);<BR>&nbsp;if (!subsystem) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: unset subsystem caused the "<BR>&nbsp;&nbsp;&nbsp; "event to drop!\n", kobject_name(kobj), kobj,<BR>&nbsp;&nbsp;&nbsp; __func__);<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* environment buffer */<BR>&nbsp;env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);<BR>&nbsp;if (!env)<BR>&nbsp;&nbsp;return -ENOMEM;</FONT></P>
<P><FONT class=extract>&nbsp;/* complete object path */<BR>&nbsp;devpath = kobject_get_path(kobj, GFP_KERNEL);<BR>&nbsp;if (!devpath) {<BR>&nbsp;&nbsp;retval = -ENOENT;<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* default keys */<BR>&nbsp;retval = add_uevent_var(env, "ACTION=%s", action_string);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;retval = add_uevent_var(env, "DEVPATH=%s", devpath);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;retval = add_uevent_var(env, "SUBSYSTEM=%s", subsystem);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto exit;</FONT></P>
<P><FONT class=extract>&nbsp;/* keys passed in from the caller */<BR>&nbsp;if (envp_ext) {<BR>&nbsp;&nbsp;for (i = 0; envp_ext[i]; i++) {<BR>&nbsp;&nbsp;&nbsp;retval = add_uevent_var(env, "%s", envp_ext[i]);<BR>&nbsp;&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* let the kset specific function add its stuff */<BR>&nbsp;if (uevent_ops &amp;&amp; uevent_ops-&gt;uevent) {<BR>&nbsp;&nbsp;retval = uevent_ops-&gt;uevent(kset, kobj, env);<BR>&nbsp;&nbsp;if (retval) {<BR>&nbsp;&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: uevent() returned "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "%d\n", kobject_name(kobj), kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp; __func__, retval);<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * Mark "add" and "remove" events in the object to ensure proper<BR>&nbsp; * events to userspace during automatic cleanup. If the object did<BR>&nbsp; * send an "add" event, "remove" will automatically generated by<BR>&nbsp; * the core, if not already done by the caller.<BR>&nbsp; */<BR>&nbsp;if (action == KOBJ_ADD)<BR>&nbsp;&nbsp;kobj-&gt;state_add_uevent_sent = 1;<BR>&nbsp;else if (action == KOBJ_REMOVE)<BR>&nbsp;&nbsp;kobj-&gt;state_remove_uevent_sent = 1;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;uevent_sock_mutex);<BR>&nbsp;/* we will send an event, so request a new sequence number */<BR>&nbsp;retval = add_uevent_var(env, "SEQNUM=%llu", (unsigned long long)++uevent_seqnum);<BR>&nbsp;if (retval) {<BR>&nbsp;&nbsp;mutex_unlock(&amp;uevent_sock_mutex);<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>#if defined(CONFIG_NET)<BR>&nbsp;/* send netlink message */<BR>&nbsp;list_for_each_entry(ue_sk, &amp;uevent_sock_list, list) {<BR>&nbsp;&nbsp;struct sock *uevent_sock = ue_sk-&gt;sk;<BR>&nbsp;&nbsp;struct sk_buff *skb;<BR>&nbsp;&nbsp;size_t len;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (!netlink_has_listeners(uevent_sock, 1))<BR>&nbsp;&nbsp;&nbsp;continue;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;/* allocate message with the maximum possible size */<BR>&nbsp;&nbsp;len = strlen(action_string) + strlen(devpath) + 2;<BR>&nbsp;&nbsp;skb = alloc_skb(len + env-&gt;buflen, GFP_KERNEL);<BR>&nbsp;&nbsp;if (skb) {<BR>&nbsp;&nbsp;&nbsp;char *scratch;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;/* add header */<BR>&nbsp;&nbsp;&nbsp;scratch = skb_put(skb, len);<BR>&nbsp;&nbsp;&nbsp;sprintf(scratch, "</FONT><A href="mailto:%s@%s"><FONT class=extract>%s@%s</FONT></A><FONT class=extract>", action_string, devpath);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;/* copy keys to our continuous event payload buffer */<BR>&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; env-&gt;envp_idx; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;len = strlen(env-&gt;envp[i]) + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;scratch = skb_put(skb, len);<BR>&nbsp;&nbsp;&nbsp;&nbsp;strcpy(scratch, env-&gt;envp[i]);<BR>&nbsp;&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;NETLINK_CB(skb).dst_group = 1;<BR>&nbsp;&nbsp;&nbsp;retval = netlink_broadcast_filtered(uevent_sock, skb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, GFP_KERNEL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kobj_bcast_filter,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kobj);<BR>&nbsp;&nbsp;&nbsp;/* ENOBUFS should be handled in userspace */<BR>&nbsp;&nbsp;&nbsp;if (retval == -ENOBUFS || retval == -ESRCH)<BR>&nbsp;&nbsp;&nbsp;&nbsp;retval = 0;<BR>&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;}<BR>#endif<BR>&nbsp;mutex_unlock(&amp;uevent_sock_mutex);</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_UEVENT_HELPER<BR>&nbsp;/* call uevent_helper, usually only enabled during early boot */<BR>&nbsp;if (uevent_helper[0] &amp;&amp; !kobj_usermode_filter(kobj)) {<BR>&nbsp;&nbsp;struct subprocess_info *info;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;retval = add_uevent_var(env, "HOME=/");<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;retval = add_uevent_var(env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"PATH=/sbin:/bin:/usr/sbin:/usr/bin");<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;retval = init_uevent_argv(env, subsystem);<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;goto exit;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;&nbsp;info = call_usermodehelper_setup(env-&gt;argv[0], env-&gt;argv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;envp, GFP_KERNEL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, cleanup_uevent_env, env);<BR>&nbsp;&nbsp;if (info) {<BR>&nbsp;&nbsp;&nbsp;retval = call_usermodehelper_exec(info, UMH_NO_WAIT);<BR>&nbsp;&nbsp;&nbsp;env = NULL;&nbsp;/* freed by cleanup_uevent_env */<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>#endif</FONT></P>
<P><FONT class=extract>exit:<BR>&nbsp;kfree(devpath);<BR>&nbsp;kfree(env);<BR>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_uevent_env);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_uevent - notify userspace by sending an uevent<BR>&nbsp;*<BR>&nbsp;* @action: action that is happening<BR>&nbsp;* @kobj: struct kobject that the action is happening to<BR>&nbsp;*<BR>&nbsp;* Returns 0 if kobject_uevent() is completed with success or the<BR>&nbsp;* corresponding error when it fails.<BR>&nbsp;*/<BR>int kobject_uevent(struct kobject *kobj, enum kobject_action action)<BR>{<BR>&nbsp;return kobject_uevent_env(kobj, action, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_uevent);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* add_uevent_var - add key value string to the environment buffer<BR>&nbsp;* @env: environment buffer structure<BR>&nbsp;* @format: printf format for the key=value pair<BR>&nbsp;*<BR>&nbsp;* Returns 0 if environment variable was added successfully or -ENOMEM<BR>&nbsp;* if no space was available.<BR>&nbsp;*/<BR>int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int len;</FONT></P>
<P><FONT class=extract>&nbsp;if (env-&gt;envp_idx &gt;= ARRAY_SIZE(env-&gt;envp)) {<BR>&nbsp;&nbsp;WARN(1, KERN_ERR "add_uevent_var: too many keys\n");<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;va_start(args, format);<BR>&nbsp;len = vsnprintf(&amp;env-&gt;buf[env-&gt;buflen],<BR>&nbsp;&nbsp;&nbsp;sizeof(env-&gt;buf) - env-&gt;buflen,<BR>&nbsp;&nbsp;&nbsp;format, args);<BR>&nbsp;va_end(args);</FONT></P>
<P><FONT class=extract>&nbsp;if (len &gt;= (sizeof(env-&gt;buf) - env-&gt;buflen)) {<BR>&nbsp;&nbsp;WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;env-&gt;envp[env-&gt;envp_idx++] = &amp;env-&gt;buf[env-&gt;buflen];<BR>&nbsp;env-&gt;buflen += len + 1;<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(add_uevent_var);</FONT></P>
<P>#if defined(CONFIG_NET)<BR>static int uevent_net_init(struct net *net)<BR>{<BR>&nbsp;struct uevent_sock *ue_sk;<BR>&nbsp;struct netlink_kernel_cfg cfg = {<BR>&nbsp;&nbsp;.groups&nbsp;= 1,<BR>&nbsp;&nbsp;.flags&nbsp;= NL_CFG_F_NONROOT_RECV,<BR>&nbsp;};</P>
<P>&nbsp;ue_sk = kzalloc(sizeof(*ue_sk), GFP_KERNEL);<BR>&nbsp;if (!ue_sk)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;ue_sk-&gt;sk = netlink_kernel_create(net, NETLINK_KOBJECT_UEVENT, &amp;cfg);<BR>&nbsp;if (!ue_sk-&gt;sk) {<BR>&nbsp;&nbsp;printk(KERN_ERR<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "kobject_uevent: unable to create netlink socket!\n");<BR>&nbsp;&nbsp;kfree(ue_sk);<BR>&nbsp;&nbsp;return -ENODEV;<BR>&nbsp;}<BR>&nbsp;mutex_lock(&amp;uevent_sock_mutex);<BR>&nbsp;list_add_tail(&amp;ue_sk-&gt;list, &amp;uevent_sock_list);<BR>&nbsp;mutex_unlock(&amp;uevent_sock_mutex);<BR>&nbsp;return 0;<BR>}</P>
<P>static void uevent_net_exit(struct net *net)<BR>{<BR>&nbsp;struct uevent_sock *ue_sk;</P>
<P>&nbsp;mutex_lock(&amp;uevent_sock_mutex);<BR>&nbsp;list_for_each_entry(ue_sk, &amp;uevent_sock_list, list) {<BR>&nbsp;&nbsp;if (sock_net(ue_sk-&gt;sk) == net)<BR>&nbsp;&nbsp;&nbsp;goto found;<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;uevent_sock_mutex);<BR>&nbsp;return;</P>
<P>found:<BR>&nbsp;list_del(&amp;ue_sk-&gt;list);<BR>&nbsp;mutex_unlock(&amp;uevent_sock_mutex);</P>
<P>&nbsp;netlink_kernel_release(ue_sk-&gt;sk);<BR>&nbsp;kfree(ue_sk);<BR>}</P>
<P>static struct pernet_operations uevent_net_ops = {<BR>&nbsp;.init&nbsp;= uevent_net_init,<BR>&nbsp;.exit&nbsp;= uevent_net_exit,<BR>};</P>
<P>static int __init kobject_uevent_init(void)<BR>{<BR>&nbsp;return register_pernet_subsys(&amp;uevent_net_ops);<BR>}</P>
<P><BR>postcore_initcall(kobject_uevent_init);<BR>#endif