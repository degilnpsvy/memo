drivers/base/base.h 
<P></P>
<P>&nbsp;</P>
<P>#include &lt;linux/notifier.h&gt;</P>
<P></P>
<P><FONT class=extract>/**<BR>&nbsp;* struct subsys_private - structure to hold the private to the driver core portions of the bus_type/class structure.<BR>&nbsp;*<BR>&nbsp;* @subsys - the struct kset that defines this subsystem<BR>&nbsp;* @devices_kset - the subsystem's 'devices' directory<BR>&nbsp;* @interfaces - list of subsystem interfaces associated<BR>&nbsp;* @mutex - protect the devices, and interfaces lists.<BR>&nbsp;*<BR>&nbsp;* @drivers_kset - the list of drivers associated<BR>&nbsp;* @klist_devices - the klist to iterate over the @devices_kset<BR>&nbsp;* @klist_drivers - the klist to iterate over the @drivers_kset<BR>&nbsp;* @bus_notifier - the bus notifier list for anything that cares about things<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on this bus.<BR>&nbsp;* @bus - pointer back to the struct bus_type that this structure is associated<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with.<BR>&nbsp;*<BR>&nbsp;* @glue_dirs - "glue" directory to put in-between the parent device to<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; avoid namespace conflicts<BR>&nbsp;* @class - pointer back to the struct class that this structure is associated<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with.<BR>&nbsp;*<BR>&nbsp;* This structure is the one that is the actual kobject allowing struct<BR>&nbsp;* bus_type/class to be statically allocated safely.&nbsp; Nothing outside of the<BR>&nbsp;* driver core should ever touch these fields.<BR>&nbsp;*/<BR>struct subsys_private {<BR>&nbsp;struct kset subsys;<BR>&nbsp;struct kset *devices_kset;<BR>&nbsp;struct list_head interfaces;<BR>&nbsp;struct mutex mutex;</FONT></P>
<P><FONT class=extract>&nbsp;struct kset *drivers_kset;<BR>&nbsp;struct klist klist_devices;<BR>&nbsp;struct klist klist_drivers;<BR>&nbsp;struct blocking_notifier_head bus_notifier;<BR>&nbsp;unsigned int drivers_autoprobe:1;<BR>&nbsp;struct bus_type *bus;</FONT></P>
<P><FONT class=extract>&nbsp;struct kset glue_dirs;<BR>&nbsp;struct class *class;<BR>};<BR>#define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)</FONT></P>
<P><FONT class=extract>struct driver_private {<BR>&nbsp;struct kobject kobj;<BR>&nbsp;struct klist klist_devices;<BR>&nbsp;struct klist_node knode_bus;<BR>&nbsp;struct module_kobject *mkobj;<BR>&nbsp;struct device_driver *driver;<BR>};<BR>#define to_driver(obj) container_of(obj, struct driver_private, kobj)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* struct device_private - structure to hold the private to the driver core portions of the device structure.<BR>&nbsp;*<BR>&nbsp;* @klist_children - klist containing all children of this device<BR>&nbsp;* @knode_parent - node in sibling list<BR>&nbsp;* @knode_driver - node in driver list<BR>&nbsp;* @knode_bus - node in bus list<BR>&nbsp;* @deferred_probe - entry in deferred_probe_list which is used to retry the<BR>&nbsp;*&nbsp;binding of drivers which were unable to get all the resources needed by<BR>&nbsp;*&nbsp;the device; typically because it depends on another driver getting<BR>&nbsp;*&nbsp;probed first.<BR>&nbsp;* @device - pointer back to the struct class that this structure is<BR>&nbsp;* associated with.<BR>&nbsp;*<BR>&nbsp;* Nothing outside of the driver core should ever touch these fields.<BR>&nbsp;*/<BR>struct device_private {<BR>&nbsp;struct klist klist_children;<BR>&nbsp;struct klist_node knode_parent;<BR>&nbsp;struct klist_node knode_driver;<BR>&nbsp;struct klist_node knode_bus;<BR>&nbsp;struct list_head deferred_probe;<BR>&nbsp;struct device *device;<BR>};<BR>#define to_device_private_parent(obj)&nbsp;\<BR>&nbsp;container_of(obj, struct device_private, knode_parent)<BR>#define to_device_private_driver(obj)&nbsp;\<BR>&nbsp;container_of(obj, struct device_private, knode_driver)<BR>#define to_device_private_bus(obj)&nbsp;\<BR>&nbsp;container_of(obj, struct device_private, knode_bus)</FONT></P>
<P><FONT class=extract>extern int device_private_init(struct device *dev);</FONT></P>
<P>/* initialisation functions */<BR>extern int devices_init(void);<BR>extern int buses_init(void);<BR>extern int classes_init(void);<BR>extern int firmware_init(void);<BR>#ifdef CONFIG_SYS_HYPERVISOR<BR>extern int hypervisor_init(void);<BR>#else<BR>static inline int hypervisor_init(void) { return 0; }<BR>#endif<BR>extern int platform_bus_init(void);<BR>extern void cpu_dev_init(void);<BR>extern void container_dev_init(void);</P>
<P>struct kobject *virtual_device_parent(struct device *dev);</P>
<P>extern int bus_add_device(struct device *dev);<BR>extern void bus_probe_device(struct device *dev);<BR>extern void bus_remove_device(struct device *dev);</P>
<P>extern int bus_add_driver(struct device_driver *drv);<BR>extern void bus_remove_driver(struct device_driver *drv);</P>
<P>extern void driver_detach(struct device_driver *drv);<BR>extern int driver_probe_device(struct device_driver *drv, struct device *dev);<BR>extern void driver_deferred_probe_del(struct device *dev);<BR>static inline int driver_match_device(struct device_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *dev)<BR>{<BR>&nbsp;return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;<BR>}<BR>extern bool driver_allows_async_probing(struct device_driver *drv);</P>
<P>extern int driver_add_groups(struct device_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups);<BR>extern void driver_remove_groups(struct device_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups);</P>
<P>extern int device_add_groups(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups);<BR>extern void device_remove_groups(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups);</P>
<P>extern char *make_class_name(const char *name, struct kobject *kobj);</P>
<P>extern int devres_release_all(struct device *dev);</P>
<P>/* /sys/devices directory */<BR>extern struct kset *devices_kset;</P>
<P>#if defined(CONFIG_MODULES) &amp;&amp; defined(CONFIG_SYSFS)<BR>extern void module_add_driver(struct module *mod, struct device_driver *drv);<BR>extern void module_remove_driver(struct device_driver *drv);<BR>#else<BR>static inline void module_add_driver(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_driver *drv) { }<BR>static inline void module_remove_driver(struct device_driver *drv) { }<BR>#endif</P>
<P>#ifdef CONFIG_DEVTMPFS<BR>extern int devtmpfs_init(void);<BR>#else<BR>static inline int devtmpfs_init(void) { return 0; }<BR>#endif