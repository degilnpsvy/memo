lib/kobject.c 
<P></P>
<P>/*<BR>&nbsp;* kobject.c - library routines for handling generic kernel objects<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2002-2003 Patrick Mochel &lt;<A href="mailto:mochel@osdl.org">mochel@osdl.org</A>&gt;<BR>&nbsp;* Copyright (c) 2006-2007 Greg Kroah-Hartman &lt;<A href="mailto:greg@kroah.com">greg@kroah.com</A>&gt;<BR>&nbsp;* Copyright (c) 2006-2007 Novell Inc.<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2.<BR>&nbsp;*<BR>&nbsp;*<BR>&nbsp;* Please see the file Documentation/kobject.txt for critical information<BR>&nbsp;* about using the kobject interface.<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/kobject.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/stat.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/random.h&gt;</P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_namespace - return @kobj's namespace tag<BR>&nbsp;* @kobj: kobject in question<BR>&nbsp;*<BR>&nbsp;* Returns namespace tag of @kobj if its parent has namespace ops enabled<BR>&nbsp;* and thus @kobj should have a namespace tag associated with it.&nbsp; Returns<BR>&nbsp;* %NULL otherwise.<BR>&nbsp;*/<BR>const void *kobject_namespace(struct kobject *kobj)<BR>{<BR>&nbsp;const struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);</FONT></P>
<P><FONT class=extract>&nbsp;if (!ns_ops || ns_ops-&gt;type == KOBJ_NS_TYPE_NONE)<BR>&nbsp;&nbsp;return NULL;</FONT></P>
<P><FONT class=extract>&nbsp;return kobj-&gt;ktype-&gt;namespace(kobj);<BR>}</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* populate_dir - populate directory with attributes.<BR>&nbsp;* @kobj: object we're working on.<BR>&nbsp;*<BR>&nbsp;* Most subsystems have a set of default attributes that are associated<BR>&nbsp;* with an object that registers with them.&nbsp; This is a helper called during<BR>&nbsp;* object registration that loops through the default attributes of the<BR>&nbsp;* subsystem and creates attributes files for them in sysfs.<BR>&nbsp;*/<BR>static int populate_dir(struct kobject *kobj)<BR>{<BR>&nbsp;struct kobj_type *t = get_ktype(kobj);<BR>&nbsp;struct attribute *attr;<BR>&nbsp;int error = 0;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;if (t &amp;&amp; t-&gt;default_attrs) {<BR>&nbsp;&nbsp;for (i = 0; (attr = t-&gt;default_attrs[i]) != NULL; i++) {<BR>&nbsp;&nbsp;&nbsp;error = sysfs_create_file(kobj, attr);<BR>&nbsp;&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;return error;<BR>}</FONT></P>
<P><FONT class=extract>static int create_dir(struct kobject *kobj)<BR>{<BR>&nbsp;const struct kobj_ns_type_operations *ops;<BR>&nbsp;int error;</FONT></P>
<P><FONT class=extract>&nbsp;error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;return error;</FONT></P>
<P><FONT class=extract>&nbsp;error = populate_dir(kobj);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;sysfs_remove_dir(kobj);<BR>&nbsp;&nbsp;return error;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * @kobj-&gt;sd may be deleted by an ancestor going away.&nbsp; Hold an<BR>&nbsp; * extra reference so that it stays until @kobj is gone.<BR>&nbsp; */<BR>&nbsp;sysfs_get(kobj-&gt;sd);</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * If @kobj has ns_ops, its children need to be filtered based on<BR>&nbsp; * their namespace tags.&nbsp; Enable namespace support on @kobj-&gt;sd.<BR>&nbsp; */<BR>&nbsp;ops = kobj_child_ns_ops(kobj);<BR>&nbsp;if (ops) {<BR>&nbsp;&nbsp;BUG_ON(ops-&gt;type &lt;= KOBJ_NS_TYPE_NONE);<BR>&nbsp;&nbsp;BUG_ON(ops-&gt;type &gt;= KOBJ_NS_TYPES);<BR>&nbsp;&nbsp;BUG_ON(!kobj_ns_type_registered(ops-&gt;type));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;sysfs_enable_ns(kobj-&gt;sd);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>static int get_kobj_path_length(struct kobject *kobj)<BR>{<BR>&nbsp;int length = 1;<BR>&nbsp;struct kobject *parent = kobj;</FONT></P>
<P><FONT class=extract>&nbsp;/* walk up the ancestors until we hit the one pointing to the<BR>&nbsp; * root.<BR>&nbsp; * Add 1 to strlen for leading '/' of each level.<BR>&nbsp; */<BR>&nbsp;do {<BR>&nbsp;&nbsp;if (kobject_name(parent) == NULL)<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;length += strlen(kobject_name(parent)) + 1;<BR>&nbsp;&nbsp;parent = parent-&gt;parent;<BR>&nbsp;} while (parent);<BR>&nbsp;return length;<BR>}</FONT></P>
<P><FONT class=extract>static void fill_kobj_path(struct kobject *kobj, char *path, int length)<BR>{<BR>&nbsp;struct kobject *parent;</FONT></P>
<P><FONT class=extract>&nbsp;--length;<BR>&nbsp;for (parent = kobj; parent; parent = parent-&gt;parent) {<BR>&nbsp;&nbsp;int cur = strlen(kobject_name(parent));<BR>&nbsp;&nbsp;/* back up enough to print this name with '/' */<BR>&nbsp;&nbsp;length -= cur;<BR>&nbsp;&nbsp;strncpy(path + length, kobject_name(parent), cur);<BR>&nbsp;&nbsp;*(path + --length) = '/';<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("kobject: '%s' (%p): %s: path = '%s'\n", kobject_name(kobj),<BR>&nbsp;&nbsp; kobj, __func__, path);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_get_path - generate and return the path associated with a given kobj and kset pair.<BR>&nbsp;*<BR>&nbsp;* @kobj:&nbsp;kobject in question, with which to build the path<BR>&nbsp;* @gfp_mask:&nbsp;the allocation type used to allocate the path<BR>&nbsp;*<BR>&nbsp;* The result must be freed by the caller with kfree().<BR>&nbsp;*/<BR>char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)<BR>{<BR>&nbsp;char *path;<BR>&nbsp;int len;</FONT></P>
<P><FONT class=extract>&nbsp;len = get_kobj_path_length(kobj);<BR>&nbsp;if (len == 0)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;path = kzalloc(len, gfp_mask);<BR>&nbsp;if (!path)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;fill_kobj_path(kobj, path, len);</FONT></P>
<P><FONT class=extract>&nbsp;return path;<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_get_path);</FONT></P>
<P><FONT class=extract>/* add the kobject to its kset's list */<BR>static void kobj_kset_join(struct kobject *kobj)<BR>{<BR>&nbsp;if (!kobj-&gt;kset)<BR>&nbsp;&nbsp;return;</FONT></P>
<P><FONT class=extract>&nbsp;kset_get(kobj-&gt;kset);<BR>&nbsp;spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);<BR>&nbsp;list_add_tail(&amp;kobj-&gt;entry, &amp;kobj-&gt;kset-&gt;list);<BR>&nbsp;spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);<BR>}</FONT></P>
<P><FONT class=extract>/* remove the kobject from its kset's list */<BR>static void kobj_kset_leave(struct kobject *kobj)<BR>{<BR>&nbsp;if (!kobj-&gt;kset)<BR>&nbsp;&nbsp;return;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);<BR>&nbsp;list_del_init(&amp;kobj-&gt;entry);<BR>&nbsp;spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);<BR>&nbsp;kset_put(kobj-&gt;kset);<BR>}</FONT></P>
<P><FONT class=extract>static void kobject_init_internal(struct kobject *kobj)<BR>{<BR>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return;<BR>&nbsp;kref_init(&amp;kobj-&gt;kref);<BR>&nbsp;INIT_LIST_HEAD(&amp;kobj-&gt;entry);<BR>&nbsp;kobj-&gt;state_in_sysfs = 0;<BR>&nbsp;kobj-&gt;state_add_uevent_sent = 0;<BR>&nbsp;kobj-&gt;state_remove_uevent_sent = 0;<BR>&nbsp;kobj-&gt;state_initialized = 1;<BR>}</FONT></P>
<P><BR><FONT class=extract>static int kobject_add_internal(struct kobject *kobj)<BR>{<BR>&nbsp;int error = 0;<BR>&nbsp;struct kobject *parent;</FONT></P>
<P><FONT class=extract>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return -ENOENT;</FONT></P>
<P><FONT class=extract>&nbsp;if (!kobj-&gt;name || !kobj-&gt;name[0]) {<BR>&nbsp;&nbsp;WARN(1, "kobject: (%p): attempted to be registered with empty "<BR>&nbsp;&nbsp;&nbsp; "name!\n", kobj);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;parent = kobject_get(kobj-&gt;parent);</FONT></P>
<P><FONT class=extract>&nbsp;/* join kset if set, use it as parent if we do not already have one */<BR>&nbsp;if (kobj-&gt;kset) {<BR>&nbsp;&nbsp;if (!parent)<BR>&nbsp;&nbsp;&nbsp;parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);<BR>&nbsp;&nbsp;kobj_kset_join(kobj);<BR>&nbsp;&nbsp;kobj-&gt;parent = parent;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",<BR>&nbsp;&nbsp; kobject_name(kobj), kobj, __func__,<BR>&nbsp;&nbsp; parent ? kobject_name(parent) : "&lt;NULL&gt;",<BR>&nbsp;&nbsp; kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : "&lt;NULL&gt;");</FONT></P>
<P><FONT class=extract>&nbsp;error = create_dir(kobj);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;kobj_kset_leave(kobj);<BR>&nbsp;&nbsp;kobject_put(parent);<BR>&nbsp;&nbsp;kobj-&gt;parent = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;/* be noisy on error issues */<BR>&nbsp;&nbsp;if (error == -EEXIST)<BR>&nbsp;&nbsp;&nbsp;WARN(1, "%s failed for %s with "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-EEXIST, don't try to register things with "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "the same name in the same directory.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, kobject_name(kobj));<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;WARN(1, "%s failed for %s (error: %d parent: %s)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, kobject_name(kobj), error,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent ? kobject_name(parent) : "'none'");<BR>&nbsp;} else<BR>&nbsp;&nbsp;kobj-&gt;state_in_sysfs = 1;</FONT></P>
<P><FONT class=extract>&nbsp;return error;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_set_name_vargs - Set the name of an kobject<BR>&nbsp;* @kobj: struct kobject to set the name of<BR>&nbsp;* @fmt: format string used to build the name<BR>&nbsp;* @vargs: vargs to format the string.<BR>&nbsp;*/<BR>int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list vargs)<BR>{<BR>&nbsp;char *s;</FONT></P>
<P><FONT class=extract>&nbsp;if (kobj-&gt;name &amp;&amp; !fmt)<BR>&nbsp;&nbsp;return 0;</FONT></P>
<P><FONT class=extract>&nbsp;s = kvasprintf(GFP_KERNEL, fmt, vargs);<BR>&nbsp;if (!s)<BR>&nbsp;&nbsp;return -ENOMEM;</FONT></P>
<P><FONT class=extract>&nbsp;/* ewww... some of these buggers have '/' in the name ... */<BR>&nbsp;strreplace(s, '/', '!');<BR>&nbsp;kfree(kobj-&gt;name);<BR>&nbsp;kobj-&gt;name = s;</FONT></P>
<P><FONT class=extract>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_set_name - Set the name of a kobject<BR>&nbsp;* @kobj: struct kobject to set the name of<BR>&nbsp;* @fmt: format string used to build the name<BR>&nbsp;*<BR>&nbsp;* This sets the name of the kobject.&nbsp; If you have already added the<BR>&nbsp;* kobject to the system, you must call kobject_rename() in order to<BR>&nbsp;* change the name of the kobject.<BR>&nbsp;*/<BR>int kobject_set_name(struct kobject *kobj, const char *fmt, ...)<BR>{<BR>&nbsp;va_list vargs;<BR>&nbsp;int retval;</FONT></P>
<P><FONT class=extract>&nbsp;va_start(vargs, fmt);<BR>&nbsp;retval = kobject_set_name_vargs(kobj, fmt, vargs);<BR>&nbsp;va_end(vargs);</FONT></P>
<P><FONT class=extract>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL(kobject_set_name);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_init - initialize a kobject structure<BR>&nbsp;* @kobj: pointer to the kobject to initialize<BR>&nbsp;* @ktype: pointer to the ktype for this kobject.<BR>&nbsp;*<BR>&nbsp;* This function will properly initialize a kobject such that it can then<BR>&nbsp;* be passed to the kobject_add() call.<BR>&nbsp;*<BR>&nbsp;* After this function is called, the kobject MUST be cleaned up by a call<BR>&nbsp;* to kobject_put(), not by a call to kfree directly to ensure that all of<BR>&nbsp;* the memory is cleaned up properly.<BR>&nbsp;*/<BR>void kobject_init(struct kobject *kobj, struct kobj_type *ktype)<BR>{<BR>&nbsp;char *err_str;</FONT></P>
<P><FONT class=extract>&nbsp;if (!kobj) {<BR>&nbsp;&nbsp;err_str = "invalid kobject pointer!";<BR>&nbsp;&nbsp;goto error;<BR>&nbsp;}<BR>&nbsp;if (!ktype) {<BR>&nbsp;&nbsp;err_str = "must have a ktype to be initialized properly!\n";<BR>&nbsp;&nbsp;goto error;<BR>&nbsp;}<BR>&nbsp;if (kobj-&gt;state_initialized) {<BR>&nbsp;&nbsp;/* do not error out as sometimes we can recover */<BR>&nbsp;&nbsp;printk(KERN_ERR "kobject (%p): tried to init an initialized "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "object, something is seriously wrong.\n", kobj);<BR>&nbsp;&nbsp;dump_stack();<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;kobject_init_internal(kobj);<BR>&nbsp;kobj-&gt;ktype = ktype;<BR>&nbsp;return;</FONT></P>
<P><FONT class=extract>error:<BR>&nbsp;printk(KERN_ERR "kobject (%p): %s\n", kobj, err_str);<BR>&nbsp;dump_stack();<BR>}<BR>EXPORT_SYMBOL(kobject_init);</FONT></P>
<P><FONT class=extract>static __printf(3, 0) int kobject_add_varg(struct kobject *kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kobject *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, va_list vargs)<BR>{<BR>&nbsp;int retval;</FONT></P>
<P><FONT class=extract>&nbsp;retval = kobject_set_name_vargs(kobj, fmt, vargs);<BR>&nbsp;if (retval) {<BR>&nbsp;&nbsp;printk(KERN_ERR "kobject: can not set name properly!\n");<BR>&nbsp;&nbsp;return retval;<BR>&nbsp;}<BR>&nbsp;kobj-&gt;parent = parent;<BR>&nbsp;return kobject_add_internal(kobj);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_add - the main kobject add function<BR>&nbsp;* @kobj: the kobject to add<BR>&nbsp;* @parent: pointer to the parent of the kobject.<BR>&nbsp;* @fmt: format to name the kobject with.<BR>&nbsp;*<BR>&nbsp;* The kobject name is set and added to the kobject hierarchy in this<BR>&nbsp;* function.<BR>&nbsp;*<BR>&nbsp;* If @parent is set, then the parent of the @kobj will be set to it.<BR>&nbsp;* If @parent is NULL, then the parent of the @kobj will be set to the<BR>&nbsp;* kobject associated with the kset assigned to this kobject.&nbsp; If no kset<BR>&nbsp;* is assigned to the kobject, then the kobject will be located in the<BR>&nbsp;* root of the sysfs tree.<BR>&nbsp;*<BR>&nbsp;* If this function returns an error, kobject_put() must be called to<BR>&nbsp;* properly clean up the memory associated with the object.<BR>&nbsp;* Under no instance should the kobject that is passed to this function<BR>&nbsp;* be directly freed with a call to kfree(), that can leak memory.<BR>&nbsp;*<BR>&nbsp;* Note, no "add" uevent will be created with this call, the caller should set<BR>&nbsp;* up all of the necessary sysfs files for the object and then call<BR>&nbsp;* kobject_uevent() with the UEVENT_ADD parameter to ensure that<BR>&nbsp;* userspace is properly notified of this kobject's creation.<BR>&nbsp;*/<BR>int kobject_add(struct kobject *kobj, struct kobject *parent,<BR>&nbsp;&nbsp;const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int retval;</FONT></P>
<P><FONT class=extract>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;if (!kobj-&gt;state_initialized) {<BR>&nbsp;&nbsp;printk(KERN_ERR "kobject '%s' (%p): tried to add an "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "uninitialized object, something is seriously wrong.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj);<BR>&nbsp;&nbsp;dump_stack();<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}<BR>&nbsp;va_start(args, fmt);<BR>&nbsp;retval = kobject_add_varg(kobj, parent, fmt, args);<BR>&nbsp;va_end(args);</FONT></P>
<P><FONT class=extract>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL(kobject_add);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_init_and_add - initialize a kobject structure and add it to the kobject hierarchy<BR>&nbsp;* @kobj: pointer to the kobject to initialize<BR>&nbsp;* @ktype: pointer to the ktype for this kobject.<BR>&nbsp;* @parent: pointer to the parent of this kobject.<BR>&nbsp;* @fmt: the name of the kobject.<BR>&nbsp;*<BR>&nbsp;* This function combines the call to kobject_init() and<BR>&nbsp;* kobject_add().&nbsp; The same type of error handling after a call to<BR>&nbsp;* kobject_add() and kobject lifetime rules are the same here.<BR>&nbsp;*/<BR>int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,<BR>&nbsp;&nbsp;&nbsp; struct kobject *parent, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int retval;</FONT></P>
<P><FONT class=extract>&nbsp;kobject_init(kobj, ktype);</FONT></P>
<P><FONT class=extract>&nbsp;va_start(args, fmt);<BR>&nbsp;retval = kobject_add_varg(kobj, parent, fmt, args);<BR>&nbsp;va_end(args);</FONT></P>
<P><FONT class=extract>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_init_and_add);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_rename - change the name of an object<BR>&nbsp;* @kobj: object in question.<BR>&nbsp;* @new_name: object's new name<BR>&nbsp;*<BR>&nbsp;* It is the responsibility of the caller to provide mutual<BR>&nbsp;* exclusion between two different calls of kobject_rename<BR>&nbsp;* on the same kobject and to ensure that new_name is valid and<BR>&nbsp;* won't conflict with other kobjects.<BR>&nbsp;*/<BR>int kobject_rename(struct kobject *kobj, const char *new_name)<BR>{<BR>&nbsp;int error = 0;<BR>&nbsp;const char *devpath = NULL;<BR>&nbsp;const char *dup_name = NULL, *name;<BR>&nbsp;char *devpath_string = NULL;<BR>&nbsp;char *envp[2];</FONT></P>
<P><FONT class=extract>&nbsp;kobj = kobject_get(kobj);<BR>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;if (!kobj-&gt;parent)<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;devpath = kobject_get_path(kobj, GFP_KERNEL);<BR>&nbsp;if (!devpath) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}<BR>&nbsp;devpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);<BR>&nbsp;if (!devpath_string) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}<BR>&nbsp;sprintf(devpath_string, "DEVPATH_OLD=%s", devpath);<BR>&nbsp;envp[0] = devpath_string;<BR>&nbsp;envp[1] = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;name = dup_name = kstrdup(new_name, GFP_KERNEL);<BR>&nbsp;if (!name) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;error = sysfs_rename_dir_ns(kobj, new_name, kobject_namespace(kobj));<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;/* Install the new kobject name */<BR>&nbsp;dup_name = kobj-&gt;name;<BR>&nbsp;kobj-&gt;name = name;</FONT></P>
<P><FONT class=extract>&nbsp;/* This function is mostly/only used for network interface.<BR>&nbsp; * Some hotplug package track interfaces by their name and<BR>&nbsp; * therefore want to know when the name is changed by the user. */<BR>&nbsp;kobject_uevent_env(kobj, KOBJ_MOVE, envp);</FONT></P>
<P><FONT class=extract>out:<BR>&nbsp;kfree(dup_name);<BR>&nbsp;kfree(devpath_string);<BR>&nbsp;kfree(devpath);<BR>&nbsp;kobject_put(kobj);</FONT></P>
<P><FONT class=extract>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_rename);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_move - move object to another parent<BR>&nbsp;* @kobj: object in question.<BR>&nbsp;* @new_parent: object's new parent (can be NULL)<BR>&nbsp;*/<BR>int kobject_move(struct kobject *kobj, struct kobject *new_parent)<BR>{<BR>&nbsp;int error;<BR>&nbsp;struct kobject *old_parent;<BR>&nbsp;const char *devpath = NULL;<BR>&nbsp;char *devpath_string = NULL;<BR>&nbsp;char *envp[2];</FONT></P>
<P><FONT class=extract>&nbsp;kobj = kobject_get(kobj);<BR>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;new_parent = kobject_get(new_parent);<BR>&nbsp;if (!new_parent) {<BR>&nbsp;&nbsp;if (kobj-&gt;kset)<BR>&nbsp;&nbsp;&nbsp;new_parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* old object path */<BR>&nbsp;devpath = kobject_get_path(kobj, GFP_KERNEL);<BR>&nbsp;if (!devpath) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}<BR>&nbsp;devpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);<BR>&nbsp;if (!devpath_string) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}<BR>&nbsp;sprintf(devpath_string, "DEVPATH_OLD=%s", devpath);<BR>&nbsp;envp[0] = devpath_string;<BR>&nbsp;envp[1] = NULL;<BR>&nbsp;error = sysfs_move_dir_ns(kobj, new_parent, kobject_namespace(kobj));<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;old_parent = kobj-&gt;parent;<BR>&nbsp;kobj-&gt;parent = new_parent;<BR>&nbsp;new_parent = NULL;<BR>&nbsp;kobject_put(old_parent);<BR>&nbsp;kobject_uevent_env(kobj, KOBJ_MOVE, envp);<BR>out:<BR>&nbsp;kobject_put(new_parent);<BR>&nbsp;kobject_put(kobj);<BR>&nbsp;kfree(devpath_string);<BR>&nbsp;kfree(devpath);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_move);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_del - unlink kobject from hierarchy.<BR>&nbsp;* @kobj: object.<BR>&nbsp;*/<BR>void kobject_del(struct kobject *kobj)<BR>{<BR>&nbsp;struct kernfs_node *sd;</FONT></P>
<P><FONT class=extract>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return;</FONT></P>
<P><FONT class=extract>&nbsp;sd = kobj-&gt;sd;<BR>&nbsp;sysfs_remove_dir(kobj);<BR>&nbsp;sysfs_put(sd);</FONT></P>
<P><FONT class=extract>&nbsp;kobj-&gt;state_in_sysfs = 0;<BR>&nbsp;kobj_kset_leave(kobj);<BR>&nbsp;kobject_put(kobj-&gt;parent);<BR>&nbsp;kobj-&gt;parent = NULL;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_get - increment refcount for object.<BR>&nbsp;* @kobj: object.<BR>&nbsp;*/<BR>struct kobject *kobject_get(struct kobject *kobj)<BR>{<BR>&nbsp;if (kobj) {<BR>&nbsp;&nbsp;if (!kobj-&gt;state_initialized)<BR>&nbsp;&nbsp;&nbsp;WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "initialized, yet kobject_get() is being "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "called.\n", kobject_name(kobj), kobj);<BR>&nbsp;&nbsp;kref_get(&amp;kobj-&gt;kref);<BR>&nbsp;}<BR>&nbsp;return kobj;<BR>}</FONT></P>
<P><FONT class=extract>static struct kobject * __must_check kobject_get_unless_zero(struct kobject *kobj)<BR>{<BR>&nbsp;if (!kref_get_unless_zero(&amp;kobj-&gt;kref))<BR>&nbsp;&nbsp;kobj = NULL;<BR>&nbsp;return kobj;<BR>}</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* kobject_cleanup - free kobject resources.<BR>&nbsp;* @kobj: object to cleanup<BR>&nbsp;*/<BR>static void kobject_cleanup(struct kobject *kobj)<BR>{<BR>&nbsp;struct kobj_type *t = get_ktype(kobj);<BR>&nbsp;const char *name = kobj-&gt;name;</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("kobject: '%s' (%p): %s, parent %p\n",<BR>&nbsp;&nbsp; kobject_name(kobj), kobj, __func__, kobj-&gt;parent);</FONT></P>
<P><FONT class=extract>&nbsp;if (t &amp;&amp; !t-&gt;release)<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): does not have a release() "<BR>&nbsp;&nbsp;&nbsp; "function, it is broken and must be fixed.\n",<BR>&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj);</FONT></P>
<P><FONT class=extract>&nbsp;/* send "remove" if the caller did not do it but sent "add" */<BR>&nbsp;if (kobj-&gt;state_add_uevent_sent &amp;&amp; !kobj-&gt;state_remove_uevent_sent) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): auto cleanup 'remove' event\n",<BR>&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj);<BR>&nbsp;&nbsp;kobject_uevent(kobj, KOBJ_REMOVE);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* remove from sysfs if the caller did not do it */<BR>&nbsp;if (kobj-&gt;state_in_sysfs) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): auto cleanup kobject_del\n",<BR>&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj);<BR>&nbsp;&nbsp;kobject_del(kobj);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;if (t &amp;&amp; t-&gt;release) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): calling ktype release\n",<BR>&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj);<BR>&nbsp;&nbsp;t-&gt;release(kobj);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* free name if we allocated it */<BR>&nbsp;if (name) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s': free name\n", name);<BR>&nbsp;&nbsp;kfree(name);<BR>&nbsp;}<BR>}</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_DEBUG_KOBJECT_RELEASE<BR>static void kobject_delayed_cleanup(struct work_struct *work)<BR>{<BR>&nbsp;kobject_cleanup(container_of(to_delayed_work(work),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kobject, release));<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>static void kobject_release(struct kref *kref)<BR>{<BR>&nbsp;struct kobject *kobj = container_of(kref, struct kobject, kref);<BR>#ifdef CONFIG_DEBUG_KOBJECT_RELEASE<BR>&nbsp;unsigned long delay = HZ + HZ * (get_random_int() &amp; 0x3);<BR>&nbsp;pr_info("kobject: '%s' (%p): %s, parent %p (delayed %ld)\n",<BR>&nbsp;&nbsp; kobject_name(kobj), kobj, __func__, kobj-&gt;parent, delay);<BR>&nbsp;INIT_DELAYED_WORK(&amp;kobj-&gt;release, kobject_delayed_cleanup);</FONT></P>
<P><FONT class=extract>&nbsp;schedule_delayed_work(&amp;kobj-&gt;release, delay);<BR>#else<BR>&nbsp;kobject_cleanup(kobj);<BR>#endif<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_put - decrement refcount for object.<BR>&nbsp;* @kobj: object.<BR>&nbsp;*<BR>&nbsp;* Decrement the refcount, and if 0, call kobject_cleanup().<BR>&nbsp;*/<BR>void kobject_put(struct kobject *kobj)<BR>{<BR>&nbsp;if (kobj) {<BR>&nbsp;&nbsp;if (!kobj-&gt;state_initialized)<BR>&nbsp;&nbsp;&nbsp;WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "initialized, yet kobject_put() is being "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "called.\n", kobject_name(kobj), kobj);<BR>&nbsp;&nbsp;kref_put(&amp;kobj-&gt;kref, kobject_release);<BR>&nbsp;}<BR>}</FONT></P>
<P><FONT class=extract>static void dynamic_kobj_release(struct kobject *kobj)<BR>{<BR>&nbsp;pr_debug("kobject: (%p): %s\n", kobj, __func__);<BR>&nbsp;kfree(kobj);<BR>}</FONT></P>
<P><FONT class=extract>static struct kobj_type dynamic_kobj_ktype = {<BR>&nbsp;.release&nbsp;= dynamic_kobj_release,<BR>&nbsp;.sysfs_ops&nbsp;= &amp;kobj_sysfs_ops,<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_create - create a struct kobject dynamically<BR>&nbsp;*<BR>&nbsp;* This function creates a kobject structure dynamically and sets it up<BR>&nbsp;* to be a "dynamic" kobject with a default release function set up.<BR>&nbsp;*<BR>&nbsp;* If the kobject was not able to be created, NULL will be returned.<BR>&nbsp;* The kobject structure returned from here must be cleaned up with a<BR>&nbsp;* call to kobject_put() and not kfree(), as kobject_init() has<BR>&nbsp;* already been called on this structure.<BR>&nbsp;*/<BR>struct kobject *kobject_create(void)<BR>{<BR>&nbsp;struct kobject *kobj;</FONT></P>
<P><FONT class=extract>&nbsp;kobj = kzalloc(sizeof(*kobj), GFP_KERNEL);<BR>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return NULL;</FONT></P>
<P><FONT class=extract>&nbsp;kobject_init(kobj, &amp;dynamic_kobj_ktype);<BR>&nbsp;return kobj;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kobject_create_and_add - create a struct kobject dynamically and register it with sysfs<BR>&nbsp;*<BR>&nbsp;* @name: the name for the kobject<BR>&nbsp;* @parent: the parent kobject of this kobject, if any.<BR>&nbsp;*<BR>&nbsp;* This function creates a kobject structure dynamically and registers it<BR>&nbsp;* with sysfs.&nbsp; When you are finished with this structure, call<BR>&nbsp;* kobject_put() and the structure will be dynamically freed when<BR>&nbsp;* it is no longer being used.<BR>&nbsp;*<BR>&nbsp;* If the kobject was not able to be created, NULL will be returned.<BR>&nbsp;*/<BR>struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)<BR>{<BR>&nbsp;struct kobject *kobj;<BR>&nbsp;int retval;</FONT></P>
<P><FONT class=extract>&nbsp;kobj = kobject_create();<BR>&nbsp;if (!kobj)<BR>&nbsp;&nbsp;return NULL;</FONT></P>
<P><FONT class=extract>&nbsp;retval = kobject_add(kobj, parent, "%s", name);<BR>&nbsp;if (retval) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: kobject_add error: %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, retval);<BR>&nbsp;&nbsp;kobject_put(kobj);<BR>&nbsp;&nbsp;kobj = NULL;<BR>&nbsp;}<BR>&nbsp;return kobj;<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_create_and_add);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kset_init - initialize a kset for use<BR>&nbsp;* @k: kset<BR>&nbsp;*/<BR>void kset_init(struct kset *k)<BR>{<BR>&nbsp;kobject_init_internal(&amp;k-&gt;kobj);<BR>&nbsp;INIT_LIST_HEAD(&amp;k-&gt;list);<BR>&nbsp;spin_lock_init(&amp;k-&gt;list_lock);<BR>}</FONT></P>
<P><FONT class=extract>/* default kobject attribute operations */<BR>static ssize_t kobj_attr_show(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct kobj_attribute *kattr;<BR>&nbsp;ssize_t ret = -EIO;</FONT></P>
<P><FONT class=extract>&nbsp;kattr = container_of(attr, struct kobj_attribute, attr);<BR>&nbsp;if (kattr-&gt;show)<BR>&nbsp;&nbsp;ret = kattr-&gt;show(kobj, kattr, buf);<BR>&nbsp;return ret;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t kobj_attr_store(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct kobj_attribute *kattr;<BR>&nbsp;ssize_t ret = -EIO;</FONT></P>
<P><FONT class=extract>&nbsp;kattr = container_of(attr, struct kobj_attribute, attr);<BR>&nbsp;if (kattr-&gt;store)<BR>&nbsp;&nbsp;ret = kattr-&gt;store(kobj, kattr, buf, count);<BR>&nbsp;return ret;<BR>}</FONT></P>
<P><FONT class=extract>const struct sysfs_ops kobj_sysfs_ops = {<BR>&nbsp;.show&nbsp;= kobj_attr_show,<BR>&nbsp;.store&nbsp;= kobj_attr_store,<BR>};<BR>EXPORT_SYMBOL_GPL(kobj_sysfs_ops);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kset_register - initialize and add a kset.<BR>&nbsp;* @k: kset.<BR>&nbsp;*/<BR>int kset_register(struct kset *k)<BR>{<BR>&nbsp;int err;</FONT></P>
<P><FONT class=extract>&nbsp;if (!k)<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;kset_init(k);<BR>&nbsp;err = kobject_add_internal(&amp;k-&gt;kobj);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;<BR>&nbsp;kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD);<BR>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kset_unregister - remove a kset.<BR>&nbsp;* @k: kset.<BR>&nbsp;*/<BR>void kset_unregister(struct kset *k)<BR>{<BR>&nbsp;if (!k)<BR>&nbsp;&nbsp;return;<BR>&nbsp;kobject_del(&amp;k-&gt;kobj);<BR>&nbsp;kobject_put(&amp;k-&gt;kobj);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kset_find_obj - search for object in kset.<BR>&nbsp;* @kset: kset we're looking in.<BR>&nbsp;* @name: object's name.<BR>&nbsp;*<BR>&nbsp;* Lock kset via @kset-&gt;subsys, and iterate over @kset-&gt;list,<BR>&nbsp;* looking for a matching kobject. If matching object is found<BR>&nbsp;* take a reference and return the object.<BR>&nbsp;*/<BR>struct kobject *kset_find_obj(struct kset *kset, const char *name)<BR>{<BR>&nbsp;struct kobject *k;<BR>&nbsp;struct kobject *ret = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kset-&gt;list_lock);</FONT></P>
<P><FONT class=extract>&nbsp;list_for_each_entry(k, &amp;kset-&gt;list, entry) {<BR>&nbsp;&nbsp;if (kobject_name(k) &amp;&amp; !strcmp(kobject_name(k), name)) {<BR>&nbsp;&nbsp;&nbsp;ret = kobject_get_unless_zero(k);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;spin_unlock(&amp;kset-&gt;list_lock);<BR>&nbsp;return ret;<BR>}</FONT></P>
<P><FONT class=extract>static void kset_release(struct kobject *kobj)<BR>{<BR>&nbsp;struct kset *kset = container_of(kobj, struct kset, kobj);<BR>&nbsp;pr_debug("kobject: '%s' (%p): %s\n",<BR>&nbsp;&nbsp; kobject_name(kobj), kobj, __func__);<BR>&nbsp;kfree(kset);<BR>}</FONT></P>
<P><FONT class=extract>static struct kobj_type kset_ktype = {<BR>&nbsp;.sysfs_ops&nbsp;= &amp;kobj_sysfs_ops,<BR>&nbsp;.release = kset_release,<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kset_create - create a struct kset dynamically<BR>&nbsp;*<BR>&nbsp;* @name: the name for the kset<BR>&nbsp;* @uevent_ops: a struct kset_uevent_ops for the kset<BR>&nbsp;* @parent_kobj: the parent kobject of this kset, if any.<BR>&nbsp;*<BR>&nbsp;* This function creates a kset structure dynamically.&nbsp; This structure can<BR>&nbsp;* then be registered with the system and show up in sysfs with a call to<BR>&nbsp;* kset_register().&nbsp; When you are finished with this structure, if<BR>&nbsp;* kset_register() has been called, call kset_unregister() and the<BR>&nbsp;* structure will be dynamically freed when it is no longer being used.<BR>&nbsp;*<BR>&nbsp;* If the kset was not able to be created, NULL will be returned.<BR>&nbsp;*/<BR>static struct kset *kset_create(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct kset_uevent_ops *uevent_ops,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct kobject *parent_kobj)<BR>{<BR>&nbsp;struct kset *kset;<BR>&nbsp;int retval;</FONT></P>
<P><FONT class=extract>&nbsp;kset = kzalloc(sizeof(*kset), GFP_KERNEL);<BR>&nbsp;if (!kset)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;retval = kobject_set_name(&amp;kset-&gt;kobj, "%s", name);<BR>&nbsp;if (retval) {<BR>&nbsp;&nbsp;kfree(kset);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}<BR>&nbsp;kset-&gt;uevent_ops = uevent_ops;<BR>&nbsp;kset-&gt;kobj.parent = parent_kobj;</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * The kobject of this kset will have a type of kset_ktype and belong to<BR>&nbsp; * no kset itself.&nbsp; That way we can properly free it when it is<BR>&nbsp; * finished being used.<BR>&nbsp; */<BR>&nbsp;kset-&gt;kobj.ktype = &amp;kset_ktype;<BR>&nbsp;kset-&gt;kobj.kset = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;return kset;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kset_create_and_add - create a struct kset dynamically and add it to sysfs<BR>&nbsp;*<BR>&nbsp;* @name: the name for the kset<BR>&nbsp;* @uevent_ops: a struct kset_uevent_ops for the kset<BR>&nbsp;* @parent_kobj: the parent kobject of this kset, if any.<BR>&nbsp;*<BR>&nbsp;* This function creates a kset structure dynamically and registers it<BR>&nbsp;* with sysfs.&nbsp; When you are finished with this structure, call<BR>&nbsp;* kset_unregister() and the structure will be dynamically freed when it<BR>&nbsp;* is no longer being used.<BR>&nbsp;*<BR>&nbsp;* If the kset was not able to be created, NULL will be returned.<BR>&nbsp;*/<BR>struct kset *kset_create_and_add(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct kset_uevent_ops *uevent_ops,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct kobject *parent_kobj)<BR>{<BR>&nbsp;struct kset *kset;<BR>&nbsp;int error;</FONT></P>
<P><FONT class=extract>&nbsp;kset = kset_create(name, uevent_ops, parent_kobj);<BR>&nbsp;if (!kset)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;error = kset_register(kset);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;kfree(kset);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}<BR>&nbsp;return kset;<BR>}<BR>EXPORT_SYMBOL_GPL(kset_create_and_add);</FONT></P>
<P><BR><FONT class=extract>static DEFINE_SPINLOCK(kobj_ns_type_lock);<BR>static const struct kobj_ns_type_operations *kobj_ns_ops_tbl[KOBJ_NS_TYPES];</FONT></P>
<P><FONT class=extract>int kobj_ns_type_register(const struct kobj_ns_type_operations *ops)<BR>{<BR>&nbsp;enum kobj_ns_type type = ops-&gt;type;<BR>&nbsp;int error;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kobj_ns_type_lock);</FONT></P>
<P><FONT class=extract>&nbsp;error = -EINVAL;<BR>&nbsp;if (type &gt;= KOBJ_NS_TYPES)<BR>&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;error = -EINVAL;<BR>&nbsp;if (type &lt;= KOBJ_NS_TYPE_NONE)<BR>&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;error = -EBUSY;<BR>&nbsp;if (kobj_ns_ops_tbl[type])<BR>&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;error = 0;<BR>&nbsp;kobj_ns_ops_tbl[type] = ops;</FONT></P>
<P><FONT class=extract>out:<BR>&nbsp;spin_unlock(&amp;kobj_ns_type_lock);<BR>&nbsp;return error;<BR>}</FONT></P>
<P><FONT class=extract>int kobj_ns_type_registered(enum kobj_ns_type type)<BR>{<BR>&nbsp;int registered = 0;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kobj_ns_type_lock);<BR>&nbsp;if ((type &gt; KOBJ_NS_TYPE_NONE) &amp;&amp; (type &lt; KOBJ_NS_TYPES))<BR>&nbsp;&nbsp;registered = kobj_ns_ops_tbl[type] != NULL;<BR>&nbsp;spin_unlock(&amp;kobj_ns_type_lock);</FONT></P>
<P><FONT class=extract>&nbsp;return registered;<BR>}</FONT></P>
<P><FONT class=extract>const struct kobj_ns_type_operations *kobj_child_ns_ops(struct kobject *parent)<BR>{<BR>&nbsp;const struct kobj_ns_type_operations *ops = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;if (parent &amp;&amp; parent-&gt;ktype &amp;&amp; parent-&gt;ktype-&gt;child_ns_type)<BR>&nbsp;&nbsp;ops = parent-&gt;ktype-&gt;child_ns_type(parent);</FONT></P>
<P><FONT class=extract>&nbsp;return ops;<BR>}</FONT></P>
<P><FONT class=extract>const struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj)<BR>{<BR>&nbsp;return kobj_child_ns_ops(kobj-&gt;parent);<BR>}</FONT></P>
<P><FONT class=extract>bool kobj_ns_current_may_mount(enum kobj_ns_type type)<BR>{<BR>&nbsp;bool may_mount = true;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kobj_ns_type_lock);<BR>&nbsp;if ((type &gt; KOBJ_NS_TYPE_NONE) &amp;&amp; (type &lt; KOBJ_NS_TYPES) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobj_ns_ops_tbl[type])<BR>&nbsp;&nbsp;may_mount = kobj_ns_ops_tbl[type]-&gt;current_may_mount();<BR>&nbsp;spin_unlock(&amp;kobj_ns_type_lock);</FONT></P>
<P><FONT class=extract>&nbsp;return may_mount;<BR>}</FONT></P>
<P><FONT class=extract>void *kobj_ns_grab_current(enum kobj_ns_type type)<BR>{<BR>&nbsp;void *ns = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kobj_ns_type_lock);<BR>&nbsp;if ((type &gt; KOBJ_NS_TYPE_NONE) &amp;&amp; (type &lt; KOBJ_NS_TYPES) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobj_ns_ops_tbl[type])<BR>&nbsp;&nbsp;ns = kobj_ns_ops_tbl[type]-&gt;grab_current_ns();<BR>&nbsp;spin_unlock(&amp;kobj_ns_type_lock);</FONT></P>
<P><FONT class=extract>&nbsp;return ns;<BR>}</FONT></P>
<P><FONT class=extract>const void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk)<BR>{<BR>&nbsp;const void *ns = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kobj_ns_type_lock);<BR>&nbsp;if ((type &gt; KOBJ_NS_TYPE_NONE) &amp;&amp; (type &lt; KOBJ_NS_TYPES) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobj_ns_ops_tbl[type])<BR>&nbsp;&nbsp;ns = kobj_ns_ops_tbl[type]-&gt;netlink_ns(sk);<BR>&nbsp;spin_unlock(&amp;kobj_ns_type_lock);</FONT></P>
<P><FONT class=extract>&nbsp;return ns;<BR>}</FONT></P>
<P><FONT class=extract>const void *kobj_ns_initial(enum kobj_ns_type type)<BR>{<BR>&nbsp;const void *ns = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;kobj_ns_type_lock);<BR>&nbsp;if ((type &gt; KOBJ_NS_TYPE_NONE) &amp;&amp; (type &lt; KOBJ_NS_TYPES) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobj_ns_ops_tbl[type])<BR>&nbsp;&nbsp;ns = kobj_ns_ops_tbl[type]-&gt;initial_ns();<BR>&nbsp;spin_unlock(&amp;kobj_ns_type_lock);</FONT></P>
<P><FONT class=extract>&nbsp;return ns;<BR>}</FONT></P>
<P><FONT class=extract>void kobj_ns_drop(enum kobj_ns_type type, void *ns)<BR>{<BR>&nbsp;spin_lock(&amp;kobj_ns_type_lock);<BR>&nbsp;if ((type &gt; KOBJ_NS_TYPE_NONE) &amp;&amp; (type &lt; KOBJ_NS_TYPES) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobj_ns_ops_tbl[type] &amp;&amp; kobj_ns_ops_tbl[type]-&gt;drop_ns)<BR>&nbsp;&nbsp;kobj_ns_ops_tbl[type]-&gt;drop_ns(ns);<BR>&nbsp;spin_unlock(&amp;kobj_ns_type_lock);<BR>}</FONT></P>
<P><FONT class=extract>EXPORT_SYMBOL(kobject_get);<BR>EXPORT_SYMBOL(kobject_put);<BR>EXPORT_SYMBOL(kobject_del);</FONT></P>
<P><FONT class=extract>EXPORT_SYMBOL(kset_register);<BR>EXPORT_SYMBOL(kset_unregister);</FONT>