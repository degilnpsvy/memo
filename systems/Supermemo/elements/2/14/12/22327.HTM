<DIV class=navheader>
<TABLE summary="Navigation header" width="100%">
<TBODY>
<TR>
<TH colSpan=3 align=middle><SPAN class=phrase>struct input_dev</SPAN></TH></TR>
<TR>
<TD width="20%" align=left><A accessKey=p href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-value.html">Prev</A>&nbsp;</TD>
<TH width="60%" align=middle>Input core</TH>
<TD width="20%" align=right>&nbsp;<A accessKey=n href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-handler.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=refentry><A name=API-struct-input-dev></A>
<DIV class=titlepage></DIV>
<DIV class=refnamediv>
<H2>Name</H2>
<P>struct input_dev &#8212; represents an input device </P></DIV>
<DIV class=refsynopsisdiv>
<H2>Synopsis</H2><PRE class=programlisting>struct input_dev {
  const char * name;
  const char * phys;
  const char * uniq;
  struct input_id id;
  unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];
  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];
  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];
  unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];
  unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  unsigned long swbit[BITS_TO_LONGS(SW_CNT)];
  unsigned int hint_events_per_packet;
  unsigned int keycodemax;
  unsigned int keycodesize;
  void * keycode;
  int (* setkeycode) (struct input_dev *dev,const struct input_keymap_entry *ke,unsigned int *old_keycode);
  int (* getkeycode) (struct input_dev *dev,struct input_keymap_entry *ke);
  struct ff_device * ff;
  unsigned int repeat_key;
  struct timer_list timer;
  int rep[REP_CNT];
  struct input_mt * mt;
  struct input_absinfo * absinfo;
  unsigned long key[BITS_TO_LONGS(KEY_CNT)];
  unsigned long led[BITS_TO_LONGS(LED_CNT)];
  unsigned long snd[BITS_TO_LONGS(SND_CNT)];
  unsigned long sw[BITS_TO_LONGS(SW_CNT)];
  int (* open) (struct input_dev *dev);
  void (* close) (struct input_dev *dev);
  int (* flush) (struct input_dev *dev, struct file *file);
  int (* event) (struct input_dev *dev, unsigned int type, unsigned int code, int value);
  struct input_handle __rcu * grab;
  spinlock_t event_lock;
  struct mutex mutex;
  unsigned int users;
  bool going_away;
  struct device dev;
  struct list_head h_list;
  struct list_head node;
  unsigned int num_vals;
  unsigned int max_vals;
  struct input_value * vals;
  bool devres_managed;
};  </PRE></DIV>
<DIV class=refsect1><A name=idp48629116></A>
<H2>Members</H2>
<DIV class=variablelist>
<DL class=variablelist>
<DT><SPAN class=term>name</SPAN> 
<DD>
<P>name of the device </P>
<DT><SPAN class=term>phys</SPAN> 
<DD>
<P>physical path to the device in the system hierarchy </P>
<DT><SPAN class=term>uniq</SPAN> 
<DD>
<P>unique identification code for the device (if device has it) </P>
<DT><SPAN class=term>id</SPAN> 
<DD>
<P>id of the device (struct input_id) </P>
<DT><SPAN class=term>propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]</SPAN> 
<DD>
<P>bitmap of device properties and quirks </P>
<DT><SPAN class=term>evbit[BITS_TO_LONGS(EV_CNT)]</SPAN> 
<DD>
<P>bitmap of types of events supported by the device (EV_KEY, EV_REL, etc.) </P>
<DT><SPAN class=term>keybit[BITS_TO_LONGS(KEY_CNT)]</SPAN> 
<DD>
<P>bitmap of keys/buttons this device has </P>
<DT><SPAN class=term>relbit[BITS_TO_LONGS(REL_CNT)]</SPAN> 
<DD>
<P>bitmap of relative axes for the device </P>
<DT><SPAN class=term>absbit[BITS_TO_LONGS(ABS_CNT)]</SPAN> 
<DD>
<P>bitmap of absolute axes for the device </P>
<DT><SPAN class=term>mscbit[BITS_TO_LONGS(MSC_CNT)]</SPAN> 
<DD>
<P>bitmap of miscellaneous events supported by the device </P>
<DT><SPAN class=term>ledbit[BITS_TO_LONGS(LED_CNT)]</SPAN> 
<DD>
<P>bitmap of leds present on the device </P>
<DT><SPAN class=term>sndbit[BITS_TO_LONGS(SND_CNT)]</SPAN> 
<DD>
<P>bitmap of sound effects supported by the device </P>
<DT><SPAN class=term>ffbit[BITS_TO_LONGS(FF_CNT)]</SPAN> 
<DD>
<P>bitmap of force feedback effects supported by the device </P>
<DT><SPAN class=term>swbit[BITS_TO_LONGS(SW_CNT)]</SPAN> 
<DD>
<P>bitmap of switches present on the device </P>
<DT><SPAN class=term>hint_events_per_packet</SPAN> 
<DD>
<P>average number of events generated by the device in a packet (between EV_SYN/SYN_REPORT events). Used by event handlers to estimate size of the buffer needed to hold events. </P>
<DT><SPAN class=term>keycodemax</SPAN> 
<DD>
<P>size of keycode table </P>
<DT><SPAN class=term>keycodesize</SPAN> 
<DD>
<P>size of elements in keycode table </P>
<DT><SPAN class=term>keycode</SPAN> 
<DD>
<P>map of scancodes to keycodes for this device </P>
<DT><SPAN class=term>setkeycode</SPAN> 
<DD>
<P>optional method to alter current keymap, used to implement sparse keymaps. If not supplied default mechanism will be used. The method is being called while holding event_lock and thus must not sleep </P>
<DT><SPAN class=term>getkeycode</SPAN> 
<DD>
<P>optional legacy method to retrieve current keymap. </P>
<DT><SPAN class=term>ff</SPAN> 
<DD>
<P>force feedback structure associated with the device if device supports force feedback effects </P>
<DT><SPAN class=term>repeat_key</SPAN> 
<DD>
<P>stores key code of the last key pressed; used to implement software autorepeat </P>
<DT><SPAN class=term>timer</SPAN> 
<DD>
<P>timer for software autorepeat </P>
<DT><SPAN class=term>rep[REP_CNT]</SPAN> 
<DD>
<P>current values for autorepeat parameters (delay, rate) </P>
<DT><SPAN class=term>mt</SPAN> 
<DD>
<P>pointer to multitouch state </P>
<DT><SPAN class=term>absinfo</SPAN> 
<DD>
<P>array of <SPAN class=structname>struct input_absinfo</SPAN> elements holding information about absolute axes (current value, min, max, flat, fuzz, resolution) </P>
<DT><SPAN class=term>key[BITS_TO_LONGS(KEY_CNT)]</SPAN> 
<DD>
<P>reflects current state of device's keys/buttons </P>
<DT><SPAN class=term>led[BITS_TO_LONGS(LED_CNT)]</SPAN> 
<DD>
<P>reflects current state of device's LEDs </P>
<DT><SPAN class=term>snd[BITS_TO_LONGS(SND_CNT)]</SPAN> 
<DD>
<P>reflects current state of sound effects </P>
<DT><SPAN class=term>sw[BITS_TO_LONGS(SW_CNT)]</SPAN> 
<DD>
<P>reflects current state of device's switches </P>
<DT><SPAN class=term>open</SPAN> 
<DD>
<P>this method is called when the very first user calls <CODE class=function>input_open_device</CODE>. The driver must prepare the device to start generating events (start polling thread, request an IRQ, submit URB, etc.) </P>
<DT><SPAN class=term>close</SPAN> 
<DD>
<P>this method is called when the very last user calls <CODE class=function>input_close_device</CODE>. </P>
<DT><SPAN class=term>flush</SPAN> 
<DD>
<P>purges the device. Most commonly used to get rid of force feedback effects loaded into the device when disconnecting from it </P>
<DT><SPAN class=term>event</SPAN> 
<DD>
<P>event handler for events sent _to_ the device, like EV_LED or EV_SND. The device is expected to carry out the requested action (turn on a LED, play sound, etc.) The call is protected by <EM class=parameter><CODE>event_lock</CODE></EM> and must not sleep </P>
<DT><SPAN class=term>grab</SPAN> 
<DD>
<P>input handle that currently has the device grabbed (via EVIOCGRAB ioctl). When a handle grabs a device it becomes sole recipient for all input events coming from the device </P>
<DT><SPAN class=term>event_lock</SPAN> 
<DD>
<P>this spinlock is is taken when input core receives and processes a new event for the device (in <CODE class=function>input_event</CODE>). Code that accesses and/or modifies parameters of a device (such as keymap or absmin, absmax, absfuzz, etc.) after device has been registered with input core must take this lock. </P>
<DT><SPAN class=term>mutex</SPAN> 
<DD>
<P>serializes calls to <CODE class=function>open</CODE>, <CODE class=function>close</CODE> and <CODE class=function>flush</CODE> methods </P>
<DT><SPAN class=term>users</SPAN> 
<DD>
<P>stores number of users (input handlers) that opened this device. It is used by <CODE class=function>input_open_device</CODE> and <CODE class=function>input_close_device</CODE> to make sure that dev-&gt;<CODE class=function>open</CODE> is only called when the first user opens device and dev-&gt;<CODE class=function>close</CODE> is called when the very last user closes the device </P>
<DT><SPAN class=term>going_away</SPAN> 
<DD>
<P>marks devices that are in a middle of unregistering and causes input_open_device*() fail with -ENODEV. </P>
<DT><SPAN class=term>dev</SPAN> 
<DD>
<P>driver model's view of this device </P>
<DT><SPAN class=term>h_list</SPAN> 
<DD>
<P>list of input handles associated with the device. When accessing the list dev-&gt;mutex must be held </P>
<DT><SPAN class=term>node</SPAN> 
<DD>
<P>used to place the device onto input_dev_list </P>
<DT><SPAN class=term>num_vals</SPAN> 
<DD>
<P>number of values queued in the current frame </P>
<DT><SPAN class=term>max_vals</SPAN> 
<DD>
<P>maximum number of values queued in a frame </P>
<DT><SPAN class=term>vals</SPAN> 
<DD>
<P>array of values queued in the current frame </P>
<DT><SPAN class=term>devres_managed</SPAN> 
<DD>
<P>indicates that devices is managed with devres framework and needs not be explicitly unregistered or freed. </P></DD></DL></DIV></DIV></DIV>
<DIV class=navfooter>
<HR>

<TABLE summary="Navigation footer" width="100%">
<TBODY>
<TR>
<TD width="40%" align=left><A accessKey=p href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-value.html">Prev</A>&nbsp;</TD>
<TD width="20%" align=middle><A accessKey=u href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/input_subsystem.html#idp48614908">Up</A></TD>
<TD width="40%" align=right>&nbsp;<A accessKey=n href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-handler.html">Next</A></TD></TR>
<TR>
<TD vAlign=top width="40%" align=left><SPAN class=phrase>struct input_value</SPAN>&nbsp;</TD>
<TD width="20%" align=middle><A accessKey=h href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/index.html">Home</A></TD>
<TD vAlign=top width="40%" align=right>&nbsp;<SPAN class=phrase>struct input_handler</SPAN></TD></TR></TBODY></TABLE></DIV>