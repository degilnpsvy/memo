<DIV class=navheader>
<TABLE summary="Navigation header" width="100%">
<TBODY>
<TR>
<TH colSpan=3 align=middle><SPAN class=phrase>struct input_handler</SPAN></TH></TR>
<TR>
<TD width="20%" align=left><A accessKey=p href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-dev.html">Prev</A>&nbsp;</TD>
<TH width="60%" align=middle>Input core</TH>
<TD width="20%" align=right>&nbsp;<A accessKey=n href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-handle.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=refentry><A name=API-struct-input-handler></A>
<DIV class=titlepage></DIV>
<DIV class=refnamediv>
<H2>Name</H2>
<P>struct input_handler &#8212; implements one of interfaces for input devices </P></DIV>
<DIV class=refsynopsisdiv>
<H2>Synopsis</H2><PRE class=programlisting>struct input_handler {
  void * private;
  void (* event) (struct input_handle *handle, unsigned int type, unsigned int code, int value);
  void (* events) (struct input_handle *handle,const struct input_value *vals, unsigned int count);
  bool (* filter) (struct input_handle *handle, unsigned int type, unsigned int code, int value);
  bool (* match) (struct input_handler *handler, struct input_dev *dev);
  int (* connect) (struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);
  void (* disconnect) (struct input_handle *handle);
  void (* start) (struct input_handle *handle);
  bool legacy_minors;
  int minor;
  const char * name;
  const struct input_device_id * id_table;
  struct list_head h_list;
  struct list_head node;
};  </PRE></DIV>
<DIV class=refsect1><A name=idp48673588></A>
<H2>Members</H2>
<DIV class=variablelist>
<DL class=variablelist>
<DT><SPAN class=term>private</SPAN> 
<DD>
<P>driver-specific data </P>
<DT><SPAN class=term>event</SPAN> 
<DD>
<P>event handler. This method is being called by input core with interrupts disabled and dev-&gt;event_lock spinlock held and so it may not sleep </P>
<DT><SPAN class=term>events</SPAN> 
<DD>
<P>event sequence handler. This method is being called by input core with interrupts disabled and dev-&gt;event_lock spinlock held and so it may not sleep </P>
<DT><SPAN class=term>filter</SPAN> 
<DD>
<P>similar to <EM class=parameter><CODE>event</CODE></EM>; separates normal event handlers from <SPAN class=quote>&#8220;<SPAN class=quote>filters</SPAN>&#8221;</SPAN>. </P>
<DT><SPAN class=term>match</SPAN> 
<DD>
<P>called after comparing device's id with handler's id_table to perform fine-grained matching between device and handler </P>
<DT><SPAN class=term>connect</SPAN> 
<DD>
<P>called when attaching a handler to an input device </P>
<DT><SPAN class=term>disconnect</SPAN> 
<DD>
<P>disconnects a handler from input device </P>
<DT><SPAN class=term>start</SPAN> 
<DD>
<P>starts handler for given handle. This function is called by input core right after <CODE class=function>connect</CODE> method and also when a process that <SPAN class=quote>&#8220;<SPAN class=quote>grabbed</SPAN>&#8221;</SPAN> a device releases it </P>
<DT><SPAN class=term>legacy_minors</SPAN> 
<DD>
<P>set to <CODE class=constant>true</CODE> by drivers using legacy minor ranges </P>
<DT><SPAN class=term>minor</SPAN> 
<DD>
<P>beginning of range of 32 legacy minors for devices this driver can provide </P>
<DT><SPAN class=term>name</SPAN> 
<DD>
<P>name of the handler, to be shown in /proc/bus/input/handlers </P>
<DT><SPAN class=term>id_table</SPAN> 
<DD>
<P>pointer to a table of input_device_ids this driver can handle </P>
<DT><SPAN class=term>h_list</SPAN> 
<DD>
<P>list of input handles associated with the handler </P>
<DT><SPAN class=term>node</SPAN> 
<DD>
<P>for placing the driver onto input_handler_list </P></DD></DL></DIV></DIV>
<DIV class=refsect1><A name=idp48686164></A>
<H2>Description</H2>
<P>Input handlers attach to input devices and create input handles. There are likely several handlers attached to any given input device at the same time. All of them will get their copy of input event generated by the device. </P>
<P>The very same structure is used to implement input filters. Input core allows filters to run first and will not pass event to regular handlers if any of the filters indicate that the event should be filtered (by returning <CODE class=constant>true</CODE> from their <CODE class=function>filter</CODE> method). </P>
<P>Note that input core serializes calls to <CODE class=function>connect</CODE> and <CODE class=function>disconnect</CODE> methods. </P></DIV></DIV>
<DIV class=navfooter>
<HR>

<TABLE summary="Navigation footer" width="100%">
<TBODY>
<TR>
<TD width="40%" align=left><A accessKey=p href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-dev.html">Prev</A>&nbsp;</TD>
<TD width="20%" align=middle><A accessKey=u href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/input_subsystem.html#idp48614908">Up</A></TD>
<TD width="40%" align=right>&nbsp;<A accessKey=n href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/API-struct-input-handle.html">Next</A></TD></TR>
<TR>
<TD vAlign=top width="40%" align=left><SPAN class=phrase>struct input_dev</SPAN>&nbsp;</TD>
<TD width="20%" align=middle><A accessKey=h href="file:///C:/Users/donpope_tang/Documents/docbook/device-drivers/index.html">Home</A></TD>
<TD vAlign=top width="40%" align=right>&nbsp;<SPAN class=phrase>struct input_handle</SPAN></TD></TR></TBODY></TABLE></DIV>