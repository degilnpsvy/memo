# Documentation/RCU/listRCU.txt
<P></P>
<P>Using RCU to Protect Read-Mostly Linked Lists</P>
<P></P>
<P><BR>One of the best applications of RCU is to protect read-mostly linked lists<BR>("struct list_head" in list.h).&nbsp; One big advantage of this approach<BR>is that all of the required memory barriers are included for you in<BR>the list macros.&nbsp; This document describes several applications of RCU,<BR>with the best fits first.</P>
<P><BR>Example 1: Read-Side Action Taken Outside of Lock, No In-Place Updates</P>
<P>The best applications are cases where, if reader-writer locking were<BR>used, the read-side lock would be dropped before taking any action<BR>based on the results of the search.&nbsp; The most celebrated example is<BR>the routing table.&nbsp; Because the routing table is tracking the state of<BR>equipment outside of the computer, it will at times contain stale data.<BR>Therefore, once the route has been computed, there is no need to hold<BR>the routing table static during transmission of the packet.&nbsp; After all,<BR>you can hold the routing table static all you want, but that won't keep<BR>the external Internet from changing, and it is the state of the external<BR>Internet that really matters.&nbsp; In addition, routing entries are typically<BR>added or deleted, rather than being modified in place.</P>
<P>A straightforward example of this use of RCU may be found in the<BR>system-call auditing support.&nbsp; For example, a reader-writer locked<BR>implementation of audit_filter_task() might be as follows:</P>
<P>&nbsp;static enum audit_state audit_filter_task(struct task_struct *tsk)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry *e;<BR>&nbsp;&nbsp;enum audit_state&nbsp;&nbsp; state;</P>
<P>&nbsp;&nbsp;read_lock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;/* Note: audit_netlink_sem held by caller. */<BR>&nbsp;&nbsp;list_for_each_entry(e, &amp;audit_tsklist, list) {<BR>&nbsp;&nbsp;&nbsp;if (audit_filter_rules(tsk, &amp;e-&gt;rule, NULL, &amp;state)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;read_unlock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return state;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;read_unlock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;return AUDIT_BUILD_CONTEXT;<BR>&nbsp;}</P>
<P>Here the list is searched under the lock, but the lock is dropped before<BR>the corresponding value is returned.&nbsp; By the time that this value is acted<BR>on, the list may well have been modified.&nbsp; This makes sense, since if<BR>you are turning auditing off, it is OK to audit a few extra system calls.</P>
<P>This means that RCU can be easily applied to the read side, as follows:</P>
<P>&nbsp;static enum audit_state audit_filter_task(struct task_struct *tsk)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry *e;<BR>&nbsp;&nbsp;enum audit_state&nbsp;&nbsp; state;</P>
<P>&nbsp;&nbsp;rcu_read_lock();<BR>&nbsp;&nbsp;/* Note: audit_netlink_sem held by caller. */<BR>&nbsp;&nbsp;list_for_each_entry_rcu(e, &amp;audit_tsklist, list) {<BR>&nbsp;&nbsp;&nbsp;if (audit_filter_rules(tsk, &amp;e-&gt;rule, NULL, &amp;state)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;rcu_read_unlock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;return state;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;rcu_read_unlock();<BR>&nbsp;&nbsp;return AUDIT_BUILD_CONTEXT;<BR>&nbsp;}</P>
<P>The read_lock() and read_unlock() calls have become rcu_read_lock()<BR>and rcu_read_unlock(), respectively, and the list_for_each_entry() has<BR>become list_for_each_entry_rcu().&nbsp; The _rcu() list-traversal primitives<BR>insert the read-side memory barriers that are required on DEC Alpha CPUs.</P>
<P>The changes to the update side are also straightforward.&nbsp; A reader-writer<BR>lock might be used as follows for deletion and insertion:</P>
<P>&nbsp;static inline int audit_del_rule(struct audit_rule *rule,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *list)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry&nbsp; *e;</P>
<P>&nbsp;&nbsp;write_lock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;list_for_each_entry(e, list, list) {<BR>&nbsp;&nbsp;&nbsp;if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;list_del(&amp;e-&gt;list);<BR>&nbsp;&nbsp;&nbsp;&nbsp;write_unlock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;write_unlock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;return -EFAULT;&nbsp;&nbsp;/* No matching rule */<BR>&nbsp;}</P>
<P>&nbsp;static inline int audit_add_rule(struct audit_entry *entry,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *list)<BR>&nbsp;{<BR>&nbsp;&nbsp;write_lock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;if (entry-&gt;rule.flags &amp; AUDIT_PREPEND) {<BR>&nbsp;&nbsp;&nbsp;entry-&gt;rule.flags &amp;= ~AUDIT_PREPEND;<BR>&nbsp;&nbsp;&nbsp;list_add(&amp;entry-&gt;list, list);<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;list_add_tail(&amp;entry-&gt;list, list);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;write_unlock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>Following are the RCU equivalents for these two functions:</P>
<P>&nbsp;static inline int audit_del_rule(struct audit_rule *rule,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *list)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry&nbsp; *e;</P>
<P>&nbsp;&nbsp;/* Do not use the _rcu iterator here, since this is the only<BR>&nbsp;&nbsp; * deletion routine. */<BR>&nbsp;&nbsp;list_for_each_entry(e, list, list) {<BR>&nbsp;&nbsp;&nbsp;if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;list_del_rcu(&amp;e-&gt;list);<BR>&nbsp;&nbsp;&nbsp;&nbsp;call_rcu(&amp;e-&gt;rcu, audit_free_rule);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;return -EFAULT;&nbsp;&nbsp;/* No matching rule */<BR>&nbsp;}</P>
<P>&nbsp;static inline int audit_add_rule(struct audit_entry *entry,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *list)<BR>&nbsp;{<BR>&nbsp;&nbsp;if (entry-&gt;rule.flags &amp; AUDIT_PREPEND) {<BR>&nbsp;&nbsp;&nbsp;entry-&gt;rule.flags &amp;= ~AUDIT_PREPEND;<BR>&nbsp;&nbsp;&nbsp;list_add_rcu(&amp;entry-&gt;list, list);<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;list_add_tail_rcu(&amp;entry-&gt;list, list);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>Normally, the write_lock() and write_unlock() would be replaced by<BR>a spin_lock() and a spin_unlock(), but in this case, all callers hold<BR>audit_netlink_sem, so no additional locking is required.&nbsp; The auditsc_lock<BR>can therefore be eliminated, since use of RCU eliminates the need for<BR>writers to exclude readers.&nbsp; Normally, the write_lock() calls would<BR>be converted into spin_lock() calls.</P>
<P>The list_del(), list_add(), and list_add_tail() primitives have been<BR>replaced by list_del_rcu(), list_add_rcu(), and list_add_tail_rcu().<BR>The _rcu() list-manipulation primitives add memory barriers that are<BR>needed on weakly ordered CPUs (most of them!).&nbsp; The list_del_rcu()<BR>primitive omits the pointer poisoning debug-assist code that would<BR>otherwise cause concurrent readers to fail spectacularly.</P>
<P>So, when readers can tolerate stale data and when entries are either added<BR>or deleted, without in-place modification, it is very easy to use RCU!</P>
<P><BR>Example 2: Handling In-Place Updates</P>
<P>The system-call auditing code does not update auditing rules in place.<BR>However, if it did, reader-writer-locked code to do so might look as<BR>follows (presumably, the field_count is only permitted to decrease,<BR>otherwise, the added fields would need to be filled in):</P>
<P>&nbsp;static inline int audit_upd_rule(struct audit_rule *rule,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __u32 newaction,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __u32 newfield_count)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry&nbsp; *e;<BR>&nbsp;&nbsp;struct audit_newentry *ne;</P>
<P>&nbsp;&nbsp;write_lock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;/* Note: audit_netlink_sem held by caller. */<BR>&nbsp;&nbsp;list_for_each_entry(e, list, list) {<BR>&nbsp;&nbsp;&nbsp;if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;rule.action = newaction;<BR>&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;rule.file_count = newfield_count;<BR>&nbsp;&nbsp;&nbsp;&nbsp;write_unlock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;write_unlock(&amp;auditsc_lock);<BR>&nbsp;&nbsp;return -EFAULT;&nbsp;&nbsp;/* No matching rule */<BR>&nbsp;}</P>
<P>The RCU version creates a copy, updates the copy, then replaces the old<BR>entry with the newly updated entry.&nbsp; This sequence of actions, allowing<BR>concurrent reads while doing a copy to perform an update, is what gives<BR>RCU ("read-copy update") its name.&nbsp; The RCU code is as follows:</P>
<P>&nbsp;static inline int audit_upd_rule(struct audit_rule *rule,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __u32 newaction,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __u32 newfield_count)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry&nbsp; *e;<BR>&nbsp;&nbsp;struct audit_newentry *ne;</P>
<P>&nbsp;&nbsp;list_for_each_entry(e, list, list) {<BR>&nbsp;&nbsp;&nbsp;if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;ne = kmalloc(sizeof(*entry), GFP_ATOMIC);<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (ne == NULL)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;&nbsp;&nbsp;&nbsp;audit_copy_rule(&amp;ne-&gt;rule, &amp;e-&gt;rule);<BR>&nbsp;&nbsp;&nbsp;&nbsp;ne-&gt;rule.action = newaction;<BR>&nbsp;&nbsp;&nbsp;&nbsp;ne-&gt;rule.file_count = newfield_count;<BR>&nbsp;&nbsp;&nbsp;&nbsp;list_replace_rcu(&amp;e-&gt;list, &amp;ne-&gt;list);<BR>&nbsp;&nbsp;&nbsp;&nbsp;call_rcu(&amp;e-&gt;rcu, audit_free_rule);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;return -EFAULT;&nbsp;&nbsp;/* No matching rule */<BR>&nbsp;}</P>
<P>Again, this assumes that the caller holds audit_netlink_sem.&nbsp; Normally,<BR>the reader-writer lock would become a spinlock in this sort of code.</P>
<P><BR>Example 3: Eliminating Stale Data</P>
<P>The auditing examples above tolerate stale data, as do most algorithms<BR>that are tracking external state.&nbsp; Because there is a delay from the<BR>time the external state changes before Linux becomes aware of the change,<BR>additional RCU-induced staleness is normally not a problem.</P>
<P>However, there are many examples where stale data cannot be tolerated.<BR>One example in the Linux kernel is the System V IPC (see the ipc_lock()<BR>function in ipc/util.c).&nbsp; This code checks a "deleted" flag under a<BR>per-entry spinlock, and, if the "deleted" flag is set, pretends that the<BR>entry does not exist.&nbsp; For this to be helpful, the search function must<BR>return holding the per-entry spinlock, as ipc_lock() does in fact do.</P>
<P>Quick Quiz:&nbsp; Why does the search function need to return holding the<BR>&nbsp;per-entry lock for this deleted-flag technique to be helpful?</P>
<P>If the system-call audit module were to ever need to reject stale data,<BR>one way to accomplish this would be to add a "deleted" flag and a "lock"<BR>spinlock to the audit_entry structure, and modify audit_filter_task()<BR>as follows:</P>
<P>&nbsp;static enum audit_state audit_filter_task(struct task_struct *tsk)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry *e;<BR>&nbsp;&nbsp;enum audit_state&nbsp;&nbsp; state;</P>
<P>&nbsp;&nbsp;rcu_read_lock();<BR>&nbsp;&nbsp;list_for_each_entry_rcu(e, &amp;audit_tsklist, list) {<BR>&nbsp;&nbsp;&nbsp;if (audit_filter_rules(tsk, &amp;e-&gt;rule, NULL, &amp;state)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;e-&gt;lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (e-&gt;deleted) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;e-&gt;lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcu_read_unlock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return AUDIT_BUILD_CONTEXT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;rcu_read_unlock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;return state;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;rcu_read_unlock();<BR>&nbsp;&nbsp;return AUDIT_BUILD_CONTEXT;<BR>&nbsp;}</P>
<P>Note that this example assumes that entries are only added and deleted.<BR>Additional mechanism is required to deal correctly with the<BR>update-in-place performed by audit_upd_rule().&nbsp; For one thing,<BR>audit_upd_rule() would need additional memory barriers to ensure<BR>that the list_add_rcu() was really executed before the list_del_rcu().</P>
<P>The audit_del_rule() function would need to set the "deleted"<BR>flag under the spinlock as follows:</P>
<P>&nbsp;static inline int audit_del_rule(struct audit_rule *rule,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *list)<BR>&nbsp;{<BR>&nbsp;&nbsp;struct audit_entry&nbsp; *e;</P>
<P>&nbsp;&nbsp;/* Do not need to use the _rcu iterator here, since this<BR>&nbsp;&nbsp; * is the only deletion routine. */<BR>&nbsp;&nbsp;list_for_each_entry(e, list, list) {<BR>&nbsp;&nbsp;&nbsp;if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;e-&gt;lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;list_del_rcu(&amp;e-&gt;list);<BR>&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;deleted = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;e-&gt;lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;call_rcu(&amp;e-&gt;rcu, audit_free_rule);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;return -EFAULT;&nbsp;&nbsp;/* No matching rule */<BR>&nbsp;}</P>
<P><BR>Summary</P>
<P>Read-mostly list-based data structures that can tolerate stale data are<BR>the most amenable to use of RCU.&nbsp; The simplest case is where entries are<BR>either added or deleted from the data structure (or atomically modified<BR>in place), but non-atomic in-place modifications can be handled by making<BR>a copy, updating the copy, then replacing the original with the copy.<BR>If stale data cannot be tolerated, then a "deleted" flag may be used<BR>in conjunction with a per-entry spinlock in order to allow the search<BR>function to reject newly deleted data.</P>
<P><BR>Answer to Quick Quiz<BR>&nbsp;Why does the search function need to return holding the per-entry<BR>&nbsp;lock for this deleted-flag technique to be helpful?</P>
<P>&nbsp;If the search function drops the per-entry lock before returning,<BR>&nbsp;then the caller will be processing stale data in any case.&nbsp; If it<BR>&nbsp;is really OK to be processing stale data, then you don't need a<BR>&nbsp;"deleted" flag.&nbsp; If processing stale data really is a problem,<BR>&nbsp;then you need to hold the per-entry lock across all of the code<BR>&nbsp;that uses the value that was returned.