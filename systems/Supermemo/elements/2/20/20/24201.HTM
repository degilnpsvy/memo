# Documentation/RCU/trace.txt
<P></P>
<P>CONFIG_RCU_TRACE debugfs Files and Formats</P>
<P></P>
<P><BR>The rcutree and rcutiny implementations of RCU provide debugfs trace<BR>output that summarizes counters and state.&nbsp; This information is useful for<BR>debugging RCU itself, and can sometimes also help to debug abuses of RCU.<BR>The following sections describe the debugfs files and formats, first<BR>for rcutree and next for rcutiny.</P>
<P><BR>CONFIG_TREE_RCU and CONFIG_TREE_PREEMPT_RCU debugfs Files and Formats</P>
<P>These implementations of RCU provide several debugfs directories under the<BR>top-level directory "rcu":</P>
<P>rcu/rcu_bh<BR>rcu/rcu_preempt<BR>rcu/rcu_sched</P>
<P>Each directory contains files for the corresponding flavor of RCU.<BR>Note that rcu/rcu_preempt is only present for CONFIG_TREE_PREEMPT_RCU.<BR>For CONFIG_TREE_RCU, the RCU flavor maps onto the RCU-sched flavor,<BR>so that activity for both appears in rcu/rcu_sched.</P>
<P>In addition, the following file appears in the top-level directory:<BR>rcu/rcutorture.&nbsp; This file displays rcutorture test progress.&nbsp; The output<BR>of "cat rcu/rcutorture" looks as follows:</P>
<P>rcutorture test sequence: 0 (test in progress)<BR>rcutorture update version number: 615</P>
<P>The first line shows the number of rcutorture tests that have completed<BR>since boot.&nbsp; If a test is currently running, the "(test in progress)"<BR>string will appear as shown above.&nbsp; The second line shows the number of<BR>update cycles that the current test has started, or zero if there is<BR>no test in progress.</P>
<P><BR>Within each flavor directory (rcu/rcu_bh, rcu/rcu_sched, and possibly<BR>also rcu/rcu_preempt) the following files will be present:</P>
<P>rcudata:<BR>&nbsp;Displays fields in struct rcu_data.<BR>rcuexp:<BR>&nbsp;Displays statistics for expedited grace periods.<BR>rcugp:<BR>&nbsp;Displays grace-period counters.<BR>rcuhier:<BR>&nbsp;Displays the struct rcu_node hierarchy.<BR>rcu_pending:<BR>&nbsp;Displays counts of the reasons rcu_pending() decided that RCU had<BR>&nbsp;work to do.<BR>rcuboost:<BR>&nbsp;Displays RCU boosting statistics.&nbsp; Only present if<BR>&nbsp;CONFIG_RCU_BOOST=y.</P>
<P>The output of "cat rcu/rcu_preempt/rcudata" looks as follows:</P>
<P>&nbsp; 0!c=30455 g=30456 pq=1 qp=1 dt=126535/140000000000000/0 df=2002 of=4 ql=0/0 qs=N... b=10 ci=74572 nci=0 co=1131 ca=716<BR>&nbsp; 1!c=30719 g=30720 pq=1 qp=0 dt=132007/140000000000000/0 df=1874 of=10 ql=0/0 qs=N... b=10 ci=123209 nci=0 co=685 ca=982<BR>&nbsp; 2!c=30150 g=30151 pq=1 qp=1 dt=138537/140000000000000/0 df=1707 of=8 ql=0/0 qs=N... b=10 ci=80132 nci=0 co=1328 ca=1458<BR>&nbsp; 3 c=31249 g=31250 pq=1 qp=0 dt=107255/140000000000000/0 df=1749 of=6 ql=0/450 qs=NRW. b=10 ci=151700 nci=0 co=509 ca=622<BR>&nbsp; 4!c=29502 g=29503 pq=1 qp=1 dt=83647/140000000000000/0 df=965 of=5 ql=0/0 qs=N... b=10 ci=65643 nci=0 co=1373 ca=1521<BR>&nbsp; 5 c=31201 g=31202 pq=1 qp=1 dt=70422/0/0 df=535 of=7 ql=0/0 qs=.... b=10 ci=58500 nci=0 co=764 ca=698<BR>&nbsp; 6!c=30253 g=30254 pq=1 qp=1 dt=95363/140000000000000/0 df=780 of=5 ql=0/0 qs=N... b=10 ci=100607 nci=0 co=1414 ca=1353<BR>&nbsp; 7 c=31178 g=31178 pq=1 qp=0 dt=91536/0/0 df=547 of=4 ql=0/0 qs=.... b=10 ci=109819 nci=0 co=1115 ca=969</P>
<P>This file has one line per CPU, or eight for this 8-CPU system.<BR>The fields are as follows:</P>
<P>o&nbsp;The number at the beginning of each line is the CPU number.<BR>&nbsp;CPUs numbers followed by an exclamation mark are offline,<BR>&nbsp;but have been online at least once since boot.&nbsp;There will be<BR>&nbsp;no output for CPUs that have never been online, which can be<BR>&nbsp;a good thing in the surprisingly common case where NR_CPUS is<BR>&nbsp;substantially larger than the number of actual CPUs.</P>
<P>o&nbsp;"c" is the count of grace periods that this CPU believes have<BR>&nbsp;completed.&nbsp; Offlined CPUs and CPUs in dynticks idle mode may lag<BR>&nbsp;quite a ways behind, for example, CPU 4 under "rcu_sched" above,<BR>&nbsp;which has been offline through 16 RCU grace periods.&nbsp; It is not<BR>&nbsp;unusual to see offline CPUs lagging by thousands of grace periods.<BR>&nbsp;Note that although the grace-period number is an unsigned long,<BR>&nbsp;it is printed out as a signed long to allow more human-friendly<BR>&nbsp;representation near boot time.</P>
<P>o&nbsp;"g" is the count of grace periods that this CPU believes have<BR>&nbsp;started.&nbsp; Again, offlined CPUs and CPUs in dynticks idle mode<BR>&nbsp;may lag behind.&nbsp; If the "c" and "g" values are equal, this CPU<BR>&nbsp;has already reported a quiescent state for the last RCU grace<BR>&nbsp;period that it is aware of, otherwise, the CPU believes that it<BR>&nbsp;owes RCU a quiescent state.</P>
<P>o&nbsp;"pq" indicates that this CPU has passed through a quiescent state<BR>&nbsp;for the current grace period.&nbsp; It is possible for "pq" to be<BR>&nbsp;"1" and "c" different than "g", which indicates that although<BR>&nbsp;the CPU has passed through a quiescent state, either (1) this<BR>&nbsp;CPU has not yet reported that fact, (2) some other CPU has not<BR>&nbsp;yet reported for this grace period, or (3) both.</P>
<P>o&nbsp;"qp" indicates that RCU still expects a quiescent state from<BR>&nbsp;this CPU.&nbsp; Offlined CPUs and CPUs in dyntick idle mode might<BR>&nbsp;well have qp=1, which is OK: RCU is still ignoring them.</P>
<P>o&nbsp;"dt" is the current value of the dyntick counter that is incremented<BR>&nbsp;when entering or leaving idle, either due to a context switch or<BR>&nbsp;due to an interrupt.&nbsp; This number is even if the CPU is in idle<BR>&nbsp;from RCU's viewpoint and odd otherwise.&nbsp; The number after the<BR>&nbsp;first "/" is the interrupt nesting depth when in idle state,<BR>&nbsp;or a large number added to the interrupt-nesting depth when<BR>&nbsp;running a non-idle task.&nbsp; Some architectures do not accurately<BR>&nbsp;count interrupt nesting when running in non-idle kernel context,<BR>&nbsp;which can result in interesting anomalies such as negative<BR>&nbsp;interrupt-nesting levels.&nbsp; The number after the second "/"<BR>&nbsp;is the NMI nesting depth.</P>
<P>o&nbsp;"df" is the number of times that some other CPU has forced a<BR>&nbsp;quiescent state on behalf of this CPU due to this CPU being in<BR>&nbsp;idle state.</P>
<P>o&nbsp;"of" is the number of times that some other CPU has forced a<BR>&nbsp;quiescent state on behalf of this CPU due to this CPU being<BR>&nbsp;offline.&nbsp; In a perfect world, this might never happen, but it<BR>&nbsp;turns out that offlining and onlining a CPU can take several grace<BR>&nbsp;periods, and so there is likely to be an extended period of time<BR>&nbsp;when RCU believes that the CPU is online when it really is not.<BR>&nbsp;Please note that erring in the other direction (RCU believing a<BR>&nbsp;CPU is offline when it is really alive and kicking) is a fatal<BR>&nbsp;error, so it makes sense to err conservatively.</P>
<P>o&nbsp;"ql" is the number of RCU callbacks currently residing on<BR>&nbsp;this CPU.&nbsp; The first number is the number of "lazy" callbacks<BR>&nbsp;that are known to RCU to only be freeing memory, and the number<BR>&nbsp;after the "/" is the total number of callbacks, lazy or not.<BR>&nbsp;These counters count callbacks regardless of what phase of<BR>&nbsp;grace-period processing that they are in (new, waiting for<BR>&nbsp;grace period to start, waiting for grace period to end, ready<BR>&nbsp;to invoke).</P>
<P>o&nbsp;"qs" gives an indication of the state of the callback queue<BR>&nbsp;with four characters:</P>
<P>&nbsp;"N"&nbsp;Indicates that there are callbacks queued that are not<BR>&nbsp;&nbsp;ready to be handled by the next grace period, and thus<BR>&nbsp;&nbsp;will be handled by the grace period following the next<BR>&nbsp;&nbsp;one.</P>
<P>&nbsp;"R"&nbsp;Indicates that there are callbacks queued that are<BR>&nbsp;&nbsp;ready to be handled by the next grace period.</P>
<P>&nbsp;"W"&nbsp;Indicates that there are callbacks queued that are<BR>&nbsp;&nbsp;waiting on the current grace period.</P>
<P>&nbsp;"D"&nbsp;Indicates that there are callbacks queued that have<BR>&nbsp;&nbsp;already been handled by a prior grace period, and are<BR>&nbsp;&nbsp;thus waiting to be invoked.&nbsp; Note that callbacks in<BR>&nbsp;&nbsp;the process of being invoked are not counted here.<BR>&nbsp;&nbsp;Callbacks in the process of being invoked are those<BR>&nbsp;&nbsp;that have been removed from the rcu_data structures<BR>&nbsp;&nbsp;queues by rcu_do_batch(), but which have not yet been<BR>&nbsp;&nbsp;invoked.</P>
<P>&nbsp;If there are no callbacks in a given one of the above states,<BR>&nbsp;the corresponding character is replaced by ".".</P>
<P>o&nbsp;"b" is the batch limit for this CPU.&nbsp; If more than this number<BR>&nbsp;of RCU callbacks is ready to invoke, then the remainder will<BR>&nbsp;be deferred.</P>
<P>o&nbsp;"ci" is the number of RCU callbacks that have been invoked for<BR>&nbsp;this CPU.&nbsp; Note that ci+nci+ql is the number of callbacks that have<BR>&nbsp;been registered in absence of CPU-hotplug activity.</P>
<P>o&nbsp;"nci" is the number of RCU callbacks that have been offloaded from<BR>&nbsp;this CPU.&nbsp; This will always be zero unless the kernel was built<BR>&nbsp;with CONFIG_RCU_NOCB_CPU=y and the "rcu_nocbs=" kernel boot<BR>&nbsp;parameter was specified.</P>
<P>o&nbsp;"co" is the number of RCU callbacks that have been orphaned due to<BR>&nbsp;this CPU going offline.&nbsp; These orphaned callbacks have been moved<BR>&nbsp;to an arbitrarily chosen online CPU.</P>
<P>o&nbsp;"ca" is the number of RCU callbacks that have been adopted by this<BR>&nbsp;CPU due to other CPUs going offline.&nbsp; Note that ci+co-ca+ql is<BR>&nbsp;the number of RCU callbacks registered on this CPU.</P>
<P><BR>Kernels compiled with CONFIG_RCU_BOOST=y display the following from<BR>/debug/rcu/rcu_preempt/rcudata:</P>
<P>&nbsp; 0!c=12865 g=12866 pq=1 qp=1 dt=83113/140000000000000/0 df=288 of=11 ql=0/0 qs=N... kt=0/O ktl=944 b=10 ci=60709 nci=0 co=748 ca=871<BR>&nbsp; 1 c=14407 g=14408 pq=1 qp=0 dt=100679/140000000000000/0 df=378 of=7 ql=0/119 qs=NRW. kt=0/W ktl=9b6 b=10 ci=109740 nci=0 co=589 ca=485<BR>&nbsp; 2 c=14407 g=14408 pq=1 qp=0 dt=105486/0/0 df=90 of=9 ql=0/89 qs=NRW. kt=0/W ktl=c0c b=10 ci=83113 nci=0 co=533 ca=490<BR>&nbsp; 3 c=14407 g=14408 pq=1 qp=0 dt=107138/0/0 df=142 of=8 ql=0/188 qs=NRW. kt=0/W ktl=b96 b=10 ci=121114 nci=0 co=426 ca=290<BR>&nbsp; 4 c=14405 g=14406 pq=1 qp=1 dt=50238/0/0 df=706 of=7 ql=0/0 qs=.... kt=0/W ktl=812 b=10 ci=34929 nci=0 co=643 ca=114<BR>&nbsp; 5!c=14168 g=14169 pq=1 qp=0 dt=45465/140000000000000/0 df=161 of=11 ql=0/0 qs=N... kt=0/O ktl=b4d b=10 ci=47712 nci=0 co=677 ca=722<BR>&nbsp; 6 c=14404 g=14405 pq=1 qp=0 dt=59454/0/0 df=94 of=6 ql=0/0 qs=.... kt=0/W ktl=e57 b=10 ci=55597 nci=0 co=701 ca=811<BR>&nbsp; 7 c=14407 g=14408 pq=1 qp=1 dt=68850/0/0 df=31 of=8 ql=0/0 qs=.... kt=0/W ktl=14bd b=10 ci=77475 nci=0 co=508 ca=1042</P>
<P>This is similar to the output discussed above, but contains the following<BR>additional fields:</P>
<P>o&nbsp;"kt" is the per-CPU kernel-thread state.&nbsp; The digit preceding<BR>&nbsp;the first slash is zero if there is no work pending and 1<BR>&nbsp;otherwise.&nbsp; The character between the first pair of slashes is<BR>&nbsp;as follows:</P>
<P>&nbsp;"S"&nbsp;The kernel thread is stopped, in other words, all<BR>&nbsp;&nbsp;CPUs corresponding to this rcu_node structure are<BR>&nbsp;&nbsp;offline.</P>
<P>&nbsp;"R"&nbsp;The kernel thread is running.</P>
<P>&nbsp;"W"&nbsp;The kernel thread is waiting because there is no work<BR>&nbsp;&nbsp;for it to do.</P>
<P>&nbsp;"O"&nbsp;The kernel thread is waiting because it has been<BR>&nbsp;&nbsp;forced off of its designated CPU or because its<BR>&nbsp;&nbsp;-&gt;cpus_allowed mask permits it to run on other than<BR>&nbsp;&nbsp;its designated CPU.</P>
<P>&nbsp;"Y"&nbsp;The kernel thread is yielding to avoid hogging CPU.</P>
<P>&nbsp;"?"&nbsp;Unknown value, indicates a bug.</P>
<P>&nbsp;The number after the final slash is the CPU that the kthread<BR>&nbsp;is actually running on.</P>
<P>&nbsp;This field is displayed only for CONFIG_RCU_BOOST kernels.</P>
<P>o&nbsp;"ktl" is the low-order 16 bits (in hexadecimal) of the count of<BR>&nbsp;the number of times that this CPU's per-CPU kthread has gone<BR>&nbsp;through its loop servicing invoke_rcu_cpu_kthread() requests.</P>
<P>&nbsp;This field is displayed only for CONFIG_RCU_BOOST kernels.</P>
<P><BR>The output of "cat rcu/rcu_preempt/rcuexp" looks as follows:</P>
<P>s=21872 d=21872 w=0 tf=0 wd1=0 wd2=0 n=0 sc=21872 dt=21872 dl=0 dx=21872</P>
<P>These fields are as follows:</P>
<P>o&nbsp;"s" is the starting sequence number.</P>
<P>o&nbsp;"d" is the ending sequence number.&nbsp; When the starting and ending<BR>&nbsp;numbers differ, there is an expedited grace period in progress.</P>
<P>o&nbsp;"w" is the number of times that the sequence numbers have been<BR>&nbsp;in danger of wrapping.</P>
<P>o&nbsp;"tf" is the number of times that contention has resulted in a<BR>&nbsp;failure to begin an expedited grace period.</P>
<P>o&nbsp;"wd1" and "wd2" are the number of times that an attempt to<BR>&nbsp;start an expedited grace period found that someone else had<BR>&nbsp;completed an expedited grace period that satisfies the<BR>&nbsp;attempted request.&nbsp; "Our work is done."</P>
<P>o&nbsp;"n" is number of times that contention was so great that<BR>&nbsp;the request was demoted from an expedited grace period to<BR>&nbsp;a normal grace period.</P>
<P>o&nbsp;"sc" is the number of times that the attempt to start a<BR>&nbsp;new expedited grace period succeeded.</P>
<P>o&nbsp;"dt" is the number of times that we attempted to update<BR>&nbsp;the "d" counter.</P>
<P>o&nbsp;"dl" is the number of times that we failed to update the "d"<BR>&nbsp;counter.</P>
<P>o&nbsp;"dx" is the number of times that we succeeded in updating<BR>&nbsp;the "d" counter.</P>
<P><BR>The output of "cat rcu/rcu_preempt/rcugp" looks as follows:</P>
<P>completed=31249&nbsp; gpnum=31250&nbsp; age=1&nbsp; max=18</P>
<P>These fields are taken from the rcu_state structure, and are as follows:</P>
<P>o&nbsp;"completed" is the number of grace periods that have completed.<BR>&nbsp;It is comparable to the "c" field from rcu/rcudata in that a<BR>&nbsp;CPU whose "c" field matches the value of "completed" is aware<BR>&nbsp;that the corresponding RCU grace period has completed.</P>
<P>o&nbsp;"gpnum" is the number of grace periods that have started.&nbsp; It is<BR>&nbsp;similarly comparable to the "g" field from rcu/rcudata in that<BR>&nbsp;a CPU whose "g" field matches the value of "gpnum" is aware that<BR>&nbsp;the corresponding RCU grace period has started.</P>
<P>&nbsp;If these two fields are equal, then there is no grace period<BR>&nbsp;in progress, in other words, RCU is idle.&nbsp; On the other hand,<BR>&nbsp;if the two fields differ (as they are above), then an RCU grace<BR>&nbsp;period is in progress.</P>
<P>o&nbsp;"age" is the number of jiffies that the current grace period<BR>&nbsp;has extended for, or zero if there is no grace period currently<BR>&nbsp;in effect.</P>
<P>o&nbsp;"max" is the age in jiffies of the longest-duration grace period<BR>&nbsp;thus far.</P>
<P>The output of "cat rcu/rcu_preempt/rcuhier" looks as follows:</P>
<P>c=14407 g=14408 s=0 jfq=2 j=c863 nfqs=12040/nfqsng=0(12040) fqlh=1051 oqlen=0/0<BR>3/3 ..&gt;. 0:7 ^0<BR>e/e ..&gt;. 0:3 ^0&nbsp;&nbsp;&nbsp; d/d ..&gt;. 4:7 ^1</P>
<P>The fields are as follows:</P>
<P>o&nbsp;"c" is exactly the same as "completed" under rcu/rcu_preempt/rcugp.</P>
<P>o&nbsp;"g" is exactly the same as "gpnum" under rcu/rcu_preempt/rcugp.</P>
<P>o&nbsp;"s" is the current state of the force_quiescent_state()<BR>&nbsp;state machine.</P>
<P>o&nbsp;"jfq" is the number of jiffies remaining for this grace period<BR>&nbsp;before force_quiescent_state() is invoked to help push things<BR>&nbsp;along.&nbsp;Note that CPUs in idle mode throughout the grace period<BR>&nbsp;will not report on their own, but rather must be check by some<BR>&nbsp;other CPU via force_quiescent_state().</P>
<P>o&nbsp;"j" is the low-order four hex digits of the jiffies counter.<BR>&nbsp;Yes, Paul did run into a number of problems that turned out to<BR>&nbsp;be due to the jiffies counter no longer counting.&nbsp; Why do you ask?</P>
<P>o&nbsp;"nfqs" is the number of calls to force_quiescent_state() since<BR>&nbsp;boot.</P>
<P>o&nbsp;"nfqsng" is the number of useless calls to force_quiescent_state(),<BR>&nbsp;where there wasn't actually a grace period active.&nbsp; This can<BR>&nbsp;no longer happen due to grace-period processing being pushed<BR>&nbsp;into a kthread.&nbsp; The number in parentheses is the difference<BR>&nbsp;between "nfqs" and "nfqsng", or the number of times that<BR>&nbsp;force_quiescent_state() actually did some real work.</P>
<P>o&nbsp;"fqlh" is the number of calls to force_quiescent_state() that<BR>&nbsp;exited immediately (without even being counted in nfqs above)<BR>&nbsp;due to contention on -&gt;fqslock.</P>
<P>o&nbsp;Each element of the form "3/3 ..&gt;. 0:7 ^0" represents one rcu_node<BR>&nbsp;structure.&nbsp; Each line represents one level of the hierarchy,<BR>&nbsp;from root to leaves.&nbsp; It is best to think of the rcu_data<BR>&nbsp;structures as forming yet another level after the leaves.<BR>&nbsp;Note that there might be either one, two, three, or even four<BR>&nbsp;levels of rcu_node structures, depending on the relationship<BR>&nbsp;between CONFIG_RCU_FANOUT, CONFIG_RCU_FANOUT_LEAF (possibly<BR>&nbsp;adjusted using the rcu_fanout_leaf kernel boot parameter), and<BR>&nbsp;CONFIG_NR_CPUS (possibly adjusted using the nr_cpu_ids count of<BR>&nbsp;possible CPUs for the booting hardware).</P>
<P>&nbsp;o&nbsp;The numbers separated by the "/" are the qsmask followed<BR>&nbsp;&nbsp;by the qsmaskinit.&nbsp; The qsmask will have one bit<BR>&nbsp;&nbsp;set for each entity in the next lower level that has<BR>&nbsp;&nbsp;not yet checked in for the current grace period ("e"<BR>&nbsp;&nbsp;indicating CPUs 5, 6, and 7 in the example above).<BR>&nbsp;&nbsp;The qsmaskinit will have one bit for each entity that is<BR>&nbsp;&nbsp;currently expected to check in during each grace period.<BR>&nbsp;&nbsp;The value of qsmaskinit is assigned to that of qsmask<BR>&nbsp;&nbsp;at the beginning of each grace period.</P>
<P>&nbsp;o&nbsp;The characters separated by the "&gt;" indicate the state<BR>&nbsp;&nbsp;of the blocked-tasks lists.&nbsp; A "G" preceding the "&gt;"<BR>&nbsp;&nbsp;indicates that at least one task blocked in an RCU<BR>&nbsp;&nbsp;read-side critical section blocks the current grace<BR>&nbsp;&nbsp;period, while a "E" preceding the "&gt;" indicates that<BR>&nbsp;&nbsp;at least one task blocked in an RCU read-side critical<BR>&nbsp;&nbsp;section blocks the current expedited grace period.<BR>&nbsp;&nbsp;A "T" character following the "&gt;" indicates that at<BR>&nbsp;&nbsp;least one task is blocked within an RCU read-side<BR>&nbsp;&nbsp;critical section, regardless of whether any current<BR>&nbsp;&nbsp;grace period (expedited or normal) is inconvenienced.<BR>&nbsp;&nbsp;A "." character appears if the corresponding condition<BR>&nbsp;&nbsp;does not hold, so that "..&gt;." indicates that no tasks<BR>&nbsp;&nbsp;are blocked.&nbsp; In contrast, "GE&gt;T" indicates maximal<BR>&nbsp;&nbsp;inconvenience from blocked tasks.&nbsp; CONFIG_TREE_RCU<BR>&nbsp;&nbsp;builds of the kernel will always show "..&gt;.".</P>
<P>&nbsp;o&nbsp;The numbers separated by the ":" are the range of CPUs<BR>&nbsp;&nbsp;served by this struct rcu_node.&nbsp; This can be helpful<BR>&nbsp;&nbsp;in working out how the hierarchy is wired together.</P>
<P>&nbsp;&nbsp;For example, the example rcu_node structure shown above<BR>&nbsp;&nbsp;has "0:7", indicating that it covers CPUs 0 through 7.</P>
<P>&nbsp;o&nbsp;The number after the "^" indicates the bit in the<BR>&nbsp;&nbsp;next higher level rcu_node structure that this rcu_node<BR>&nbsp;&nbsp;structure corresponds to.&nbsp; For example, the "d/d ..&gt;. 4:7<BR>&nbsp;&nbsp;^1" has a "1" in this position, indicating that it<BR>&nbsp;&nbsp;corresponds to the "1" bit in the "3" shown in the<BR>&nbsp;&nbsp;"3/3 ..&gt;. 0:7 ^0" entry on the next level up.</P>
<P><BR>The output of "cat rcu/rcu_sched/rcu_pending" looks as follows:</P>
<P>&nbsp; 0!np=26111 qsp=29 rpq=5386 cbr=1 cng=570 gpc=3674 gps=577 nn=15903<BR>&nbsp; 1!np=28913 qsp=35 rpq=6097 cbr=1 cng=448 gpc=3700 gps=554 nn=18113<BR>&nbsp; 2!np=32740 qsp=37 rpq=6202 cbr=0 cng=476 gpc=4627 gps=546 nn=20889<BR>&nbsp; 3 np=23679 qsp=22 rpq=5044 cbr=1 cng=415 gpc=3403 gps=347 nn=14469<BR>&nbsp; 4!np=30714 qsp=4 rpq=5574 cbr=0 cng=528 gpc=3931 gps=639 nn=20042<BR>&nbsp; 5 np=28910 qsp=2 rpq=5246 cbr=0 cng=428 gpc=4105 gps=709 nn=18422<BR>&nbsp; 6!np=38648 qsp=5 rpq=7076 cbr=0 cng=840 gpc=4072 gps=961 nn=25699<BR>&nbsp; 7 np=37275 qsp=2 rpq=6873 cbr=0 cng=868 gpc=3416 gps=971 nn=25147</P>
<P>The fields are as follows:</P>
<P>o&nbsp;The leading number is the CPU number, with "!" indicating<BR>&nbsp;an offline CPU.</P>
<P>o&nbsp;"np" is the number of times that __rcu_pending() has been invoked<BR>&nbsp;for the corresponding flavor of RCU.</P>
<P>o&nbsp;"qsp" is the number of times that the RCU was waiting for a<BR>&nbsp;quiescent state from this CPU.</P>
<P>o&nbsp;"rpq" is the number of times that the CPU had passed through<BR>&nbsp;a quiescent state, but not yet reported it to RCU.</P>
<P>o&nbsp;"cbr" is the number of times that this CPU had RCU callbacks<BR>&nbsp;that had passed through a grace period, and were thus ready<BR>&nbsp;to be invoked.</P>
<P>o&nbsp;"cng" is the number of times that this CPU needed another<BR>&nbsp;grace period while RCU was idle.</P>
<P>o&nbsp;"gpc" is the number of times that an old grace period had<BR>&nbsp;completed, but this CPU was not yet aware of it.</P>
<P>o&nbsp;"gps" is the number of times that a new grace period had started,<BR>&nbsp;but this CPU was not yet aware of it.</P>
<P>o&nbsp;"nn" is the number of times that this CPU needed nothing.</P>
<P><BR>The output of "cat rcu/rcuboost" looks as follows:</P>
<P>0:3 tasks=.... kt=W ntb=0 neb=0 nnb=0 j=c864 bt=c894<BR>&nbsp;&nbsp;&nbsp; balk: nt=0 egt=4695 bt=0 nb=0 ny=56 nos=0<BR>4:7 tasks=.... kt=W ntb=0 neb=0 nnb=0 j=c864 bt=c894<BR>&nbsp;&nbsp;&nbsp; balk: nt=0 egt=6541 bt=0 nb=0 ny=126 nos=0</P>
<P>This information is output only for rcu_preempt.&nbsp; Each two-line entry<BR>corresponds to a leaf rcu_node strcuture.&nbsp; The fields are as follows:</P>
<P>o&nbsp;"n:m" is the CPU-number range for the corresponding two-line<BR>&nbsp;entry.&nbsp; In the sample output above, the first entry covers<BR>&nbsp;CPUs zero through three and the second entry covers CPUs four<BR>&nbsp;through seven.</P>
<P>o&nbsp;"tasks=TNEB" gives the state of the various segments of the<BR>&nbsp;rnp-&gt;blocked_tasks list:</P>
<P>&nbsp;"T"&nbsp;This indicates that there are some tasks that blocked<BR>&nbsp;&nbsp;while running on one of the corresponding CPUs while<BR>&nbsp;&nbsp;in an RCU read-side critical section.</P>
<P>&nbsp;"N"&nbsp;This indicates that some of the blocked tasks are preventing<BR>&nbsp;&nbsp;the current normal (non-expedited) grace period from<BR>&nbsp;&nbsp;completing.</P>
<P>&nbsp;"E"&nbsp;This indicates that some of the blocked tasks are preventing<BR>&nbsp;&nbsp;the current expedited grace period from completing.</P>
<P>&nbsp;"B"&nbsp;This indicates that some of the blocked tasks are in<BR>&nbsp;&nbsp;need of RCU priority boosting.</P>
<P>&nbsp;Each character is replaced with "." if the corresponding<BR>&nbsp;condition does not hold.</P>
<P>o&nbsp;"kt" is the state of the RCU priority-boosting kernel<BR>&nbsp;thread associated with the corresponding rcu_node structure.<BR>&nbsp;The state can be one of the following:</P>
<P>&nbsp;"S"&nbsp;The kernel thread is stopped, in other words, all<BR>&nbsp;&nbsp;CPUs corresponding to this rcu_node structure are<BR>&nbsp;&nbsp;offline.</P>
<P>&nbsp;"R"&nbsp;The kernel thread is running.</P>
<P>&nbsp;"W"&nbsp;The kernel thread is waiting because there is no work<BR>&nbsp;&nbsp;for it to do.</P>
<P>&nbsp;"Y"&nbsp;The kernel thread is yielding to avoid hogging CPU.</P>
<P>&nbsp;"?"&nbsp;Unknown value, indicates a bug.</P>
<P>o&nbsp;"ntb" is the number of tasks boosted.</P>
<P>o&nbsp;"neb" is the number of tasks boosted in order to complete an<BR>&nbsp;expedited grace period.</P>
<P>o&nbsp;"nnb" is the number of tasks boosted in order to complete a<BR>&nbsp;normal (non-expedited) grace period.&nbsp; When boosting a task<BR>&nbsp;that was blocking both an expedited and a normal grace period,<BR>&nbsp;it is counted against the expedited total above.</P>
<P>o&nbsp;"j" is the low-order 16 bits of the jiffies counter in<BR>&nbsp;hexadecimal.</P>
<P>o&nbsp;"bt" is the low-order 16 bits of the value that the jiffies<BR>&nbsp;counter will have when we next start boosting, assuming that<BR>&nbsp;the current grace period does not end beforehand.&nbsp; This is<BR>&nbsp;also in hexadecimal.</P>
<P>o&nbsp;"balk: nt" counts the number of times we didn't boost (in<BR>&nbsp;other words, we balked) even though it was time to boost because<BR>&nbsp;there were no blocked tasks to boost.&nbsp; This situation occurs<BR>&nbsp;when there is one blocked task on one rcu_node structure and<BR>&nbsp;none on some other rcu_node structure.</P>
<P>o&nbsp;"egt" counts the number of times we balked because although<BR>&nbsp;there were blocked tasks, none of them were blocking the<BR>&nbsp;current grace period, whether expedited or otherwise.</P>
<P>o&nbsp;"bt" counts the number of times we balked because boosting<BR>&nbsp;had already been initiated for the current grace period.</P>
<P>o&nbsp;"nb" counts the number of times we balked because there<BR>&nbsp;was at least one task blocking the current non-expedited grace<BR>&nbsp;period that never had blocked.&nbsp; If it is already running, it<BR>&nbsp;just won't help to boost its priority!</P>
<P>o&nbsp;"ny" counts the number of times we balked because it was<BR>&nbsp;not yet time to start boosting.</P>
<P>o&nbsp;"nos" counts the number of times we balked for other<BR>&nbsp;reasons, e.g., the grace period ended first.</P>
<P><BR>CONFIG_TINY_RCU and CONFIG_TINY_PREEMPT_RCU debugfs Files and Formats</P>
<P>These implementations of RCU provides a single debugfs file under the<BR>top-level directory RCU, namely rcu/rcudata, which displays fields in<BR>rcu_bh_ctrlblk, rcu_sched_ctrlblk and, for CONFIG_TINY_PREEMPT_RCU,<BR>rcu_preempt_ctrlblk.</P>
<P>The output of "cat rcu/rcudata" is as follows:</P>
<P>rcu_preempt: qlen=24 gp=1097669 g197/p197/c197 tasks=...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttb=. btg=no ntb=184 neb=0 nnb=183 j=01f7 bt=0274<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal balk: nt=1097669 gt=0 bt=371 b=0 ny=25073378 nos=0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exp balk: bt=0 nos=0<BR>rcu_sched: qlen: 0<BR>rcu_bh: qlen: 0</P>
<P>This is split into rcu_preempt, rcu_sched, and rcu_bh sections, with the<BR>rcu_preempt section appearing only in CONFIG_TINY_PREEMPT_RCU builds.<BR>The last three lines of the rcu_preempt section appear only in<BR>CONFIG_RCU_BOOST kernel builds.&nbsp; The fields are as follows:</P>
<P>o&nbsp;"qlen" is the number of RCU callbacks currently waiting either<BR>&nbsp;for an RCU grace period or waiting to be invoked.&nbsp; This is the<BR>&nbsp;only field present for rcu_sched and rcu_bh, due to the<BR>&nbsp;short-circuiting of grace period in those two cases.</P>
<P>o&nbsp;"gp" is the number of grace periods that have completed.</P>
<P>o&nbsp;"g197/p197/c197" displays the grace-period state, with the<BR>&nbsp;"g" number being the number of grace periods that have started<BR>&nbsp;(mod 256), the "p" number being the number of grace periods<BR>&nbsp;that the CPU has responded to (also mod 256), and the "c"<BR>&nbsp;number being the number of grace periods that have completed<BR>&nbsp;(once again mode 256).</P>
<P>&nbsp;Why have both "gp" and "g"?&nbsp; Because the data flowing into<BR>&nbsp;"gp" is only present in a CONFIG_RCU_TRACE kernel.</P>
<P>o&nbsp;"tasks" is a set of bits.&nbsp; The first bit is "T" if there are<BR>&nbsp;currently tasks that have recently blocked within an RCU<BR>&nbsp;read-side critical section, the second bit is "N" if any of the<BR>&nbsp;aforementioned tasks are blocking the current RCU grace period,<BR>&nbsp;and the third bit is "E" if any of the aforementioned tasks are<BR>&nbsp;blocking the current expedited grace period.&nbsp; Each bit is "."<BR>&nbsp;if the corresponding condition does not hold.</P>
<P>o&nbsp;"ttb" is a single bit.&nbsp; It is "B" if any of the blocked tasks<BR>&nbsp;need to be priority boosted and "." otherwise.</P>
<P>o&nbsp;"btg" indicates whether boosting has been carried out during<BR>&nbsp;the current grace period, with "exp" indicating that boosting<BR>&nbsp;is in progress for an expedited grace period, "no" indicating<BR>&nbsp;that boosting has not yet started for a normal grace period,<BR>&nbsp;"begun" indicating that boosting has bebug for a normal grace<BR>&nbsp;period, and "done" indicating that boosting has completed for<BR>&nbsp;a normal grace period.</P>
<P>o&nbsp;"ntb" is the total number of tasks subjected to RCU priority boosting<BR>&nbsp;periods since boot.</P>
<P>o&nbsp;"neb" is the number of expedited grace periods that have had<BR>&nbsp;to resort to RCU priority boosting since boot.</P>
<P>o&nbsp;"nnb" is the number of normal grace periods that have had<BR>&nbsp;to resort to RCU priority boosting since boot.</P>
<P>o&nbsp;"j" is the low-order 16 bits of the jiffies counter in hexadecimal.</P>
<P>o&nbsp;"bt" is the low-order 16 bits of the value that the jiffies counter<BR>&nbsp;will have at the next time that boosting is scheduled to begin.</P>
<P>o&nbsp;In the line beginning with "normal balk", the fields are as follows:</P>
<P>&nbsp;o&nbsp;"nt" is the number of times that the system balked from<BR>&nbsp;&nbsp;boosting because there were no blocked tasks to boost.<BR>&nbsp;&nbsp;Note that the system will balk from boosting even if the<BR>&nbsp;&nbsp;grace period is overdue when the currently running task<BR>&nbsp;&nbsp;is looping within an RCU read-side critical section.<BR>&nbsp;&nbsp;There is no point in boosting in this case, because<BR>&nbsp;&nbsp;boosting a running task won't make it run any faster.</P>
<P>&nbsp;o&nbsp;"gt" is the number of times that the system balked<BR>&nbsp;&nbsp;from boosting because, although there were blocked tasks,<BR>&nbsp;&nbsp;none of them were preventing the current grace period<BR>&nbsp;&nbsp;from completing.</P>
<P>&nbsp;o&nbsp;"bt" is the number of times that the system balked<BR>&nbsp;&nbsp;from boosting because boosting was already in progress.</P>
<P>&nbsp;o&nbsp;"b" is the number of times that the system balked from<BR>&nbsp;&nbsp;boosting because boosting had already completed for<BR>&nbsp;&nbsp;the grace period in question.</P>
<P>&nbsp;o&nbsp;"ny" is the number of times that the system balked from<BR>&nbsp;&nbsp;boosting because it was not yet time to start boosting<BR>&nbsp;&nbsp;the grace period in question.</P>
<P>&nbsp;o&nbsp;"nos" is the number of times that the system balked from<BR>&nbsp;&nbsp;boosting for inexplicable ("not otherwise specified")<BR>&nbsp;&nbsp;reasons.&nbsp; This can actually happen due to races involving<BR>&nbsp;&nbsp;increments of the jiffies counter.</P>
<P>o&nbsp;In the line beginning with "exp balk", the fields are as follows:</P>
<P>&nbsp;o&nbsp;"bt" is the number of times that the system balked from<BR>&nbsp;&nbsp;boosting because there were no blocked tasks to boost.</P>
<P>&nbsp;o&nbsp;"nos" is the number of times that the system balked from<BR>&nbsp;&nbsp; boosting for inexplicable ("not otherwise specified")<BR>&nbsp;&nbsp; reasons.