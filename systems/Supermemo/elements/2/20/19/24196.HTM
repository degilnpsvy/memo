# Documentation/RCU/rcuref.txt
<P></P>
<P>Reference-count design for elements of lists/arrays protected by RCU. </P>
<P></P>
<P>Reference counting on elements of lists which are protected by traditional<BR>reader/writer spinlocks or semaphores are straightforward:</P>
<P>1.&nbsp;&nbsp;&nbsp;&nbsp;2.<BR>add()&nbsp;&nbsp;&nbsp;&nbsp;search_and_reference()<BR>{&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp; alloc_object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_lock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; search_for_element<BR>&nbsp;&nbsp;&nbsp; atomic_set(&amp;el-&gt;rc, 1);&nbsp;&nbsp;&nbsp;&nbsp; atomic_inc(&amp;el-&gt;rc);<BR>&nbsp;&nbsp;&nbsp; write_lock(&amp;list_lock);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; add_element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_unlock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; write_unlock(&amp;list_lock);&nbsp;}<BR>}</P>
<P>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.<BR>release_referenced()&nbsp;&nbsp;&nbsp;delete()<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_lock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp; atomic_dec(&amp;el-&gt;rc, relfunc)&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove_element<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_unlock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (atomic_dec_and_test(&amp;el-&gt;rc))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(el);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</P>
<P>If this list/array is made lock free using RCU as in changing the<BR>write_lock() in add() and delete() to spin_lock() and changing read_lock()<BR>in search_and_reference() to rcu_read_lock(), the atomic_inc() in<BR>search_and_reference() could potentially hold reference to an element which<BR>has already been deleted from the list/array.&nbsp; Use atomic_inc_not_zero()<BR>in this scenario as follows:</P>
<P>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<BR>add()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search_and_reference()<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp; alloc_object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_lock();<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; search_for_element<BR>&nbsp;&nbsp;&nbsp; atomic_set(&amp;el-&gt;rc, 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!atomic_inc_not_zero(&amp;el-&gt;rc)) {<BR>&nbsp;&nbsp;&nbsp; spin_lock(&amp;list_lock);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_unlock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FAIL;<BR>&nbsp;&nbsp;&nbsp; add_element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; spin_unlock(&amp;list_lock);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_unlock();<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.<BR>release_referenced()&nbsp;&nbsp;&nbsp;delete()<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp; if (atomic_dec_and_test(&amp;el-&gt;rc))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call_rcu(&amp;el-&gt;head, el_free);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove_element<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;list_lock);<BR>} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (atomic_dec_and_test(&amp;el-&gt;rc))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call_rcu(&amp;el-&gt;head, el_free);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</P>
<P>Sometimes, a reference to the element needs to be obtained in the<BR>update (write) stream.&nbsp; In such cases, atomic_inc_not_zero() might be<BR>overkill, since we hold the update-side spinlock.&nbsp; One might instead<BR>use atomic_inc() in such cases.</P>
<P>It is not always convenient to deal with "FAIL" in the<BR>search_and_reference() code path.&nbsp; In such cases, the<BR>atomic_dec_and_test() may be moved from delete() to el_free()<BR>as follows:</P>
<P>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<BR>add()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search_and_reference()<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp; alloc_object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_lock();<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; search_for_element<BR>&nbsp;&nbsp;&nbsp; atomic_set(&amp;el-&gt;rc, 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_inc(&amp;el-&gt;rc);<BR>&nbsp;&nbsp;&nbsp; spin_lock(&amp;list_lock);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</P>
<P>&nbsp;&nbsp;&nbsp; add_element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_unlock();<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp; spin_unlock(&amp;list_lock);&nbsp;&nbsp;4.<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete()<BR>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>release_referenced()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;list_lock);<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove_element<BR>&nbsp;&nbsp;&nbsp; if (atomic_dec_and_test(&amp;el-&gt;rc))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(el);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call_rcu(&amp;el-&gt;head, el_free);<BR>} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>void el_free(struct rcu_head *rhp)<BR>{<BR>&nbsp;&nbsp;&nbsp; release_referenced();<BR>}</P>
<P>The key point is that the initial reference added by add() is not removed<BR>until after a grace period has elapsed following removal.&nbsp; This means that<BR>search_and_reference() cannot find this element, which means that the value<BR>of el-&gt;rc cannot increase.&nbsp; Thus, once it reaches zero, there are no<BR>readers that can or ever will be able to reference the element.&nbsp; The<BR>element can therefore safely be freed.&nbsp; This in turn guarantees that if<BR>any reader finds the element, that reader may safely acquire a reference<BR>without checking the value of the reference counter.</P>
<P>In cases where delete() can sleep, synchronize_rcu() can be called from<BR>delete(), so that el_free() can be subsumed into delete as follows:</P>
<P>4.<BR>delete()<BR>{<BR>&nbsp;&nbsp;&nbsp; spin_lock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; remove_element<BR>&nbsp;&nbsp;&nbsp; spin_unlock(&amp;list_lock);<BR>&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; synchronize_rcu();<BR>&nbsp;&nbsp;&nbsp; if (atomic_dec_and_test(&amp;el-&gt;rc))<BR>&nbsp;&nbsp;&nbsp; &nbsp;kfree(el);<BR>&nbsp;&nbsp;&nbsp; ...<BR>}