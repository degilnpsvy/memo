# Documentation/RCU/lockdep.txt
<P></P>
<P>RCU and lockdep checking</P>
<P></P>
<P>All flavors of RCU have lockdep checking available, so that lockdep is<BR>aware of when each task enters and leaves any flavor of RCU read-side<BR>critical section.&nbsp; Each flavor of RCU is tracked separately (but note<BR>that this is not the case in 2.6.32 and earlier).&nbsp; This allows lockdep's<BR>tracking to include RCU state, which can sometimes help when debugging<BR>deadlocks and the like.</P>
<P>In addition, RCU provides the following primitives that check lockdep's<BR>state:</P>
<P>&nbsp;rcu_read_lock_held() for normal RCU.<BR>&nbsp;rcu_read_lock_bh_held() for RCU-bh.<BR>&nbsp;rcu_read_lock_sched_held() for RCU-sched.<BR>&nbsp;srcu_read_lock_held() for SRCU.</P>
<P>These functions are conservative, and will therefore return 1 if they<BR>aren't certain (for example, if CONFIG_DEBUG_LOCK_ALLOC is not set).<BR>This prevents things like WARN_ON(!rcu_read_lock_held()) from giving false<BR>positives when lockdep is disabled.</P>
<P>In addition, a separate kernel config parameter CONFIG_PROVE_RCU enables<BR>checking of rcu_dereference() primitives:</P>
<P>&nbsp;rcu_dereference(p):<BR>&nbsp;&nbsp;Check for RCU read-side critical section.<BR>&nbsp;rcu_dereference_bh(p):<BR>&nbsp;&nbsp;Check for RCU-bh read-side critical section.<BR>&nbsp;rcu_dereference_sched(p):<BR>&nbsp;&nbsp;Check for RCU-sched read-side critical section.<BR>&nbsp;srcu_dereference(p, sp):<BR>&nbsp;&nbsp;Check for SRCU read-side critical section.<BR>&nbsp;rcu_dereference_check(p, c):<BR>&nbsp;&nbsp;Use explicit check expression "c" along with<BR>&nbsp;&nbsp;rcu_read_lock_held().&nbsp; This is useful in code that is<BR>&nbsp;&nbsp;invoked by both RCU readers and updaters.<BR>&nbsp;rcu_dereference_bh_check(p, c):<BR>&nbsp;&nbsp;Use explicit check expression "c" along with<BR>&nbsp;&nbsp;rcu_read_lock_bh_held().&nbsp; This is useful in code that<BR>&nbsp;&nbsp;is invoked by both RCU-bh readers and updaters.<BR>&nbsp;rcu_dereference_sched_check(p, c):<BR>&nbsp;&nbsp;Use explicit check expression "c" along with<BR>&nbsp;&nbsp;rcu_read_lock_sched_held().&nbsp; This is useful in code that<BR>&nbsp;&nbsp;is invoked by both RCU-sched readers and updaters.<BR>&nbsp;srcu_dereference_check(p, c):<BR>&nbsp;&nbsp;Use explicit check expression "c" along with<BR>&nbsp;&nbsp;srcu_read_lock_held()().&nbsp; This is useful in code that<BR>&nbsp;&nbsp;is invoked by both SRCU readers and updaters.<BR>&nbsp;rcu_dereference_index_check(p, c):<BR>&nbsp;&nbsp;Use explicit check expression "c", but the caller<BR>&nbsp;&nbsp;must supply one of the rcu_read_lock_held() functions.<BR>&nbsp;&nbsp;This is useful in code that uses RCU-protected arrays<BR>&nbsp;&nbsp;that is invoked by both RCU readers and updaters.<BR>&nbsp;rcu_dereference_raw(p):<BR>&nbsp;&nbsp;Don't check.&nbsp; (Use sparingly, if at all.)<BR>&nbsp;rcu_dereference_protected(p, c):<BR>&nbsp;&nbsp;Use explicit check expression "c", and omit all barriers<BR>&nbsp;&nbsp;and compiler constraints.&nbsp; This is useful when the data<BR>&nbsp;&nbsp;structure cannot change, for example, in code that is<BR>&nbsp;&nbsp;invoked only by updaters.<BR>&nbsp;rcu_access_pointer(p):<BR>&nbsp;&nbsp;Return the value of the pointer and omit all barriers,<BR>&nbsp;&nbsp;but retain the compiler constraints that prevent duplicating<BR>&nbsp;&nbsp;or coalescsing.&nbsp; This is useful when when testing the<BR>&nbsp;&nbsp;value of the pointer itself, for example, against NULL.<BR>&nbsp;rcu_access_index(idx):<BR>&nbsp;&nbsp;Return the value of the index and omit all barriers, but<BR>&nbsp;&nbsp;retain the compiler constraints that prevent duplicating<BR>&nbsp;&nbsp;or coalescsing.&nbsp; This is useful when when testing the<BR>&nbsp;&nbsp;value of the index itself, for example, against -1.</P>
<P>The rcu_dereference_check() check expression can be any boolean<BR>expression, but would normally include a lockdep expression.&nbsp; However,<BR>any boolean expression can be used.&nbsp; For a moderately ornate example,<BR>consider the following:</P>
<P>&nbsp;file = rcu_dereference_check(fdt-&gt;fd[fd],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lockdep_is_held(&amp;files-&gt;file_lock) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_read(&amp;files-&gt;count) == 1);</P>
<P>This expression picks up the pointer "fdt-&gt;fd[fd]" in an RCU-safe manner,<BR>and, if CONFIG_PROVE_RCU is configured, verifies that this expression<BR>is used in:</P>
<P>1.&nbsp;An RCU read-side critical section (implicit), or<BR>2.&nbsp;with files-&gt;file_lock held, or<BR>3.&nbsp;on an unshared files_struct.</P>
<P>In case (1), the pointer is picked up in an RCU-safe manner for vanilla<BR>RCU read-side critical sections, in case (2) the -&gt;file_lock prevents<BR>any change from taking place, and finally, in case (3) the current task<BR>is the only task accessing the file_struct, again preventing any change<BR>from taking place.&nbsp; If the above statement was invoked only from updater<BR>code, it could instead be written as follows:</P>
<P>&nbsp;file = rcu_dereference_protected(fdt-&gt;fd[fd],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lockdep_is_held(&amp;files-&gt;file_lock) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_read(&amp;files-&gt;count) == 1);</P>
<P>This would verify cases #2 and #3 above, and furthermore lockdep would<BR>complain if this was used in an RCU read-side critical section unless one<BR>of these two cases held.&nbsp; Because rcu_dereference_protected() omits all<BR>barriers and compiler constraints, it generates better code than do the<BR>other flavors of rcu_dereference().&nbsp; On the other hand, it is illegal<BR>to use rcu_dereference_protected() if either the RCU-protected pointer<BR>or the RCU-protected data that it points to can change concurrently.</P>
<P>There are currently only "universal" versions of the rcu_assign_pointer()<BR>and RCU list-/tree-traversal primitives, which do not (yet) check for<BR>being in an RCU read-side critical section.&nbsp; In the future, separate<BR>versions of these primitives might be created.