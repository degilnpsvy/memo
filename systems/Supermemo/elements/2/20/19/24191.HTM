# Documentation/RCU/lockdep-splat.txt
<P></P>
<P>Lockdep-RCU was added to the Linux kernel in early 2010<BR>(<A href="http://lwn.net/Articles/371986/">http://lwn.net/Articles/371986/</A>).&nbsp; This facility checks for some common<BR>misuses of the RCU API, most notably using one of the rcu_dereference()<BR>family to access an RCU-protected pointer without the proper protection.<BR>When such misuse is detected, an lockdep-RCU splat is emitted.</P>
<P></P>
<P>The usual cause of a lockdep-RCU slat is someone accessing an<BR>RCU-protected data structure without either (1) being in the right kind of<BR>RCU read-side critical section or (2) holding the right update-side lock.<BR>This problem can therefore be serious: it might result in random memory<BR>overwriting or worse.&nbsp; There can of course be false positives, this<BR>being the real world and all that.</P>
<P>So let's look at an example RCU lockdep splat from 3.0-rc5, one that<BR>has long since been fixed:</P>
<P>===============================<BR>[ INFO: suspicious RCU usage. ]<BR>-------------------------------<BR>block/cfq-iosched.c:2776 suspicious rcu_dereference_protected() usage!</P>
<P>other info that might help us debug this:</P>
<P><BR>rcu_scheduler_active = 1, debug_locks = 0<BR>3 locks held by scsi_scan_6/1552:<BR>&nbsp;#0:&nbsp; (&amp;shost-&gt;scan_mutex){+.+.+.}, at: [&lt;ffffffff8145efca&gt;]<BR>scsi_scan_host_selected+0x5a/0x150<BR>&nbsp;#1:&nbsp; (&amp;eq-&gt;sysfs_lock){+.+...}, at: [&lt;ffffffff812a5032&gt;]<BR>elevator_exit+0x22/0x60<BR>&nbsp;#2:&nbsp; (&amp;(&amp;q-&gt;__queue_lock)-&gt;rlock){-.-...}, at: [&lt;ffffffff812b6233&gt;]<BR>cfq_exit_queue+0x43/0x190</P>
<P>stack backtrace:<BR>Pid: 1552, comm: scsi_scan_6 Not tainted 3.0.0-rc5 #17<BR>Call Trace:<BR>&nbsp;[&lt;ffffffff810abb9b&gt;] lockdep_rcu_dereference+0xbb/0xc0<BR>&nbsp;[&lt;ffffffff812b6139&gt;] __cfq_exit_single_io_context+0xe9/0x120<BR>&nbsp;[&lt;ffffffff812b626c&gt;] cfq_exit_queue+0x7c/0x190<BR>&nbsp;[&lt;ffffffff812a5046&gt;] elevator_exit+0x36/0x60<BR>&nbsp;[&lt;ffffffff812a802a&gt;] blk_cleanup_queue+0x4a/0x60<BR>&nbsp;[&lt;ffffffff8145cc09&gt;] scsi_free_queue+0x9/0x10<BR>&nbsp;[&lt;ffffffff81460944&gt;] __scsi_remove_device+0x84/0xd0<BR>&nbsp;[&lt;ffffffff8145dca3&gt;] scsi_probe_and_add_lun+0x353/0xb10<BR>&nbsp;[&lt;ffffffff817da069&gt;] ? error_exit+0x29/0xb0<BR>&nbsp;[&lt;ffffffff817d98ed&gt;] ? _raw_spin_unlock_irqrestore+0x3d/0x80<BR>&nbsp;[&lt;ffffffff8145e722&gt;] __scsi_scan_target+0x112/0x680<BR>&nbsp;[&lt;ffffffff812c690d&gt;] ? trace_hardirqs_off_thunk+0x3a/0x3c<BR>&nbsp;[&lt;ffffffff817da069&gt;] ? error_exit+0x29/0xb0<BR>&nbsp;[&lt;ffffffff812bcc60&gt;] ? kobject_del+0x40/0x40<BR>&nbsp;[&lt;ffffffff8145ed16&gt;] scsi_scan_channel+0x86/0xb0<BR>&nbsp;[&lt;ffffffff8145f0b0&gt;] scsi_scan_host_selected+0x140/0x150<BR>&nbsp;[&lt;ffffffff8145f149&gt;] do_scsi_scan_host+0x89/0x90<BR>&nbsp;[&lt;ffffffff8145f170&gt;] do_scan_async+0x20/0x160<BR>&nbsp;[&lt;ffffffff8145f150&gt;] ? do_scsi_scan_host+0x90/0x90<BR>&nbsp;[&lt;ffffffff810975b6&gt;] kthread+0xa6/0xb0<BR>&nbsp;[&lt;ffffffff817db154&gt;] kernel_thread_helper+0x4/0x10<BR>&nbsp;[&lt;ffffffff81066430&gt;] ? finish_task_switch+0x80/0x110<BR>&nbsp;[&lt;ffffffff817d9c04&gt;] ? retint_restore_args+0xe/0xe<BR>&nbsp;[&lt;ffffffff81097510&gt;] ? __init_kthread_worker+0x70/0x70<BR>&nbsp;[&lt;ffffffff817db150&gt;] ? gs_change+0xb/0xb</P>
<P>Line 2776 of block/cfq-iosched.c in v3.0-rc5 is as follows:</P>
<P>&nbsp;if (rcu_dereference(ioc-&gt;ioc_data) == cic) {</P>
<P>This form says that it must be in a plain vanilla RCU read-side critical<BR>section, but the "other info" list above shows that this is not the<BR>case.&nbsp; Instead, we hold three locks, one of which might be RCU related.<BR>And maybe that lock really does protect this reference.&nbsp; If so, the fix<BR>is to inform RCU, perhaps by changing __cfq_exit_single_io_context() to<BR>take the struct request_queue "q" from cfq_exit_queue() as an argument,<BR>which would permit us to invoke rcu_dereference_protected as follows:</P>
<P>&nbsp;if (rcu_dereference_protected(ioc-&gt;ioc_data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lockdep_is_held(&amp;q-&gt;queue_lock)) == cic) {</P>
<P>With this change, there would be no lockdep-RCU splat emitted if this<BR>code was invoked either from within an RCU read-side critical section<BR>or with the -&gt;queue_lock held.&nbsp; In particular, this would have suppressed<BR>the above lockdep-RCU splat because -&gt;queue_lock is held (see #2 in the<BR>list above).</P>
<P>On the other hand, perhaps we really do need an RCU read-side critical<BR>section.&nbsp; In this case, the critical section must span the use of the<BR>return value from rcu_dereference(), or at least until there is some<BR>reference count incremented or some such.&nbsp; One way to handle this is to<BR>add rcu_read_lock() and rcu_read_unlock() as follows:</P>
<P>&nbsp;rcu_read_lock();<BR>&nbsp;if (rcu_dereference(ioc-&gt;ioc_data) == cic) {<BR>&nbsp;&nbsp;spin_lock(&amp;ioc-&gt;lock);<BR>&nbsp;&nbsp;rcu_assign_pointer(ioc-&gt;ioc_data, NULL);<BR>&nbsp;&nbsp;spin_unlock(&amp;ioc-&gt;lock);<BR>&nbsp;}<BR>&nbsp;rcu_read_unlock();</P>
<P>With this change, the rcu_dereference() is always within an RCU<BR>read-side critical section, which again would have suppressed the<BR>above lockdep-RCU splat.</P>
<P>But in this particular case, we don't actually deference the pointer<BR>returned from rcu_dereference().&nbsp; Instead, that pointer is just compared<BR>to the cic pointer, which means that the rcu_dereference() can be replaced<BR>by rcu_access_pointer() as follows:</P>
<P>&nbsp;if (rcu_access_pointer(ioc-&gt;ioc_data) == cic) {</P>
<P>Because it is legal to invoke rcu_access_pointer() without protection,<BR>this change would also suppress the above lockdep-RCU splat.