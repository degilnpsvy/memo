# Documentation/RCU/torture.txt
<P></P>
<P>RCU Torture Test Operation</P>
<P></P>
<P><BR>CONFIG_RCU_TORTURE_TEST</P>
<P>The CONFIG_RCU_TORTURE_TEST config option is available for all RCU<BR>implementations.&nbsp; It creates an rcutorture kernel module that can<BR>be loaded to run a torture test.&nbsp; The test periodically outputs<BR>status messages via printk(), which can be examined via the dmesg<BR>command (perhaps grepping for "torture").&nbsp; The test is started<BR>when the module is loaded, and stops when the module is unloaded.</P>
<P>CONFIG_RCU_TORTURE_TEST_RUNNABLE</P>
<P>It is also possible to specify CONFIG_RCU_TORTURE_TEST=y, which will<BR>result in the tests being loaded into the base kernel.&nbsp; In this case,<BR>the CONFIG_RCU_TORTURE_TEST_RUNNABLE config option is used to specify<BR>whether the RCU torture tests are to be started immediately during<BR>boot or whether the /proc/sys/kernel/rcutorture_runnable file is used<BR>to enable them.&nbsp; This /proc file can be used to repeatedly pause and<BR>restart the tests, regardless of the initial state specified by the<BR>CONFIG_RCU_TORTURE_TEST_RUNNABLE config option.</P>
<P>You will normally -not- want to start the RCU torture tests during boot<BR>(and thus the default is CONFIG_RCU_TORTURE_TEST_RUNNABLE=n), but doing<BR>this can sometimes be useful in finding boot-time bugs.</P>
<P><BR>MODULE PARAMETERS</P>
<P>This module has the following parameters:</P>
<P>fqs_duration&nbsp;Duration (in microseconds) of artificially induced bursts<BR>&nbsp;&nbsp;of force_quiescent_state() invocations.&nbsp; In RCU<BR>&nbsp;&nbsp;implementations having force_quiescent_state(), these<BR>&nbsp;&nbsp;bursts help force races between forcing a given grace<BR>&nbsp;&nbsp;period and that grace period ending on its own.</P>
<P>fqs_holdoff&nbsp;Holdoff time (in microseconds) between consecutive calls<BR>&nbsp;&nbsp;to force_quiescent_state() within a burst.</P>
<P>fqs_stutter&nbsp;Wait time (in seconds) between consecutive bursts<BR>&nbsp;&nbsp;of calls to force_quiescent_state().</P>
<P>irqreader&nbsp;Says to invoke RCU readers from irq level.&nbsp; This is currently<BR>&nbsp;&nbsp;done via timers.&nbsp; Defaults to "1" for variants of RCU that<BR>&nbsp;&nbsp;permit this.&nbsp; (Or, more accurately, variants of RCU that do<BR>&nbsp;&nbsp;-not- permit this know to ignore this variable.)</P>
<P>n_barrier_cbs&nbsp;If this is nonzero, RCU barrier testing will be conducted,<BR>&nbsp;&nbsp;in which case n_barrier_cbs specifies the number of<BR>&nbsp;&nbsp;RCU callbacks (and corresponding kthreads) to use for<BR>&nbsp;&nbsp;this testing.&nbsp; The value cannot be negative.&nbsp; If you<BR>&nbsp;&nbsp;specify this to be non-zero when torture_type indicates a<BR>&nbsp;&nbsp;synchronous RCU implementation (one for which a member of<BR>&nbsp;&nbsp;the synchronize_rcu() rather than the call_rcu() family is<BR>&nbsp;&nbsp;used -- see the documentation for torture_type below), an<BR>&nbsp;&nbsp;error will be reported and no testing will be carried out.</P>
<P>nfakewriters&nbsp;This is the number of RCU fake writer threads to run.&nbsp; Fake<BR>&nbsp;&nbsp;writer threads repeatedly use the synchronous "wait for<BR>&nbsp;&nbsp;current readers" function of the interface selected by<BR>&nbsp;&nbsp;torture_type, with a delay between calls to allow for various<BR>&nbsp;&nbsp;different numbers of writers running in parallel.<BR>&nbsp;&nbsp;nfakewriters defaults to 4, which provides enough parallelism<BR>&nbsp;&nbsp;to trigger special cases caused by multiple writers, such as<BR>&nbsp;&nbsp;the synchronize_srcu() early return optimization.</P>
<P>nreaders&nbsp;This is the number of RCU reading threads supported.<BR>&nbsp;&nbsp;The default is twice the number of CPUs.&nbsp; Why twice?<BR>&nbsp;&nbsp;To properly exercise RCU implementations with preemptible<BR>&nbsp;&nbsp;read-side critical sections.</P>
<P>onoff_interval<BR>&nbsp;&nbsp;The number of seconds between each attempt to execute a<BR>&nbsp;&nbsp;randomly selected CPU-hotplug operation.&nbsp; Defaults to<BR>&nbsp;&nbsp;zero, which disables CPU hotplugging.&nbsp; In HOTPLUG_CPU=n<BR>&nbsp;&nbsp;kernels, rcutorture will silently refuse to do any<BR>&nbsp;&nbsp;CPU-hotplug operations regardless of what value is<BR>&nbsp;&nbsp;specified for onoff_interval.</P>
<P>onoff_holdoff&nbsp;The number of seconds to wait until starting CPU-hotplug<BR>&nbsp;&nbsp;operations.&nbsp; This would normally only be used when<BR>&nbsp;&nbsp;rcutorture was built into the kernel and started<BR>&nbsp;&nbsp;automatically at boot time, in which case it is useful<BR>&nbsp;&nbsp;in order to avoid confusing boot-time code with CPUs<BR>&nbsp;&nbsp;coming and going.</P>
<P>shuffle_interval<BR>&nbsp;&nbsp;The number of seconds to keep the test threads affinitied<BR>&nbsp;&nbsp;to a particular subset of the CPUs, defaults to 3 seconds.<BR>&nbsp;&nbsp;Used in conjunction with test_no_idle_hz.</P>
<P>shutdown_secs&nbsp;The number of seconds to run the test before terminating<BR>&nbsp;&nbsp;the test and powering off the system.&nbsp; The default is<BR>&nbsp;&nbsp;zero, which disables test termination and system shutdown.<BR>&nbsp;&nbsp;This capability is useful for automated testing.</P>
<P>stall_cpu&nbsp;The number of seconds that a CPU should be stalled while<BR>&nbsp;&nbsp;within both an rcu_read_lock() and a preempt_disable().<BR>&nbsp;&nbsp;This stall happens only once per rcutorture run.<BR>&nbsp;&nbsp;If you need multiple stalls, use modprobe and rmmod to<BR>&nbsp;&nbsp;repeatedly run rcutorture.&nbsp; The default for stall_cpu<BR>&nbsp;&nbsp;is zero, which prevents rcutorture from stalling a CPU.</P>
<P>&nbsp;&nbsp;Note that attempts to rmmod rcutorture while the stall<BR>&nbsp;&nbsp;is ongoing will hang, so be careful what value you<BR>&nbsp;&nbsp;choose for this module parameter!&nbsp; In addition, too-large<BR>&nbsp;&nbsp;values for stall_cpu might well induce failures and<BR>&nbsp;&nbsp;warnings in other parts of the kernel.&nbsp; You have been<BR>&nbsp;&nbsp;warned!</P>
<P>stall_cpu_holdoff<BR>&nbsp;&nbsp;The number of seconds to wait after rcutorture starts<BR>&nbsp;&nbsp;before stalling a CPU.&nbsp; Defaults to 10 seconds.</P>
<P>stat_interval&nbsp;The number of seconds between output of torture<BR>&nbsp;&nbsp;statistics (via printk()).&nbsp; Regardless of the interval,<BR>&nbsp;&nbsp;statistics are printed when the module is unloaded.<BR>&nbsp;&nbsp;Setting the interval to zero causes the statistics to<BR>&nbsp;&nbsp;be printed -only- when the module is unloaded, and this<BR>&nbsp;&nbsp;is the default.</P>
<P>stutter&nbsp;&nbsp;The length of time to run the test before pausing for this<BR>&nbsp;&nbsp;same period of time.&nbsp; Defaults to "stutter=5", so as<BR>&nbsp;&nbsp;to run and pause for (roughly) five-second intervals.<BR>&nbsp;&nbsp;Specifying "stutter=0" causes the test to run continuously<BR>&nbsp;&nbsp;without pausing, which is the old default behavior.</P>
<P>test_boost&nbsp;Whether or not to test the ability of RCU to do priority<BR>&nbsp;&nbsp;boosting.&nbsp; Defaults to "test_boost=1", which performs<BR>&nbsp;&nbsp;RCU priority-inversion testing only if the selected<BR>&nbsp;&nbsp;RCU implementation supports priority boosting.&nbsp; Specifying<BR>&nbsp;&nbsp;"test_boost=0" never performs RCU priority-inversion<BR>&nbsp;&nbsp;testing.&nbsp; Specifying "test_boost=2" performs RCU<BR>&nbsp;&nbsp;priority-inversion testing even if the selected RCU<BR>&nbsp;&nbsp;implementation does not support RCU priority boosting,<BR>&nbsp;&nbsp;which can be used to test rcutorture's ability to<BR>&nbsp;&nbsp;carry out RCU priority-inversion testing.</P>
<P>test_boost_interval<BR>&nbsp;&nbsp;The number of seconds in an RCU priority-inversion test<BR>&nbsp;&nbsp;cycle.&nbsp;Defaults to "test_boost_interval=7".&nbsp; It is<BR>&nbsp;&nbsp;usually wise for this value to be relatively prime to<BR>&nbsp;&nbsp;the value selected for "stutter".</P>
<P>test_boost_duration<BR>&nbsp;&nbsp;The number of seconds to do RCU priority-inversion testing<BR>&nbsp;&nbsp;within any given "test_boost_interval".&nbsp; Defaults to<BR>&nbsp;&nbsp;"test_boost_duration=4".</P>
<P>test_no_idle_hz&nbsp;Whether or not to test the ability of RCU to operate in<BR>&nbsp;&nbsp;a kernel that disables the scheduling-clock interrupt to<BR>&nbsp;&nbsp;idle CPUs.&nbsp; Boolean parameter, "1" to test, "0" otherwise.<BR>&nbsp;&nbsp;Defaults to omitting this test.</P>
<P>torture_type&nbsp;The type of RCU to test, with string values as follows:</P>
<P>&nbsp;&nbsp;"rcu":&nbsp; rcu_read_lock(), rcu_read_unlock() and call_rcu().</P>
<P>&nbsp;&nbsp;"rcu_sync":&nbsp; rcu_read_lock(), rcu_read_unlock(), and<BR>&nbsp;&nbsp;&nbsp;synchronize_rcu().</P>
<P>&nbsp;&nbsp;"rcu_expedited": rcu_read_lock(), rcu_read_unlock(), and<BR>&nbsp;&nbsp;&nbsp;synchronize_rcu_expedited().</P>
<P>&nbsp;&nbsp;"rcu_bh": rcu_read_lock_bh(), rcu_read_unlock_bh(), and<BR>&nbsp;&nbsp;&nbsp;call_rcu_bh().</P>
<P>&nbsp;&nbsp;"rcu_bh_sync": rcu_read_lock_bh(), rcu_read_unlock_bh(),<BR>&nbsp;&nbsp;&nbsp;and synchronize_rcu_bh().</P>
<P>&nbsp;&nbsp;"rcu_bh_expedited": rcu_read_lock_bh(), rcu_read_unlock_bh(),<BR>&nbsp;&nbsp;&nbsp;and synchronize_rcu_bh_expedited().</P>
<P>&nbsp;&nbsp;"srcu": srcu_read_lock(), srcu_read_unlock() and<BR>&nbsp;&nbsp;&nbsp;call_srcu().</P>
<P>&nbsp;&nbsp;"srcu_sync": srcu_read_lock(), srcu_read_unlock() and<BR>&nbsp;&nbsp;&nbsp;synchronize_srcu().</P>
<P>&nbsp;&nbsp;"srcu_expedited": srcu_read_lock(), srcu_read_unlock() and<BR>&nbsp;&nbsp;&nbsp;synchronize_srcu_expedited().</P>
<P>&nbsp;&nbsp;"srcu_raw": srcu_read_lock_raw(), srcu_read_unlock_raw(),<BR>&nbsp;&nbsp;&nbsp;and call_srcu().</P>
<P>&nbsp;&nbsp;"srcu_raw_sync": srcu_read_lock_raw(), srcu_read_unlock_raw(),<BR>&nbsp;&nbsp;&nbsp;and synchronize_srcu().</P>
<P>&nbsp;&nbsp;"sched": preempt_disable(), preempt_enable(), and<BR>&nbsp;&nbsp;&nbsp;call_rcu_sched().</P>
<P>&nbsp;&nbsp;"sched_sync": preempt_disable(), preempt_enable(), and<BR>&nbsp;&nbsp;&nbsp;synchronize_sched().</P>
<P>&nbsp;&nbsp;"sched_expedited": preempt_disable(), preempt_enable(), and<BR>&nbsp;&nbsp;&nbsp;synchronize_sched_expedited().</P>
<P>&nbsp;&nbsp;Defaults to "rcu".</P>
<P>verbose&nbsp;&nbsp;Enable debug printk()s.&nbsp; Default is disabled.</P>
<P><BR>OUTPUT</P>
<P>The statistics output is as follows:</P>
<P>&nbsp;rcu-torture:--- Start of test: nreaders=16 nfakewriters=4 stat_interval=30 verbose=0 test_no_idle_hz=1 shuffle_interval=3 stutter=5 irqreader=1 fqs_duration=0 fqs_holdoff=0 fqs_stutter=3 test_boost=1/0 test_boost_interval=7 test_boost_duration=4<BR>&nbsp;rcu-torture: rtc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (null) ver: 155441 tfle: 0 rta: 155441 rtaf: 8884 rtf: 155440 rtmbe: 0 rtbe: 0 rtbke: 0 rtbre: 0 rtbf: 0 rtb: 0 nt: 3055767<BR>&nbsp;rcu-torture: Reader Pipe:&nbsp; 727860534 34213 0 0 0 0 0 0 0 0 0<BR>&nbsp;rcu-torture: Reader Batch:&nbsp; 727877838 17003 0 0 0 0 0 0 0 0 0<BR>&nbsp;rcu-torture: Free-Block Circulation:&nbsp; 155440 155440 155440 155440 155440 155440 155440 155440 155440 155440 0<BR>&nbsp;rcu-torture:--- End of test: SUCCESS: nreaders=16 nfakewriters=4 stat_interval=30 verbose=0 test_no_idle_hz=1 shuffle_interval=3 stutter=5 irqreader=1 fqs_duration=0 fqs_holdoff=0 fqs_stutter=3 test_boost=1/0 test_boost_interval=7 test_boost_duration=4</P>
<P>The command "dmesg | grep torture:" will extract this information on<BR>most systems.&nbsp; On more esoteric configurations, it may be necessary to<BR>use other commands to access the output of the printk()s used by<BR>the RCU torture test.&nbsp; The printk()s use KERN_ALERT, so they should<BR>be evident.&nbsp; ;-)</P>
<P>The first and last lines show the rcutorture module parameters, and the<BR>last line shows either "SUCCESS" or "FAILURE", based on rcutorture's<BR>automatic determination as to whether RCU operated correctly.</P>
<P>The entries are as follows:</P>
<P>o&nbsp;"rtc": The hexadecimal address of the structure currently visible<BR>&nbsp;to readers.</P>
<P>o&nbsp;"ver": The number of times since boot that the RCU writer task<BR>&nbsp;has changed the structure visible to readers.</P>
<P>o&nbsp;"tfle": If non-zero, indicates that the "torture freelist"<BR>&nbsp;containing structures to be placed into the "rtc" area is empty.<BR>&nbsp;This condition is important, since it can fool you into thinking<BR>&nbsp;that RCU is working when it is not.&nbsp; :-/</P>
<P>o&nbsp;"rta": Number of structures allocated from the torture freelist.</P>
<P>o&nbsp;"rtaf": Number of allocations from the torture freelist that have<BR>&nbsp;failed due to the list being empty.&nbsp; It is not unusual for this<BR>&nbsp;to be non-zero, but it is bad for it to be a large fraction of<BR>&nbsp;the value indicated by "rta".</P>
<P>o&nbsp;"rtf": Number of frees into the torture freelist.</P>
<P>o&nbsp;"rtmbe": A non-zero value indicates that rcutorture believes that<BR>&nbsp;rcu_assign_pointer() and rcu_dereference() are not working<BR>&nbsp;correctly.&nbsp; This value should be zero.</P>
<P>o&nbsp;"rtbe": A non-zero value indicates that one of the rcu_barrier()<BR>&nbsp;family of functions is not working correctly.</P>
<P>o&nbsp;"rtbke": rcutorture was unable to create the real-time kthreads<BR>&nbsp;used to force RCU priority inversion.&nbsp; This value should be zero.</P>
<P>o&nbsp;"rtbre": Although rcutorture successfully created the kthreads<BR>&nbsp;used to force RCU priority inversion, it was unable to set them<BR>&nbsp;to the real-time priority level of 1.&nbsp; This value should be zero.</P>
<P>o&nbsp;"rtbf": The number of times that RCU priority boosting failed<BR>&nbsp;to resolve RCU priority inversion.</P>
<P>o&nbsp;"rtb": The number of times that rcutorture attempted to force<BR>&nbsp;an RCU priority inversion condition.&nbsp; If you are testing RCU<BR>&nbsp;priority boosting via the "test_boost" module parameter, this<BR>&nbsp;value should be non-zero.</P>
<P>o&nbsp;"nt": The number of times rcutorture ran RCU read-side code from<BR>&nbsp;within a timer handler.&nbsp; This value should be non-zero only<BR>&nbsp;if you specified the "irqreader" module parameter.</P>
<P>o&nbsp;"Reader Pipe": Histogram of "ages" of structures seen by readers.<BR>&nbsp;If any entries past the first two are non-zero, RCU is broken.<BR>&nbsp;And rcutorture prints the error flag string "!!!" to make sure<BR>&nbsp;you notice.&nbsp; The age of a newly allocated structure is zero,<BR>&nbsp;it becomes one when removed from reader visibility, and is<BR>&nbsp;incremented once per grace period subsequently -- and is freed<BR>&nbsp;after passing through (RCU_TORTURE_PIPE_LEN-2) grace periods.</P>
<P>&nbsp;The output displayed above was taken from a correctly working<BR>&nbsp;RCU.&nbsp; If you want to see what it looks like when broken, break<BR>&nbsp;it yourself.&nbsp; ;-)</P>
<P>o&nbsp;"Reader Batch": Another histogram of "ages" of structures seen<BR>&nbsp;by readers, but in terms of counter flips (or batches) rather<BR>&nbsp;than in terms of grace periods.&nbsp; The legal number of non-zero<BR>&nbsp;entries is again two.&nbsp; The reason for this separate view is that<BR>&nbsp;it is sometimes easier to get the third entry to show up in the<BR>&nbsp;"Reader Batch" list than in the "Reader Pipe" list.</P>
<P>o&nbsp;"Free-Block Circulation": Shows the number of torture structures<BR>&nbsp;that have reached a given point in the pipeline.&nbsp; The first element<BR>&nbsp;should closely correspond to the number of structures allocated,<BR>&nbsp;the second to the number that have been removed from reader view,<BR>&nbsp;and all but the last remaining to the corresponding number of<BR>&nbsp;passes through a grace period.&nbsp; The last entry should be zero,<BR>&nbsp;as it is only incremented if a torture structure's counter<BR>&nbsp;somehow gets incremented farther than it should.</P>
<P>Different implementations of RCU can provide implementation-specific<BR>additional information.&nbsp; For example, SRCU provides the following<BR>additional line:</P>
<P>&nbsp;srcu-torture: per-CPU(idx=1): 0(0,1) 1(0,1) 2(0,0) 3(0,1)</P>
<P>This line shows the per-CPU counter state.&nbsp; The numbers in parentheses are<BR>the values of the "old" and "current" counters for the corresponding CPU.<BR>The "idx" value maps the "old" and "current" values to the underlying<BR>array, and is useful for debugging.</P>
<P><BR>USAGE</P>
<P>The following script may be used to torture RCU:</P>
<P>&nbsp;#!/bin/sh</P>
<P>&nbsp;modprobe rcutorture<BR>&nbsp;sleep 3600<BR>&nbsp;rmmod rcutorture<BR>&nbsp;dmesg | grep torture:</P>
<P>The output can be manually inspected for the error flag of "!!!".<BR>One could of course create a more elaborate script that automatically<BR>checked for such errors.&nbsp; The "rmmod" command forces a "SUCCESS",<BR>"FAILURE", or "RCU_HOTPLUG" indication to be printk()ed.&nbsp; The first<BR>two are self-explanatory, while the last indicates that while there<BR>were no RCU failures, CPU-hotplug problems were detected.