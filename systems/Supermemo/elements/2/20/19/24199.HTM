# Documentation/RCU/stallwarn.txt
<P></P>
<P>Using RCU's CPU Stall Detector</P>
<P></P>
<P>The rcu_cpu_stall_suppress module parameter enables RCU's CPU stall<BR>detector, which detects conditions that unduly delay RCU grace periods.<BR>This module parameter enables CPU stall detection by default, but<BR>may be overridden via boot-time parameter or at runtime via sysfs.<BR>The stall detector's idea of what constitutes "unduly delayed" is<BR>controlled by a set of kernel configuration variables and cpp macros:</P>
<P>CONFIG_RCU_CPU_STALL_TIMEOUT</P>
<P>&nbsp;This kernel configuration parameter defines the period of time<BR>&nbsp;that RCU will wait from the beginning of a grace period until it<BR>&nbsp;issues an RCU CPU stall warning.&nbsp; This time period is normally<BR>&nbsp;sixty seconds.</P>
<P>&nbsp;This configuration parameter may be changed at runtime via the<BR>&nbsp;/sys/module/rcutree/parameters/rcu_cpu_stall_timeout, however<BR>&nbsp;this parameter is checked only at the beginning of a cycle.<BR>&nbsp;So if you are 30 seconds into a 70-second stall, setting this<BR>&nbsp;sysfs parameter to (say) five will shorten the timeout for the<BR>&nbsp;-next- stall, or the following warning for the current stall<BR>&nbsp;(assuming the stall lasts long enough).&nbsp; It will not affect the<BR>&nbsp;timing of the next warning for the current stall.</P>
<P>&nbsp;Stall-warning messages may be enabled and disabled completely via<BR>&nbsp;/sys/module/rcutree/parameters/rcu_cpu_stall_suppress.</P>
<P>CONFIG_RCU_CPU_STALL_VERBOSE</P>
<P>&nbsp;This kernel configuration parameter causes the stall warning to<BR>&nbsp;also dump the stacks of any tasks that are blocking the current<BR>&nbsp;RCU-preempt grace period.</P>
<P>RCU_CPU_STALL_INFO</P>
<P>&nbsp;This kernel configuration parameter causes the stall warning to<BR>&nbsp;print out additional per-CPU diagnostic information, including<BR>&nbsp;information on scheduling-clock ticks and RCU's idle-CPU tracking.</P>
<P>RCU_STALL_DELAY_DELTA</P>
<P>&nbsp;Although the lockdep facility is extremely useful, it does add<BR>&nbsp;some overhead.&nbsp; Therefore, under CONFIG_PROVE_RCU, the<BR>&nbsp;RCU_STALL_DELAY_DELTA macro allows five extra seconds before<BR>&nbsp;giving an RCU CPU stall warning message.</P>
<P>RCU_STALL_RAT_DELAY</P>
<P>&nbsp;The CPU stall detector tries to make the offending CPU print its<BR>&nbsp;own warnings, as this often gives better-quality stack traces.<BR>&nbsp;However, if the offending CPU does not detect its own stall in<BR>&nbsp;the number of jiffies specified by RCU_STALL_RAT_DELAY, then<BR>&nbsp;some other CPU will complain.&nbsp; This delay is normally set to<BR>&nbsp;two jiffies.</P>
<P>When a CPU detects that it is stalling, it will print a message similar<BR>to the following:</P>
<P>INFO: rcu_sched_state detected stall on CPU 5 (t=2500 jiffies)</P>
<P>This message indicates that CPU 5 detected that it was causing a stall,<BR>and that the stall was affecting RCU-sched.&nbsp; This message will normally be<BR>followed by a stack dump of the offending CPU.&nbsp; On TREE_RCU kernel builds,<BR>RCU and RCU-sched are implemented by the same underlying mechanism,<BR>while on TREE_PREEMPT_RCU kernel builds, RCU is instead implemented<BR>by rcu_preempt_state.</P>
<P>On the other hand, if the offending CPU fails to print out a stall-warning<BR>message quickly enough, some other CPU will print a message similar to<BR>the following:</P>
<P>INFO: rcu_bh_state detected stalls on CPUs/tasks: { 3 5 } (detected by 2, 2502 jiffies)</P>
<P>This message indicates that CPU 2 detected that CPUs 3 and 5 were both<BR>causing stalls, and that the stall was affecting RCU-bh.&nbsp; This message<BR>will normally be followed by stack dumps for each CPU.&nbsp; Please note that<BR>TREE_PREEMPT_RCU builds can be stalled by tasks as well as by CPUs,<BR>and that the tasks will be indicated by PID, for example, "P3421".<BR>It is even possible for a rcu_preempt_state stall to be caused by both<BR>CPUs -and- tasks, in which case the offending CPUs and tasks will all<BR>be called out in the list.</P>
<P>Finally, if the grace period ends just as the stall warning starts<BR>printing, there will be a spurious stall-warning message:</P>
<P>INFO: rcu_bh_state detected stalls on CPUs/tasks: { } (detected by 4, 2502 jiffies)</P>
<P>This is rare, but does happen from time to time in real life.</P>
<P>If the CONFIG_RCU_CPU_STALL_INFO kernel configuration parameter is set,<BR>more information is printed with the stall-warning message, for example:</P>
<P>&nbsp;INFO: rcu_preempt detected stall on CPU<BR>&nbsp;0: (63959 ticks this GP) idle=241/3fffffffffffffff/0 softirq=82/543<BR>&nbsp;&nbsp;&nbsp; (t=65000 jiffies)</P>
<P>In kernels with CONFIG_RCU_FAST_NO_HZ, even more information is<BR>printed:</P>
<P>&nbsp;INFO: rcu_preempt detected stall on CPU<BR>&nbsp;0: (64628 ticks this GP) idle=dd5/3fffffffffffffff/0 softirq=82/543 last_accelerate: a345/d342 nonlazy_posted: 25 .D<BR>&nbsp;&nbsp;&nbsp; (t=65000 jiffies)</P>
<P>The "(64628 ticks this GP)" indicates that this CPU has taken more<BR>than 64,000 scheduling-clock interrupts during the current stalled<BR>grace period.&nbsp; If the CPU was not yet aware of the current grace<BR>period (for example, if it was offline), then this part of the message<BR>indicates how many grace periods behind the CPU is.</P>
<P>The "idle=" portion of the message prints the dyntick-idle state.<BR>The hex number before the first "/" is the low-order 12 bits of the<BR>dynticks counter, which will have an even-numbered value if the CPU is<BR>in dyntick-idle mode and an odd-numbered value otherwise.&nbsp; The hex<BR>number between the two "/"s is the value of the nesting, which will<BR>be a small positive number if in the idle loop and a very large positive<BR>number (as shown above) otherwise.</P>
<P>The "softirq=" portion of the message tracks the number of RCU softirq<BR>handlers that the stalled CPU has executed.&nbsp; The number before the "/"<BR>is the number that had executed since boot at the time that this CPU<BR>last noted the beginning of a grace period, which might be the current<BR>(stalled) grace period, or it might be some earlier grace period (for<BR>example, if the CPU might have been in dyntick-idle mode for an extended<BR>time period.&nbsp; The number after the "/" is the number that have executed<BR>since boot until the current time.&nbsp; If this latter number stays constant<BR>across repeated stall-warning messages, it is possible that RCU's softirq<BR>handlers are no longer able to execute on this CPU.&nbsp; This can happen if<BR>the stalled CPU is spinning with interrupts are disabled, or, in -rt<BR>kernels, if a high-priority process is starving RCU's softirq handler.</P>
<P>For CONFIG_RCU_FAST_NO_HZ kernels, the "last_accelerate:" prints the<BR>low-order 16 bits (in hex) of the jiffies counter when this CPU last<BR>invoked rcu_try_advance_all_cbs() from rcu_needs_cpu() or last invoked<BR>rcu_accelerate_cbs() from rcu_prepare_for_idle().&nbsp; The "nonlazy_posted:"<BR>prints the number of non-lazy callbacks posted since the last call to<BR>rcu_needs_cpu().&nbsp; Finally, an "L" indicates that there are currently<BR>no non-lazy callbacks ("." is printed otherwise, as shown above) and<BR>"D" indicates that dyntick-idle processing is enabled ("." is printed<BR>otherwise, for example, if disabled via the "nohz=" kernel boot parameter).</P>
<P><BR>Multiple Warnings From One Stall</P>
<P>If a stall lasts long enough, multiple stall-warning messages will be<BR>printed for it.&nbsp; The second and subsequent messages are printed at<BR>longer intervals, so that the time between (say) the first and second<BR>message will be about three times the interval between the beginning<BR>of the stall and the first message.</P>
<P><BR>What Causes RCU CPU Stall Warnings?</P>
<P>So your kernel printed an RCU CPU stall warning.&nbsp; The next question is<BR>"What caused it?"&nbsp; The following problems can result in RCU CPU stall<BR>warnings:</P>
<P>o&nbsp;A CPU looping in an RCU read-side critical section.<BR>&nbsp;<BR>o&nbsp;A CPU looping with interrupts disabled.&nbsp; This condition can<BR>&nbsp;result in RCU-sched and RCU-bh stalls.</P>
<P>o&nbsp;A CPU looping with preemption disabled.&nbsp; This condition can<BR>&nbsp;result in RCU-sched stalls and, if ksoftirqd is in use, RCU-bh<BR>&nbsp;stalls.</P>
<P>o&nbsp;A CPU looping with bottom halves disabled.&nbsp; This condition can<BR>&nbsp;result in RCU-sched and RCU-bh stalls.</P>
<P>o&nbsp;For !CONFIG_PREEMPT kernels, a CPU looping anywhere in the kernel<BR>&nbsp;without invoking schedule().</P>
<P>o&nbsp;A CPU-bound real-time task in a CONFIG_PREEMPT kernel, which might<BR>&nbsp;happen to preempt a low-priority task in the middle of an RCU<BR>&nbsp;read-side critical section.&nbsp;&nbsp; This is especially damaging if<BR>&nbsp;that low-priority task is not permitted to run on any other CPU,<BR>&nbsp;in which case the next RCU grace period can never complete, which<BR>&nbsp;will eventually cause the system to run out of memory and hang.<BR>&nbsp;While the system is in the process of running itself out of<BR>&nbsp;memory, you might see stall-warning messages.</P>
<P>o&nbsp;A CPU-bound real-time task in a CONFIG_PREEMPT_RT kernel that<BR>&nbsp;is running at a higher priority than the RCU softirq threads.<BR>&nbsp;This will prevent RCU callbacks from ever being invoked,<BR>&nbsp;and in a CONFIG_TREE_PREEMPT_RCU kernel will further prevent<BR>&nbsp;RCU grace periods from ever completing.&nbsp; Either way, the<BR>&nbsp;system will eventually run out of memory and hang.&nbsp; In the<BR>&nbsp;CONFIG_TREE_PREEMPT_RCU case, you might see stall-warning<BR>&nbsp;messages.</P>
<P>o&nbsp;A hardware or software issue shuts off the scheduler-clock<BR>&nbsp;interrupt on a CPU that is not in dyntick-idle mode.&nbsp; This<BR>&nbsp;problem really has happened, and seems to be most likely to<BR>&nbsp;result in RCU CPU stall warnings for CONFIG_NO_HZ_COMMON=n kernels.</P>
<P>o&nbsp;A bug in the RCU implementation.</P>
<P>o&nbsp;A hardware failure.&nbsp; This is quite unlikely, but has occurred<BR>&nbsp;at least once in real life.&nbsp; A CPU failed in a running system,<BR>&nbsp;becoming unresponsive, but not causing an immediate crash.<BR>&nbsp;This resulted in a series of RCU CPU stall warnings, eventually<BR>&nbsp;leading the realization that the CPU had failed.</P>
<P>The RCU, RCU-sched, and RCU-bh implementations have CPU stall warning.<BR>SRCU does not have its own CPU stall warnings, but its calls to<BR>synchronize_sched() will result in RCU-sched detecting RCU-sched-related<BR>CPU stalls.&nbsp; Please note that RCU only detects CPU stalls when there is<BR>a grace period in progress.&nbsp; No grace period, no CPU stall warnings.</P>
<P>To diagnose the cause of the stall, inspect the stack traces.<BR>The offending function will usually be near the top of the stack.<BR>If you have a series of stall warnings from a single extended stall,<BR>comparing the stack traces can often help determine where the stall<BR>is occurring, which will usually be in the function nearest the top of<BR>that portion of the stack which remains the same from trace to trace.<BR>If you can reliably trigger the stall, ftrace can be quite helpful.</P>
<P>RCU bugs can often be debugged with the help of CONFIG_RCU_TRACE<BR>and with RCU's event tracing.