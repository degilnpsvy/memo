<H4 id=title-ID0EN4OM class=docSection2Title>Reader-Writer Locks</H4>
<P class=docText><A name="If the"></A><FONT class=extract>Another specialized concurrency regulation mechanism is a reader-writer variant of spinlocks. If the usage of a critical section is such that separate threads either read from or write to a shared data structure, but don't do both, these locks are a natural fit. Multiple reader threads are allowed inside a critical region simultaneously. <FONT class=extract>Reader spinlocks are defined as follows:</FONT></FONT></P>
<DIV class=docText><PRE><FONT class=extract>rwlock_t myrwlock = RW_LOCK_UNLOCKED;

read_lock(&amp;myrwlock);     /* Acquire reader lock */
/* ... Critical Region ... */
read_unlock(&amp;myrwlock);   /* Release lock */</FONT></PRE></DIV><BR>
<P class=docText><A name="a critical"></A><FONT class=extract>However, if a writer thread enters a critical section, other reader or writer threads are not allowed inside. To use writer spinlocks, you would write this:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>rwlock_t myrwlock = RW_LOCK_UNLOCKED;

write_lock(&amp;myrwlock);    /* Acquire writer lock */
/* ... Critical Region ... */
write_unlock(&amp;myrwlock);  /* Release lock */</FONT></PRE></DIV><BR>
<P class=docText><FONT class=extract><FONT class=extract>Look at the IPX routing code present in <SPAN class=docEmphasis>net/ipx/ipx_route.c</SPAN> for a real-life example of a reader-writer spinlock. A reader-writer lock called <TT>ipx_routes_lock</TT></FONT></FONT><A name="need to"></A><FONT class=extract> protects the IPX routing table from simultaneous access. Threads that need to look up the routing table to forward packets request reader locks. Threads that need to add or delete entries from the routing table acquire writer locks. This improves performance because there are usually far more instances of routing table lookups than routing table updates.</FONT></P>
<P class=docText><A name="irq variants"></A><FONT class=extract>Like regular spinlocks, reader-writer locks also have corresponding irq variants&#37413;&#25871;amely, <TT>read_lock_irqsave()</TT>, <TT>read_lock_irqrestore()</TT>, <TT>write_lock_irqsave()</TT>, </FONT><A name=iddle3719></A><A name=iddle3724></A><A name=iddle3931></A><A name=iddle3932></A><A name=iddle4652></A><FONT class=extract><FONT class=extract>and <TT>write_lock_irqrestore()</TT></FONT></FONT><A name="those of"></A><FONT class=extract>. The semantics of these functions are similar to those of regular spinlocks.</FONT></P>
<P class=docText><A name="locks or"></A><FONT class=extract>Sequence locks or <SPAN class=docEmphasis>seqlocks</SPAN></FONT><A name="This is"></A><FONT class=extract>, introduced in the 2.6 kernel, are reader-writer locks where writers are favored over readers. This is useful if write operations on a variable far outnumber read accesses. An example is the <TT>jiffies_64</TT></FONT><A name="variable discussed"></A><FONT class=extract> variable discussed earlier in this chapter. Writer threads do not wait for readers who may be inside a critical section. Because of this, reader threads may discover that their entry inside a critical section has failed and may need to retry:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>u64 get_jiffies_64(void) /* Defined in <SPAN class=docEmphasis>kernel/time.c</SPAN> */
{
  unsigned long seq;
  u64 ret;
  do {
    seq = read_seqbegin(&amp;xtime_lock);
    ret = jiffies_64;
  } while (read_seqretry(&amp;xtime_lock, seq));
  return ret;
}</FONT></PRE></DIV><BR>
<P class=docText><A name="critical regions"></A><FONT class=extract>Writers protect critical regions using <TT>write_seqlock()</TT> and <TT>write_sequnlock()</TT>.</FONT></P>
<P class=docText><A name="kernel introduced"></A><FONT class=extract>The 2.6 kernel introduced another mechanism called <SPAN class=docEmphasis>Read-Copy Update</SPAN></FONT><A name="basic idea"></A><FONT class=extract> (RCU), which yields improved performance when readers far outnumber writers. The basic idea is that reader threads can execute without locking. Writer threads are more complex. They perform update operations on a copy of the data structure and replace the pointer that readers see. The original copy is maintained until the next context switch on all CPUs to ensure completion of all ongoing read operations. Be aware that using RCU is more involved than using the primitives discussed thus far and should be used only if you are sure that it's the right tool for the job. RCU data structures and interface functions are defined in <SPAN class=docEmphasis>include/linux/rcupdate.h.</SPAN> There is ample documentation in <SPAN class=docEmphasis>Documentation/RCU/*</SPAN>.</FONT></P>
<P class=docText><A name=at></A><FONT class=extract>For an RCU usage example, look at <SPAN class=docEmphasis>fs/dcache.c.</SPAN></FONT><A name="in a"></A><FONT class=extract> On Linux, each file is associated with directory entry information (stored in a structure called <SPAN class=docEmphasis>dentry</SPAN></FONT><A name="data "></A><FONT class=extract>), metadata information (stored in an inode), and actual data (stored in data blocks). Each time you operate on a file, the components in the file path are parsed, and the corresponding dentries are obtained. The dentries are kept cached in a data structure called the <SPAN class=docEmphasis>dcache</SPAN>, to speed </FONT><A name=iddle1550></A><A name=iddle1684></A><A name=iddle2556></A><A name=iddle3705></A><A name="lookups is"></A><FONT class=extract>up future operations. At any time, the number of dcache lookups is much more than dcache updates, so references to the dcache are protected using RCU primitives.</FONT>