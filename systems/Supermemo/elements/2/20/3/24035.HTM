<P class=docText><FONT class=extract>A kernel thread (or a normal process) can be in any of the following process states: <SPAN class=docEmphasis>running</SPAN>, <SPAN class=docEmphasis>interruptible</SPAN>, <SPAN class=docEmphasis>uninterruptible</SPAN>, <SPAN class=docEmphasis>zombie</SPAN>, <SPAN class=docEmphasis>stopped</SPAN>, <SPAN class=docEmphasis>traced</SPAN></FONT><A name=or></A><FONT class=extract>, or <SPAN class=docEmphasis>dead</SPAN></FONT><A name="are defined"></A><FONT class=extract>.</FONT> These states are defined in <SPAN class=docEmphasis>include</SPAN>/<SPAN class=docEmphasis>linux</SPAN>/<SPAN class=docEmphasis>sched</SPAN>.<SPAN class=docEmphasis>h</SPAN>:</P>
<UL>
<LI>
<P class=docList><A name="process in"></A><FONT class=extract>A process in the <SPAN class=docEmphStrong>running</SPAN> state (<TT>TASK_RUNNING</TT></FONT><A name="candidate for"></A><FONT class=extract>) is in the scheduler run queue and is a candidate for getting CPU time allotted by the scheduler.</FONT></P>
<LI>
<P class=docList><FONT class=extract>A task in the <SPAN class=docEmphStrong>interruptible</SPAN> state (<TT>TASK_INTERRUPTIBLE</TT></FONT><A name="to occur"></A><FONT class=extract>) is waiting for an event to occur and is not in the scheduler run queue. When the task gets woken up, or if a signal is delivered to it, it re-enters the run queue.</FONT></P>
<LI>
<P class=docList><FONT class=extract>The <SPAN class=docEmphStrong>uninterruptible</SPAN> state (<TT>TASK_UNINTERRUPTIBLE</TT>) is similar to the <SPAN class=docEmphStrong>interruptible</SPAN></FONT><A name="put the"></A><FONT class=extract> state except that receipt of a signal will not put the task back into the run queue.</FONT></P>
<LI>
<P class=docList><FONT class=extract>A <SPAN class=docEmphStrong>stopped</SPAN> task (<TT>TASK_STOPPED</TT></FONT><A name="of certain"></A><FONT class=extract>) has stopped execution due to receipt of certain signals.</FONT></P>
<LI>
<P class=docList><A name="the ptrace"></A><FONT class=extract>If an application such as strace is using the ptrace support in the kernel to intercept a task, it'll be in the <SPAN class=docEmphStrong>traced</SPAN> state (<TT>TASK_TRACED</TT>).</FONT></P>
<LI>
<P class=docList><A name="task in"></A><FONT class=extract>A task in the <SPAN class=docEmphStrong>zombie</SPAN> state (<TT>EXIT_ZOMBIE</TT></FONT><A name="to complete"></A><FONT class=extract>) has terminated, but its parent did not wait for the task to complete. An exiting task is either in the <TT>EXIT_ZOMBIE</TT></FONT><A name="state or"></A><FONT class=extract> state or the dead (<TT>EXIT_DEAD</TT>) state.</FONT></P></LI></UL>
<P class=docText><A name=use></A><FONT class=extract>You can use <TT>set_current_state()</TT></FONT><A name="set the"></A><FONT class=extract> to set the run state of your kernel thread.</FONT>