include/linux/notifier.h 
<P></P>
<P>&nbsp;</P>
<P>/*<BR>&nbsp;*&nbsp;Routines to manage notifier chains for passing status changes to any<BR>&nbsp;*&nbsp;interested routines. We need this instead of hard coded call lists so<BR>&nbsp;*&nbsp;that modules can poke their nose into the innards. The network devices<BR>&nbsp;*&nbsp;needed them so here they are for the rest of you.<BR>&nbsp;*<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Alan Cox &lt;<A href="mailto:Alan.Cox@linux.org">Alan.Cox@linux.org</A>&gt;<BR>&nbsp;*/<BR>&nbsp;<BR>#ifndef _LINUX_NOTIFIER_H<BR>#define _LINUX_NOTIFIER_H<BR>#include &lt;linux/errno.h&gt;<BR>#include &lt;linux/mutex.h&gt;<BR>#include &lt;linux/rwsem.h&gt;<BR>#include &lt;linux/srcu.h&gt;</P>
<P></P>
<P><FONT class=extract>/*<BR>&nbsp;* Notifier chains are of four types:<BR>&nbsp;*<BR>&nbsp;*&nbsp;Atomic notifier chains: Chain callbacks run in interrupt/atomic<BR>&nbsp;*&nbsp;&nbsp;context. Callouts are not allowed to block.<BR>&nbsp;*&nbsp;Blocking notifier chains: Chain callbacks run in process context.<BR>&nbsp;*&nbsp;&nbsp;Callouts are allowed to block.<BR>&nbsp;*&nbsp;Raw notifier chains: There are no restrictions on callbacks,<BR>&nbsp;*&nbsp;&nbsp;registration, or unregistration.&nbsp; All locking and protection<BR>&nbsp;*&nbsp;&nbsp;must be provided by the caller.<BR>&nbsp;*&nbsp;SRCU notifier chains: A variant of blocking notifier chains, with<BR>&nbsp;*&nbsp;&nbsp;the same restrictions.<BR>&nbsp;*<BR>&nbsp;* atomic_notifier_chain_register() may be called from an atomic context,<BR>&nbsp;* but blocking_notifier_chain_register() and srcu_notifier_chain_register()<BR>&nbsp;* must be called from a process context.&nbsp; Ditto for the corresponding<BR>&nbsp;* _unregister() routines.<BR>&nbsp;*<BR>&nbsp;* atomic_notifier_chain_unregister(), blocking_notifier_chain_unregister(),<BR>&nbsp;* and srcu_notifier_chain_unregister() _must not_ be called from within<BR>&nbsp;* the call chain.<BR>&nbsp;*<BR>&nbsp;* SRCU notifier chains are an alternative form of blocking notifier chains.<BR>&nbsp;* They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for<BR>&nbsp;* protection of the chain links.&nbsp; This means there is _very_ low overhead<BR>&nbsp;* in srcu_notifier_call_chain(): no cache bounces and no memory barriers.<BR>&nbsp;* As compensation, srcu_notifier_chain_unregister() is rather expensive.<BR>&nbsp;* SRCU notifier chains should be used when the chain will be called very<BR>&nbsp;* often but notifier_blocks will seldom be removed.&nbsp; Also, SRCU notifier<BR>&nbsp;* chains are slightly more difficult to use because they require special<BR>&nbsp;* runtime initialization.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>typedef&nbsp;int (*notifier_fn_t)(struct notifier_block *nb,<BR>&nbsp;&nbsp;&nbsp;unsigned long action, void *data);</FONT></P>
<P><FONT class=extract>struct notifier_block {<BR>&nbsp;notifier_fn_t notifier_call;<BR>&nbsp;struct notifier_block __rcu *next;<BR>&nbsp;int priority;<BR>};</FONT></P>
<P><FONT class=extract>struct atomic_notifier_head {<BR>&nbsp;spinlock_t lock;<BR>&nbsp;struct notifier_block __rcu *head;<BR>};</FONT></P>
<P><FONT class=extract>struct blocking_notifier_head {<BR>&nbsp;struct rw_semaphore rwsem;<BR>&nbsp;struct notifier_block __rcu *head;<BR>};</FONT></P>
<P><FONT class=extract>struct raw_notifier_head {<BR>&nbsp;struct notifier_block __rcu *head;<BR>};</FONT></P>
<P><FONT class=extract>struct srcu_notifier_head {<BR>&nbsp;struct mutex mutex;<BR>&nbsp;struct srcu_struct srcu;<BR>&nbsp;struct notifier_block __rcu *head;<BR>};</FONT></P>
<P><FONT class=extract>#define ATOMIC_INIT_NOTIFIER_HEAD(name) do {&nbsp;\<BR>&nbsp;&nbsp;spin_lock_init(&amp;(name)-&gt;lock);&nbsp;\<BR>&nbsp;&nbsp;(name)-&gt;head = NULL;&nbsp;&nbsp;\<BR>&nbsp;} while (0)<BR>#define BLOCKING_INIT_NOTIFIER_HEAD(name) do {&nbsp;\<BR>&nbsp;&nbsp;init_rwsem(&amp;(name)-&gt;rwsem);&nbsp;\<BR>&nbsp;&nbsp;(name)-&gt;head = NULL;&nbsp;&nbsp;\<BR>&nbsp;} while (0)<BR>#define RAW_INIT_NOTIFIER_HEAD(name) do {&nbsp;\<BR>&nbsp;&nbsp;(name)-&gt;head = NULL;&nbsp;&nbsp;\<BR>&nbsp;} while (0)</FONT></P>
<P><FONT class=extract>/* srcu_notifier_heads must be initialized and cleaned up dynamically */<BR>extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);<BR>#define srcu_cleanup_notifier_head(name)&nbsp;\<BR>&nbsp;&nbsp;cleanup_srcu_struct(&amp;(name)-&gt;srcu);</FONT></P>
<P><FONT class=extract>#define ATOMIC_NOTIFIER_INIT(name) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.lock = __SPIN_LOCK_UNLOCKED(name.lock),&nbsp;\<BR>&nbsp;&nbsp;.head = NULL }<BR>#define BLOCKING_NOTIFIER_INIT(name) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.rwsem = __RWSEM_INITIALIZER((name).rwsem),&nbsp;\<BR>&nbsp;&nbsp;.head = NULL }<BR>#define RAW_NOTIFIER_INIT(name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.head = NULL }<BR>/* srcu_notifier_heads cannot be initialized statically */</FONT></P>
<P><FONT class=extract>#define ATOMIC_NOTIFIER_HEAD(name)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct atomic_notifier_head name =&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;ATOMIC_NOTIFIER_INIT(name)<BR>#define BLOCKING_NOTIFIER_HEAD(name)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct blocking_notifier_head name =&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;BLOCKING_NOTIFIER_INIT(name)<BR>#define RAW_NOTIFIER_HEAD(name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct raw_notifier_head name =&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;RAW_NOTIFIER_INIT(name)</FONT></P>
<P>#ifdef __KERNEL__</P>
<P><FONT class=extract>extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);<BR>extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);<BR>extern int raw_notifier_chain_register(struct raw_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);<BR>extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);</FONT></P>
<P><FONT class=extract>extern int blocking_notifier_chain_cond_register(<BR>&nbsp;&nbsp;struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);</FONT></P>
<P><FONT class=extract>extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);<BR>extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);<BR>extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);<BR>extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,<BR>&nbsp;&nbsp;struct notifier_block *nb);</FONT></P>
<P><FONT class=extract>extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;unsigned long val, void *v);<BR>extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh,<BR>&nbsp;unsigned long val, void *v, int nr_to_call, int *nr_calls);<BR>extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;unsigned long val, void *v);<BR>extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,<BR>&nbsp;unsigned long val, void *v, int nr_to_call, int *nr_calls);<BR>extern int raw_notifier_call_chain(struct raw_notifier_head *nh,<BR>&nbsp;&nbsp;unsigned long val, void *v);<BR>extern int __raw_notifier_call_chain(struct raw_notifier_head *nh,<BR>&nbsp;unsigned long val, void *v, int nr_to_call, int *nr_calls);<BR>extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh,<BR>&nbsp;&nbsp;unsigned long val, void *v);<BR>extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh,<BR>&nbsp;unsigned long val, void *v, int nr_to_call, int *nr_calls);</FONT></P>
<P><FONT class=extract>#define NOTIFY_DONE&nbsp;&nbsp;0x0000&nbsp;&nbsp;/* Don't care */<BR>#define NOTIFY_OK&nbsp;&nbsp;0x0001&nbsp;&nbsp;/* Suits me */<BR>#define NOTIFY_STOP_MASK&nbsp;0x8000&nbsp;&nbsp;/* Don't call further */<BR>#define NOTIFY_BAD&nbsp;&nbsp;(NOTIFY_STOP_MASK|0x0002)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Bad/Veto action */</FONT><BR><FONT class=extract>/*<BR>&nbsp;* Clean way to return from the notifier and stop further calls.<BR>&nbsp;*/<BR>#define NOTIFY_STOP&nbsp;&nbsp;(NOTIFY_OK|NOTIFY_STOP_MASK)</FONT></P>
<P><FONT class=extract>/* Encapsulate (negative) errno value (in particular, NOTIFY_BAD &lt;=&gt; EPERM). */<BR>static inline int notifier_from_errno(int err)<BR>{<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return NOTIFY_STOP_MASK | (NOTIFY_OK - err);</FONT></P>
<P><FONT class=extract>&nbsp;return NOTIFY_OK;<BR>}</FONT></P>
<P><FONT class=extract>/* Restore (negative) errno value from notify return value. */<BR>static inline int notifier_to_errno(int ret)<BR>{<BR>&nbsp;ret &amp;= ~NOTIFY_STOP_MASK;<BR>&nbsp;return ret &gt; NOTIFY_OK ? NOTIFY_OK - ret : 0;<BR>}</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;*&nbsp;Declared notifiers so far. I can imagine quite a few more chains<BR>&nbsp;*&nbsp;over time (eg laptop power reset chains, reboot chain (to clean <BR>&nbsp;*&nbsp;device units up), device [un]mount chain, module load/unload chain,<BR>&nbsp;*&nbsp;low memory chain, screenblank chain (for plug in modular screenblankers) <BR>&nbsp;*&nbsp;VC switch chains (for loadable kernel svgalib VC switch helpers) etc...<BR>&nbsp;*/<BR>&nbsp;<BR>/* CPU notfiers are defined in include/linux/cpu.h. */</FONT></P>
<P><FONT class=extract>/* netdevice notifiers are defined in include/linux/netdevice.h */</FONT></P>
<P><FONT class=extract>/* reboot notifiers are defined in include/linux/reboot.h. */</FONT></P>
<P><FONT class=extract>/* Hibernation and suspend events are defined in include/linux/suspend.h. */</FONT></P>
<P><FONT class=extract>/* Virtual Terminal events are defined in include/linux/vt.h. */</FONT></P>
<P><FONT class=extract>#define NETLINK_URELEASE&nbsp;0x0001&nbsp;/* Unicast netlink socket released */</FONT></P>
<P><FONT class=extract>/* Console keyboard events.<BR>&nbsp;* Note: KBD_KEYCODE is always sent before KBD_UNBOUND_KEYCODE, KBD_UNICODE and<BR>&nbsp;* KBD_KEYSYM. */<BR>#define KBD_KEYCODE&nbsp;&nbsp;0x0001 /* Keyboard keycode, called before any other */<BR>#define KBD_UNBOUND_KEYCODE&nbsp;0x0002 /* Keyboard keycode which is not bound to any other */<BR>#define KBD_UNICODE&nbsp;&nbsp;0x0003 /* Keyboard unicode */<BR>#define KBD_KEYSYM&nbsp;&nbsp;0x0004 /* Keyboard keysym */<BR>#define KBD_POST_KEYSYM&nbsp;&nbsp;0x0005 /* Called after keyboard keysym interpretation */</FONT></P>
<P>extern struct blocking_notifier_head reboot_notifier_list;</P>
<P>#endif /* __KERNEL__ */<BR>#endif /* _LINUX_NOTIFIER_H */