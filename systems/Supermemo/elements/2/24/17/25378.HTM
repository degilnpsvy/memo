/*<BR><FONT class=extract>&nbsp;* Notifier chains are of four types:<BR>&nbsp;*<BR>&nbsp;*&nbsp;Atomic notifier chains: Chain callbacks run in interrupt/atomic<BR>&nbsp;*&nbsp;&nbsp;context. Callouts are not allowed to block.<BR>&nbsp;*&nbsp;Blocking notifier chains: Chain callbacks run in process context.<BR>&nbsp;*&nbsp;&nbsp;Callouts are allowed to block.<BR>&nbsp;*&nbsp;Raw notifier chains: There are no restrictions on callbacks,<BR>&nbsp;*&nbsp;&nbsp;registration, or unregistration.&nbsp; All locking and protection<BR>&nbsp;*&nbsp;&nbsp;must be provided by the caller.<BR>&nbsp;*&nbsp;SRCU notifier chains: A variant of blocking notifier chains, with<BR>&nbsp;*&nbsp;&nbsp;the same restrictions.</FONT><BR>&nbsp;*<BR>&nbsp;* atomic_notifier_chain_register() may be called from an atomic context,<BR>&nbsp;* but blocking_notifier_chain_register() and srcu_notifier_chain_register()<BR>&nbsp;* must be called from a process context.&nbsp; Ditto for the corresponding<BR>&nbsp;* _unregister() routines.<BR>&nbsp;*<BR>&nbsp;* atomic_notifier_chain_unregister(), blocking_notifier_chain_unregister(),<BR>&nbsp;* and srcu_notifier_chain_unregister() _must not_ be called from within<BR>&nbsp;* the call chain.<BR>&nbsp;*<BR><FONT class=extract>&nbsp;* SRCU notifier chains are an alternative form of blocking notifier chains.<BR>&nbsp;* They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for<BR>&nbsp;* protection of the chain links.</FONT>&nbsp; This means there is _very_ low overhead<BR>&nbsp;* in srcu_notifier_call_chain(): no cache bounces and no memory barriers.<BR>&nbsp;* As compensation, srcu_notifier_chain_unregister() is rather expensive.<BR>&nbsp;* SRCU notifier chains should be used when the chain will be called very<BR>&nbsp;* often but notifier_blocks will seldom be removed.&nbsp; Also, SRCU notifier<BR>&nbsp;* chains are slightly more difficult to use because they require special<BR>&nbsp;* runtime initialization.<BR>&nbsp;*/