/*<BR>&nbsp;* Reader/writer consistent mechanism without starving writers. This type of<BR>&nbsp;* lock for data where the reader wants a consistent set of information<BR>&nbsp;* and is willing to retry if the information changes. There are two types<BR>&nbsp;* of readers:<BR>&nbsp;* 1. Sequence readers which never block a writer but they may have to retry<BR>&nbsp;*&nbsp;&nbsp;&nbsp; if a writer is in progress by detecting change in sequence number.<BR>&nbsp;*&nbsp;&nbsp;&nbsp; Writers do not wait for a sequence reader.<BR>&nbsp;* 2. Locking readers which will wait if a writer or another locking reader<BR>&nbsp;*&nbsp;&nbsp;&nbsp; is in progress. A locking reader in progress will also block a writer<BR>&nbsp;*&nbsp;&nbsp;&nbsp; from going forward. Unlike the regular rwlock, the read lock here is<BR>&nbsp;*&nbsp;&nbsp;&nbsp; exclusive so that only one locking reader can get it.<BR>&nbsp;*<BR>&nbsp;* This is not as cache friendly as brlock. Also, this may not work well<BR>&nbsp;* for data that contains pointers, because any writer could<BR>&nbsp;* invalidate a pointer that a reader was following.<BR>&nbsp;*<BR>&nbsp;* Expected non-blocking reader usage:<BR>&nbsp;* &nbsp;do {<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; seq = read_seqbegin(&amp;foo);<BR>&nbsp;* &nbsp;...<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while (read_seqretry(&amp;foo, seq));<BR>&nbsp;*<BR>&nbsp;*<BR>&nbsp;* On non-SMP the spin locks disappear but the writer still needs<BR>&nbsp;* to increment the sequence variables because an interrupt routine could<BR>&nbsp;* change the state of the data.<BR>&nbsp;*<BR>&nbsp;* Based on x86_64 vsyscall gettimeofday <BR>&nbsp;* by Keith Owens and Andrea Arcangeli<BR>&nbsp;*/