lib/klist.c 
<P></P>
<P><FONT class=extract>/*<BR>&nbsp;* klist.c - Routines for manipulating klists.<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2005 Patrick Mochel<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPL v2.<BR>&nbsp;*<BR>&nbsp;* This klist interface provides a couple of structures that wrap around<BR>&nbsp;* struct list_head to provide explicit list "head" (struct klist) and list<BR>&nbsp;* "node" (struct klist_node) objects. For struct klist, a spinlock is<BR>&nbsp;* included that protects access to the actual list itself. struct<BR>&nbsp;* klist_node provides a pointer to the klist that owns it and a kref<BR>&nbsp;* reference count that indicates the number of current users of that node<BR>&nbsp;* in the list.<BR>&nbsp;*<BR>&nbsp;* The entire point is to provide an interface for iterating over a list<BR>&nbsp;* that is safe and allows for modification of the list during the<BR>&nbsp;* iteration (e.g. insertion and removal), including modification of the<BR>&nbsp;* current node on the list.<BR>&nbsp;*<BR>&nbsp;* It works using a 3rd object type - struct klist_iter - that is declared<BR>&nbsp;* and initialized before an iteration. klist_next() is used to acquire the<BR>&nbsp;* next element in the list. It returns NULL if there are no more items.<BR>&nbsp;* Internally, that routine takes the klist's lock, decrements the<BR>&nbsp;* reference count of the previous klist_node and increments the count of<BR>&nbsp;* the next klist_node. It then drops the lock and returns.<BR>&nbsp;*<BR>&nbsp;* There are primitives for adding and removing nodes to/from a klist.<BR>&nbsp;* When deleting, klist_del() will simply decrement the reference count.<BR>&nbsp;* Only when the count goes to 0 is the node removed from the list.<BR>&nbsp;* klist_remove() will try to delete the node from the list and block until<BR>&nbsp;* it is actually removed. This is useful for objects (like devices) that<BR>&nbsp;* have been removed from the system and must be freed (but must wait until<BR>&nbsp;* all accessors have finished).<BR>&nbsp;*/</FONT></P>
<P></P>
<P>#include &lt;linux/klist.h&gt;<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/sched.h&gt;</P>
<P>/*<BR>&nbsp;* Use the lowest bit of n_klist to mark deleted nodes and exclude<BR>&nbsp;* dead ones from iteration.<BR>&nbsp;*/<BR><FONT class=extract>#define KNODE_DEAD&nbsp;&nbsp;1LU<BR>#define KNODE_KLIST_MASK&nbsp;~KNODE_DEAD</FONT></P>
<P><FONT class=extract>static struct klist *knode_klist(struct klist_node *knode)<BR>{<BR>&nbsp;return (struct klist *)<BR>&nbsp;&nbsp;((unsigned long)knode-&gt;n_klist &amp; KNODE_KLIST_MASK);<BR>}</FONT></P>
<P><FONT class=extract>static bool knode_dead(struct klist_node *knode)<BR>{<BR>&nbsp;return (unsigned long)knode-&gt;n_klist &amp; KNODE_DEAD;<BR>}</FONT></P>
<P><FONT class=extract>static void knode_set_klist(struct klist_node *knode, struct klist *klist)<BR>{<BR>&nbsp;knode-&gt;n_klist = klist;<BR>&nbsp;/* no knode deserves to start its life dead */<BR>&nbsp;WARN_ON(knode_dead(knode));<BR>}</FONT></P>
<P><FONT class=extract>static void knode_kill(struct klist_node *knode)<BR>{<BR>&nbsp;/* and no knode should die twice ever either, see we're very humane */<BR>&nbsp;WARN_ON(knode_dead(knode));<BR>&nbsp;*(unsigned long *)&amp;knode-&gt;n_klist |= KNODE_DEAD;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_init - Initialize a klist structure.<BR>&nbsp;* @k: The klist we're initializing.<BR>&nbsp;* @get: The get function for the embedding object (NULL if none)<BR>&nbsp;* @put: The put function for the embedding object (NULL if none)<BR>&nbsp;*<BR>&nbsp;* Initialises the klist structure.&nbsp; If the klist_node structures are<BR>&nbsp;* going to be embedded in refcounted objects (necessary for safe<BR>&nbsp;* deletion) then the get/put arguments are used to initialise<BR>&nbsp;* functions that take and release references on the embedding<BR>&nbsp;* objects.<BR>&nbsp;*/<BR>void klist_init(struct klist *k, void (*get)(struct klist_node *),<BR>&nbsp;&nbsp;void (*put)(struct klist_node *))<BR>{<BR>&nbsp;INIT_LIST_HEAD(&amp;k-&gt;k_list);<BR>&nbsp;spin_lock_init(&amp;k-&gt;k_lock);<BR>&nbsp;k-&gt;get = get;<BR>&nbsp;k-&gt;put = put;<BR>}<BR>EXPORT_SYMBOL_GPL(klist_init);</FONT></P>
<P><FONT class=extract>static void add_head(struct klist *k, struct klist_node *n)<BR>{<BR>&nbsp;spin_lock(&amp;k-&gt;k_lock);<BR>&nbsp;list_add(&amp;n-&gt;n_node, &amp;k-&gt;k_list);<BR>&nbsp;spin_unlock(&amp;k-&gt;k_lock);<BR>}</FONT></P>
<P><FONT class=extract>static void add_tail(struct klist *k, struct klist_node *n)<BR>{<BR>&nbsp;spin_lock(&amp;k-&gt;k_lock);<BR>&nbsp;list_add_tail(&amp;n-&gt;n_node, &amp;k-&gt;k_list);<BR>&nbsp;spin_unlock(&amp;k-&gt;k_lock);<BR>}</FONT></P>
<P><FONT class=extract>static void klist_node_init(struct klist *k, struct klist_node *n)<BR>{<BR>&nbsp;INIT_LIST_HEAD(&amp;n-&gt;n_node);<BR>&nbsp;kref_init(&amp;n-&gt;n_ref);<BR>&nbsp;knode_set_klist(n, k);<BR>&nbsp;if (k-&gt;get)<BR>&nbsp;&nbsp;k-&gt;get(n);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_add_head - Initialize a klist_node and add it to front.<BR>&nbsp;* @n: node we're adding.<BR>&nbsp;* @k: klist it's going on.<BR>&nbsp;*/<BR>void klist_add_head(struct klist_node *n, struct klist *k)<BR>{<BR>&nbsp;klist_node_init(k, n);<BR>&nbsp;add_head(k, n);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_add_head);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_add_tail - Initialize a klist_node and add it to back.<BR>&nbsp;* @n: node we're adding.<BR>&nbsp;* @k: klist it's going on.<BR>&nbsp;*/<BR>void klist_add_tail(struct klist_node *n, struct klist *k)<BR>{<BR>&nbsp;klist_node_init(k, n);<BR>&nbsp;add_tail(k, n);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_add_tail);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_add_behind - Init a klist_node and add it after an existing node<BR>&nbsp;* @n: node we're adding.<BR>&nbsp;* @pos: node to put @n after<BR>&nbsp;*/<BR>void klist_add_behind(struct klist_node *n, struct klist_node *pos)<BR>{<BR>&nbsp;struct klist *k = knode_klist(pos);</FONT></P>
<P><FONT class=extract>&nbsp;klist_node_init(k, n);<BR>&nbsp;spin_lock(&amp;k-&gt;k_lock);<BR>&nbsp;list_add(&amp;n-&gt;n_node, &amp;pos-&gt;n_node);<BR>&nbsp;spin_unlock(&amp;k-&gt;k_lock);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_add_behind);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_add_before - Init a klist_node and add it before an existing node<BR>&nbsp;* @n: node we're adding.<BR>&nbsp;* @pos: node to put @n after<BR>&nbsp;*/<BR>void klist_add_before(struct klist_node *n, struct klist_node *pos)<BR>{<BR>&nbsp;struct klist *k = knode_klist(pos);</FONT></P>
<P><FONT class=extract>&nbsp;klist_node_init(k, n);<BR>&nbsp;spin_lock(&amp;k-&gt;k_lock);<BR>&nbsp;list_add_tail(&amp;n-&gt;n_node, &amp;pos-&gt;n_node);<BR>&nbsp;spin_unlock(&amp;k-&gt;k_lock);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_add_before);</FONT></P>
<P><FONT class=extract>struct klist_waiter {<BR>&nbsp;struct list_head list;<BR>&nbsp;struct klist_node *node;<BR>&nbsp;struct task_struct *process;<BR>&nbsp;int woken;<BR>};</FONT></P>
<P><FONT class=extract>static DEFINE_SPINLOCK(klist_remove_lock);<BR>static LIST_HEAD(klist_remove_waiters);</FONT></P>
<P><FONT class=extract>static void klist_release(struct kref *kref)<BR>{<BR>&nbsp;struct klist_waiter *waiter, *tmp;<BR>&nbsp;struct klist_node *n = container_of(kref, struct klist_node, n_ref);</FONT></P>
<P><FONT class=extract>&nbsp;WARN_ON(!knode_dead(n));<BR>&nbsp;list_del(&amp;n-&gt;n_node);<BR>&nbsp;spin_lock(&amp;klist_remove_lock);<BR>&nbsp;list_for_each_entry_safe(waiter, tmp, &amp;klist_remove_waiters, list) {<BR>&nbsp;&nbsp;if (waiter-&gt;node != n)<BR>&nbsp;&nbsp;&nbsp;continue;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;list_del(&amp;waiter-&gt;list);<BR>&nbsp;&nbsp;waiter-&gt;woken = 1;<BR>&nbsp;&nbsp;mb();<BR>&nbsp;&nbsp;wake_up_process(waiter-&gt;process);<BR>&nbsp;}<BR>&nbsp;spin_unlock(&amp;klist_remove_lock);<BR>&nbsp;knode_set_klist(n, NULL);<BR>}</FONT></P>
<P><FONT class=extract>static int klist_dec_and_del(struct klist_node *n)<BR>{<BR>&nbsp;return kref_put(&amp;n-&gt;n_ref, klist_release);<BR>}</FONT></P>
<P><FONT class=extract>static void klist_put(struct klist_node *n, bool kill)<BR>{<BR>&nbsp;struct klist *k = knode_klist(n);<BR>&nbsp;void (*put)(struct klist_node *) = k-&gt;put;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;k-&gt;k_lock);<BR>&nbsp;if (kill)<BR>&nbsp;&nbsp;knode_kill(n);<BR>&nbsp;if (!klist_dec_and_del(n))<BR>&nbsp;&nbsp;put = NULL;<BR>&nbsp;spin_unlock(&amp;k-&gt;k_lock);<BR>&nbsp;if (put)<BR>&nbsp;&nbsp;put(n);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_del - Decrement the reference count of node and try to remove.<BR>&nbsp;* @n: node we're deleting.<BR>&nbsp;*/<BR>void klist_del(struct klist_node *n)<BR>{<BR>&nbsp;klist_put(n, true);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_del);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_remove - Decrement the refcount of node and wait for it to go away.<BR>&nbsp;* @n: node we're removing.<BR>&nbsp;*/<BR>void klist_remove(struct klist_node *n)<BR>{<BR>&nbsp;struct klist_waiter waiter;</FONT></P>
<P><FONT class=extract>&nbsp;waiter.node = n;<BR>&nbsp;waiter.process = current;<BR>&nbsp;waiter.woken = 0;<BR>&nbsp;spin_lock(&amp;klist_remove_lock);<BR>&nbsp;list_add(&amp;waiter.list, &amp;klist_remove_waiters);<BR>&nbsp;spin_unlock(&amp;klist_remove_lock);</FONT></P>
<P><FONT class=extract>&nbsp;klist_del(n);</FONT></P>
<P><FONT class=extract>&nbsp;for (;;) {<BR>&nbsp;&nbsp;set_current_state(TASK_UNINTERRUPTIBLE);<BR>&nbsp;&nbsp;if (waiter.woken)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;schedule();<BR>&nbsp;}<BR>&nbsp;__set_current_state(TASK_RUNNING);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_remove);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_node_attached - Say whether a node is bound to a list or not.<BR>&nbsp;* @n: Node that we're testing.<BR>&nbsp;*/<BR>int klist_node_attached(struct klist_node *n)<BR>{<BR>&nbsp;return (n-&gt;n_klist != NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_node_attached);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_iter_init_node - Initialize a klist_iter structure.<BR>&nbsp;* @k: klist we're iterating.<BR>&nbsp;* @i: klist_iter we're filling.<BR>&nbsp;* @n: node to start with.<BR>&nbsp;*<BR>&nbsp;* Similar to klist_iter_init(), but starts the action off with @n,<BR>&nbsp;* instead of with the list head.<BR>&nbsp;*/<BR>void klist_iter_init_node(struct klist *k, struct klist_iter *i,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct klist_node *n)<BR>{<BR>&nbsp;i-&gt;i_klist = k;<BR>&nbsp;i-&gt;i_cur = n;<BR>&nbsp;if (n)<BR>&nbsp;&nbsp;kref_get(&amp;n-&gt;n_ref);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_iter_init_node);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_iter_init - Iniitalize a klist_iter structure.<BR>&nbsp;* @k: klist we're iterating.<BR>&nbsp;* @i: klist_iter structure we're filling.<BR>&nbsp;*<BR>&nbsp;* Similar to klist_iter_init_node(), but start with the list head.<BR>&nbsp;*/<BR>void klist_iter_init(struct klist *k, struct klist_iter *i)<BR>{<BR>&nbsp;klist_iter_init_node(k, i, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(klist_iter_init);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_iter_exit - Finish a list iteration.<BR>&nbsp;* @i: Iterator structure.<BR>&nbsp;*<BR>&nbsp;* Must be called when done iterating over list, as it decrements the<BR>&nbsp;* refcount of the current node. Necessary in case iteration exited before<BR>&nbsp;* the end of the list was reached, and always good form.<BR>&nbsp;*/<BR>void klist_iter_exit(struct klist_iter *i)<BR>{<BR>&nbsp;if (i-&gt;i_cur) {<BR>&nbsp;&nbsp;klist_put(i-&gt;i_cur, false);<BR>&nbsp;&nbsp;i-&gt;i_cur = NULL;<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(klist_iter_exit);</FONT></P>
<P><FONT class=extract>static struct klist_node *to_klist_node(struct list_head *n)<BR>{<BR>&nbsp;return container_of(n, struct klist_node, n_node);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* klist_next - Ante up next node in list.<BR>&nbsp;* @i: Iterator structure.<BR>&nbsp;*<BR>&nbsp;* First grab list lock. Decrement the reference count of the previous<BR>&nbsp;* node, if there was one. Grab the next node, increment its reference<BR>&nbsp;* count, drop the lock, and return that next node.<BR>&nbsp;*/<BR>struct klist_node *klist_next(struct klist_iter *i)<BR>{<BR>&nbsp;void (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;<BR>&nbsp;struct klist_node *last = i-&gt;i_cur;<BR>&nbsp;struct klist_node *next;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock(&amp;i-&gt;i_klist-&gt;k_lock);</FONT></P>
<P><FONT class=extract>&nbsp;if (last) {<BR>&nbsp;&nbsp;next = to_klist_node(last-&gt;n_node.next);<BR>&nbsp;&nbsp;if (!klist_dec_and_del(last))<BR>&nbsp;&nbsp;&nbsp;put = NULL;<BR>&nbsp;} else<BR>&nbsp;&nbsp;next = to_klist_node(i-&gt;i_klist-&gt;k_list.next);</FONT></P>
<P><FONT class=extract>&nbsp;i-&gt;i_cur = NULL;<BR>&nbsp;while (next != to_klist_node(&amp;i-&gt;i_klist-&gt;k_list)) {<BR>&nbsp;&nbsp;if (likely(!knode_dead(next))) {<BR>&nbsp;&nbsp;&nbsp;kref_get(&amp;next-&gt;n_ref);<BR>&nbsp;&nbsp;&nbsp;i-&gt;i_cur = next;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;next = to_klist_node(next-&gt;n_node.next);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;spin_unlock(&amp;i-&gt;i_klist-&gt;k_lock);</FONT></P>
<P><FONT class=extract>&nbsp;if (put &amp;&amp; last)<BR>&nbsp;&nbsp;put(last);<BR>&nbsp;return i-&gt;i_cur;<BR>}<BR>EXPORT_SYMBOL_GPL(klist_next);</FONT>