include/linux/module.h</P>
<P>#ifndef _LINUX_MODULE_H<BR>#define _LINUX_MODULE_H<BR>/*<BR>&nbsp;* Dynamic loading of modules into the kernel.<BR>&nbsp;*<BR>&nbsp;* Rewritten by Richard Henderson &lt;<A href="mailto:rth@tamu.edu">rth@tamu.edu</A>&gt; Dec 1996<BR>&nbsp;* Rewritten again by Rusty Russell, 2002<BR>&nbsp;*/<BR>#include &lt;linux/list.h&gt;<BR>#include &lt;linux/stat.h&gt;<BR>#include &lt;linux/compiler.h&gt;<BR>#include &lt;linux/cache.h&gt;<BR>#include &lt;linux/kmod.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/elf.h&gt;<BR>#include &lt;linux/stringify.h&gt;<BR>#include &lt;linux/kobject.h&gt;<BR>#include &lt;linux/moduleparam.h&gt;<BR>#include &lt;linux/jump_label.h&gt;<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/rbtree_latch.h&gt;</P>
<P></P>
<P>#include &lt;linux/percpu.h&gt;<BR>#include &lt;asm/module.h&gt;</P>
<P>/* In stripped ARM and x86-64 modules, ~ is surprisingly rare. */<BR>#define MODULE_SIG_STRING "~Module signature appended~\n"</P>
<P>/* Not Yet Implemented */<BR>#define MODULE_SUPPORTED_DEVICE(name)</P>
<P>#define MODULE_NAME_LEN MAX_PARAM_PREFIX_LEN</P>
<P>struct modversion_info {<BR>&nbsp;unsigned long crc;<BR>&nbsp;char name[MODULE_NAME_LEN];<BR>};</P>
<P>struct module;</P>
<P>struct module_kobject {<BR>&nbsp;struct kobject kobj;<BR>&nbsp;struct module *mod;<BR>&nbsp;struct kobject *drivers_dir;<BR>&nbsp;struct module_param_attrs *mp;<BR>&nbsp;struct completion *kobj_completion;<BR>};</P>
<P>struct module_attribute {<BR>&nbsp;struct attribute attr;<BR>&nbsp;ssize_t (*show)(struct module_attribute *, struct module_kobject *,<BR>&nbsp;&nbsp;&nbsp;char *);<BR>&nbsp;ssize_t (*store)(struct module_attribute *, struct module_kobject *,<BR>&nbsp;&nbsp;&nbsp; const char *, size_t count);<BR>&nbsp;void (*setup)(struct module *, const char *);<BR>&nbsp;int (*test)(struct module *);<BR>&nbsp;void (*free)(struct module *);<BR>};</P>
<P>struct module_version_attribute {<BR>&nbsp;struct module_attribute mattr;<BR>&nbsp;const char *module_name;<BR>&nbsp;const char *version;<BR>} __attribute__ ((__aligned__(sizeof(void *))));</P>
<P>extern ssize_t __modver_version_show(struct module_attribute *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module_kobject *, char *);</P>
<P>extern struct module_attribute module_uevent;</P>
<P>/* These are either module local, or the kernel's dummy ones. */<BR>extern int init_module(void);<BR>extern void cleanup_module(void);</P>
<P>#ifndef MODULE<BR>/**<BR>&nbsp;* module_init() - driver initialization entry point<BR>&nbsp;* @x: function to be run at kernel boot time or module insertion<BR>&nbsp;*<BR>&nbsp;* module_init() will either be called during do_initcalls() (if<BR>&nbsp;* builtin) or at module insertion time (if a module).&nbsp; There can only<BR>&nbsp;* be one per module.<BR>&nbsp;*/<BR>#define module_init(x)&nbsp;__initcall(x);</P>
<P>/**<BR>&nbsp;* module_exit() - driver exit entry point<BR>&nbsp;* @x: function to be run when driver is removed<BR>&nbsp;*<BR>&nbsp;* module_exit() will wrap the driver clean-up code<BR>&nbsp;* with cleanup_module() when used with rmmod when<BR>&nbsp;* the driver is a module.&nbsp; If the driver is statically<BR>&nbsp;* compiled into the kernel, module_exit() has no effect.<BR>&nbsp;* There can only be one per module.<BR>&nbsp;*/<BR>#define module_exit(x)&nbsp;__exitcall(x);</P>
<P>#else /* MODULE */</P>
<P>/*<BR>&nbsp;* In most cases loadable modules do not need custom<BR>&nbsp;* initcall levels. There are still some valid cases where<BR>&nbsp;* a driver may be needed early if built in, and does not<BR>&nbsp;* matter when built as a loadable module. Like bus<BR>&nbsp;* snooping debug drivers.<BR>&nbsp;*/<BR>#define early_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define core_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define core_initcall_sync(fn)&nbsp;&nbsp;module_init(fn)<BR>#define postcore_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define postcore_initcall_sync(fn)&nbsp;module_init(fn)<BR>#define arch_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define subsys_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define subsys_initcall_sync(fn)&nbsp;module_init(fn)<BR>#define fs_initcall(fn)&nbsp;&nbsp;&nbsp;module_init(fn)<BR>#define fs_initcall_sync(fn)&nbsp;&nbsp;module_init(fn)<BR>#define rootfs_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define device_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define device_initcall_sync(fn)&nbsp;module_init(fn)<BR>#define late_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define late_initcall_sync(fn)&nbsp;&nbsp;module_init(fn)</P>
<P>#define console_initcall(fn)&nbsp;&nbsp;module_init(fn)<BR>#define security_initcall(fn)&nbsp;&nbsp;module_init(fn)</P>
<P>/* Each module must use one module_init(). */<BR>#define module_init(initfn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static inline initcall_t __inittest(void)&nbsp;&nbsp;\<BR>&nbsp;{ return initfn; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int init_module(void) __attribute__((alias(#initfn)));</P>
<P>/* This is only required if you want to be unloadable. */<BR>#define module_exit(exitfn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static inline exitcall_t __exittest(void)&nbsp;&nbsp;\<BR>&nbsp;{ return exitfn; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;void cleanup_module(void) __attribute__((alias(#exitfn)));</P>
<P>#endif</P>
<P>/* This means "can be init if no module support, otherwise module load<BR>&nbsp;&nbsp; may call it." */<BR>#ifdef CONFIG_MODULES<BR>#define __init_or_module<BR>#define __initdata_or_module<BR>#define __initconst_or_module<BR>#define __INIT_OR_MODULE&nbsp;.text<BR>#define __INITDATA_OR_MODULE&nbsp;.data<BR>#define __INITRODATA_OR_MODULE&nbsp;.section ".rodata","a",%progbits<BR>#else<BR>#define __init_or_module __init<BR>#define __initdata_or_module __initdata<BR>#define __initconst_or_module __initconst<BR>#define __INIT_OR_MODULE __INIT<BR>#define __INITDATA_OR_MODULE __INITDATA<BR>#define __INITRODATA_OR_MODULE __INITRODATA<BR>#endif /*CONFIG_MODULES*/</P>
<P>/* Archs provide a method of finding the correct exception table. */<BR>struct exception_table_entry;</P>
<P>const struct exception_table_entry *<BR>search_extable(const struct exception_table_entry *first,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct exception_table_entry *last,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long value);<BR>void sort_extable(struct exception_table_entry *start,<BR>&nbsp;&nbsp;&nbsp; struct exception_table_entry *finish);<BR>void sort_main_extable(void);<BR>void trim_init_extable(struct module *m);</P>
<P>/* Generic info of form tag = "info" */<BR>#define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)</P>
<P>/* For userspace: you can also call me... */<BR>#define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)</P>
<P>/* Soft module dependencies. See man modprobe.d for details.<BR>&nbsp;* Example: MODULE_SOFTDEP("pre: module-foo module-bar post: module-baz")<BR>&nbsp;*/<BR>#define MODULE_SOFTDEP(_softdep) MODULE_INFO(softdep, _softdep)</P>
<P>/*<BR>&nbsp;* The following license idents are currently accepted as indicating free<BR>&nbsp;* software modules<BR>&nbsp;*<BR>&nbsp;*&nbsp;"GPL"&nbsp;&nbsp;&nbsp;&nbsp;[GNU Public License v2 or later]<BR>&nbsp;*&nbsp;"GPL v2"&nbsp;&nbsp;&nbsp;[GNU Public License v2]<BR>&nbsp;*&nbsp;"GPL and additional rights"&nbsp;[GNU Public License v2 rights and more]<BR>&nbsp;*&nbsp;"Dual BSD/GPL"&nbsp;&nbsp;&nbsp;[GNU Public License v2<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or BSD license choice]<BR>&nbsp;*&nbsp;"Dual MIT/GPL"&nbsp;&nbsp;&nbsp;[GNU Public License v2<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or MIT license choice]<BR>&nbsp;*&nbsp;"Dual MPL/GPL"&nbsp;&nbsp;&nbsp;[GNU Public License v2<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or Mozilla license choice]<BR>&nbsp;*<BR>&nbsp;* The following other idents are available<BR>&nbsp;*<BR>&nbsp;*&nbsp;"Proprietary"&nbsp;&nbsp;&nbsp;[Non free products]<BR>&nbsp;*<BR>&nbsp;* There are dual licensed components, but when running with Linux it is the<BR>&nbsp;* GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL<BR>&nbsp;* is a GPL combined work.<BR>&nbsp;*<BR>&nbsp;* This exists for several reasons<BR>&nbsp;* 1.&nbsp;So modinfo can show license info for users wanting to vet their setup<BR>&nbsp;*&nbsp;is free<BR>&nbsp;* 2.&nbsp;So the community can ignore bug reports including proprietary modules<BR>&nbsp;* 3.&nbsp;So vendors can do likewise based on their own policies<BR>&nbsp;*/<BR>#define MODULE_LICENSE(_license) MODULE_INFO(license, _license)</P>
<P>/*<BR>&nbsp;* Author(s), use "Name &lt;email&gt;" or just "Name", for multiple<BR>&nbsp;* authors use multiple MODULE_AUTHOR() statements/lines.<BR>&nbsp;*/<BR>#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)</P>
<P>/* What your module does. */<BR>#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)</P>
<P>#ifdef MODULE<BR>/* Creates an alias so file2alias.c can find device table. */<BR>#define MODULE_DEVICE_TABLE(type, name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>extern const typeof(name) __mod_##type##__##name##_device_table&nbsp;&nbsp;\<BR>&nbsp; __attribute__ ((unused, alias(__stringify(name))))<BR>#else&nbsp; /* !MODULE */<BR>#define MODULE_DEVICE_TABLE(type, name)<BR>#endif</P>
<P>/* Version of form [&lt;epoch&gt;:]&lt;version&gt;[-&lt;extra-version&gt;].<BR>&nbsp;* Or for CVS/RCS ID version, everything but the number is stripped.<BR>&nbsp;* &lt;epoch&gt;: A (small) unsigned integer which allows you to start versions<BR>&nbsp;* anew. If not mentioned, it's zero.&nbsp; eg. "2:1.0" is after<BR>&nbsp;* "1:2.0".</P>
<P>&nbsp;* &lt;version&gt;: The &lt;version&gt; may contain only alphanumerics and the<BR>&nbsp;* character `.'.&nbsp; Ordered by numeric sort for numeric parts,<BR>&nbsp;* ascii sort for ascii parts (as per RPM or DEB algorithm).</P>
<P>&nbsp;* &lt;extraversion&gt;: Like &lt;version&gt;, but inserted for local<BR>&nbsp;* customizations, eg "rh3" or "rusty1".</P>
<P>&nbsp;* Using this automatically adds a checksum of the .c files and the<BR>&nbsp;* local headers in "srcversion".<BR>&nbsp;*/</P>
<P>#if defined(MODULE) || !defined(CONFIG_SYSFS)<BR>#define MODULE_VERSION(_version) MODULE_INFO(version, _version)<BR>#else<BR>#define MODULE_VERSION(_version)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static struct module_version_attribute ___modver_attr = {&nbsp;\<BR>&nbsp;&nbsp;.mattr&nbsp;= {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;.attr&nbsp;= {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;.name&nbsp;= "version",&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;.mode&nbsp;= S_IRUGO,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;.show&nbsp;= __modver_version_show,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.module_name&nbsp;= KBUILD_MODNAME,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.version&nbsp;= _version,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static const struct module_version_attribute&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__used __attribute__ ((__section__ ("__modver")))&nbsp;&nbsp;\<BR>&nbsp;* __moduleparam_const __modver_attr = &amp;___modver_attr<BR>#endif</P>
<P>/* Optional firmware file (or files) needed by the module<BR>&nbsp;* format is simply firmware file name.&nbsp; Multiple firmware<BR>&nbsp;* files require multiple MODULE_FIRMWARE() specifiers */<BR>#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)</P>
<P>/* Given an address, look for it in the exception tables */<BR>const struct exception_table_entry *search_exception_tables(unsigned long add);</P>
<P>struct notifier_block;</P>
<P>#ifdef CONFIG_MODULES</P>
<P>extern int modules_disabled; /* for sysctl */<BR>/* Get/put a kernel symbol (calls must be symmetric) */<BR>void *__symbol_get(const char *symbol);<BR>void *__symbol_get_gpl(const char *symbol);<BR>#define symbol_get(x) ((typeof(&amp;x))(__symbol_get(VMLINUX_SYMBOL_STR(x))))</P>
<P>/* modules using other modules: kdb wants to see this. */<BR>struct module_use {<BR>&nbsp;struct list_head source_list;<BR>&nbsp;struct list_head target_list;<BR>&nbsp;struct module *source, *target;<BR>};</P>
<P>enum module_state {<BR>&nbsp;MODULE_STATE_LIVE,&nbsp;/* Normal state. */<BR>&nbsp;MODULE_STATE_COMING,&nbsp;/* Full formed, running module_init. */<BR>&nbsp;MODULE_STATE_GOING,&nbsp;/* Going away. */<BR>&nbsp;MODULE_STATE_UNFORMED,&nbsp;/* Still setting it up. */<BR>};</P>
<P>struct module;</P>
<P>struct mod_tree_node {<BR>&nbsp;struct module *mod;<BR>&nbsp;struct latch_tree_node node;<BR>};</P>
<P>struct module {<BR>&nbsp;enum module_state state;</P>
<P>&nbsp;/* Member of list of modules */<BR>&nbsp;struct list_head list;</P>
<P>&nbsp;/* Unique handle for this module */<BR>&nbsp;char name[MODULE_NAME_LEN];</P>
<P>&nbsp;/* Sysfs stuff. */<BR>&nbsp;struct module_kobject mkobj;<BR>&nbsp;struct module_attribute *modinfo_attrs;<BR>&nbsp;const char *version;<BR>&nbsp;const char *srcversion;<BR>&nbsp;struct kobject *holders_dir;</P>
<P>&nbsp;/* Exported symbols */<BR>&nbsp;const struct kernel_symbol *syms;<BR>&nbsp;const unsigned long *crcs;<BR>&nbsp;unsigned int num_syms;</P>
<P>&nbsp;/* Kernel parameters. */<BR>#ifdef CONFIG_SYSFS<BR>&nbsp;struct mutex param_lock;<BR>#endif<BR>&nbsp;struct kernel_param *kp;<BR>&nbsp;unsigned int num_kp;</P>
<P>&nbsp;/* GPL-only exported symbols. */<BR>&nbsp;unsigned int num_gpl_syms;<BR>&nbsp;const struct kernel_symbol *gpl_syms;<BR>&nbsp;const unsigned long *gpl_crcs;</P>
<P>#ifdef CONFIG_UNUSED_SYMBOLS<BR>&nbsp;/* unused exported symbols. */<BR>&nbsp;const struct kernel_symbol *unused_syms;<BR>&nbsp;const unsigned long *unused_crcs;<BR>&nbsp;unsigned int num_unused_syms;</P>
<P>&nbsp;/* GPL-only, unused exported symbols. */<BR>&nbsp;unsigned int num_unused_gpl_syms;<BR>&nbsp;const struct kernel_symbol *unused_gpl_syms;<BR>&nbsp;const unsigned long *unused_gpl_crcs;<BR>#endif</P>
<P>#ifdef CONFIG_MODULE_SIG<BR>&nbsp;/* Signature was verified. */<BR>&nbsp;bool sig_ok;<BR>#endif</P>
<P>&nbsp;bool async_probe_requested;</P>
<P>&nbsp;/* symbols that will be GPL-only in the near future. */<BR>&nbsp;const struct kernel_symbol *gpl_future_syms;<BR>&nbsp;const unsigned long *gpl_future_crcs;<BR>&nbsp;unsigned int num_gpl_future_syms;</P>
<P>&nbsp;/* Exception table */<BR>&nbsp;unsigned int num_exentries;<BR>&nbsp;struct exception_table_entry *extable;</P>
<P>&nbsp;/* Startup function. */<BR>&nbsp;int (*init)(void);</P>
<P>&nbsp;/*<BR>&nbsp; * If this is non-NULL, vfree() after init() returns.<BR>&nbsp; *<BR>&nbsp; * Cacheline align here, such that:<BR>&nbsp; *&nbsp;&nbsp; module_init, module_core, init_size, core_size,<BR>&nbsp; *&nbsp;&nbsp; init_text_size, core_text_size and mtn_core::{mod,node[0]}<BR>&nbsp; * are on the same cacheline.<BR>&nbsp; */<BR>&nbsp;void *module_init&nbsp;____cacheline_aligned;</P>
<P>&nbsp;/* Here is the actual code + data, vfree'd on unload. */<BR>&nbsp;void *module_core;</P>
<P>&nbsp;/* Here are the sizes of the init and core sections */<BR>&nbsp;unsigned int init_size, core_size;</P>
<P>&nbsp;/* The size of the executable code in each section.&nbsp; */<BR>&nbsp;unsigned int init_text_size, core_text_size;</P>
<P>#ifdef CONFIG_MODULES_TREE_LOOKUP<BR>&nbsp;/*<BR>&nbsp; * We want mtn_core::{mod,node[0]} to be in the same cacheline as the<BR>&nbsp; * above entries such that a regular lookup will only touch one<BR>&nbsp; * cacheline.<BR>&nbsp; */<BR>&nbsp;struct mod_tree_node&nbsp;mtn_core;<BR>&nbsp;struct mod_tree_node&nbsp;mtn_init;<BR>#endif</P>
<P>&nbsp;/* Size of RO sections of the module (text+rodata) */<BR>&nbsp;unsigned int init_ro_size, core_ro_size;</P>
<P>&nbsp;/* Arch-specific module values */<BR>&nbsp;struct mod_arch_specific arch;</P>
<P>&nbsp;unsigned int taints;&nbsp;/* same bits as kernel:tainted */</P>
<P>#ifdef CONFIG_GENERIC_BUG<BR>&nbsp;/* Support for BUG */<BR>&nbsp;unsigned num_bugs;<BR>&nbsp;struct list_head bug_list;<BR>&nbsp;struct bug_entry *bug_table;<BR>#endif</P>
<P>#ifdef CONFIG_KALLSYMS<BR>&nbsp;/*<BR>&nbsp; * We keep the symbol and string tables for kallsyms.<BR>&nbsp; * The core_* fields below are temporary, loader-only (they<BR>&nbsp; * could really be discarded after module init).<BR>&nbsp; */<BR>&nbsp;Elf_Sym *symtab, *core_symtab;<BR>&nbsp;unsigned int num_symtab, core_num_syms;<BR>&nbsp;char *strtab, *core_strtab;</P>
<P>&nbsp;/* Section attributes */<BR>&nbsp;struct module_sect_attrs *sect_attrs;</P>
<P>&nbsp;/* Notes attributes */<BR>&nbsp;struct module_notes_attrs *notes_attrs;<BR>#endif</P>
<P>&nbsp;/* The command line arguments (may be mangled).&nbsp; People like<BR>&nbsp;&nbsp;&nbsp; keeping pointers to this stuff */<BR>&nbsp;char *args;</P>
<P>#ifdef CONFIG_SMP<BR>&nbsp;/* Per-cpu data. */<BR>&nbsp;void __percpu *percpu;<BR>&nbsp;unsigned int percpu_size;<BR>#endif</P>
<P>#ifdef CONFIG_TRACEPOINTS<BR>&nbsp;unsigned int num_tracepoints;<BR>&nbsp;struct tracepoint * const *tracepoints_ptrs;<BR>#endif<BR>#ifdef HAVE_JUMP_LABEL<BR>&nbsp;struct jump_entry *jump_entries;<BR>&nbsp;unsigned int num_jump_entries;<BR>#endif<BR>#ifdef CONFIG_TRACING<BR>&nbsp;unsigned int num_trace_bprintk_fmt;<BR>&nbsp;const char **trace_bprintk_fmt_start;<BR>#endif<BR>#ifdef CONFIG_EVENT_TRACING<BR>&nbsp;struct trace_event_call **trace_events;<BR>&nbsp;unsigned int num_trace_events;<BR>&nbsp;struct trace_enum_map **trace_enums;<BR>&nbsp;unsigned int num_trace_enums;<BR>#endif<BR>#ifdef CONFIG_FTRACE_MCOUNT_RECORD<BR>&nbsp;unsigned int num_ftrace_callsites;<BR>&nbsp;unsigned long *ftrace_callsites;<BR>#endif</P>
<P>#ifdef CONFIG_LIVEPATCH<BR>&nbsp;bool klp_alive;<BR>#endif</P>
<P>#ifdef CONFIG_MODULE_UNLOAD<BR>&nbsp;/* What modules depend on me? */<BR>&nbsp;struct list_head source_list;<BR>&nbsp;/* What modules do I depend on? */<BR>&nbsp;struct list_head target_list;</P>
<P>&nbsp;/* Destruction function. */<BR>&nbsp;void (*exit)(void);</P>
<P>&nbsp;atomic_t refcnt;<BR>#endif</P>
<P>#ifdef CONFIG_CONSTRUCTORS<BR>&nbsp;/* Constructor functions. */<BR>&nbsp;ctor_fn_t *ctors;<BR>&nbsp;unsigned int num_ctors;<BR>#endif<BR>} ____cacheline_aligned;<BR>#ifndef MODULE_ARCH_INIT<BR>#define MODULE_ARCH_INIT {}<BR>#endif</P>
<P>extern struct mutex module_mutex;</P>
<P>/* FIXME: It'd be nice to isolate modules during init, too, so they<BR>&nbsp;&nbsp; aren't used before they (may) fail.&nbsp; But presently too much code<BR>&nbsp;&nbsp; (IDE &amp; SCSI) require entry into the module during init.*/<BR>static inline int module_is_live(struct module *mod)<BR>{<BR>&nbsp;return mod-&gt;state != MODULE_STATE_GOING;<BR>}</P>
<P>struct module *__module_text_address(unsigned long addr);<BR>struct module *__module_address(unsigned long addr);<BR>bool is_module_address(unsigned long addr);<BR>bool is_module_percpu_address(unsigned long addr);<BR>bool is_module_text_address(unsigned long addr);</P>
<P>static inline bool within_module_core(unsigned long addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct module *mod)<BR>{<BR>&nbsp;return (unsigned long)mod-&gt;module_core &lt;= addr &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr &lt; (unsigned long)mod-&gt;module_core + mod-&gt;core_size;<BR>}</P>
<P>static inline bool within_module_init(unsigned long addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct module *mod)<BR>{<BR>&nbsp;return (unsigned long)mod-&gt;module_init &lt;= addr &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr &lt; (unsigned long)mod-&gt;module_init + mod-&gt;init_size;<BR>}</P>
<P>static inline bool within_module(unsigned long addr, const struct module *mod)<BR>{<BR>&nbsp;return within_module_init(addr, mod) || within_module_core(addr, mod);<BR>}</P>
<P>/* Search for module by name: must hold module_mutex. */<BR>struct module *find_module(const char *name);</P>
<P>struct symsearch {<BR>&nbsp;const struct kernel_symbol *start, *stop;<BR>&nbsp;const unsigned long *crcs;<BR>&nbsp;enum {<BR>&nbsp;&nbsp;NOT_GPL_ONLY,<BR>&nbsp;&nbsp;GPL_ONLY,<BR>&nbsp;&nbsp;WILL_BE_GPL_ONLY,<BR>&nbsp;} licence;<BR>&nbsp;bool unused;<BR>};</P>
<P>/*<BR>&nbsp;* Search for an exported symbol by name.<BR>&nbsp;*<BR>&nbsp;* Must be called with module_mutex held or preemption disabled.<BR>&nbsp;*/<BR>const struct kernel_symbol *find_symbol(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct module **owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned long **crc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool gplok,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool warn);</P>
<P>/*<BR>&nbsp;* Walk the exported symbol table<BR>&nbsp;*<BR>&nbsp;* Must be called with module_mutex held or preemption disabled.<BR>&nbsp;*/<BR>bool each_symbol_section(bool (*fn)(const struct symsearch *arr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data), void *data);</P>
<P>/* Returns 0 and fills in value, defined and namebuf, or -ERANGE if<BR>&nbsp;&nbsp; symnum out of range. */<BR>int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,<BR>&nbsp;&nbsp;&nbsp;char *name, char *module_name, int *exported);</P>
<P>/* Look for this name: can be of form module:name. */<BR>unsigned long module_kallsyms_lookup_name(const char *name);</P>
<P>int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *, unsigned long),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data);</P>
<P>extern void __module_put_and_exit(struct module *mod, long code)<BR>&nbsp;__attribute__((noreturn));<BR>#define module_put_and_exit(code) __module_put_and_exit(THIS_MODULE, code)</P>
<P>#ifdef CONFIG_MODULE_UNLOAD<BR>int module_refcount(struct module *mod);<BR>void __symbol_put(const char *symbol);<BR>#define symbol_put(x) __symbol_put(VMLINUX_SYMBOL_STR(x))<BR>void symbol_put_addr(void *addr);</P>
<P>/* Sometimes we know we already have a refcount, and it's easier not<BR>&nbsp;&nbsp; to handle the error case (which only happens with rmmod --wait). */<BR>extern void __module_get(struct module *module);</P>
<P>/* This is the Right Way to get a module: if it fails, it's being removed,<BR>&nbsp;* so pretend it's not there. */<BR>extern bool try_module_get(struct module *module);</P>
<P>extern void module_put(struct module *module);</P>
<P>#else /*!CONFIG_MODULE_UNLOAD*/<BR>static inline int try_module_get(struct module *module)<BR>{<BR>&nbsp;return !module || module_is_live(module);<BR>}<BR>static inline void module_put(struct module *module)<BR>{<BR>}<BR>static inline void __module_get(struct module *module)<BR>{<BR>}<BR>#define symbol_put(x) do { } while (0)<BR>#define symbol_put_addr(p) do { } while (0)</P>
<P>#endif /* CONFIG_MODULE_UNLOAD */<BR>int ref_module(struct module *a, struct module *b);</P>
<P>/* This is a #define so the string doesn't get put in every .o file */<BR>#define module_name(mod)&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct module *__mod = (mod);&nbsp;&nbsp;\<BR>&nbsp;__mod ? __mod-&gt;name : "kernel";&nbsp;&nbsp;\<BR>})</P>
<P>/* For kallsyms to ask for address resolution.&nbsp; namebuf should be at<BR>&nbsp;* least KSYM_NAME_LEN long: a pointer to namebuf is returned if<BR>&nbsp;* found, otherwise NULL. */<BR>const char *module_address_lookup(unsigned long addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *symbolsize,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *offset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **modname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *namebuf);<BR>int lookup_module_symbol_name(unsigned long addr, char *symname);<BR>int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname, char *name);</P>
<P>/* For extable.c to search modules' exception tables. */<BR>const struct exception_table_entry *search_module_extables(unsigned long addr);</P>
<P>int register_module_notifier(struct notifier_block *nb);<BR>int unregister_module_notifier(struct notifier_block *nb);</P>
<P>extern void print_modules(void);</P>
<P>static inline bool module_requested_async_probing(struct module *module)<BR>{<BR>&nbsp;return module &amp;&amp; module-&gt;async_probe_requested;<BR>}</P>
<P>#else /* !CONFIG_MODULES... */</P>
<P>/* Given an address, look for it in the exception tables. */<BR>static inline const struct exception_table_entry *<BR>search_module_extables(unsigned long addr)<BR>{<BR>&nbsp;return NULL;<BR>}</P>
<P>static inline struct module *__module_address(unsigned long addr)<BR>{<BR>&nbsp;return NULL;<BR>}</P>
<P>static inline struct module *__module_text_address(unsigned long addr)<BR>{<BR>&nbsp;return NULL;<BR>}</P>
<P>static inline bool is_module_address(unsigned long addr)<BR>{<BR>&nbsp;return false;<BR>}</P>
<P>static inline bool is_module_percpu_address(unsigned long addr)<BR>{<BR>&nbsp;return false;<BR>}</P>
<P>static inline bool is_module_text_address(unsigned long addr)<BR>{<BR>&nbsp;return false;<BR>}</P>
<P>/* Get/put a kernel symbol (calls should be symmetric) */<BR>#define symbol_get(x) ({ extern typeof(x) x __attribute__((weak)); &amp;(x); })<BR>#define symbol_put(x) do { } while (0)<BR>#define symbol_put_addr(x) do { } while (0)</P>
<P>static inline void __module_get(struct module *module)<BR>{<BR>}</P>
<P>static inline int try_module_get(struct module *module)<BR>{<BR>&nbsp;return 1;<BR>}</P>
<P>static inline void module_put(struct module *module)<BR>{<BR>}</P>
<P>#define module_name(mod) "kernel"</P>
<P>/* For kallsyms to ask for address resolution.&nbsp; NULL means not found. */<BR>static inline const char *module_address_lookup(unsigned long addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *symbolsize,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *offset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **modname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *namebuf)<BR>{<BR>&nbsp;return NULL;<BR>}</P>
<P>static inline int lookup_module_symbol_name(unsigned long addr, char *symname)<BR>{<BR>&nbsp;return -ERANGE;<BR>}</P>
<P>static inline int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname, char *name)<BR>{<BR>&nbsp;return -ERANGE;<BR>}</P>
<P>static inline int module_get_kallsym(unsigned int symnum, unsigned long *value,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *type, char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *module_name, int *exported)<BR>{<BR>&nbsp;return -ERANGE;<BR>}</P>
<P>static inline unsigned long module_kallsyms_lookup_name(const char *name)<BR>{<BR>&nbsp;return 0;<BR>}</P>
<P>static inline int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data)<BR>{<BR>&nbsp;return 0;<BR>}</P>
<P>static inline int register_module_notifier(struct notifier_block *nb)<BR>{<BR>&nbsp;/* no events will happen anyway, so this can always succeed */<BR>&nbsp;return 0;<BR>}</P>
<P>static inline int unregister_module_notifier(struct notifier_block *nb)<BR>{<BR>&nbsp;return 0;<BR>}</P>
<P>#define module_put_and_exit(code) do_exit(code)</P>
<P>static inline void print_modules(void)<BR>{<BR>}</P>
<P>static inline bool module_requested_async_probing(struct module *module)<BR>{<BR>&nbsp;return false;<BR>}</P>
<P>#endif /* CONFIG_MODULES */</P>
<P>#ifdef CONFIG_SYSFS<BR>extern struct kset *module_kset;<BR>extern struct kobj_type module_ktype;<BR>extern int module_sysfs_initialized;<BR>#endif /* CONFIG_SYSFS */</P>
<P>#define symbol_request(x) try_then_request_module(symbol_get(x), "symbol:" #x)</P>
<P>/* BELOW HERE ALL THESE ARE OBSOLETE AND WILL VANISH */</P>
<P>#define __MODULE_STRING(x) __stringify(x)</P>
<P>#ifdef CONFIG_DEBUG_SET_MODULE_RONX<BR>extern void set_all_modules_text_rw(void);<BR>extern void set_all_modules_text_ro(void);<BR>#else<BR>static inline void set_all_modules_text_rw(void) { }<BR>static inline void set_all_modules_text_ro(void) { }<BR>#endif</P>
<P>#ifdef CONFIG_GENERIC_BUG<BR>void module_bug_finalize(const Elf_Ehdr *, const Elf_Shdr *,<BR>&nbsp;&nbsp;&nbsp; struct module *);<BR>void module_bug_cleanup(struct module *);</P>
<P>#else&nbsp;/* !CONFIG_GENERIC_BUG */</P>
<P>static inline void module_bug_finalize(const Elf_Ehdr *hdr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct module *mod)<BR>{<BR>}<BR>static inline void module_bug_cleanup(struct module *mod) {}<BR>#endif&nbsp;/* CONFIG_GENERIC_BUG */</P>
<P>#ifdef CONFIG_MODULE_SIG<BR>static inline bool module_sig_ok(struct module *module)<BR>{<BR>&nbsp;return module-&gt;sig_ok;<BR>}<BR>#else&nbsp;/* !CONFIG_MODULE_SIG */<BR>static inline bool module_sig_ok(struct module *module)<BR>{<BR>&nbsp;return true;<BR>}<BR>#endif&nbsp;/* CONFIG_MODULE_SIG */</P>
<P>#endif /* _LINUX_MODULE_H */