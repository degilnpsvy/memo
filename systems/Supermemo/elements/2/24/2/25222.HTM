/**<BR>&nbsp;* kobject_uevent_env - send an uevent with environmental data<BR>&nbsp;*<BR>&nbsp;* @action: action that is happening<BR>&nbsp;* @kobj: struct kobject that the action is happening to<BR>&nbsp;* @envp_ext: pointer to environmental data<BR>&nbsp;*<BR>&nbsp;* Returns 0 if kobject_uevent_env() is completed with success or the<BR>&nbsp;* corresponding error when it fails.<BR>&nbsp;*/<BR>int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *envp_ext[])<BR>{<BR>&nbsp;struct kobj_uevent_env *env;<BR>&nbsp;const char *action_string = kobject_actions[action];<BR>&nbsp;const char *devpath = NULL;<BR>&nbsp;const char *subsystem;<BR>&nbsp;struct kobject *top_kobj;<BR>&nbsp;struct kset *kset;<BR>&nbsp;const struct kset_uevent_ops *uevent_ops;<BR>&nbsp;int i = 0;<BR>&nbsp;int retval = 0;<BR>#ifdef CONFIG_NET<BR>&nbsp;struct uevent_sock *ue_sk;<BR>#endif 
<P></P>
<P>&nbsp;pr_debug("kobject: '%s' (%p): %s\n",<BR>&nbsp;&nbsp; kobject_name(kobj), kobj, __func__);</P>
<P>&nbsp;/* search the kset we belong to */<BR>&nbsp;top_kobj = kobj;<BR>&nbsp;while (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)<BR>&nbsp;&nbsp;top_kobj = top_kobj-&gt;parent;</P>
<P>&nbsp;if (!top_kobj-&gt;kset) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: attempted to send uevent "<BR>&nbsp;&nbsp;&nbsp; "without kset!\n", kobject_name(kobj), kobj,<BR>&nbsp;&nbsp;&nbsp; __func__);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}</P>
<P>&nbsp;kset = top_kobj-&gt;kset;<BR>&nbsp;uevent_ops = kset-&gt;uevent_ops;</P>
<P>&nbsp;/* skip the event, if uevent_suppress is set*/<BR>&nbsp;if (kobj-&gt;uevent_suppress) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: uevent_suppress "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "caused the event to drop!\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj, __func__);<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}<BR>&nbsp;/* skip the event, if the filter returns zero. */<BR>&nbsp;if (uevent_ops &amp;&amp; uevent_ops-&gt;filter)<BR>&nbsp;&nbsp;if (!uevent_ops-&gt;filter(kset, kobj)) {<BR>&nbsp;&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: filter function "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "caused the event to drop!\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobject_name(kobj), kobj, __func__);<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;/* originating subsystem */<BR>&nbsp;if (uevent_ops &amp;&amp; uevent_ops-&gt;name)<BR>&nbsp;&nbsp;subsystem = uevent_ops-&gt;name(kset, kobj);<BR>&nbsp;else<BR>&nbsp;&nbsp;subsystem = kobject_name(&amp;kset-&gt;kobj);<BR>&nbsp;if (!subsystem) {<BR>&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: unset subsystem caused the "<BR>&nbsp;&nbsp;&nbsp; "event to drop!\n", kobject_name(kobj), kobj,<BR>&nbsp;&nbsp;&nbsp; __func__);<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>&nbsp;/* environment buffer */<BR>&nbsp;env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);<BR>&nbsp;if (!env)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;/* complete object path */<BR>&nbsp;devpath = kobject_get_path(kobj, GFP_KERNEL);<BR>&nbsp;if (!devpath) {<BR>&nbsp;&nbsp;retval = -ENOENT;<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;}</P>
<P>&nbsp;/* default keys */<BR>&nbsp;retval = add_uevent_var(env, "ACTION=%s", action_string);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;retval = add_uevent_var(env, "DEVPATH=%s", devpath);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;retval = add_uevent_var(env, "SUBSYSTEM=%s", subsystem);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto exit;</P>
<P>&nbsp;/* keys passed in from the caller */<BR>&nbsp;if (envp_ext) {<BR>&nbsp;&nbsp;for (i = 0; envp_ext[i]; i++) {<BR>&nbsp;&nbsp;&nbsp;retval = add_uevent_var(env, "%s", envp_ext[i]);<BR>&nbsp;&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* let the kset specific function add its stuff */<BR>&nbsp;if (uevent_ops &amp;&amp; uevent_ops-&gt;uevent) {<BR>&nbsp;&nbsp;retval = uevent_ops-&gt;uevent(kset, kobj, env);<BR>&nbsp;&nbsp;if (retval) {<BR>&nbsp;&nbsp;&nbsp;pr_debug("kobject: '%s' (%p): %s: uevent() returned "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "%d\n", kobject_name(kobj), kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp; __func__, retval);<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Mark "add" and "remove" events in the object to ensure proper<BR>&nbsp; * events to userspace during automatic cleanup. If the object did<BR>&nbsp; * send an "add" event, "remove" will automatically generated by<BR>&nbsp; * the core, if not already done by the caller.<BR>&nbsp; */<BR>&nbsp;if (action == KOBJ_ADD)<BR>&nbsp;&nbsp;kobj-&gt;state_add_uevent_sent = 1;<BR>&nbsp;else if (action == KOBJ_REMOVE)<BR>&nbsp;&nbsp;kobj-&gt;state_remove_uevent_sent = 1;</P>
<P>&nbsp;mutex_lock(&amp;uevent_sock_mutex);<BR>&nbsp;/* we will send an event, so request a new sequence number */<BR>&nbsp;retval = add_uevent_var(env, "SEQNUM=%llu", (unsigned long long)++uevent_seqnum);<BR>&nbsp;if (retval) {<BR>&nbsp;&nbsp;mutex_unlock(&amp;uevent_sock_mutex);<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;}</P>
<P>#if defined(CONFIG_NET)<BR>&nbsp;/* send netlink message */<BR>&nbsp;list_for_each_entry(ue_sk, &amp;uevent_sock_list, list) {<BR>&nbsp;&nbsp;struct sock *uevent_sock = ue_sk-&gt;sk;<BR>&nbsp;&nbsp;struct sk_buff *skb;<BR>&nbsp;&nbsp;size_t len;</P>
<P>&nbsp;&nbsp;if (!netlink_has_listeners(uevent_sock, 1))<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;/* allocate message with the maximum possible size */<BR>&nbsp;&nbsp;len = strlen(action_string) + strlen(devpath) + 2;<BR>&nbsp;&nbsp;skb = alloc_skb(len + env-&gt;buflen, GFP_KERNEL);<BR>&nbsp;&nbsp;if (skb) {<BR>&nbsp;&nbsp;&nbsp;char *scratch;</P>
<P>&nbsp;&nbsp;&nbsp;/* add header */<BR>&nbsp;&nbsp;&nbsp;scratch = skb_put(skb, len);<BR>&nbsp;&nbsp;&nbsp;sprintf(scratch, "<A href="mailto:%s@%s">%s@%s</A>", action_string, devpath);</P>
<P>&nbsp;&nbsp;&nbsp;/* copy keys to our continuous event payload buffer */<BR>&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; env-&gt;envp_idx; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;len = strlen(env-&gt;envp[i]) + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;scratch = skb_put(skb, len);<BR>&nbsp;&nbsp;&nbsp;&nbsp;strcpy(scratch, env-&gt;envp[i]);<BR>&nbsp;&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;&nbsp;NETLINK_CB(skb).dst_group = 1;<BR>&nbsp;&nbsp;&nbsp;retval = netlink_broadcast_filtered(uevent_sock, skb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, GFP_KERNEL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kobj_bcast_filter,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kobj);<BR>&nbsp;&nbsp;&nbsp;/* ENOBUFS should be handled in userspace */<BR>&nbsp;&nbsp;&nbsp;if (retval == -ENOBUFS || retval == -ESRCH)<BR>&nbsp;&nbsp;&nbsp;&nbsp;retval = 0;<BR>&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;}<BR>#endif<BR>&nbsp;mutex_unlock(&amp;uevent_sock_mutex);</P>
<P>#ifdef CONFIG_UEVENT_HELPER<BR>&nbsp;/* call uevent_helper, usually only enabled during early boot */<BR>&nbsp;if (uevent_helper[0] &amp;&amp; !kobj_usermode_filter(kobj)) {<BR>&nbsp;&nbsp;struct subprocess_info *info;</P>
<P>&nbsp;&nbsp;retval = add_uevent_var(env, "HOME=/");<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;retval = add_uevent_var(env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"PATH=/sbin:/bin:/usr/sbin:/usr/bin");<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;retval = init_uevent_argv(env, subsystem);<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;goto exit;</P>
<P>&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;&nbsp;info = call_usermodehelper_setup(env-&gt;argv[0], env-&gt;argv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;envp, GFP_KERNEL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, cleanup_uevent_env, env);<BR>&nbsp;&nbsp;if (info) {<BR>&nbsp;&nbsp;&nbsp;retval = call_usermodehelper_exec(info, UMH_NO_WAIT);<BR>&nbsp;&nbsp;&nbsp;env = NULL;&nbsp;/* freed by cleanup_uevent_env */<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>#endif</P>
<P>exit:<BR>&nbsp;kfree(devpath);<BR>&nbsp;kfree(env);<BR>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL_GPL(kobject_uevent_env);