include/linux/list.h 
<P></P>
<P>&nbsp;</P>
<P>#ifndef _LINUX_LIST_H<BR>#define _LINUX_LIST_H</P>
<P></P>
<P>#include &lt;linux/types.h&gt;<BR>#include &lt;linux/stddef.h&gt;<BR>#include &lt;linux/poison.h&gt;<BR>#include &lt;linux/const.h&gt;<BR>#include &lt;linux/kernel.h&gt;</P>
<P>/*<BR>&nbsp;* Simple doubly linked list implementation.<BR>&nbsp;*<BR>&nbsp;* Some of the internal functions ("__xxx") are useful when<BR>&nbsp;* manipulating whole lists rather than single entries, as<BR>&nbsp;* sometimes we already know the next/prev entries and we can<BR>&nbsp;* generate better code by using them directly rather than<BR>&nbsp;* using the generic single-entry routines.<BR>&nbsp;*/</P>
<P><FONT class=extract>#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</FONT></P>
<P><FONT class=extract>#define LIST_HEAD(name) \<BR>&nbsp;struct list_head name = LIST_HEAD_INIT(name)</FONT></P>
<P><FONT class=extract>static inline void INIT_LIST_HEAD(struct list_head *list)<BR>{<BR>&nbsp;list-&gt;next = list;<BR>&nbsp;list-&gt;prev = list;<BR>}</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Insert a new entry between two known consecutive entries.<BR>&nbsp;*<BR>&nbsp;* This is only for internal list manipulation where we know<BR>&nbsp;* the prev/next entries already!<BR>&nbsp;*/<BR>#ifndef CONFIG_DEBUG_LIST<BR>static inline void __list_add(struct list_head *new,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *prev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *next)<BR>{<BR>&nbsp;next-&gt;prev = new;<BR>&nbsp;new-&gt;next = next;<BR>&nbsp;new-&gt;prev = prev;<BR>&nbsp;prev-&gt;next = new;<BR>}<BR>#else<BR>extern void __list_add(struct list_head *new,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *prev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *next);<BR>#endif</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_add - add a new entry<BR>&nbsp;* @new: new entry to be added<BR>&nbsp;* @head: list head to add it after<BR>&nbsp;*<BR>&nbsp;* Insert a new entry after the specified head.<BR>&nbsp;* This is good for implementing stacks.<BR>&nbsp;*/<BR>static inline void list_add(struct list_head *new, struct list_head *head)<BR>{<BR>&nbsp;__list_add(new, head, head-&gt;next);<BR>}</FONT></P>
<P><BR><FONT class=extract>/**<BR>&nbsp;* list_add_tail - add a new entry<BR>&nbsp;* @new: new entry to be added<BR>&nbsp;* @head: list head to add it before<BR>&nbsp;*<BR>&nbsp;* Insert a new entry before the specified head.<BR>&nbsp;* This is useful for implementing queues.<BR>&nbsp;*/<BR>static inline void list_add_tail(struct list_head *new, struct list_head *head)<BR>{<BR>&nbsp;__list_add(new, head-&gt;prev, head);<BR>}</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Delete a list entry by making the prev/next entries<BR>&nbsp;* point to each other.<BR>&nbsp;*<BR>&nbsp;* This is only for internal list manipulation where we know<BR>&nbsp;* the prev/next entries already!<BR>&nbsp;*/<BR>static inline void __list_del(struct list_head * prev, struct list_head * next)<BR>{<BR>&nbsp;next-&gt;prev = prev;<BR>&nbsp;prev-&gt;next = next;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_del - deletes entry from list.<BR>&nbsp;* @entry: the element to delete from the list.<BR>&nbsp;* Note: list_empty() on entry does not return true after this, the entry is<BR>&nbsp;* in an undefined state.<BR>&nbsp;*/<BR>#ifndef CONFIG_DEBUG_LIST<BR>static inline void __list_del_entry(struct list_head *entry)<BR>{<BR>&nbsp;__list_del(entry-&gt;prev, entry-&gt;next);<BR>}</FONT></P>
<P><FONT class=extract>static inline void list_del(struct list_head *entry)<BR>{<BR>&nbsp;__list_del(entry-&gt;prev, entry-&gt;next);<BR>&nbsp;entry-&gt;next = LIST_POISON1;<BR>&nbsp;entry-&gt;prev = LIST_POISON2;<BR>}<BR>#else<BR>extern void __list_del_entry(struct list_head *entry);<BR>extern void list_del(struct list_head *entry);<BR>#endif</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_replace - replace old entry by new one<BR>&nbsp;* @old : the element to be replaced<BR>&nbsp;* @new : the new element to insert<BR>&nbsp;*<BR>&nbsp;* If @old was empty, it will be overwritten.<BR>&nbsp;*/<BR>static inline void list_replace(struct list_head *old,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *new)<BR>{<BR>&nbsp;new-&gt;next = old-&gt;next;<BR>&nbsp;new-&gt;next-&gt;prev = new;<BR>&nbsp;new-&gt;prev = old-&gt;prev;<BR>&nbsp;new-&gt;prev-&gt;next = new;<BR>}</FONT></P>
<P><FONT class=extract>static inline void list_replace_init(struct list_head *old,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *new)<BR>{<BR>&nbsp;list_replace(old, new);<BR>&nbsp;INIT_LIST_HEAD(old);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_del_init - deletes entry from list and reinitialize it.<BR>&nbsp;* @entry: the element to delete from the list.<BR>&nbsp;*/<BR>static inline void list_del_init(struct list_head *entry)<BR>{<BR>&nbsp;__list_del_entry(entry);<BR>&nbsp;INIT_LIST_HEAD(entry);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_move - delete from one list and add as another's head<BR>&nbsp;* @list: the entry to move<BR>&nbsp;* @head: the head that will precede our entry<BR>&nbsp;*/<BR>static inline void list_move(struct list_head *list, struct list_head *head)<BR>{<BR>&nbsp;__list_del_entry(list);<BR>&nbsp;list_add(list, head);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_move_tail - delete from one list and add as another's tail<BR>&nbsp;* @list: the entry to move<BR>&nbsp;* @head: the head that will follow our entry<BR>&nbsp;*/<BR>static inline void list_move_tail(struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head)<BR>{<BR>&nbsp;__list_del_entry(list);<BR>&nbsp;list_add_tail(list, head);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_is_last - tests whether @list is the last entry in list @head<BR>&nbsp;* @list: the entry to test<BR>&nbsp;* @head: the head of the list<BR>&nbsp;*/<BR>static inline int list_is_last(const struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct list_head *head)<BR>{<BR>&nbsp;return list-&gt;next == head;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_empty - tests whether a list is empty<BR>&nbsp;* @head: the list to test.<BR>&nbsp;*/<BR>static inline int list_empty(const struct list_head *head)<BR>{<BR>&nbsp;return head-&gt;next == head;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_empty_careful - tests whether a list is empty and not being modified<BR>&nbsp;* @head: the list to test<BR>&nbsp;*<BR>&nbsp;* Description:<BR>&nbsp;* tests whether a list is empty _and_ checks that no other CPU might be<BR>&nbsp;* in the process of modifying either member (next or prev)<BR>&nbsp;*<BR>&nbsp;* NOTE: using list_empty_careful() without synchronization<BR>&nbsp;* can only be safe if the only activity that can happen<BR>&nbsp;* to the list entry is list_del_init(). Eg. it cannot be used<BR>&nbsp;* if another CPU could re-list_add() it.<BR>&nbsp;*/<BR>static inline int list_empty_careful(const struct list_head *head)<BR>{<BR>&nbsp;struct list_head *next = head-&gt;next;<BR>&nbsp;return (next == head) &amp;&amp; (next == head-&gt;prev);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_rotate_left - rotate the list to the left<BR>&nbsp;* @head: the head of the list<BR>&nbsp;*/<BR>static inline void list_rotate_left(struct list_head *head)<BR>{<BR>&nbsp;struct list_head *first;</FONT></P>
<P><FONT class=extract>&nbsp;if (!list_empty(head)) {<BR>&nbsp;&nbsp;first = head-&gt;next;<BR>&nbsp;&nbsp;list_move_tail(first, head);<BR>&nbsp;}<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_is_singular - tests whether a list has just one entry.<BR>&nbsp;* @head: the list to test.<BR>&nbsp;*/<BR>static inline int list_is_singular(const struct list_head *head)<BR>{<BR>&nbsp;return !list_empty(head) &amp;&amp; (head-&gt;next == head-&gt;prev);<BR>}</FONT></P>
<P><FONT class=extract>static inline void __list_cut_position(struct list_head *list,<BR>&nbsp;&nbsp;struct list_head *head, struct list_head *entry)<BR>{<BR>&nbsp;struct list_head *new_first = entry-&gt;next;<BR>&nbsp;list-&gt;next = head-&gt;next;<BR>&nbsp;list-&gt;next-&gt;prev = list;<BR>&nbsp;list-&gt;prev = entry;<BR>&nbsp;entry-&gt;next = list;<BR>&nbsp;head-&gt;next = new_first;<BR>&nbsp;new_first-&gt;prev = head;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_cut_position - cut a list into two<BR>&nbsp;* @list: a new list to add all removed entries<BR>&nbsp;* @head: a list with entries<BR>&nbsp;* @entry: an entry within head, could be the head itself<BR>&nbsp;*&nbsp;and if so we won't cut the list<BR>&nbsp;*<BR>&nbsp;* This helper moves the initial part of @head, up to and<BR>&nbsp;* including @entry, from @head to @list. You should<BR>&nbsp;* pass on @entry an element you know is on @head. @list<BR>&nbsp;* should be an empty list or a list you do not care about<BR>&nbsp;* losing its data.<BR>&nbsp;*<BR>&nbsp;*/<BR>static inline void list_cut_position(struct list_head *list,<BR>&nbsp;&nbsp;struct list_head *head, struct list_head *entry)<BR>{<BR>&nbsp;if (list_empty(head))<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (list_is_singular(head) &amp;&amp;<BR>&nbsp;&nbsp;(head-&gt;next != entry &amp;&amp; head != entry))<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (entry == head)<BR>&nbsp;&nbsp;INIT_LIST_HEAD(list);<BR>&nbsp;else<BR>&nbsp;&nbsp;__list_cut_position(list, head, entry);<BR>}</FONT></P>
<P><FONT class=extract>static inline void __list_splice(const struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *prev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *next)<BR>{<BR>&nbsp;struct list_head *first = list-&gt;next;<BR>&nbsp;struct list_head *last = list-&gt;prev;</FONT></P>
<P><FONT class=extract>&nbsp;first-&gt;prev = prev;<BR>&nbsp;prev-&gt;next = first;</FONT></P>
<P><FONT class=extract>&nbsp;last-&gt;next = next;<BR>&nbsp;next-&gt;prev = last;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_splice - join two lists, this is designed for stacks<BR>&nbsp;* @list: the new list to add.<BR>&nbsp;* @head: the place to add it in the first list.<BR>&nbsp;*/<BR>static inline void list_splice(const struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *head)<BR>{<BR>&nbsp;if (!list_empty(list))<BR>&nbsp;&nbsp;__list_splice(list, head, head-&gt;next);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_splice_tail - join two lists, each list being a queue<BR>&nbsp;* @list: the new list to add.<BR>&nbsp;* @head: the place to add it in the first list.<BR>&nbsp;*/<BR>static inline void list_splice_tail(struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *head)<BR>{<BR>&nbsp;if (!list_empty(list))<BR>&nbsp;&nbsp;__list_splice(list, head-&gt;prev, head);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_splice_init - join two lists and reinitialise the emptied list.<BR>&nbsp;* @list: the new list to add.<BR>&nbsp;* @head: the place to add it in the first list.<BR>&nbsp;*<BR>&nbsp;* The list at @list is reinitialised<BR>&nbsp;*/<BR>static inline void list_splice_init(struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head)<BR>{<BR>&nbsp;if (!list_empty(list)) {<BR>&nbsp;&nbsp;__list_splice(list, head, head-&gt;next);<BR>&nbsp;&nbsp;INIT_LIST_HEAD(list);<BR>&nbsp;}<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_splice_tail_init - join two lists and reinitialise the emptied list<BR>&nbsp;* @list: the new list to add.<BR>&nbsp;* @head: the place to add it in the first list.<BR>&nbsp;*<BR>&nbsp;* Each of the lists is a queue.<BR>&nbsp;* The list at @list is reinitialised<BR>&nbsp;*/<BR>static inline void list_splice_tail_init(struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_head *head)<BR>{<BR>&nbsp;if (!list_empty(list)) {<BR>&nbsp;&nbsp;__list_splice(list, head-&gt;prev, head);<BR>&nbsp;&nbsp;INIT_LIST_HEAD(list);<BR>&nbsp;}<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_entry - get the struct for this entry<BR>&nbsp;* @ptr:&nbsp;the &amp;struct list_head pointer.<BR>&nbsp;* @type:&nbsp;the type of the struct this is embedded in.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*/<BR>#define list_entry(ptr, type, member) \<BR>&nbsp;container_of(ptr, type, member)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_first_entry - get the first element from a list<BR>&nbsp;* @ptr:&nbsp;the list head to take the element from.<BR>&nbsp;* @type:&nbsp;the type of the struct this is embedded in.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Note, that list is expected to be not empty.<BR>&nbsp;*/<BR>#define list_first_entry(ptr, type, member) \<BR>&nbsp;list_entry((ptr)-&gt;next, type, member)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_last_entry - get the last element from a list<BR>&nbsp;* @ptr:&nbsp;the list head to take the element from.<BR>&nbsp;* @type:&nbsp;the type of the struct this is embedded in.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Note, that list is expected to be not empty.<BR>&nbsp;*/<BR>#define list_last_entry(ptr, type, member) \<BR>&nbsp;list_entry((ptr)-&gt;prev, type, member)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_first_entry_or_null - get the first element from a list<BR>&nbsp;* @ptr:&nbsp;the list head to take the element from.<BR>&nbsp;* @type:&nbsp;the type of the struct this is embedded in.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Note that if the list is empty, it returns NULL.<BR>&nbsp;*/<BR>#define list_first_entry_or_null(ptr, type, member) \<BR>&nbsp;(!list_empty(ptr) ? list_first_entry(ptr, type, member) : NULL)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_next_entry - get the next element in list<BR>&nbsp;* @pos:&nbsp;the type * to cursor<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*/<BR>#define list_next_entry(pos, member) \<BR>&nbsp;list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_prev_entry - get the prev element in list<BR>&nbsp;* @pos:&nbsp;the type * to cursor<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*/<BR>#define list_prev_entry(pos, member) \<BR>&nbsp;list_entry((pos)-&gt;member.prev, typeof(*(pos)), member)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each&nbsp;-&nbsp;iterate over a list<BR>&nbsp;* @pos:&nbsp;the &amp;struct list_head to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;*/<BR>#define list_for_each(pos, head) \<BR>&nbsp;for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_prev&nbsp;-&nbsp;iterate over a list backwards<BR>&nbsp;* @pos:&nbsp;the &amp;struct list_head to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;*/<BR>#define list_for_each_prev(pos, head) \<BR>&nbsp;for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_safe - iterate over a list safe against removal of list entry<BR>&nbsp;* @pos:&nbsp;the &amp;struct list_head to use as a loop cursor.<BR>&nbsp;* @n:&nbsp;&nbsp;another &amp;struct list_head to use as temporary storage<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;*/<BR>#define list_for_each_safe(pos, n, head) \<BR>&nbsp;for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \<BR>&nbsp;&nbsp;pos = n, n = pos-&gt;next)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry<BR>&nbsp;* @pos:&nbsp;the &amp;struct list_head to use as a loop cursor.<BR>&nbsp;* @n:&nbsp;&nbsp;another &amp;struct list_head to use as temporary storage<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;*/<BR>#define list_for_each_prev_safe(pos, n, head) \<BR>&nbsp;for (pos = (head)-&gt;prev, n = pos-&gt;prev; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos != (head); \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = n, n = pos-&gt;prev)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry&nbsp;-&nbsp;iterate over list of given type<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*/<BR>#define list_for_each_entry(pos, head, member)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (pos = list_first_entry(head, typeof(*pos), member);&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = list_next_entry(pos, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_reverse - iterate backwards over list of given type.<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*/<BR>#define list_for_each_entry_reverse(pos, head, member)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (pos = list_last_entry(head, typeof(*pos), member);&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = list_prev_entry(pos, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()<BR>&nbsp;* @pos:&nbsp;the type * to use as a start point<BR>&nbsp;* @head:&nbsp;the head of the list<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Prepares a pos entry for use as a start point in list_for_each_entry_continue().<BR>&nbsp;*/<BR>#define list_prepare_entry(pos, head, member) \<BR>&nbsp;((pos) ? : list_entry(head, typeof(*pos), member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_continue - continue iteration over list of given type<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Continue to iterate over list of given type, continuing after<BR>&nbsp;* the current position.<BR>&nbsp;*/<BR>#define list_for_each_entry_continue(pos, head, member) &nbsp;&nbsp;\<BR>&nbsp;for (pos = list_next_entry(pos, member);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = list_next_entry(pos, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_continue_reverse - iterate backwards from the given point<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Start to iterate over list of given type backwards, continuing after<BR>&nbsp;* the current position.<BR>&nbsp;*/<BR>#define list_for_each_entry_continue_reverse(pos, head, member)&nbsp;&nbsp;\<BR>&nbsp;for (pos = list_prev_entry(pos, member);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = list_prev_entry(pos, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_from - iterate over list of given type from the current point<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Iterate over list of given type, continuing from current position.<BR>&nbsp;*/<BR>#define list_for_each_entry_from(pos, head, member) &nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (; &amp;pos-&gt;member != (head);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = list_next_entry(pos, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_safe - iterate over list of given type safe against removal of list entry<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @n:&nbsp;&nbsp;another type * to use as temporary storage<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*/<BR>#define list_for_each_entry_safe(pos, n, head, member)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (pos = list_first_entry(head, typeof(*pos), member),&nbsp;\<BR>&nbsp;&nbsp;n = list_next_entry(pos, member);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = n, n = list_next_entry(n, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_safe_continue - continue list iteration safe against removal<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @n:&nbsp;&nbsp;another type * to use as temporary storage<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Iterate over list of given type, continuing after current point,<BR>&nbsp;* safe against removal of list entry.<BR>&nbsp;*/<BR>#define list_for_each_entry_safe_continue(pos, n, head, member) &nbsp;&nbsp;\<BR>&nbsp;for (pos = list_next_entry(pos, member), &nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;n = list_next_entry(pos, member);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = n, n = list_next_entry(n, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_safe_from - iterate over list from current point safe against removal<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @n:&nbsp;&nbsp;another type * to use as temporary storage<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Iterate over list of given type from current point, safe against<BR>&nbsp;* removal of list entry.<BR>&nbsp;*/<BR>#define list_for_each_entry_safe_from(pos, n, head, member) &nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (n = list_next_entry(pos, member);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = n, n = list_next_entry(n, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_for_each_entry_safe_reverse - iterate backwards over list safe against removal<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @n:&nbsp;&nbsp;another type * to use as temporary storage<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* Iterate backwards over list of given type, safe against removal<BR>&nbsp;* of list entry.<BR>&nbsp;*/<BR>#define list_for_each_entry_safe_reverse(pos, n, head, member)&nbsp;&nbsp;\<BR>&nbsp;for (pos = list_last_entry(head, typeof(*pos), member),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;n = list_prev_entry(pos, member);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pos-&gt;member != (head); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = n, n = list_prev_entry(n, member))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* list_safe_reset_next - reset a stale list_for_each_entry_safe loop<BR>&nbsp;* @pos:&nbsp;the loop cursor used in the list_for_each_entry_safe loop<BR>&nbsp;* @n:&nbsp;&nbsp;temporary storage used in list_for_each_entry_safe<BR>&nbsp;* @member:&nbsp;the name of the list_head within the struct.<BR>&nbsp;*<BR>&nbsp;* list_safe_reset_next is not safe to use in general if the list may be<BR>&nbsp;* modified concurrently (eg. the lock is dropped in the loop body). An<BR>&nbsp;* exception to this is if the cursor element (pos) is pinned in the list,<BR>&nbsp;* and list_safe_reset_next is called after re-taking the lock and before<BR>&nbsp;* completing the current iteration of the loop body.<BR>&nbsp;*/<BR>#define list_safe_reset_next(pos, n, member)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;n = list_next_entry(pos, member)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Double linked lists with a single pointer list head.<BR>&nbsp;* Mostly useful for hash tables where the two pointer list head is<BR>&nbsp;* too wasteful.<BR>&nbsp;* You lose the ability to access the tail in O(1).<BR>&nbsp;*/</FONT></P>
<P>#define HLIST_HEAD_INIT { .first = NULL }<BR>#define HLIST_HEAD(name) struct hlist_head name = {&nbsp; .first = NULL }<BR>#define INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)<BR>static inline void INIT_HLIST_NODE(struct hlist_node *h)<BR>{<BR>&nbsp;h-&gt;next = NULL;<BR>&nbsp;h-&gt;pprev = NULL;<BR>}</P>
<P>static inline int hlist_unhashed(const struct hlist_node *h)<BR>{<BR>&nbsp;return !h-&gt;pprev;<BR>}</P>
<P>static inline int hlist_empty(const struct hlist_head *h)<BR>{<BR>&nbsp;return !h-&gt;first;<BR>}</P>
<P>static inline void __hlist_del(struct hlist_node *n)<BR>{<BR>&nbsp;struct hlist_node *next = n-&gt;next;<BR>&nbsp;struct hlist_node **pprev = n-&gt;pprev;<BR>&nbsp;*pprev = next;<BR>&nbsp;if (next)<BR>&nbsp;&nbsp;next-&gt;pprev = pprev;<BR>}</P>
<P>static inline void hlist_del(struct hlist_node *n)<BR>{<BR>&nbsp;__hlist_del(n);<BR>&nbsp;n-&gt;next = LIST_POISON1;<BR>&nbsp;n-&gt;pprev = LIST_POISON2;<BR>}</P>
<P>static inline void hlist_del_init(struct hlist_node *n)<BR>{<BR>&nbsp;if (!hlist_unhashed(n)) {<BR>&nbsp;&nbsp;__hlist_del(n);<BR>&nbsp;&nbsp;INIT_HLIST_NODE(n);<BR>&nbsp;}<BR>}</P>
<P>static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)<BR>{<BR>&nbsp;struct hlist_node *first = h-&gt;first;<BR>&nbsp;n-&gt;next = first;<BR>&nbsp;if (first)<BR>&nbsp;&nbsp;first-&gt;pprev = &amp;n-&gt;next;<BR>&nbsp;h-&gt;first = n;<BR>&nbsp;n-&gt;pprev = &amp;h-&gt;first;<BR>}</P>
<P>/* next must be != NULL */<BR>static inline void hlist_add_before(struct hlist_node *n,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct hlist_node *next)<BR>{<BR>&nbsp;n-&gt;pprev = next-&gt;pprev;<BR>&nbsp;n-&gt;next = next;<BR>&nbsp;next-&gt;pprev = &amp;n-&gt;next;<BR>&nbsp;*(n-&gt;pprev) = n;<BR>}</P>
<P>static inline void hlist_add_behind(struct hlist_node *n,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct hlist_node *prev)<BR>{<BR>&nbsp;n-&gt;next = prev-&gt;next;<BR>&nbsp;prev-&gt;next = n;<BR>&nbsp;n-&gt;pprev = &amp;prev-&gt;next;</P>
<P>&nbsp;if (n-&gt;next)<BR>&nbsp;&nbsp;n-&gt;next-&gt;pprev&nbsp; = &amp;n-&gt;next;<BR>}</P>
<P>/* after that we'll appear to be on some hlist and hlist_del will work */<BR>static inline void hlist_add_fake(struct hlist_node *n)<BR>{<BR>&nbsp;n-&gt;pprev = &amp;n-&gt;next;<BR>}</P>
<P>/*<BR>&nbsp;* Move a list from one list head to another. Fixup the pprev<BR>&nbsp;* reference of the first entry if it exists.<BR>&nbsp;*/<BR>static inline void hlist_move_list(struct hlist_head *old,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct hlist_head *new)<BR>{<BR>&nbsp;new-&gt;first = old-&gt;first;<BR>&nbsp;if (new-&gt;first)<BR>&nbsp;&nbsp;new-&gt;first-&gt;pprev = &amp;new-&gt;first;<BR>&nbsp;old-&gt;first = NULL;<BR>}</P>
<P>#define hlist_entry(ptr, type, member) container_of(ptr,type,member)</P>
<P>#define hlist_for_each(pos, head) \<BR>&nbsp;for (pos = (head)-&gt;first; pos ; pos = pos-&gt;next)</P>
<P>#define hlist_for_each_safe(pos, n, head) \<BR>&nbsp;for (pos = (head)-&gt;first; pos &amp;&amp; ({ n = pos-&gt;next; 1; }); \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = n)</P>
<P>#define hlist_entry_safe(ptr, type, member) \<BR>&nbsp;({ typeof(ptr) ____ptr = (ptr); \<BR>&nbsp;&nbsp;&nbsp; ____ptr ? hlist_entry(____ptr, type, member) : NULL; \<BR>&nbsp;})</P>
<P>/**<BR>&nbsp;* hlist_for_each_entry&nbsp;- iterate over list of given type<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the hlist_node within the struct.<BR>&nbsp;*/<BR>#define hlist_for_each_entry(pos, head, member)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (pos = hlist_entry_safe((head)-&gt;first, typeof(*(pos)), member);\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</P>
<P>/**<BR>&nbsp;* hlist_for_each_entry_continue - iterate over a hlist continuing after current point<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @member:&nbsp;the name of the hlist_node within the struct.<BR>&nbsp;*/<BR>#define hlist_for_each_entry_continue(pos, member)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member);\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</P>
<P>/**<BR>&nbsp;* hlist_for_each_entry_from - iterate over a hlist continuing from current point<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @member:&nbsp;the name of the hlist_node within the struct.<BR>&nbsp;*/<BR>#define hlist_for_each_entry_from(pos, member)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (; pos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</P>
<P>/**<BR>&nbsp;* hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry<BR>&nbsp;* @pos:&nbsp;the type * to use as a loop cursor.<BR>&nbsp;* @n:&nbsp;&nbsp;another &amp;struct hlist_node to use as temporary storage<BR>&nbsp;* @head:&nbsp;the head for your list.<BR>&nbsp;* @member:&nbsp;the name of the hlist_node within the struct.<BR>&nbsp;*/<BR>#define hlist_for_each_entry_safe(pos, n, head, member) &nbsp;&nbsp;\<BR>&nbsp;for (pos = hlist_entry_safe((head)-&gt;first, typeof(*pos), member);\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos &amp;&amp; ({ n = pos-&gt;member.next; 1; });&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = hlist_entry_safe(n, typeof(*pos), member))</P>
<P>#endif