static inline void __list_cut_position(struct list_head *list,<BR>&nbsp;&nbsp;struct list_head *head, struct list_head *entry)<BR>{<BR>&nbsp;struct list_head *new_first = entry-&gt;next;<BR>&nbsp;list-&gt;next = head-&gt;next;<BR>&nbsp;list-&gt;next-&gt;prev = list;<BR>&nbsp;list-&gt;prev = entry;<BR>&nbsp;entry-&gt;next = list;<BR>&nbsp;head-&gt;next = new_first;<BR>&nbsp;new_first-&gt;prev = head;<BR>}
<P></P>
<P>/**<BR>&nbsp;* list_cut_position - cut a list into two<BR>&nbsp;* @list: a new list to add all removed entries<BR>&nbsp;* @head: a list with entries<BR>&nbsp;* @entry: an entry within head, could be the head itself<BR>&nbsp;*&nbsp;and if so we won't cut the list<BR>&nbsp;*<BR>&nbsp;* This helper moves the initial part of @head, up to and<BR>&nbsp;* including @entry, from @head to @list. You should<BR>&nbsp;* pass on @entry an element you know is on @head. @list<BR>&nbsp;* should be an empty list or a list you do not care about<BR>&nbsp;* losing its data.<BR>&nbsp;*<BR>&nbsp;*/<BR>static inline void list_cut_position(struct list_head *list,<BR>&nbsp;&nbsp;struct list_head *head, struct list_head *entry)<BR>{<BR>&nbsp;if (list_empty(head))<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (list_is_singular(head) &amp;&amp;<BR>&nbsp;&nbsp;(head-&gt;next != entry &amp;&amp; head != entry))<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (entry == head)<BR>&nbsp;&nbsp;INIT_LIST_HEAD(list);<BR>&nbsp;else<BR>&nbsp;&nbsp;__list_cut_position(list, head, entry);<BR>}