/**<BR>&nbsp;* flush_scheduled_work - ensure that any scheduled work has run to completion.<BR>&nbsp;*<BR>&nbsp;* Forces execution of the kernel-global workqueue and blocks until its<BR>&nbsp;* completion.<BR>&nbsp;*<BR>&nbsp;* Think twice before calling this function!&nbsp; It's very easy to get into<BR>&nbsp;* trouble if you don't take great care.&nbsp; Either of the following situations<BR>&nbsp;* will lead to deadlock:<BR>&nbsp;*<BR>&nbsp;*&nbsp;One of the work items currently on the workqueue needs to acquire<BR>&nbsp;*&nbsp;a lock held by your code or its caller.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Your code is running in the context of a work routine.<BR>&nbsp;*<BR>&nbsp;* They will be detected by lockdep when they occur, but the first might not<BR>&nbsp;* occur very often.&nbsp; It depends on what work items are on the workqueue and<BR>&nbsp;* what locks they need, which you have no control over.<BR>&nbsp;*<BR>&nbsp;* In most situations flushing the entire workqueue is overkill; you merely<BR>&nbsp;* need to know that a particular work item isn't queued and isn't running.<BR>&nbsp;* In such cases you should use cancel_delayed_work_sync() or<BR>&nbsp;* cancel_work_sync() instead.<BR>&nbsp;*/<BR>static inline void flush_scheduled_work(void)<BR>{<BR>&nbsp;flush_workqueue(system_wq);<BR>}