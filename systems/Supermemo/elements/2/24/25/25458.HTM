/**<BR>&nbsp;*&nbsp;__atomic_notifier_call_chain - Call functions in an atomic notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the atomic notifier chain<BR>&nbsp;*&nbsp;@val: Value passed unmodified to notifier function<BR>&nbsp;*&nbsp;@v: Pointer passed unmodified to notifier function<BR>&nbsp;*&nbsp;@nr_to_call: See the comment for notifier_call_chain.<BR>&nbsp;*&nbsp;@nr_calls: See the comment for notifier_call_chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Calls each function in a notifier chain in turn.&nbsp; The functions<BR>&nbsp;*&nbsp;run in an atomic context, so they must not block.<BR>&nbsp;*&nbsp;This routine uses RCU to synchronize with changes to the chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If the return value of the notifier can be and'ed<BR>&nbsp;*&nbsp;with %NOTIFY_STOP_MASK then atomic_notifier_call_chain()<BR>&nbsp;*&nbsp;will return immediately, with the return value of<BR>&nbsp;*&nbsp;the notifier function which halted execution.<BR>&nbsp;*&nbsp;Otherwise the return value is the return value<BR>&nbsp;*&nbsp;of the last notifier function called.<BR>&nbsp;*/<BR>int __atomic_notifier_call_chain(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int nr_to_call, int *nr_calls)<BR>{<BR>&nbsp;int ret; 
<P></P>
<P>&nbsp;rcu_read_lock();<BR>&nbsp;ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call, nr_calls);<BR>&nbsp;rcu_read_unlock();<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(__atomic_notifier_call_chain);<BR>NOKPROBE_SYMBOL(__atomic_notifier_call_chain);</P>
<P>int atomic_notifier_call_chain(struct atomic_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v)<BR>{<BR>&nbsp;return __atomic_notifier_call_chain(nh, val, v, -1, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(atomic_notifier_call_chain);<BR>NOKPROBE_SYMBOL(atomic_notifier_call_chain);