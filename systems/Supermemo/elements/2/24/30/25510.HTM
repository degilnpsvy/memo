drivers/base/platform.c 
<P></P>
<P>/*<BR>&nbsp;* platform.c - platform 'pseudo' bus for legacy devices<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2002-3 Patrick Mochel<BR>&nbsp;* Copyright (c) 2002-3 Open Source Development Labs<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2<BR>&nbsp;*<BR>&nbsp;* Please see Documentation/driver-model/platform.txt for more<BR>&nbsp;* information.<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/platform_device.h&gt;<BR>#include &lt;linux/of_device.h&gt;<BR>#include &lt;linux/of_irq.h&gt;<BR>#include &lt;linux/module.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/dma-mapping.h&gt;<BR>#include &lt;linux/bootmem.h&gt;<BR>#include &lt;linux/err.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/pm_runtime.h&gt;<BR>#include &lt;linux/pm_domain.h&gt;<BR>#include &lt;linux/idr.h&gt;<BR>#include &lt;linux/acpi.h&gt;<BR>#include &lt;linux/clk/clk-conf.h&gt;<BR>#include &lt;linux/limits.h&gt;</P>
<P>#include "base.h"<BR>#include "power/power.h"</P>
<P><FONT class=extract>/* For automatically allocated device IDs */<BR>static DEFINE_IDA(platform_devid_ida);</FONT></P>
<P><FONT class=extract>struct device platform_bus = {<BR>&nbsp;.init_name&nbsp;= "platform",<BR>};<BR>EXPORT_SYMBOL_GPL(platform_bus);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* arch_setup_pdev_archdata - Allow manipulation of archdata before its used<BR>&nbsp;* @pdev: platform device<BR>&nbsp;*<BR>&nbsp;* This is called before platform_device_add() such that any pdev_archdata may<BR>&nbsp;* be setup before the platform_notifier is called.&nbsp; So if a user needs to<BR>&nbsp;* manipulate any relevant information in the pdev_archdata they can do:<BR>&nbsp;*<BR>&nbsp;*&nbsp;platform_device_alloc()<BR>&nbsp;*&nbsp;... manipulate ...<BR>&nbsp;*&nbsp;platform_device_add()<BR>&nbsp;*<BR>&nbsp;* And if they don't care they can just call platform_device_register() and<BR>&nbsp;* everything will just work out.<BR>&nbsp;*/<BR>void __weak arch_setup_pdev_archdata(struct platform_device *pdev)<BR>{<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_get_resource - get a resource for a device<BR>&nbsp;* @dev: platform device<BR>&nbsp;* @type: resource type<BR>&nbsp;* @num: resource index<BR>&nbsp;*/<BR>struct resource *platform_get_resource(struct platform_device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int type, unsigned int num)<BR>{<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;for (i = 0; i &lt; dev-&gt;num_resources; i++) {<BR>&nbsp;&nbsp;struct resource *r = &amp;dev-&gt;resource[i];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (type == resource_type(r) &amp;&amp; num-- == 0)<BR>&nbsp;&nbsp;&nbsp;return r;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_get_resource);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_get_irq - get an IRQ for a device<BR>&nbsp;* @dev: platform device<BR>&nbsp;* @num: IRQ number index<BR>&nbsp;*/<BR>int platform_get_irq(struct platform_device *dev, unsigned int num)<BR>{<BR>#ifdef CONFIG_SPARC<BR>&nbsp;/* sparc does not have irqs represented as IORESOURCE_IRQ resources */<BR>&nbsp;if (!dev || num &gt;= dev-&gt;archdata.num_irqs)<BR>&nbsp;&nbsp;return -ENXIO;<BR>&nbsp;return dev-&gt;archdata.irqs[num];<BR>#else<BR>&nbsp;struct resource *r;<BR>&nbsp;if (IS_ENABLED(CONFIG_OF_IRQ) &amp;&amp; dev-&gt;dev.of_node) {<BR>&nbsp;&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;ret = of_irq_get(dev-&gt;dev.of_node, num);<BR>&nbsp;&nbsp;if (ret &gt;= 0 || ret == -EPROBE_DEFER)<BR>&nbsp;&nbsp;&nbsp;return ret;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;r = platform_get_resource(dev, IORESOURCE_IRQ, num);<BR>&nbsp;/*<BR>&nbsp; * The resources may pass trigger flags to the irqs that need<BR>&nbsp; * to be set up. It so happens that the trigger flags for<BR>&nbsp; * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*<BR>&nbsp; * settings.<BR>&nbsp; */<BR>&nbsp;if (r &amp;&amp; r-&gt;flags &amp; IORESOURCE_BITS)<BR>&nbsp;&nbsp;irqd_set_trigger_type(irq_get_irq_data(r-&gt;start),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;flags &amp; IORESOURCE_BITS);</FONT></P>
<P><FONT class=extract>&nbsp;return r ? r-&gt;start : -ENXIO;<BR>#endif<BR>}<BR>EXPORT_SYMBOL_GPL(platform_get_irq);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_get_resource_byname - get a resource for a device by name<BR>&nbsp;* @dev: platform device<BR>&nbsp;* @type: resource type<BR>&nbsp;* @name: resource name<BR>&nbsp;*/<BR>struct resource *platform_get_resource_byname(struct platform_device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name)<BR>{<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;for (i = 0; i &lt; dev-&gt;num_resources; i++) {<BR>&nbsp;&nbsp;struct resource *r = &amp;dev-&gt;resource[i];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (unlikely(!r-&gt;name))<BR>&nbsp;&nbsp;&nbsp;continue;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (type == resource_type(r) &amp;&amp; !strcmp(r-&gt;name, name))<BR>&nbsp;&nbsp;&nbsp;return r;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_get_resource_byname);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_get_irq_byname - get an IRQ for a device by name<BR>&nbsp;* @dev: platform device<BR>&nbsp;* @name: IRQ name<BR>&nbsp;*/<BR>int platform_get_irq_byname(struct platform_device *dev, const char *name)<BR>{<BR>&nbsp;struct resource *r;</FONT></P>
<P><FONT class=extract>&nbsp;if (IS_ENABLED(CONFIG_OF_IRQ) &amp;&amp; dev-&gt;dev.of_node) {<BR>&nbsp;&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;ret = of_irq_get_byname(dev-&gt;dev.of_node, name);<BR>&nbsp;&nbsp;if (ret &gt;= 0 || ret == -EPROBE_DEFER)<BR>&nbsp;&nbsp;&nbsp;return ret;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);<BR>&nbsp;return r ? r-&gt;start : -ENXIO;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_get_irq_byname);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_add_devices - add a numbers of platform devices<BR>&nbsp;* @devs: array of platform devices to add<BR>&nbsp;* @num: number of platform devices in array<BR>&nbsp;*/<BR>int platform_add_devices(struct platform_device **devs, int num)<BR>{<BR>&nbsp;int i, ret = 0;</FONT></P>
<P><FONT class=extract>&nbsp;for (i = 0; i &lt; num; i++) {<BR>&nbsp;&nbsp;ret = platform_device_register(devs[i]);<BR>&nbsp;&nbsp;if (ret) {<BR>&nbsp;&nbsp;&nbsp;while (--i &gt;= 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;platform_device_unregister(devs[i]);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_add_devices);</FONT></P>
<P><FONT class=extract>struct platform_object {<BR>&nbsp;struct platform_device pdev;<BR>&nbsp;char name[];<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_put - destroy a platform device<BR>&nbsp;* @pdev: platform device to free<BR>&nbsp;*<BR>&nbsp;* Free all memory associated with a platform device.&nbsp; This function must<BR>&nbsp;* _only_ be externally called in error cases.&nbsp; All other usage is a bug.<BR>&nbsp;*/<BR>void platform_device_put(struct platform_device *pdev)<BR>{<BR>&nbsp;if (pdev)<BR>&nbsp;&nbsp;put_device(&amp;pdev-&gt;dev);<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_put);</FONT></P>
<P><FONT class=extract>static void platform_device_release(struct device *dev)<BR>{<BR>&nbsp;struct platform_object *pa = container_of(dev, struct platform_object,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdev.dev);</FONT></P>
<P><FONT class=extract>&nbsp;of_device_node_put(&amp;pa-&gt;pdev.dev);<BR>&nbsp;kfree(pa-&gt;pdev.dev.platform_data);<BR>&nbsp;kfree(pa-&gt;pdev.mfd_cell);<BR>&nbsp;kfree(pa-&gt;pdev.resource);<BR>&nbsp;kfree(pa-&gt;pdev.driver_override);<BR>&nbsp;kfree(pa);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_alloc - create a platform device<BR>&nbsp;* @name: base name of the device we're adding<BR>&nbsp;* @id: instance id<BR>&nbsp;*<BR>&nbsp;* Create a platform device object which can have other objects attached<BR>&nbsp;* to it, and which will have attached objects freed when it is released.<BR>&nbsp;*/<BR>struct platform_device *platform_device_alloc(const char *name, int id)<BR>{<BR>&nbsp;struct platform_object *pa;</FONT></P>
<P><FONT class=extract>&nbsp;pa = kzalloc(sizeof(*pa) + strlen(name) + 1, GFP_KERNEL);<BR>&nbsp;if (pa) {<BR>&nbsp;&nbsp;strcpy(pa-&gt;name, name);<BR>&nbsp;&nbsp;pa-&gt;pdev.name = pa-&gt;name;<BR>&nbsp;&nbsp;pa-&gt;pdev.id = id;<BR>&nbsp;&nbsp;device_initialize(&amp;pa-&gt;pdev.dev);<BR>&nbsp;&nbsp;pa-&gt;pdev.dev.release = platform_device_release;<BR>&nbsp;&nbsp;arch_setup_pdev_archdata(&amp;pa-&gt;pdev);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return pa ? &amp;pa-&gt;pdev : NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_alloc);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_add_resources - add resources to a platform device<BR>&nbsp;* @pdev: platform device allocated by platform_device_alloc to add resources to<BR>&nbsp;* @res: set of resources that needs to be allocated for the device<BR>&nbsp;* @num: number of resources<BR>&nbsp;*<BR>&nbsp;* Add a copy of the resources to the platform device.&nbsp; The memory<BR>&nbsp;* associated with the resources will be freed when the platform device is<BR>&nbsp;* released.<BR>&nbsp;*/<BR>int platform_device_add_resources(struct platform_device *pdev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct resource *res, unsigned int num)<BR>{<BR>&nbsp;struct resource *r = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;if (res) {<BR>&nbsp;&nbsp;r = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);<BR>&nbsp;&nbsp;if (!r)<BR>&nbsp;&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;kfree(pdev-&gt;resource);<BR>&nbsp;pdev-&gt;resource = r;<BR>&nbsp;pdev-&gt;num_resources = num;<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_add_resources);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_add_data - add platform-specific data to a platform device<BR>&nbsp;* @pdev: platform device allocated by platform_device_alloc to add resources to<BR>&nbsp;* @data: platform specific data for this platform device<BR>&nbsp;* @size: size of platform specific data<BR>&nbsp;*<BR>&nbsp;* Add a copy of platform specific data to the platform device's<BR>&nbsp;* platform_data pointer.&nbsp; The memory associated with the platform data<BR>&nbsp;* will be freed when the platform device is released.<BR>&nbsp;*/<BR>int platform_device_add_data(struct platform_device *pdev, const void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size)<BR>{<BR>&nbsp;void *d = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;if (data) {<BR>&nbsp;&nbsp;d = kmemdup(data, size, GFP_KERNEL);<BR>&nbsp;&nbsp;if (!d)<BR>&nbsp;&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;kfree(pdev-&gt;dev.platform_data);<BR>&nbsp;pdev-&gt;dev.platform_data = d;<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_add_data);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_add - add a platform device to device hierarchy<BR>&nbsp;* @pdev: platform device we're adding<BR>&nbsp;*<BR>&nbsp;* This is part 2 of platform_device_register(), though may be called<BR>&nbsp;* separately _iff_ pdev was allocated by platform_device_alloc().<BR>&nbsp;*/<BR>int platform_device_add(struct platform_device *pdev)<BR>{<BR>&nbsp;int i, ret;</FONT></P>
<P><FONT class=extract>&nbsp;if (!pdev)<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;if (!pdev-&gt;dev.parent)<BR>&nbsp;&nbsp;pdev-&gt;dev.parent = &amp;platform_bus;</FONT></P>
<P><FONT class=extract>&nbsp;pdev-&gt;dev.bus = &amp;platform_bus_type;</FONT></P>
<P><FONT class=extract>&nbsp;switch (pdev-&gt;id) {<BR>&nbsp;default:<BR>&nbsp;&nbsp;dev_set_name(&amp;pdev-&gt;dev, "%s.%d", pdev-&gt;name,&nbsp; pdev-&gt;id);<BR>&nbsp;&nbsp;break;<BR>&nbsp;case PLATFORM_DEVID_NONE:<BR>&nbsp;&nbsp;dev_set_name(&amp;pdev-&gt;dev, "%s", pdev-&gt;name);<BR>&nbsp;&nbsp;break;<BR>&nbsp;case PLATFORM_DEVID_AUTO:<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Automatically allocated device ID. We mark it as such so<BR>&nbsp;&nbsp; * that we remember it must be freed, and we append a suffix<BR>&nbsp;&nbsp; * to avoid namespace collision with explicit IDs.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;ret = ida_simple_get(&amp;platform_devid_ida, 0, 0, GFP_KERNEL);<BR>&nbsp;&nbsp;if (ret &lt; 0)<BR>&nbsp;&nbsp;&nbsp;goto err_out;<BR>&nbsp;&nbsp;pdev-&gt;id = ret;<BR>&nbsp;&nbsp;pdev-&gt;id_auto = true;<BR>&nbsp;&nbsp;dev_set_name(&amp;pdev-&gt;dev, "%s.%d.auto", pdev-&gt;name, pdev-&gt;id);<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;for (i = 0; i &lt; pdev-&gt;num_resources; i++) {<BR>&nbsp;&nbsp;struct resource *p, *r = &amp;pdev-&gt;resource[i];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (r-&gt;name == NULL)<BR>&nbsp;&nbsp;&nbsp;r-&gt;name = dev_name(&amp;pdev-&gt;dev);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;p = r-&gt;parent;<BR>&nbsp;&nbsp;if (!p) {<BR>&nbsp;&nbsp;&nbsp;if (resource_type(r) == IORESOURCE_MEM)<BR>&nbsp;&nbsp;&nbsp;&nbsp;p = &amp;iomem_resource;<BR>&nbsp;&nbsp;&nbsp;else if (resource_type(r) == IORESOURCE_IO)<BR>&nbsp;&nbsp;&nbsp;&nbsp;p = &amp;ioport_resource;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (p &amp;&amp; insert_resource(p, r)) {<BR>&nbsp;&nbsp;&nbsp;dev_err(&amp;pdev-&gt;dev, "failed to claim resource %d\n", i);<BR>&nbsp;&nbsp;&nbsp;ret = -EBUSY;<BR>&nbsp;&nbsp;&nbsp;goto failed;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("Registering platform device '%s'. Parent at %s\n",<BR>&nbsp;&nbsp; dev_name(&amp;pdev-&gt;dev), dev_name(pdev-&gt;dev.parent));</FONT></P>
<P><FONT class=extract>&nbsp;ret = device_add(&amp;pdev-&gt;dev);<BR>&nbsp;if (ret == 0)<BR>&nbsp;&nbsp;return ret;</FONT></P>
<P><FONT class=extract>&nbsp;failed:<BR>&nbsp;if (pdev-&gt;id_auto) {<BR>&nbsp;&nbsp;ida_simple_remove(&amp;platform_devid_ida, pdev-&gt;id);<BR>&nbsp;&nbsp;pdev-&gt;id = PLATFORM_DEVID_AUTO;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;while (--i &gt;= 0) {<BR>&nbsp;&nbsp;struct resource *r = &amp;pdev-&gt;resource[i];<BR>&nbsp;&nbsp;unsigned long type = resource_type(r);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (type == IORESOURCE_MEM || type == IORESOURCE_IO)<BR>&nbsp;&nbsp;&nbsp;release_resource(r);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;err_out:<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_add);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_del - remove a platform-level device<BR>&nbsp;* @pdev: platform device we're removing<BR>&nbsp;*<BR>&nbsp;* Note that this function will also release all memory- and port-based<BR>&nbsp;* resources owned by the device (@dev-&gt;resource).&nbsp; This function must<BR>&nbsp;* _only_ be externally called in error cases.&nbsp; All other usage is a bug.<BR>&nbsp;*/<BR>void platform_device_del(struct platform_device *pdev)<BR>{<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;if (pdev) {<BR>&nbsp;&nbsp;device_del(&amp;pdev-&gt;dev);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (pdev-&gt;id_auto) {<BR>&nbsp;&nbsp;&nbsp;ida_simple_remove(&amp;platform_devid_ida, pdev-&gt;id);<BR>&nbsp;&nbsp;&nbsp;pdev-&gt;id = PLATFORM_DEVID_AUTO;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;for (i = 0; i &lt; pdev-&gt;num_resources; i++) {<BR>&nbsp;&nbsp;&nbsp;struct resource *r = &amp;pdev-&gt;resource[i];<BR>&nbsp;&nbsp;&nbsp;unsigned long type = resource_type(r);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;if (type == IORESOURCE_MEM || type == IORESOURCE_IO)<BR>&nbsp;&nbsp;&nbsp;&nbsp;release_resource(r);<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_del);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_register - add a platform-level device<BR>&nbsp;* @pdev: platform device we're adding<BR>&nbsp;*/<BR>int platform_device_register(struct platform_device *pdev)<BR>{<BR>&nbsp;device_initialize(&amp;pdev-&gt;dev);<BR>&nbsp;arch_setup_pdev_archdata(pdev);<BR>&nbsp;return platform_device_add(pdev);<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_register);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_unregister - unregister a platform-level device<BR>&nbsp;* @pdev: platform device we're unregistering<BR>&nbsp;*<BR>&nbsp;* Unregistration is done in 2 steps. First we release all resources<BR>&nbsp;* and remove it from the subsystem, then we drop reference count by<BR>&nbsp;* calling platform_device_put().<BR>&nbsp;*/<BR>void platform_device_unregister(struct platform_device *pdev)<BR>{<BR>&nbsp;platform_device_del(pdev);<BR>&nbsp;platform_device_put(pdev);<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_unregister);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* platform_device_register_full - add a platform-level device with<BR>&nbsp;* resources and platform-specific data<BR>&nbsp;*<BR>&nbsp;* @pdevinfo: data used to create device<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*/<BR>struct platform_device *platform_device_register_full(<BR>&nbsp;&nbsp;const struct platform_device_info *pdevinfo)<BR>{<BR>&nbsp;int ret = -ENOMEM;<BR>&nbsp;struct platform_device *pdev;</FONT></P>
<P><FONT class=extract>&nbsp;pdev = platform_device_alloc(pdevinfo-&gt;name, pdevinfo-&gt;id);<BR>&nbsp;if (!pdev)<BR>&nbsp;&nbsp;goto err_alloc;</FONT></P>
<P><FONT class=extract>&nbsp;pdev-&gt;dev.parent = pdevinfo-&gt;parent;<BR>&nbsp;pdev-&gt;dev.fwnode = pdevinfo-&gt;fwnode;</FONT></P>
<P><FONT class=extract>&nbsp;if (pdevinfo-&gt;dma_mask) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * This memory isn't freed when the device is put,<BR>&nbsp;&nbsp; * I don't have a nice idea for that though.&nbsp; Conceptually<BR>&nbsp;&nbsp; * dma_mask in struct device should not be a pointer.<BR>&nbsp;&nbsp; * See </FONT><A href="http://thread.gmane.org/gmane.linux.kernel.pci/9081"><FONT class=extract>http://thread.gmane.org/gmane.linux.kernel.pci/9081</FONT></A><BR><FONT class=extract>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;pdev-&gt;dev.dma_mask =<BR>&nbsp;&nbsp;&nbsp;kmalloc(sizeof(*pdev-&gt;dev.dma_mask), GFP_KERNEL);<BR>&nbsp;&nbsp;if (!pdev-&gt;dev.dma_mask)<BR>&nbsp;&nbsp;&nbsp;goto err;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;*pdev-&gt;dev.dma_mask = pdevinfo-&gt;dma_mask;<BR>&nbsp;&nbsp;pdev-&gt;dev.coherent_dma_mask = pdevinfo-&gt;dma_mask;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;ret = platform_device_add_resources(pdev,<BR>&nbsp;&nbsp;&nbsp;pdevinfo-&gt;res, pdevinfo-&gt;num_res);<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;goto err;</FONT></P>
<P><FONT class=extract>&nbsp;ret = platform_device_add_data(pdev,<BR>&nbsp;&nbsp;&nbsp;pdevinfo-&gt;data, pdevinfo-&gt;size_data);<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;goto err;</FONT></P>
<P><FONT class=extract>&nbsp;ret = platform_device_add(pdev);<BR>&nbsp;if (ret) {<BR>err:<BR>&nbsp;&nbsp;ACPI_COMPANION_SET(&amp;pdev-&gt;dev, NULL);<BR>&nbsp;&nbsp;kfree(pdev-&gt;dev.dma_mask);</FONT></P>
<P><FONT class=extract>err_alloc:<BR>&nbsp;&nbsp;platform_device_put(pdev);<BR>&nbsp;&nbsp;return ERR_PTR(ret);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return pdev;<BR>}<BR>EXPORT_SYMBOL_GPL(platform_device_register_full);</FONT></P>
<P>static int platform_drv_probe(struct device *_dev)<BR>{<BR>&nbsp;struct platform_driver *drv = to_platform_driver(_dev-&gt;driver);<BR>&nbsp;struct platform_device *dev = to_platform_device(_dev);<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = of_clk_set_defaults(_dev-&gt;of_node, false);<BR>&nbsp;if (ret &lt; 0)<BR>&nbsp;&nbsp;return ret;</P>
<P>&nbsp;ret = dev_pm_domain_attach(_dev, true);<BR>&nbsp;if (ret != -EPROBE_DEFER) {<BR>&nbsp;&nbsp;ret = drv-&gt;probe(dev);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;dev_pm_domain_detach(_dev, true);<BR>&nbsp;}</P>
<P>&nbsp;if (drv-&gt;prevent_deferred_probe &amp;&amp; ret == -EPROBE_DEFER) {<BR>&nbsp;&nbsp;dev_warn(_dev, "probe deferral not supported\n");<BR>&nbsp;&nbsp;ret = -ENXIO;<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>static int platform_drv_probe_fail(struct device *_dev)<BR>{<BR>&nbsp;return -ENXIO;<BR>}</P>
<P>static int platform_drv_remove(struct device *_dev)<BR>{<BR>&nbsp;struct platform_driver *drv = to_platform_driver(_dev-&gt;driver);<BR>&nbsp;struct platform_device *dev = to_platform_device(_dev);<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = drv-&gt;remove(dev);<BR>&nbsp;dev_pm_domain_detach(_dev, true);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>static void platform_drv_shutdown(struct device *_dev)<BR>{<BR>&nbsp;struct platform_driver *drv = to_platform_driver(_dev-&gt;driver);<BR>&nbsp;struct platform_device *dev = to_platform_device(_dev);</P>
<P>&nbsp;drv-&gt;shutdown(dev);<BR>&nbsp;dev_pm_domain_detach(_dev, true);<BR>}</P>
<P>/**<BR>&nbsp;* __platform_driver_register - register a driver for platform-level devices<BR>&nbsp;* @drv: platform driver structure<BR>&nbsp;* @owner: owning module/driver<BR>&nbsp;*/<BR>int __platform_driver_register(struct platform_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct module *owner)<BR>{<BR>&nbsp;drv-&gt;driver.owner = owner;<BR>&nbsp;drv-&gt;driver.bus = &amp;platform_bus_type;<BR>&nbsp;if (drv-&gt;probe)<BR>&nbsp;&nbsp;drv-&gt;driver.probe = platform_drv_probe;<BR>&nbsp;if (drv-&gt;remove)<BR>&nbsp;&nbsp;drv-&gt;driver.remove = platform_drv_remove;<BR>&nbsp;if (drv-&gt;shutdown)<BR>&nbsp;&nbsp;drv-&gt;driver.shutdown = platform_drv_shutdown;</P>
<P>&nbsp;return driver_register(&amp;drv-&gt;driver);<BR>}<BR>EXPORT_SYMBOL_GPL(__platform_driver_register);</P>
<P>/**<BR>&nbsp;* platform_driver_unregister - unregister a driver for platform-level devices<BR>&nbsp;* @drv: platform driver structure<BR>&nbsp;*/<BR>void platform_driver_unregister(struct platform_driver *drv)<BR>{<BR>&nbsp;driver_unregister(&amp;drv-&gt;driver);<BR>}<BR>EXPORT_SYMBOL_GPL(platform_driver_unregister);</P>
<P>/**<BR>&nbsp;* __platform_driver_probe - register driver for non-hotpluggable device<BR>&nbsp;* @drv: platform driver structure<BR>&nbsp;* @probe: the driver probe routine, probably from an __init section<BR>&nbsp;* @module: module which will be the owner of the driver<BR>&nbsp;*<BR>&nbsp;* Use this instead of platform_driver_register() when you know the device<BR>&nbsp;* is not hotpluggable and has already been registered, and you want to<BR>&nbsp;* remove its run-once probe() infrastructure from memory after the driver<BR>&nbsp;* has bound to the device.<BR>&nbsp;*<BR>&nbsp;* One typical use for this would be with drivers for controllers integrated<BR>&nbsp;* into system-on-chip processors, where the controller devices have been<BR>&nbsp;* configured as part of board setup.<BR>&nbsp;*<BR>&nbsp;* Note that this is incompatible with deferred probing.<BR>&nbsp;*<BR>&nbsp;* Returns zero if the driver registered and bound to a device, else returns<BR>&nbsp;* a negative error code and with the driver not registered.<BR>&nbsp;*/<BR>int __init_or_module __platform_driver_probe(struct platform_driver *drv,<BR>&nbsp;&nbsp;int (*probe)(struct platform_device *), struct module *module)<BR>{<BR>&nbsp;int retval, code;</P>
<P>&nbsp;if (drv-&gt;driver.probe_type == PROBE_PREFER_ASYNCHRONOUS) {<BR>&nbsp;&nbsp;pr_err("%s: drivers registered with %s can not be probed asynchronously\n",<BR>&nbsp;&nbsp;&nbsp; drv-&gt;driver.name, __func__);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * We have to run our probes synchronously because we check if<BR>&nbsp; * we find any devices to bind to and exit with error if there<BR>&nbsp; * are any.<BR>&nbsp; */<BR>&nbsp;drv-&gt;driver.probe_type = PROBE_FORCE_SYNCHRONOUS;</P>
<P>&nbsp;/*<BR>&nbsp; * Prevent driver from requesting probe deferral to avoid further<BR>&nbsp; * futile probe attempts.<BR>&nbsp; */<BR>&nbsp;drv-&gt;prevent_deferred_probe = true;</P>
<P>&nbsp;/* make sure driver won't have bind/unbind attributes */<BR>&nbsp;drv-&gt;driver.suppress_bind_attrs = true;</P>
<P>&nbsp;/* temporary section violation during probe() */<BR>&nbsp;drv-&gt;probe = probe;<BR>&nbsp;retval = code = __platform_driver_register(drv, module);</P>
<P>&nbsp;/*<BR>&nbsp; * Fixup that section violation, being paranoid about code scanning<BR>&nbsp; * the list of drivers in order to probe new devices.&nbsp; Check to see<BR>&nbsp; * if the probe was successful, and make sure any forced probes of<BR>&nbsp; * new devices fail.<BR>&nbsp; */<BR>&nbsp;spin_lock(&amp;drv-&gt;driver.bus-&gt;p-&gt;klist_drivers.k_lock);<BR>&nbsp;drv-&gt;probe = NULL;<BR>&nbsp;if (code == 0 &amp;&amp; list_empty(&amp;drv-&gt;driver.p-&gt;klist_devices.k_list))<BR>&nbsp;&nbsp;retval = -ENODEV;<BR>&nbsp;drv-&gt;driver.probe = platform_drv_probe_fail;<BR>&nbsp;spin_unlock(&amp;drv-&gt;driver.bus-&gt;p-&gt;klist_drivers.k_lock);</P>
<P>&nbsp;if (code != retval)<BR>&nbsp;&nbsp;platform_driver_unregister(drv);<BR>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL_GPL(__platform_driver_probe);</P>
<P>/**<BR>&nbsp;* __platform_create_bundle - register driver and create corresponding device<BR>&nbsp;* @driver: platform driver structure<BR>&nbsp;* @probe: the driver probe routine, probably from an __init section<BR>&nbsp;* @res: set of resources that needs to be allocated for the device<BR>&nbsp;* @n_res: number of resources<BR>&nbsp;* @data: platform specific data for this platform device<BR>&nbsp;* @size: size of platform specific data<BR>&nbsp;* @module: module which will be the owner of the driver<BR>&nbsp;*<BR>&nbsp;* Use this in legacy-style modules that probe hardware directly and<BR>&nbsp;* register a single platform device and corresponding platform driver.<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*/<BR>struct platform_device * __init_or_module __platform_create_bundle(<BR>&nbsp;&nbsp;&nbsp;struct platform_driver *driver,<BR>&nbsp;&nbsp;&nbsp;int (*probe)(struct platform_device *),<BR>&nbsp;&nbsp;&nbsp;struct resource *res, unsigned int n_res,<BR>&nbsp;&nbsp;&nbsp;const void *data, size_t size, struct module *module)<BR>{<BR>&nbsp;struct platform_device *pdev;<BR>&nbsp;int error;</P>
<P>&nbsp;pdev = platform_device_alloc(driver-&gt;driver.name, -1);<BR>&nbsp;if (!pdev) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto err_out;<BR>&nbsp;}</P>
<P>&nbsp;error = platform_device_add_resources(pdev, res, n_res);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto err_pdev_put;</P>
<P>&nbsp;error = platform_device_add_data(pdev, data, size);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto err_pdev_put;</P>
<P>&nbsp;error = platform_device_add(pdev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto err_pdev_put;</P>
<P>&nbsp;error = __platform_driver_probe(driver, probe, module);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto err_pdev_del;</P>
<P>&nbsp;return pdev;</P>
<P>err_pdev_del:<BR>&nbsp;platform_device_del(pdev);<BR>err_pdev_put:<BR>&nbsp;platform_device_put(pdev);<BR>err_out:<BR>&nbsp;return ERR_PTR(error);<BR>}<BR>EXPORT_SYMBOL_GPL(__platform_create_bundle);</P>
<P>/* modalias support enables more hands-off userspace setup:<BR>&nbsp;* (a) environment variable lets new-style hotplug events work once system is<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; fully running:&nbsp; "modprobe $MODALIAS"<BR>&nbsp;* (b) sysfs attribute lets new-style coldplug recover from hotplug events<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; mishandled before system is fully running:&nbsp; "modprobe $(cat modalias)"<BR>&nbsp;*/<BR>static ssize_t modalias_show(struct device *dev, struct device_attribute *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct platform_device&nbsp;*pdev = to_platform_device(dev);<BR>&nbsp;int len;</P>
<P>&nbsp;len = of_device_get_modalias(dev, buf, PAGE_SIZE -1);<BR>&nbsp;if (len != -ENODEV)<BR>&nbsp;&nbsp;return len;</P>
<P>&nbsp;len = acpi_device_modalias(dev, buf, PAGE_SIZE -1);<BR>&nbsp;if (len != -ENODEV)<BR>&nbsp;&nbsp;return len;</P>
<P>&nbsp;len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev-&gt;name);</P>
<P>&nbsp;return (len &gt;= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;<BR>}<BR>static DEVICE_ATTR_RO(modalias);</P>
<P>static ssize_t driver_override_store(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct platform_device *pdev = to_platform_device(dev);<BR>&nbsp;char *driver_override, *old = pdev-&gt;driver_override, *cp;</P>
<P>&nbsp;if (count &gt; PATH_MAX)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;driver_override = kstrndup(buf, count, GFP_KERNEL);<BR>&nbsp;if (!driver_override)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;cp = strchr(driver_override, '\n');<BR>&nbsp;if (cp)<BR>&nbsp;&nbsp;*cp = '\0';</P>
<P>&nbsp;if (strlen(driver_override)) {<BR>&nbsp;&nbsp;pdev-&gt;driver_override = driver_override;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;kfree(driver_override);<BR>&nbsp;&nbsp;pdev-&gt;driver_override = NULL;<BR>&nbsp;}</P>
<P>&nbsp;kfree(old);</P>
<P>&nbsp;return count;<BR>}</P>
<P>static ssize_t driver_override_show(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_attribute *attr, char *buf)<BR>{<BR>&nbsp;struct platform_device *pdev = to_platform_device(dev);</P>
<P>&nbsp;return sprintf(buf, "%s\n", pdev-&gt;driver_override);<BR>}<BR>static DEVICE_ATTR_RW(driver_override);</P>
<P><BR>static struct attribute *platform_dev_attrs[] = {<BR>&nbsp;&amp;dev_attr_modalias.attr,<BR>&nbsp;&amp;dev_attr_driver_override.attr,<BR>&nbsp;NULL,<BR>};<BR>ATTRIBUTE_GROUPS(platform_dev);</P>
<P>static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)<BR>{<BR>&nbsp;struct platform_device&nbsp;*pdev = to_platform_device(dev);<BR>&nbsp;int rc;</P>
<P>&nbsp;/* Some devices have extra OF data and an OF-style MODALIAS */<BR>&nbsp;rc = of_device_uevent_modalias(dev, env);<BR>&nbsp;if (rc != -ENODEV)<BR>&nbsp;&nbsp;return rc;</P>
<P>&nbsp;rc = acpi_device_uevent_modalias(dev, env);<BR>&nbsp;if (rc != -ENODEV)<BR>&nbsp;&nbsp;return rc;</P>
<P>&nbsp;add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,<BR>&nbsp;&nbsp;&nbsp;pdev-&gt;name);<BR>&nbsp;return 0;<BR>}</P>
<P>static const struct platform_device_id *platform_match_id(<BR>&nbsp;&nbsp;&nbsp;const struct platform_device_id *id,<BR>&nbsp;&nbsp;&nbsp;struct platform_device *pdev)<BR>{<BR>&nbsp;while (id-&gt;name[0]) {<BR>&nbsp;&nbsp;if (strcmp(pdev-&gt;name, id-&gt;name) == 0) {<BR>&nbsp;&nbsp;&nbsp;pdev-&gt;id_entry = id;<BR>&nbsp;&nbsp;&nbsp;return id;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;id++;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}</P>
<P>/**<BR>&nbsp;* platform_match - bind platform device to platform driver.<BR>&nbsp;* @dev: device.<BR>&nbsp;* @drv: driver.<BR>&nbsp;*<BR>&nbsp;* Platform device IDs are assumed to be encoded like this:<BR>&nbsp;* "&lt;name&gt;&lt;instance&gt;", where &lt;name&gt; is a short description of the type of<BR>&nbsp;* device, like "pci" or "floppy", and &lt;instance&gt; is the enumerated<BR>&nbsp;* instance of the device, like '0' or '42'.&nbsp; Driver IDs are simply<BR>&nbsp;* "&lt;name&gt;".&nbsp; So, extract the &lt;name&gt; from the platform_device structure,<BR>&nbsp;* and compare it against the name of the driver. Return whether they match<BR>&nbsp;* or not.<BR>&nbsp;*/<BR>static int platform_match(struct device *dev, struct device_driver *drv)<BR>{<BR>&nbsp;struct platform_device *pdev = to_platform_device(dev);<BR>&nbsp;struct platform_driver *pdrv = to_platform_driver(drv);</P>
<P>&nbsp;/* When driver_override is set, only bind to the matching driver */<BR>&nbsp;if (pdev-&gt;driver_override)<BR>&nbsp;&nbsp;return !strcmp(pdev-&gt;driver_override, drv-&gt;name);</P>
<P>&nbsp;/* Attempt an OF style match first */<BR>&nbsp;if (of_driver_match_device(dev, drv))<BR>&nbsp;&nbsp;return 1;</P>
<P>&nbsp;/* Then try ACPI style match */<BR>&nbsp;if (acpi_driver_match_device(dev, drv))<BR>&nbsp;&nbsp;return 1;</P>
<P>&nbsp;/* Then try to match against the id table */<BR>&nbsp;if (pdrv-&gt;id_table)<BR>&nbsp;&nbsp;return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;</P>
<P>&nbsp;/* fall-back to driver name match */<BR>&nbsp;return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);<BR>}</P>
<P>#ifdef CONFIG_PM_SLEEP</P>
<P>static int platform_legacy_suspend(struct device *dev, pm_message_t mesg)<BR>{<BR>&nbsp;struct platform_driver *pdrv = to_platform_driver(dev-&gt;driver);<BR>&nbsp;struct platform_device *pdev = to_platform_device(dev);<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (dev-&gt;driver &amp;&amp; pdrv-&gt;suspend)<BR>&nbsp;&nbsp;ret = pdrv-&gt;suspend(pdev, mesg);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>static int platform_legacy_resume(struct device *dev)<BR>{<BR>&nbsp;struct platform_driver *pdrv = to_platform_driver(dev-&gt;driver);<BR>&nbsp;struct platform_device *pdev = to_platform_device(dev);<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (dev-&gt;driver &amp;&amp; pdrv-&gt;resume)<BR>&nbsp;&nbsp;ret = pdrv-&gt;resume(pdev);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>#endif /* CONFIG_PM_SLEEP */</P>
<P>#ifdef CONFIG_SUSPEND</P>
<P>int platform_pm_suspend(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!drv)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;if (drv-&gt;pm) {<BR>&nbsp;&nbsp;if (drv-&gt;pm-&gt;suspend)<BR>&nbsp;&nbsp;&nbsp;ret = drv-&gt;pm-&gt;suspend(dev);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;ret = platform_legacy_suspend(dev, PMSG_SUSPEND);<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>int platform_pm_resume(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!drv)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;if (drv-&gt;pm) {<BR>&nbsp;&nbsp;if (drv-&gt;pm-&gt;resume)<BR>&nbsp;&nbsp;&nbsp;ret = drv-&gt;pm-&gt;resume(dev);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;ret = platform_legacy_resume(dev);<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>#endif /* CONFIG_SUSPEND */</P>
<P>#ifdef CONFIG_HIBERNATE_CALLBACKS</P>
<P>int platform_pm_freeze(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!drv)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;if (drv-&gt;pm) {<BR>&nbsp;&nbsp;if (drv-&gt;pm-&gt;freeze)<BR>&nbsp;&nbsp;&nbsp;ret = drv-&gt;pm-&gt;freeze(dev);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;ret = platform_legacy_suspend(dev, PMSG_FREEZE);<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>int platform_pm_thaw(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!drv)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;if (drv-&gt;pm) {<BR>&nbsp;&nbsp;if (drv-&gt;pm-&gt;thaw)<BR>&nbsp;&nbsp;&nbsp;ret = drv-&gt;pm-&gt;thaw(dev);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;ret = platform_legacy_resume(dev);<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>int platform_pm_poweroff(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!drv)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;if (drv-&gt;pm) {<BR>&nbsp;&nbsp;if (drv-&gt;pm-&gt;poweroff)<BR>&nbsp;&nbsp;&nbsp;ret = drv-&gt;pm-&gt;poweroff(dev);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;ret = platform_legacy_suspend(dev, PMSG_HIBERNATE);<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>int platform_pm_restore(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!drv)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;if (drv-&gt;pm) {<BR>&nbsp;&nbsp;if (drv-&gt;pm-&gt;restore)<BR>&nbsp;&nbsp;&nbsp;ret = drv-&gt;pm-&gt;restore(dev);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;ret = platform_legacy_resume(dev);<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>#endif /* CONFIG_HIBERNATE_CALLBACKS */</P>
<P>static const struct dev_pm_ops platform_dev_pm_ops = {<BR>&nbsp;.runtime_suspend = pm_generic_runtime_suspend,<BR>&nbsp;.runtime_resume = pm_generic_runtime_resume,<BR>&nbsp;USE_PLATFORM_PM_SLEEP_OPS<BR>};</P>
<P>struct bus_type platform_bus_type = {<BR>&nbsp;.name&nbsp;&nbsp;= "platform",<BR>&nbsp;.dev_groups&nbsp;= platform_dev_groups,<BR>&nbsp;.match&nbsp;&nbsp;= platform_match,<BR>&nbsp;.uevent&nbsp;&nbsp;= platform_uevent,<BR>&nbsp;.pm&nbsp;&nbsp;= &amp;platform_dev_pm_ops,<BR>};<BR>EXPORT_SYMBOL_GPL(platform_bus_type);</P>
<P>int __init platform_bus_init(void)<BR>{<BR>&nbsp;int error;</P>
<P>&nbsp;early_platform_cleanup();</P>
<P>&nbsp;error = device_register(&amp;platform_bus);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;return error;<BR>&nbsp;error =&nbsp; bus_register(&amp;platform_bus_type);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;device_unregister(&amp;platform_bus);<BR>&nbsp;of_platform_register_reconfig_notifier();<BR>&nbsp;return error;<BR>}</P>
<P>#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK<BR>u64 dma_get_required_mask(struct device *dev)<BR>{<BR>&nbsp;u32 low_totalram = ((max_pfn - 1) &lt;&lt; PAGE_SHIFT);<BR>&nbsp;u32 high_totalram = ((max_pfn - 1) &gt;&gt; (32 - PAGE_SHIFT));<BR>&nbsp;u64 mask;</P>
<P>&nbsp;if (!high_totalram) {<BR>&nbsp;&nbsp;/* convert to mask just covering totalram */<BR>&nbsp;&nbsp;low_totalram = (1 &lt;&lt; (fls(low_totalram) - 1));<BR>&nbsp;&nbsp;low_totalram += low_totalram - 1;<BR>&nbsp;&nbsp;mask = low_totalram;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;high_totalram = (1 &lt;&lt; (fls(high_totalram) - 1));<BR>&nbsp;&nbsp;high_totalram += high_totalram - 1;<BR>&nbsp;&nbsp;mask = (((u64)high_totalram) &lt;&lt; 32) + 0xffffffff;<BR>&nbsp;}<BR>&nbsp;return mask;<BR>}<BR>EXPORT_SYMBOL_GPL(dma_get_required_mask);<BR>#endif</P>
<P><FONT class=extract>static __initdata LIST_HEAD(early_platform_driver_list);<BR>static __initdata LIST_HEAD(early_platform_device_list);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_driver_register - register early platform driver<BR>&nbsp;* @epdrv: early_platform driver structure<BR>&nbsp;* @buf: string passed from early_param()<BR>&nbsp;*<BR>&nbsp;* Helper function for early_platform_init() / early_platform_init_buffer()<BR>&nbsp;*/<BR>int __init early_platform_driver_register(struct early_platform_driver *epdrv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;char *tmp;<BR>&nbsp;int n;</FONT></P>
<P><FONT class=extract>&nbsp;/* Simply add the driver to the end of the global list.<BR>&nbsp; * Drivers will by default be put on the list in compiled-in order.<BR>&nbsp; */<BR>&nbsp;if (!epdrv-&gt;list.next) {<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;epdrv-&gt;list);<BR>&nbsp;&nbsp;list_add_tail(&amp;epdrv-&gt;list, &amp;early_platform_driver_list);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* If the user has specified device then make sure the driver<BR>&nbsp; * gets prioritized. The driver of the last device specified on<BR>&nbsp; * command line will be put first on the list.<BR>&nbsp; */<BR>&nbsp;n = strlen(epdrv-&gt;pdrv-&gt;driver.name);<BR>&nbsp;if (buf &amp;&amp; !strncmp(buf, epdrv-&gt;pdrv-&gt;driver.name, n)) {<BR>&nbsp;&nbsp;list_move(&amp;epdrv-&gt;list, &amp;early_platform_driver_list);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;/* Allow passing parameters after device name */<BR>&nbsp;&nbsp;if (buf[n] == '\0' || buf[n] == ',')<BR>&nbsp;&nbsp;&nbsp;epdrv-&gt;requested_id = -1;<BR>&nbsp;&nbsp;else {<BR>&nbsp;&nbsp;&nbsp;epdrv-&gt;requested_id = simple_strtoul(&amp;buf[n + 1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tmp, 10);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;if (buf[n] != '.' || (tmp == &amp;buf[n + 1])) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;epdrv-&gt;requested_id = EARLY_PLATFORM_ID_ERROR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;n = 0;<BR>&nbsp;&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;&nbsp;n += strcspn(&amp;buf[n + 1], ",") + 1;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (buf[n] == ',')<BR>&nbsp;&nbsp;&nbsp;n++;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (epdrv-&gt;bufsize) {<BR>&nbsp;&nbsp;&nbsp;memcpy(epdrv-&gt;buffer, &amp;buf[n],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_t(int, epdrv-&gt;bufsize, strlen(&amp;buf[n]) + 1));<BR>&nbsp;&nbsp;&nbsp;epdrv-&gt;buffer[epdrv-&gt;bufsize - 1] = '\0';<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_add_devices - adds a number of early platform devices<BR>&nbsp;* @devs: array of early platform devices to add<BR>&nbsp;* @num: number of early platform devices in array<BR>&nbsp;*<BR>&nbsp;* Used by early architecture code to register early platform devices and<BR>&nbsp;* their platform data.<BR>&nbsp;*/<BR>void __init early_platform_add_devices(struct platform_device **devs, int num)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;/* simply add the devices to list */<BR>&nbsp;for (i = 0; i &lt; num; i++) {<BR>&nbsp;&nbsp;dev = &amp;devs[i]-&gt;dev;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (!dev-&gt;devres_head.next) {<BR>&nbsp;&nbsp;&nbsp;pm_runtime_early_init(dev);<BR>&nbsp;&nbsp;&nbsp;INIT_LIST_HEAD(&amp;dev-&gt;devres_head);<BR>&nbsp;&nbsp;&nbsp;list_add_tail(&amp;dev-&gt;devres_head,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;early_platform_device_list);<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_driver_register_all - register early platform drivers<BR>&nbsp;* @class_str: string to identify early platform driver class<BR>&nbsp;*<BR>&nbsp;* Used by architecture code to register all early platform drivers<BR>&nbsp;* for a certain class. If omitted then only early platform drivers<BR>&nbsp;* with matching kernel command line class parameters will be registered.<BR>&nbsp;*/<BR>void __init early_platform_driver_register_all(char *class_str)<BR>{<BR>&nbsp;/* The "class_str" parameter may or may not be present on the kernel<BR>&nbsp; * command line. If it is present then there may be more than one<BR>&nbsp; * matching parameter.<BR>&nbsp; *<BR>&nbsp; * Since we register our early platform drivers using early_param()<BR>&nbsp; * we need to make sure that they also get registered in the case<BR>&nbsp; * when the parameter is missing from the kernel command line.<BR>&nbsp; *<BR>&nbsp; * We use parse_early_options() to make sure the early_param() gets<BR>&nbsp; * called at least once. The early_param() may be called more than<BR>&nbsp; * once since the name of the preferred device may be specified on<BR>&nbsp; * the kernel command line. early_platform_driver_register() handles<BR>&nbsp; * this case for us.<BR>&nbsp; */<BR>&nbsp;parse_early_options(class_str);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_match - find early platform device matching driver<BR>&nbsp;* @epdrv: early platform driver structure<BR>&nbsp;* @id: id to match against<BR>&nbsp;*/<BR>static struct platform_device * __init<BR>early_platform_match(struct early_platform_driver *epdrv, int id)<BR>{<BR>&nbsp;struct platform_device *pd;</FONT></P>
<P><FONT class=extract>&nbsp;list_for_each_entry(pd, &amp;early_platform_device_list, dev.devres_head)<BR>&nbsp;&nbsp;if (platform_match(&amp;pd-&gt;dev, &amp;epdrv-&gt;pdrv-&gt;driver))<BR>&nbsp;&nbsp;&nbsp;if (pd-&gt;id == id)<BR>&nbsp;&nbsp;&nbsp;&nbsp;return pd;</FONT></P>
<P><FONT class=extract>&nbsp;return NULL;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_left - check if early platform driver has matching devices<BR>&nbsp;* @epdrv: early platform driver structure<BR>&nbsp;* @id: return true if id or above exists<BR>&nbsp;*/<BR>static int __init early_platform_left(struct early_platform_driver *epdrv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id)<BR>{<BR>&nbsp;struct platform_device *pd;</FONT></P>
<P><FONT class=extract>&nbsp;list_for_each_entry(pd, &amp;early_platform_device_list, dev.devres_head)<BR>&nbsp;&nbsp;if (platform_match(&amp;pd-&gt;dev, &amp;epdrv-&gt;pdrv-&gt;driver))<BR>&nbsp;&nbsp;&nbsp;if (pd-&gt;id &gt;= id)<BR>&nbsp;&nbsp;&nbsp;&nbsp;return 1;</FONT></P>
<P><FONT class=extract>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_driver_probe_id - probe drivers matching class_str and id<BR>&nbsp;* @class_str: string to identify early platform driver class<BR>&nbsp;* @id: id to match against<BR>&nbsp;* @nr_probe: number of platform devices to successfully probe before exiting<BR>&nbsp;*/<BR>static int __init early_platform_driver_probe_id(char *class_str,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_probe)<BR>{<BR>&nbsp;struct early_platform_driver *epdrv;<BR>&nbsp;struct platform_device *match;<BR>&nbsp;int match_id;<BR>&nbsp;int n = 0;<BR>&nbsp;int left = 0;</FONT></P>
<P><FONT class=extract>&nbsp;list_for_each_entry(epdrv, &amp;early_platform_driver_list, list) {<BR>&nbsp;&nbsp;/* only use drivers matching our class_str */<BR>&nbsp;&nbsp;if (strcmp(class_str, epdrv-&gt;class_str))<BR>&nbsp;&nbsp;&nbsp;continue;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (id == -2) {<BR>&nbsp;&nbsp;&nbsp;match_id = epdrv-&gt;requested_id;<BR>&nbsp;&nbsp;&nbsp;left = 1;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;match_id = id;<BR>&nbsp;&nbsp;&nbsp;left += early_platform_left(epdrv, id);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;/* skip requested id */<BR>&nbsp;&nbsp;&nbsp;switch (epdrv-&gt;requested_id) {<BR>&nbsp;&nbsp;&nbsp;case EARLY_PLATFORM_ID_ERROR:<BR>&nbsp;&nbsp;&nbsp;case EARLY_PLATFORM_ID_UNSET:<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (epdrv-&gt;requested_id == id)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match_id = EARLY_PLATFORM_ID_UNSET;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;switch (match_id) {<BR>&nbsp;&nbsp;case EARLY_PLATFORM_ID_ERROR:<BR>&nbsp;&nbsp;&nbsp;pr_warn("%s: unable to parse %s parameter\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;class_str, epdrv-&gt;pdrv-&gt;driver.name);<BR>&nbsp;&nbsp;&nbsp;/* fall-through */<BR>&nbsp;&nbsp;case EARLY_PLATFORM_ID_UNSET:<BR>&nbsp;&nbsp;&nbsp;match = NULL;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;match = early_platform_match(epdrv, match_id);<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (match) {<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Set up a sensible init_name to enable<BR>&nbsp;&nbsp;&nbsp; * dev_name() and others to be used before the<BR>&nbsp;&nbsp;&nbsp; * rest of the driver core is initialized.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (!match-&gt;dev.init_name &amp;&amp; slab_is_available()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (match-&gt;id != -1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match-&gt;dev.init_name =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kasprintf(GFP_KERNEL, "%s.%d",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;id);<BR>&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match-&gt;dev.init_name =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kasprintf(GFP_KERNEL, "%s",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;name);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;if (!match-&gt;dev.init_name)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;if (epdrv-&gt;pdrv-&gt;probe(match))<BR>&nbsp;&nbsp;&nbsp;&nbsp;pr_warn("%s: unable to probe %s early.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_str, match-&gt;name);<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;n++;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (n &gt;= nr_probe)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;if (left)<BR>&nbsp;&nbsp;return n;<BR>&nbsp;else<BR>&nbsp;&nbsp;return -ENODEV;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_driver_probe - probe a class of registered drivers<BR>&nbsp;* @class_str: string to identify early platform driver class<BR>&nbsp;* @nr_probe: number of platform devices to successfully probe before exiting<BR>&nbsp;* @user_only: only probe user specified early platform devices<BR>&nbsp;*<BR>&nbsp;* Used by architecture code to probe registered early platform drivers<BR>&nbsp;* within a certain class. For probe to happen a registered early platform<BR>&nbsp;* device matching a registered early platform driver is needed.<BR>&nbsp;*/<BR>int __init early_platform_driver_probe(char *class_str,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_probe,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int user_only)<BR>{<BR>&nbsp;int k, n, i;</FONT></P>
<P><FONT class=extract>&nbsp;n = 0;<BR>&nbsp;for (i = -2; n &lt; nr_probe; i++) {<BR>&nbsp;&nbsp;k = early_platform_driver_probe_id(class_str, i, nr_probe - n);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (k &lt; 0)<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;n += k;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (user_only)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return n;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_cleanup - clean up early platform code<BR>&nbsp;*/<BR>void __init early_platform_cleanup(void)<BR>{<BR>&nbsp;struct platform_device *pd, *pd2;</FONT></P>
<P><FONT class=extract>&nbsp;/* clean up the devres list used to chain devices */<BR>&nbsp;list_for_each_entry_safe(pd, pd2, &amp;early_platform_device_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp; dev.devres_head) {<BR>&nbsp;&nbsp;list_del(&amp;pd-&gt;dev.devres_head);<BR>&nbsp;&nbsp;memset(&amp;pd-&gt;dev.devres_head, 0, sizeof(pd-&gt;dev.devres_head));<BR>&nbsp;}<BR>}</FONT></P>
<P>&nbsp;