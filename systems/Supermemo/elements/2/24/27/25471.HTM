/**<BR>&nbsp;* struct device - The basic device structure<BR>&nbsp;* @parent:&nbsp;The device's "parent" device, the device to which it is attached.<BR>&nbsp;* &nbsp;&nbsp;In most cases, a parent device is some sort of bus or host<BR>&nbsp;* &nbsp;&nbsp;controller. If parent is NULL, the device, is a top-level device,<BR>&nbsp;* &nbsp;&nbsp;which is not usually what you want.<BR>&nbsp;* @p:&nbsp;&nbsp;Holds the private data of the driver core portions of the device.<BR>&nbsp;* &nbsp;&nbsp;See the comment of the struct device_private for detail.<BR>&nbsp;* @kobj:&nbsp;A top-level, abstract class from which other classes are derived.<BR>&nbsp;* @init_name:&nbsp;Initial name of the device.<BR>&nbsp;* @type:&nbsp;The type of device.<BR>&nbsp;* &nbsp;&nbsp;This identifies the device type and carries type-specific<BR>&nbsp;* &nbsp;&nbsp;information.<BR>&nbsp;* @mutex:&nbsp;Mutex to synchronize calls to its driver.<BR>&nbsp;* @bus:&nbsp;Type of bus device is on.<BR>&nbsp;* @driver:&nbsp;Which driver has allocated this<BR>&nbsp;* @platform_data: Platform data specific to the device.<BR>&nbsp;* &nbsp;&nbsp;Example: For devices on custom boards, as typical of embedded<BR>&nbsp;* &nbsp;&nbsp;and SOC based hardware, Linux often uses platform_data to point<BR>&nbsp;* &nbsp;&nbsp;to board-specific structures describing devices and how they<BR>&nbsp;* &nbsp;&nbsp;are wired.&nbsp; That can include what ports are available, chip<BR>&nbsp;* &nbsp;&nbsp;variants, which GPIO pins act in what additional roles, and so<BR>&nbsp;* &nbsp;&nbsp;on.&nbsp; This shrinks the "Board Support Packages" (BSPs) and<BR>&nbsp;* &nbsp;&nbsp;minimizes board-specific #ifdefs in drivers.<BR>&nbsp;* @driver_data: Private pointer for driver specific info.<BR>&nbsp;* @power:&nbsp;For device power management.<BR>&nbsp;* &nbsp;&nbsp;See Documentation/power/devices.txt for details.<BR>&nbsp;* @pm_domain:&nbsp;Provide callbacks that are executed during system suspend,<BR>&nbsp;* &nbsp;&nbsp;hibernation, system resume and during runtime PM transitions<BR>&nbsp;* &nbsp;&nbsp;along with subsystem-level and driver-level callbacks.<BR>&nbsp;* @pins:&nbsp;For device pin management.<BR>&nbsp;*&nbsp;&nbsp;See Documentation/pinctrl.txt for details.<BR>&nbsp;* @numa_node:&nbsp;NUMA node this device is close to.<BR>&nbsp;* @dma_mask:&nbsp;Dma mask (if dma'ble device).<BR>&nbsp;* @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all<BR>&nbsp;* &nbsp;&nbsp;hardware supports 64-bit addresses for consistent allocations<BR>&nbsp;* &nbsp;&nbsp;such descriptors.<BR>&nbsp;* @dma_pfn_offset: offset of DMA memory range relatively of RAM<BR>&nbsp;* @dma_parms:&nbsp;A low level driver may set these to teach IOMMU code about<BR>&nbsp;* &nbsp;&nbsp;segment limitations.<BR>&nbsp;* @dma_pools:&nbsp;Dma pools (if dma'ble device).<BR>&nbsp;* @dma_mem:&nbsp;Internal for coherent mem override.<BR>&nbsp;* @cma_area:&nbsp;Contiguous memory area for dma allocations<BR>&nbsp;* @archdata:&nbsp;For arch-specific additions.<BR>&nbsp;* @of_node:&nbsp;Associated device tree node.<BR>&nbsp;* @fwnode:&nbsp;Associated device node supplied by platform firmware.<BR>&nbsp;* @devt:&nbsp;For creating the sysfs "dev".<BR>&nbsp;* @id:&nbsp;&nbsp;device instance<BR>&nbsp;* @devres_lock: Spinlock to protect the resource of the device.<BR>&nbsp;* @devres_head: The resources list of the device.<BR>&nbsp;* @knode_class: The node used to add the device to the class list.<BR>&nbsp;* @class:&nbsp;The class of the device.<BR>&nbsp;* @groups:&nbsp;Optional attribute groups.<BR>&nbsp;* @release:&nbsp;Callback to free the device after all references have<BR>&nbsp;* &nbsp;&nbsp;gone away. This should be set by the allocator of the<BR>&nbsp;* &nbsp;&nbsp;device (i.e. the bus driver that discovered the device).<BR>&nbsp;* @iommu_group: IOMMU group the device belongs to.<BR>&nbsp;*<BR>&nbsp;* @offline_disabled: If set, the device is permanently online.<BR>&nbsp;* @offline:&nbsp;Set after successful invocation of bus type's .offline().<BR>&nbsp;*<BR>&nbsp;* At the lowest level, every device in a Linux system is represented by an<BR>&nbsp;* instance of struct device. The device structure contains the information<BR>&nbsp;* that the device model core needs to model the system. Most subsystems,<BR>&nbsp;* however, track additional information about the devices they host. As a<BR>&nbsp;* result, it is rare for devices to be represented by bare device structures;<BR>&nbsp;* instead, that structure, like kobject structures, is usually embedded within<BR>&nbsp;* a higher-level representation of the device.<BR>&nbsp;*/<BR>struct device {<BR>&nbsp;struct device&nbsp;&nbsp;*parent; 
<P></P>
<P>&nbsp;struct device_private&nbsp;*p;</P>
<P>&nbsp;struct kobject kobj;<BR>&nbsp;const char&nbsp;&nbsp;*init_name; /* initial name of the device */<BR>&nbsp;const struct device_type *type;</P>
<P>&nbsp;struct mutex&nbsp;&nbsp;mutex;&nbsp;/* mutex to synchronize calls to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * its driver.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;struct bus_type&nbsp;*bus;&nbsp;&nbsp;/* type of bus device is on */<BR>&nbsp;struct device_driver *driver;&nbsp;/* which driver has allocated this<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device */<BR>&nbsp;void&nbsp;&nbsp;*platform_data;&nbsp;/* Platform specific data, device<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; core doesn't touch it */<BR>&nbsp;void&nbsp;&nbsp;*driver_data;&nbsp;/* Driver data, set and get with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_set/get_drvdata */<BR>&nbsp;struct dev_pm_info&nbsp;power;<BR>&nbsp;struct dev_pm_domain&nbsp;*pm_domain;</P>
<P>#ifdef CONFIG_PINCTRL<BR>&nbsp;struct dev_pin_info&nbsp;*pins;<BR>#endif</P>
<P>#ifdef CONFIG_NUMA<BR>&nbsp;int&nbsp;&nbsp;numa_node;&nbsp;/* NUMA node this device is close to */<BR>#endif<BR>&nbsp;u64&nbsp;&nbsp;*dma_mask;&nbsp;/* dma mask (if dma'able device) */<BR>&nbsp;u64&nbsp;&nbsp;coherent_dma_mask;/* Like dma_mask, but for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alloc_coherent mappings as<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not all hardware supports<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 bit addresses for consistent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocations such descriptors. */<BR>&nbsp;unsigned long&nbsp;dma_pfn_offset;</P>
<P>&nbsp;struct device_dma_parameters *dma_parms;</P>
<P>&nbsp;struct list_head&nbsp;dma_pools;&nbsp;/* dma pools (if dma'ble) */</P>
<P>&nbsp;struct dma_coherent_mem&nbsp;*dma_mem; /* internal for coherent mem<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; override */<BR>#ifdef CONFIG_DMA_CMA<BR>&nbsp;struct cma *cma_area;&nbsp;&nbsp;/* contiguous memory area for dma<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocations */<BR>#endif<BR>&nbsp;/* arch specific additions */<BR>&nbsp;struct dev_archdata&nbsp;archdata;</P>
<P>&nbsp;struct device_node&nbsp;*of_node; /* associated device tree node */<BR>&nbsp;struct fwnode_handle&nbsp;*fwnode; /* firmware device node */</P>
<P>&nbsp;dev_t&nbsp;&nbsp;&nbsp;devt;&nbsp;/* dev_t, creates the sysfs "dev" */<BR>&nbsp;u32&nbsp;&nbsp;&nbsp;id;&nbsp;/* device instance */</P>
<P>&nbsp;spinlock_t&nbsp;&nbsp;devres_lock;<BR>&nbsp;struct list_head&nbsp;devres_head;</P>
<P>&nbsp;struct klist_node&nbsp;knode_class;<BR>&nbsp;struct class&nbsp;&nbsp;*class;<BR>&nbsp;const struct attribute_group **groups;&nbsp;/* optional groups */</P>
<P>&nbsp;void&nbsp;(*release)(struct device *dev);<BR>&nbsp;struct iommu_group&nbsp;*iommu_group;</P>
<P>&nbsp;bool&nbsp;&nbsp;&nbsp;offline_disabled:1;<BR>&nbsp;bool&nbsp;&nbsp;&nbsp;offline:1;<BR>};