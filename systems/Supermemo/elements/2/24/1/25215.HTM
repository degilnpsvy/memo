/**<BR>&nbsp;* kset_create - create a struct kset dynamically<BR>&nbsp;*<BR>&nbsp;* @name: the name for the kset<BR>&nbsp;* @uevent_ops: a struct kset_uevent_ops for the kset<BR>&nbsp;* @parent_kobj: the parent kobject of this kset, if any.<BR>&nbsp;*<BR>&nbsp;* This function creates a kset structure dynamically.&nbsp; This structure can<BR>&nbsp;* then be registered with the system and show up in sysfs with a call to<BR>&nbsp;* kset_register().&nbsp; When you are finished with this structure, if<BR>&nbsp;* kset_register() has been called, call kset_unregister() and the<BR>&nbsp;* structure will be dynamically freed when it is no longer being used.<BR>&nbsp;*<BR>&nbsp;* If the kset was not able to be created, NULL will be returned.<BR>&nbsp;*/<BR>static struct kset *kset_create(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct kset_uevent_ops *uevent_ops,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct kobject *parent_kobj)<BR>{<BR>&nbsp;struct kset *kset;<BR>&nbsp;int retval; 
<P></P>
<P>&nbsp;kset = kzalloc(sizeof(*kset), GFP_KERNEL);<BR>&nbsp;if (!kset)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;retval = kobject_set_name(&amp;kset-&gt;kobj, "%s", name);<BR>&nbsp;if (retval) {<BR>&nbsp;&nbsp;kfree(kset);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}<BR>&nbsp;kset-&gt;uevent_ops = uevent_ops;<BR>&nbsp;kset-&gt;kobj.parent = parent_kobj;</P>
<P>&nbsp;/*<BR>&nbsp; * The kobject of this kset will have a type of kset_ktype and belong to<BR>&nbsp; * no kset itself.&nbsp; That way we can properly free it when it is<BR>&nbsp; * finished being used.<BR>&nbsp; */<BR>&nbsp;kset-&gt;kobj.ktype = &amp;kset_ktype;<BR>&nbsp;kset-&gt;kobj.kset = NULL;</P>
<P>&nbsp;return kset;<BR>}