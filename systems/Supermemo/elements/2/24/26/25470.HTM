include/linux/device.h 
<P></P>
<P>&nbsp;</P>
<P>/*<BR>&nbsp;* device.h - generic, centralized driver model<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2001-2003 Patrick Mochel &lt;<A href="mailto:mochel@osdl.org">mochel@osdl.org</A>&gt;<BR>&nbsp;* Copyright (c) 2004-2009 Greg Kroah-Hartman &lt;<A href="mailto:gregkh@suse.de">gregkh@suse.de</A>&gt;<BR>&nbsp;* Copyright (c) 2008-2009 Novell Inc.<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2<BR>&nbsp;*<BR>&nbsp;* See Documentation/driver-model/ for more information.<BR>&nbsp;*/</P>
<P></P>
<P>#ifndef _DEVICE_H_<BR>#define _DEVICE_H_</P>
<P>#include &lt;linux/ioport.h&gt;<BR>#include &lt;linux/kobject.h&gt;<BR>#include &lt;linux/klist.h&gt;<BR>#include &lt;linux/list.h&gt;<BR>#include &lt;linux/lockdep.h&gt;<BR>#include &lt;linux/compiler.h&gt;<BR>#include &lt;linux/types.h&gt;<BR>#include &lt;linux/mutex.h&gt;<BR>#include &lt;linux/pinctrl/devinfo.h&gt;<BR>#include &lt;linux/pm.h&gt;<BR>#include &lt;linux/atomic.h&gt;<BR>#include &lt;linux/ratelimit.h&gt;<BR>#include &lt;linux/uidgid.h&gt;<BR>#include &lt;linux/gfp.h&gt;<BR>#include &lt;asm/device.h&gt;</P>
<P>struct device;<BR>struct device_private;<BR>struct device_driver;<BR>struct driver_private;<BR>struct module;<BR>struct class;<BR>struct subsys_private;<BR>struct bus_type;<BR>struct device_node;<BR>struct fwnode_handle;<BR>struct iommu_ops;<BR>struct iommu_group;</P>
<P>struct bus_attribute {<BR>&nbsp;struct attribute&nbsp;attr;<BR>&nbsp;ssize_t (*show)(struct bus_type *bus, char *buf);<BR>&nbsp;ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);<BR>};</P>
<P>#define BUS_ATTR(_name, _mode, _show, _store)&nbsp;\<BR>&nbsp;struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)<BR>#define BUS_ATTR_RW(_name) \<BR>&nbsp;struct bus_attribute bus_attr_##_name = __ATTR_RW(_name)<BR>#define BUS_ATTR_RO(_name) \<BR>&nbsp;struct bus_attribute bus_attr_##_name = __ATTR_RO(_name)</P>
<P>extern int __must_check bus_create_file(struct bus_type *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct bus_attribute *);<BR>extern void bus_remove_file(struct bus_type *, struct bus_attribute *);</P>
<P><FONT class=extract>/**<BR>&nbsp;* struct bus_type - The bus type of the device<BR>&nbsp;*<BR>&nbsp;* @name:&nbsp;The name of the bus.<BR>&nbsp;* @dev_name:&nbsp;Used for subsystems to enumerate devices like ("foo%u", dev-&gt;id).<BR>&nbsp;* @dev_root:&nbsp;Default device to use as the parent.<BR>&nbsp;* @dev_attrs:&nbsp;Default attributes of the devices on the bus.<BR>&nbsp;* @bus_groups:&nbsp;Default attributes of the bus.<BR>&nbsp;* @dev_groups:&nbsp;Default attributes of the devices on the bus.<BR>&nbsp;* @drv_groups: Default attributes of the device drivers on the bus.<BR>&nbsp;* @match:&nbsp;Called, perhaps multiple times, whenever a new device or driver<BR>&nbsp;*&nbsp;&nbsp;is added for this bus. It should return a nonzero value if the<BR>&nbsp;*&nbsp;&nbsp;given device can be handled by the given driver.<BR>&nbsp;* @uevent:&nbsp;Called when a device is added, removed, or a few other things<BR>&nbsp;*&nbsp;&nbsp;that generate uevents to add the environment variables.<BR>&nbsp;* @probe:&nbsp;Called when a new device or driver add to this bus, and callback<BR>&nbsp;*&nbsp;&nbsp;the specific driver's probe to initial the matched device.<BR>&nbsp;* @remove:&nbsp;Called when a device removed from this bus.<BR>&nbsp;* @shutdown:&nbsp;Called at shut-down time to quiesce the device.<BR>&nbsp;*<BR>&nbsp;* @online:&nbsp;Called to put the device back online (after offlining it).<BR>&nbsp;* @offline:&nbsp;Called to put the device offline for hot-removal. May fail.<BR>&nbsp;*<BR>&nbsp;* @suspend:&nbsp;Called when a device on this bus wants to go to sleep mode.<BR>&nbsp;* @resume:&nbsp;Called to bring a device on this bus out of sleep mode.<BR>&nbsp;* @pm:&nbsp;&nbsp;Power management operations of this bus, callback the specific<BR>&nbsp;*&nbsp;&nbsp;device driver's pm-ops.<BR>&nbsp;* @iommu_ops:&nbsp; IOMMU specific operations for this bus, used to attach IOMMU<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver implementations to a bus and allow the driver to do<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus-specific setup<BR>&nbsp;* @p:&nbsp;&nbsp;The private data of the driver core, only the driver core can<BR>&nbsp;*&nbsp;&nbsp;touch this.<BR>&nbsp;* @lock_key:&nbsp;Lock class key for use by the lock validator<BR>&nbsp;*<BR>&nbsp;* A bus is a channel between the processor and one or more devices. For the<BR>&nbsp;* purposes of the device model, all devices are connected via a bus, even if<BR>&nbsp;* it is an internal, virtual, "platform" bus. Buses can plug into each other.<BR>&nbsp;* A USB controller is usually a PCI device, for example. The device model<BR>&nbsp;* represents the actual connections between buses and the devices they control.<BR>&nbsp;* A bus is represented by the bus_type structure. It contains the name, the<BR>&nbsp;* default attributes, the bus' methods, PM operations, and the driver core's<BR>&nbsp;* private data.<BR>&nbsp;*/<BR>struct bus_type {<BR>&nbsp;const char&nbsp;&nbsp;*name;<BR>&nbsp;const char&nbsp;&nbsp;*dev_name;<BR>&nbsp;struct device&nbsp;&nbsp;*dev_root;<BR>&nbsp;struct device_attribute&nbsp;*dev_attrs;&nbsp;/* use dev_groups instead */<BR>&nbsp;const struct attribute_group **bus_groups;<BR>&nbsp;const struct attribute_group **dev_groups;<BR>&nbsp;const struct attribute_group **drv_groups;</FONT></P>
<P><FONT class=extract>&nbsp;int (*match)(struct device *dev, struct device_driver *drv);<BR>&nbsp;int (*uevent)(struct device *dev, struct kobj_uevent_env *env);<BR>&nbsp;int (*probe)(struct device *dev);<BR>&nbsp;int (*remove)(struct device *dev);<BR>&nbsp;void (*shutdown)(struct device *dev);</FONT></P>
<P><FONT class=extract>&nbsp;int (*online)(struct device *dev);<BR>&nbsp;int (*offline)(struct device *dev);</FONT></P>
<P><FONT class=extract>&nbsp;int (*suspend)(struct device *dev, pm_message_t state);<BR>&nbsp;int (*resume)(struct device *dev);</FONT></P>
<P><FONT class=extract>&nbsp;const struct dev_pm_ops *pm;</FONT></P>
<P><FONT class=extract>&nbsp;const struct iommu_ops *iommu_ops;</FONT></P>
<P><FONT class=extract>&nbsp;struct subsys_private *p;<BR>&nbsp;struct lock_class_key lock_key;<BR>};</FONT></P>
<P>extern int __must_check bus_register(struct bus_type *bus);</P>
<P>extern void bus_unregister(struct bus_type *bus);</P>
<P>extern int __must_check bus_rescan_devices(struct bus_type *bus);</P>
<P>/* iterator helpers for buses */<BR>struct subsys_dev_iter {<BR>&nbsp;struct klist_iter&nbsp;&nbsp;ki;<BR>&nbsp;const struct device_type&nbsp;*type;<BR>};<BR>void subsys_dev_iter_init(struct subsys_dev_iter *iter,<BR>&nbsp;&nbsp;&nbsp; struct bus_type *subsys,<BR>&nbsp;&nbsp;&nbsp; struct device *start,<BR>&nbsp;&nbsp;&nbsp; const struct device_type *type);<BR>struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter);<BR>void subsys_dev_iter_exit(struct subsys_dev_iter *iter);</P>
<P>int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*fn)(struct device *dev, void *data));<BR>struct device *bus_find_device(struct bus_type *bus, struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*match)(struct device *dev, void *data));<BR>struct device *bus_find_device_by_name(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name);<BR>struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct device *hint);<BR>int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data, int (*fn)(struct device_driver *, void *));<BR>void bus_sort_breadthfirst(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compare)(const struct device *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct device *b));<BR>/*<BR>&nbsp;* Bus notifiers: Get notified of addition/removal of devices<BR>&nbsp;* and binding/unbinding of drivers to devices.<BR>&nbsp;* In the long run, it should be a replacement for the platform<BR>&nbsp;* notify hooks.<BR>&nbsp;*/<BR>struct notifier_block;</P>
<P>extern int bus_register_notifier(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct notifier_block *nb);<BR>extern int bus_unregister_notifier(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct notifier_block *nb);</P>
<P>/* All 4 notifers below get called with the target struct device *<BR>&nbsp;* as an argument. Note that those functions are likely to be called<BR>&nbsp;* with the device lock held in the core, so be careful.<BR>&nbsp;*/<BR>#define BUS_NOTIFY_ADD_DEVICE&nbsp;&nbsp;0x00000001 /* device added */<BR>#define BUS_NOTIFY_DEL_DEVICE&nbsp;&nbsp;0x00000002 /* device to be removed */<BR>#define BUS_NOTIFY_REMOVED_DEVICE&nbsp;0x00000003 /* device removed */<BR>#define BUS_NOTIFY_BIND_DRIVER&nbsp;&nbsp;0x00000004 /* driver about to be<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bound */<BR>#define BUS_NOTIFY_BOUND_DRIVER&nbsp;&nbsp;0x00000005 /* driver bound to device */<BR>#define BUS_NOTIFY_UNBIND_DRIVER&nbsp;0x00000006 /* driver about to be<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unbound */<BR>#define BUS_NOTIFY_UNBOUND_DRIVER&nbsp;0x00000007 /* driver is unbound<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from the device */</P>
<P>extern struct kset *bus_get_kset(struct bus_type *bus);<BR>extern struct klist *bus_get_device_klist(struct bus_type *bus);</P>
<P><FONT class=extract>/**<BR>&nbsp;* enum probe_type - device driver probe type to try<BR>&nbsp;*&nbsp;Device drivers may opt in for special handling of their<BR>&nbsp;*&nbsp;respective probe routines. This tells the core what to<BR>&nbsp;*&nbsp;expect and prefer.<BR>&nbsp;*<BR>&nbsp;* @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well<BR>&nbsp;*&nbsp;whether probed synchronously or asynchronously.<BR>&nbsp;* @PROBE_PREFER_ASYNCHRONOUS: Drivers for "slow" devices which<BR>&nbsp;*&nbsp;probing order is not essential for booting the system may<BR>&nbsp;*&nbsp;opt into executing their probes asynchronously.<BR>&nbsp;* @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need<BR>&nbsp;*&nbsp;their probe routines to run synchronously with driver and<BR>&nbsp;*&nbsp;device registration (with the exception of -EPROBE_DEFER<BR>&nbsp;*&nbsp;handling - re-probing always ends up being done asynchronously).<BR>&nbsp;*<BR>&nbsp;* Note that the end goal is to switch the kernel to use asynchronous<BR>&nbsp;* probing by default, so annotating drivers with<BR>&nbsp;* %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us<BR>&nbsp;* to speed up boot process while we are validating the rest of the<BR>&nbsp;* drivers.<BR>&nbsp;*/<BR>enum probe_type {<BR>&nbsp;PROBE_DEFAULT_STRATEGY,<BR>&nbsp;PROBE_PREFER_ASYNCHRONOUS,<BR>&nbsp;PROBE_FORCE_SYNCHRONOUS,<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* struct device_driver - The basic device driver structure<BR>&nbsp;* @name:&nbsp;Name of the device driver.<BR>&nbsp;* @bus:&nbsp;The bus which the device of this driver belongs to.<BR>&nbsp;* @owner:&nbsp;The module owner.<BR>&nbsp;* @mod_name:&nbsp;Used for built-in modules.<BR>&nbsp;* @suppress_bind_attrs: Disables bind/unbind via sysfs.<BR>&nbsp;* @probe_type:&nbsp;Type of the probe (synchronous or asynchronous) to use.<BR>&nbsp;* @of_match_table: The open firmware table.<BR>&nbsp;* @acpi_match_table: The ACPI match table.<BR>&nbsp;* @probe:&nbsp;Called to query the existence of a specific device,<BR>&nbsp;*&nbsp;&nbsp;whether this driver can work with it, and bind the driver<BR>&nbsp;*&nbsp;&nbsp;to a specific device.<BR>&nbsp;* @remove:&nbsp;Called when the device is removed from the system to<BR>&nbsp;*&nbsp;&nbsp;unbind a device from this driver.<BR>&nbsp;* @shutdown:&nbsp;Called at shut-down time to quiesce the device.<BR>&nbsp;* @suspend:&nbsp;Called to put the device to sleep mode. Usually to a<BR>&nbsp;*&nbsp;&nbsp;low power state.<BR>&nbsp;* @resume:&nbsp;Called to bring a device from sleep mode.<BR>&nbsp;* @groups:&nbsp;Default attributes that get created by the driver core<BR>&nbsp;*&nbsp;&nbsp;automatically.<BR>&nbsp;* @pm:&nbsp;&nbsp;Power management operations of the device which matched<BR>&nbsp;*&nbsp;&nbsp;this driver.<BR>&nbsp;* @p:&nbsp;&nbsp;Driver core's private data, no one other than the driver<BR>&nbsp;*&nbsp;&nbsp;core can touch this.<BR>&nbsp;*<BR>&nbsp;* The device driver-model tracks all of the drivers known to the system.<BR>&nbsp;* The main reason for this tracking is to enable the driver core to match<BR>&nbsp;* up drivers with new devices. Once drivers are known objects within the<BR>&nbsp;* system, however, a number of other things become possible. Device drivers<BR>&nbsp;* can export information and configuration variables that are independent<BR>&nbsp;* of any specific device.<BR>&nbsp;*/<BR>struct device_driver {<BR>&nbsp;const char&nbsp;&nbsp;*name;<BR>&nbsp;struct bus_type&nbsp;&nbsp;*bus;</FONT></P>
<P><FONT class=extract>&nbsp;struct module&nbsp;&nbsp;*owner;<BR>&nbsp;const char&nbsp;&nbsp;*mod_name;&nbsp;/* used for built-in modules */</FONT></P>
<P><FONT class=extract>&nbsp;bool suppress_bind_attrs;&nbsp;/* disables bind/unbind via sysfs */<BR>&nbsp;enum probe_type probe_type;</FONT></P>
<P><FONT class=extract>&nbsp;const struct of_device_id&nbsp;*of_match_table;<BR>&nbsp;const struct acpi_device_id&nbsp;*acpi_match_table;</FONT></P>
<P><FONT class=extract>&nbsp;int (*probe) (struct device *dev);<BR>&nbsp;int (*remove) (struct device *dev);<BR>&nbsp;void (*shutdown) (struct device *dev);<BR>&nbsp;int (*suspend) (struct device *dev, pm_message_t state);<BR>&nbsp;int (*resume) (struct device *dev);<BR>&nbsp;const struct attribute_group **groups;</FONT></P>
<P><FONT class=extract>&nbsp;const struct dev_pm_ops *pm;</FONT></P>
<P><FONT class=extract>&nbsp;struct driver_private *p;<BR>};</FONT></P>
<P><BR>extern int __must_check driver_register(struct device_driver *drv);<BR>extern void driver_unregister(struct device_driver *drv);</P>
<P>extern struct device_driver *driver_find(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bus_type *bus);<BR>extern int driver_probe_done(void);<BR>extern void wait_for_device_probe(void);</P>
<P><BR>/* sysfs interface for exporting driver attributes */</P>
<P>struct driver_attribute {<BR>&nbsp;struct attribute attr;<BR>&nbsp;ssize_t (*show)(struct device_driver *driver, char *buf);<BR>&nbsp;ssize_t (*store)(struct device_driver *driver, const char *buf,<BR>&nbsp;&nbsp;&nbsp; size_t count);<BR>};</P>
<P>#define DRIVER_ATTR(_name, _mode, _show, _store) \<BR>&nbsp;struct driver_attribute driver_attr_##_name = __ATTR(_name, _mode, _show, _store)<BR>#define DRIVER_ATTR_RW(_name) \<BR>&nbsp;struct driver_attribute driver_attr_##_name = __ATTR_RW(_name)<BR>#define DRIVER_ATTR_RO(_name) \<BR>&nbsp;struct driver_attribute driver_attr_##_name = __ATTR_RO(_name)<BR>#define DRIVER_ATTR_WO(_name) \<BR>&nbsp;struct driver_attribute driver_attr_##_name = __ATTR_WO(_name)</P>
<P>extern int __must_check driver_create_file(struct device_driver *driver,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const struct driver_attribute *attr);<BR>extern void driver_remove_file(struct device_driver *driver,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct driver_attribute *attr);</P>
<P>extern int __must_check driver_for_each_device(struct device_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*fn)(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *));<BR>struct device *driver_find_device(struct device_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *start, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*match)(struct device *dev, void *data));</P>
<P><FONT class=extract>/**<BR>&nbsp;* struct subsys_interface - interfaces to device functions<BR>&nbsp;* @name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name of the device function<BR>&nbsp;* @subsys:&nbsp;&nbsp;&nbsp;&nbsp; subsytem of the devices to attach to<BR>&nbsp;* @node:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the list of functions registered at the subsystem<BR>&nbsp;* @add_dev:&nbsp;&nbsp;&nbsp; device hookup to device function handler<BR>&nbsp;* @remove_dev: device hookup to device function handler<BR>&nbsp;*<BR>&nbsp;* Simple interfaces attached to a subsystem. Multiple interfaces can<BR>&nbsp;* attach to a subsystem and its devices. Unlike drivers, they do not<BR>&nbsp;* exclusively claim or control devices. Interfaces usually represent<BR>&nbsp;* a specific functionality of a subsystem/class of devices.<BR>&nbsp;*/<BR>struct subsys_interface {<BR>&nbsp;const char *name;<BR>&nbsp;struct bus_type *subsys;<BR>&nbsp;struct list_head node;<BR>&nbsp;int (*add_dev)(struct device *dev, struct subsys_interface *sif);<BR>&nbsp;int (*remove_dev)(struct device *dev, struct subsys_interface *sif);<BR>};</FONT></P>
<P>int subsys_interface_register(struct subsys_interface *sif);<BR>void subsys_interface_unregister(struct subsys_interface *sif);</P>
<P>int subsys_system_register(struct bus_type *subsys,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups);<BR>int subsys_virtual_register(struct bus_type *subsys,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups);</P>
<P><FONT class=extract>/**<BR>&nbsp;* struct class - device classes<BR>&nbsp;* @name:&nbsp;Name of the class.<BR>&nbsp;* @owner:&nbsp;The module owner.<BR>&nbsp;* @class_attrs: Default attributes of this class.<BR>&nbsp;* @dev_groups:&nbsp;Default attributes of the devices that belong to the class.<BR>&nbsp;* @dev_kobj:&nbsp;The kobject that represents this class and links it into the hierarchy.<BR>&nbsp;* @dev_uevent:&nbsp;Called when a device is added, removed from this class, or a<BR>&nbsp;*&nbsp;&nbsp;few other things that generate uevents to add the environment<BR>&nbsp;*&nbsp;&nbsp;variables.<BR>&nbsp;* @devnode:&nbsp;Callback to provide the devtmpfs.<BR>&nbsp;* @class_release: Called to release this class.<BR>&nbsp;* @dev_release: Called to release the device.<BR>&nbsp;* @suspend:&nbsp;Used to put the device to sleep mode, usually to a low power<BR>&nbsp;*&nbsp;&nbsp;state.<BR>&nbsp;* @resume:&nbsp;Used to bring the device from the sleep mode.<BR>&nbsp;* @ns_type:&nbsp;Callbacks so sysfs can detemine namespaces.<BR>&nbsp;* @namespace:&nbsp;Namespace of the device belongs to this class.<BR>&nbsp;* @pm:&nbsp;&nbsp;The default device power management operations of this class.<BR>&nbsp;* @p:&nbsp;&nbsp;The private data of the driver core, no one other than the<BR>&nbsp;*&nbsp;&nbsp;driver core can touch this.<BR>&nbsp;*<BR>&nbsp;* A class is a higher-level view of a device that abstracts out low-level<BR>&nbsp;* implementation details. Drivers may see a SCSI disk or an ATA disk, but,<BR>&nbsp;* at the class level, they are all simply disks. Classes allow user space<BR>&nbsp;* to work with devices based on what they do, rather than how they are<BR>&nbsp;* connected or how they work.<BR>&nbsp;*/<BR>struct class {<BR>&nbsp;const char&nbsp;&nbsp;*name;<BR>&nbsp;struct module&nbsp;&nbsp;*owner;</FONT></P>
<P><FONT class=extract>&nbsp;struct class_attribute&nbsp;&nbsp;*class_attrs;<BR>&nbsp;const struct attribute_group&nbsp;**dev_groups;<BR>&nbsp;struct kobject&nbsp;&nbsp;&nbsp;*dev_kobj;</FONT></P>
<P><FONT class=extract>&nbsp;int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);<BR>&nbsp;char *(*devnode)(struct device *dev, umode_t *mode);</FONT></P>
<P><FONT class=extract>&nbsp;void (*class_release)(struct class *class);<BR>&nbsp;void (*dev_release)(struct device *dev);</FONT></P>
<P><FONT class=extract>&nbsp;int (*suspend)(struct device *dev, pm_message_t state);<BR>&nbsp;int (*resume)(struct device *dev);</FONT></P>
<P><FONT class=extract>&nbsp;const struct kobj_ns_type_operations *ns_type;<BR>&nbsp;const void *(*namespace)(struct device *dev);</FONT></P>
<P><FONT class=extract>&nbsp;const struct dev_pm_ops *pm;</FONT></P>
<P><FONT class=extract>&nbsp;struct subsys_private *p;<BR>};</FONT></P>
<P>struct class_dev_iter {<BR>&nbsp;struct klist_iter&nbsp;&nbsp;ki;<BR>&nbsp;const struct device_type&nbsp;*type;<BR>};</P>
<P>extern struct kobject *sysfs_dev_block_kobj;<BR>extern struct kobject *sysfs_dev_char_kobj;<BR>extern int __must_check __class_register(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct lock_class_key *key);<BR>extern void class_unregister(struct class *class);</P>
<P><FONT class=extract>/* This is a #define to keep the compiler from merging different<BR>&nbsp;* instances of the __key variable */<BR>#define class_register(class)&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static struct lock_class_key __key;&nbsp;\<BR>&nbsp;__class_register(class, &amp;__key);&nbsp;\<BR>})</FONT></P>
<P>struct class_compat;<BR>struct class_compat *class_compat_register(const char *name);<BR>void class_compat_unregister(struct class_compat *cls);<BR>int class_compat_create_link(struct class_compat *cls, struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *device_link);<BR>void class_compat_remove_link(struct class_compat *cls, struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *device_link);</P>
<P>extern void class_dev_iter_init(struct class_dev_iter *iter,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct device_type *type);<BR>extern struct device *class_dev_iter_next(struct class_dev_iter *iter);<BR>extern void class_dev_iter_exit(struct class_dev_iter *iter);</P>
<P>extern int class_for_each_device(struct class *class, struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp; void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int (*fn)(struct device *dev, void *data));<BR>extern struct device *class_find_device(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct device *start, const void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int (*match)(struct device *, const void *));</P>
<P><FONT class=extract>struct class_attribute {<BR>&nbsp;struct attribute attr;<BR>&nbsp;ssize_t (*show)(struct class *class, struct class_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;char *buf);<BR>&nbsp;ssize_t (*store)(struct class *class, struct class_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;const char *buf, size_t count);<BR>};</FONT></P>
<P><FONT class=extract>#define CLASS_ATTR(_name, _mode, _show, _store) \<BR>&nbsp;struct class_attribute class_attr_##_name = __ATTR(_name, _mode, _show, _store)<BR>#define CLASS_ATTR_RW(_name) \<BR>&nbsp;struct class_attribute class_attr_##_name = __ATTR_RW(_name)<BR>#define CLASS_ATTR_RO(_name) \<BR>&nbsp;struct class_attribute class_attr_##_name = __ATTR_RO(_name)</FONT></P>
<P><FONT class=extract>extern int __must_check class_create_file_ns(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct class_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *ns);<BR>extern void class_remove_file_ns(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct class_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const void *ns);</FONT></P>
<P><FONT class=extract>static inline int __must_check class_create_file(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const struct class_attribute *attr)<BR>{<BR>&nbsp;return class_create_file_ns(class, attr, NULL);<BR>}</FONT></P>
<P><FONT class=extract>static inline void class_remove_file(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct class_attribute *attr)<BR>{<BR>&nbsp;return class_remove_file_ns(class, attr, NULL);<BR>}</FONT></P>
<P>/* Simple class attribute that is just a static string */<BR>struct class_attribute_string {<BR>&nbsp;struct class_attribute attr;<BR>&nbsp;char *str;<BR>};</P>
<P>/* Currently read-only only */<BR>#define _CLASS_ATTR_STRING(_name, _mode, _str) \<BR>&nbsp;{ __ATTR(_name, _mode, show_class_attr_string, NULL), _str }<BR>#define CLASS_ATTR_STRING(_name, _mode, _str) \<BR>&nbsp;struct class_attribute_string class_attr_##_name = \<BR>&nbsp;&nbsp;_CLASS_ATTR_STRING(_name, _mode, _str)</P>
<P>extern ssize_t show_class_attr_string(struct class *class, struct class_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf);</P>
<P><FONT class=extract>struct class_interface {<BR>&nbsp;struct list_head&nbsp;node;<BR>&nbsp;struct class&nbsp;&nbsp;*class;</FONT></P>
<P><FONT class=extract>&nbsp;int (*add_dev)&nbsp;&nbsp;(struct device *, struct class_interface *);<BR>&nbsp;void (*remove_dev)&nbsp;(struct device *, struct class_interface *);<BR>};</FONT></P>
<P><FONT class=extract>extern int __must_check class_interface_register(struct class_interface *);<BR>extern void class_interface_unregister(struct class_interface *);</FONT></P>
<P><FONT class=extract>extern struct class * __must_check __class_create(struct module *owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct lock_class_key *key);<BR>extern void class_destroy(struct class *cls);</FONT></P>
<P><FONT class=extract>/* This is a #define to keep the compiler from merging different<BR>&nbsp;* instances of the __key variable */<BR>#define class_create(owner, name)&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static struct lock_class_key __key;&nbsp;\<BR>&nbsp;__class_create(owner, name, &amp;__key);&nbsp;\<BR>})</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* The type of device, "struct device" is embedded in. A class<BR>&nbsp;* or bus can contain devices of different types<BR>&nbsp;* like "partitions" and "disks", "mouse" and "event".<BR>&nbsp;* This identifies the device type and carries type-specific<BR>&nbsp;* information, equivalent to the kobj_type of a kobject.<BR>&nbsp;* If "name" is specified, the uevent will contain it in<BR>&nbsp;* the DEVTYPE variable.<BR>&nbsp;*/<BR>struct device_type {<BR>&nbsp;const char *name;<BR>&nbsp;const struct attribute_group **groups;<BR>&nbsp;int (*uevent)(struct device *dev, struct kobj_uevent_env *env);<BR>&nbsp;char *(*devnode)(struct device *dev, umode_t *mode,<BR>&nbsp;&nbsp;&nbsp; kuid_t *uid, kgid_t *gid);<BR>&nbsp;void (*release)(struct device *dev);</FONT></P>
<P><FONT class=extract>&nbsp;const struct dev_pm_ops *pm;<BR>};</FONT></P>
<P>/* interface for exporting device attributes */<BR>struct device_attribute {<BR>&nbsp;struct attribute&nbsp;attr;<BR>&nbsp;ssize_t (*show)(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;char *buf);<BR>&nbsp;ssize_t (*store)(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp; const char *buf, size_t count);<BR>};</P>
<P>struct dev_ext_attribute {<BR>&nbsp;struct device_attribute attr;<BR>&nbsp;void *var;<BR>};</P>
<P>ssize_t device_show_ulong(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; char *buf);<BR>ssize_t device_store_ulong(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count);<BR>ssize_t device_show_int(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;char *buf);<BR>ssize_t device_store_int(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp; const char *buf, size_t count);<BR>ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;char *buf);<BR>ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp; const char *buf, size_t count);</P>
<P>#define DEVICE_ATTR(_name, _mode, _show, _store) \<BR>&nbsp;struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)<BR>#define DEVICE_ATTR_RW(_name) \<BR>&nbsp;struct device_attribute dev_attr_##_name = __ATTR_RW(_name)<BR>#define DEVICE_ATTR_RO(_name) \<BR>&nbsp;struct device_attribute dev_attr_##_name = __ATTR_RO(_name)<BR>#define DEVICE_ATTR_WO(_name) \<BR>&nbsp;struct device_attribute dev_attr_##_name = __ATTR_WO(_name)<BR>#define DEVICE_ULONG_ATTR(_name, _mode, _var) \<BR>&nbsp;struct dev_ext_attribute dev_attr_##_name = \<BR>&nbsp;&nbsp;{ __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &amp;(_var) }<BR>#define DEVICE_INT_ATTR(_name, _mode, _var) \<BR>&nbsp;struct dev_ext_attribute dev_attr_##_name = \<BR>&nbsp;&nbsp;{ __ATTR(_name, _mode, device_show_int, device_store_int), &amp;(_var) }<BR>#define DEVICE_BOOL_ATTR(_name, _mode, _var) \<BR>&nbsp;struct dev_ext_attribute dev_attr_##_name = \<BR>&nbsp;&nbsp;{ __ATTR(_name, _mode, device_show_bool, device_store_bool), &amp;(_var) }<BR>#define DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \<BR>&nbsp;struct device_attribute dev_attr_##_name =&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)</P>
<P>extern int device_create_file(struct device *device,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct device_attribute *entry);<BR>extern void device_remove_file(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct device_attribute *attr);<BR>extern bool device_remove_file_self(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct device_attribute *attr);<BR>extern int __must_check device_create_bin_file(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const struct bin_attribute *attr);<BR>extern void device_remove_bin_file(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct bin_attribute *attr);</P>
<P>/* device resource management */<BR>typedef void (*dr_release_t)(struct device *dev, void *res);<BR>typedef int (*dr_match_t)(struct device *dev, void *res, void *match_data);</P>
<P>#ifdef CONFIG_DEBUG_DEVRES<BR>extern void *__devres_alloc(dr_release_t release, size_t size, gfp_t gfp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name);<BR>#define devres_alloc(release, size, gfp) \<BR>&nbsp;__devres_alloc(release, size, gfp, #release)<BR>#else<BR>extern void *devres_alloc(dr_release_t release, size_t size, gfp_t gfp);<BR>#endif<BR>extern void devres_for_each_res(struct device *dev, dr_release_t release,<BR>&nbsp;&nbsp;&nbsp;&nbsp;dr_match_t match, void *match_data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;void (*fn)(struct device *, void *, void *),<BR>&nbsp;&nbsp;&nbsp;&nbsp;void *data);<BR>extern void devres_free(void *res);<BR>extern void devres_add(struct device *dev, void *res);<BR>extern void *devres_find(struct device *dev, dr_release_t release,<BR>&nbsp;&nbsp;&nbsp; dr_match_t match, void *match_data);<BR>extern void *devres_get(struct device *dev, void *new_res,<BR>&nbsp;&nbsp;&nbsp;dr_match_t match, void *match_data);<BR>extern void *devres_remove(struct device *dev, dr_release_t release,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dr_match_t match, void *match_data);<BR>extern int devres_destroy(struct device *dev, dr_release_t release,<BR>&nbsp;&nbsp;&nbsp;&nbsp; dr_match_t match, void *match_data);<BR>extern int devres_release(struct device *dev, dr_release_t release,<BR>&nbsp;&nbsp;&nbsp;&nbsp; dr_match_t match, void *match_data);</P>
<P>/* devres group */<BR>extern void * __must_check devres_open_group(struct device *dev, void *id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gfp_t gfp);<BR>extern void devres_close_group(struct device *dev, void *id);<BR>extern void devres_remove_group(struct device *dev, void *id);<BR>extern int devres_release_group(struct device *dev, void *id);</P>
<P>/* managed devm_k.alloc/kfree for device drivers */<BR>extern void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp);<BR>extern __printf(3, 0)<BR>char *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list ap);<BR>extern __printf(3, 4)<BR>char *devm_kasprintf(struct device *dev, gfp_t gfp, const char *fmt, ...);<BR>static inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)<BR>{<BR>&nbsp;return devm_kmalloc(dev, size, gfp | __GFP_ZERO);<BR>}<BR>static inline void *devm_kmalloc_array(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, size_t size, gfp_t flags)<BR>{<BR>&nbsp;if (size != 0 &amp;&amp; n &gt; SIZE_MAX / size)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;return devm_kmalloc(dev, n * size, flags);<BR>}<BR>static inline void *devm_kcalloc(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; size_t n, size_t size, gfp_t flags)<BR>{<BR>&nbsp;return devm_kmalloc_array(dev, n, size, flags | __GFP_ZERO);<BR>}<BR>extern void devm_kfree(struct device *dev, void *p);<BR>extern char *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp);<BR>extern void *devm_kmemdup(struct device *dev, const void *src, size_t len,<BR>&nbsp;&nbsp;&nbsp;&nbsp; gfp_t gfp);</P>
<P>extern unsigned long devm_get_free_pages(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gfp_t gfp_mask, unsigned int order);<BR>extern void devm_free_pages(struct device *dev, unsigned long addr);</P>
<P>void __iomem *devm_ioremap_resource(struct device *dev, struct resource *res);</P>
<P>/* allows to add/remove a custom action to devres stack */<BR>int devm_add_action(struct device *dev, void (*action)(void *), void *data);<BR>void devm_remove_action(struct device *dev, void (*action)(void *), void *data);</P>
<P>struct device_dma_parameters {<BR>&nbsp;/*<BR>&nbsp; * a low level driver may set these to teach IOMMU code about<BR>&nbsp; * sg limitations.<BR>&nbsp; */<BR>&nbsp;unsigned int max_segment_size;<BR>&nbsp;unsigned long segment_boundary_mask;<BR>};</P>
<P><FONT class=extract>/**<BR>&nbsp;* struct device - The basic device structure<BR>&nbsp;* @parent:&nbsp;The device's "parent" device, the device to which it is attached.<BR>&nbsp;* &nbsp;&nbsp;In most cases, a parent device is some sort of bus or host<BR>&nbsp;* &nbsp;&nbsp;controller. If parent is NULL, the device, is a top-level device,<BR>&nbsp;* &nbsp;&nbsp;which is not usually what you want.<BR>&nbsp;* @p:&nbsp;&nbsp;Holds the private data of the driver core portions of the device.<BR>&nbsp;* &nbsp;&nbsp;See the comment of the struct device_private for detail.<BR>&nbsp;* @kobj:&nbsp;A top-level, abstract class from which other classes are derived.<BR>&nbsp;* @init_name:&nbsp;Initial name of the device.<BR>&nbsp;* @type:&nbsp;The type of device.<BR>&nbsp;* &nbsp;&nbsp;This identifies the device type and carries type-specific<BR>&nbsp;* &nbsp;&nbsp;information.<BR>&nbsp;* @mutex:&nbsp;Mutex to synchronize calls to its driver.<BR>&nbsp;* @bus:&nbsp;Type of bus device is on.<BR>&nbsp;* @driver:&nbsp;Which driver has allocated this<BR>&nbsp;* @platform_data: Platform data specific to the device.<BR>&nbsp;* &nbsp;&nbsp;Example: For devices on custom boards, as typical of embedded<BR>&nbsp;* &nbsp;&nbsp;and SOC based hardware, Linux often uses platform_data to point<BR>&nbsp;* &nbsp;&nbsp;to board-specific structures describing devices and how they<BR>&nbsp;* &nbsp;&nbsp;are wired.&nbsp; That can include what ports are available, chip<BR>&nbsp;* &nbsp;&nbsp;variants, which GPIO pins act in what additional roles, and so<BR>&nbsp;* &nbsp;&nbsp;on.&nbsp; This shrinks the "Board Support Packages" (BSPs) and<BR>&nbsp;* &nbsp;&nbsp;minimizes board-specific #ifdefs in drivers.<BR>&nbsp;* @driver_data: Private pointer for driver specific info.<BR>&nbsp;* @power:&nbsp;For device power management.<BR>&nbsp;* &nbsp;&nbsp;See Documentation/power/devices.txt for details.<BR>&nbsp;* @pm_domain:&nbsp;Provide callbacks that are executed during system suspend,<BR>&nbsp;* &nbsp;&nbsp;hibernation, system resume and during runtime PM transitions<BR>&nbsp;* &nbsp;&nbsp;along with subsystem-level and driver-level callbacks.<BR>&nbsp;* @pins:&nbsp;For device pin management.<BR>&nbsp;*&nbsp;&nbsp;See Documentation/pinctrl.txt for details.<BR>&nbsp;* @numa_node:&nbsp;NUMA node this device is close to.<BR>&nbsp;* @dma_mask:&nbsp;Dma mask (if dma'ble device).<BR>&nbsp;* @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all<BR>&nbsp;* &nbsp;&nbsp;hardware supports 64-bit addresses for consistent allocations<BR>&nbsp;* &nbsp;&nbsp;such descriptors.<BR>&nbsp;* @dma_pfn_offset: offset of DMA memory range relatively of RAM<BR>&nbsp;* @dma_parms:&nbsp;A low level driver may set these to teach IOMMU code about<BR>&nbsp;* &nbsp;&nbsp;segment limitations.<BR>&nbsp;* @dma_pools:&nbsp;Dma pools (if dma'ble device).<BR>&nbsp;* @dma_mem:&nbsp;Internal for coherent mem override.<BR>&nbsp;* @cma_area:&nbsp;Contiguous memory area for dma allocations<BR>&nbsp;* @archdata:&nbsp;For arch-specific additions.<BR>&nbsp;* @of_node:&nbsp;Associated device tree node.<BR>&nbsp;* @fwnode:&nbsp;Associated device node supplied by platform firmware.<BR>&nbsp;* @devt:&nbsp;For creating the sysfs "dev".<BR>&nbsp;* @id:&nbsp;&nbsp;device instance<BR>&nbsp;* @devres_lock: Spinlock to protect the resource of the device.<BR>&nbsp;* @devres_head: The resources list of the device.<BR>&nbsp;* @knode_class: The node used to add the device to the class list.<BR>&nbsp;* @class:&nbsp;The class of the device.<BR>&nbsp;* @groups:&nbsp;Optional attribute groups.<BR>&nbsp;* @release:&nbsp;Callback to free the device after all references have<BR>&nbsp;* &nbsp;&nbsp;gone away. This should be set by the allocator of the<BR>&nbsp;* &nbsp;&nbsp;device (i.e. the bus driver that discovered the device).<BR>&nbsp;* @iommu_group: IOMMU group the device belongs to.<BR>&nbsp;*<BR>&nbsp;* @offline_disabled: If set, the device is permanently online.<BR>&nbsp;* @offline:&nbsp;Set after successful invocation of bus type's .offline().<BR>&nbsp;*<BR>&nbsp;* At the lowest level, every device in a Linux system is represented by an<BR>&nbsp;* instance of struct device. The device structure contains the information<BR>&nbsp;* that the device model core needs to model the system. Most subsystems,<BR>&nbsp;* however, track additional information about the devices they host. As a<BR>&nbsp;* result, it is rare for devices to be represented by bare device structures;<BR>&nbsp;* instead, that structure, like kobject structures, is usually embedded within<BR>&nbsp;* a higher-level representation of the device.<BR>&nbsp;*/<BR>struct device {<BR>&nbsp;struct device&nbsp;&nbsp;*parent;</FONT></P>
<P><FONT class=extract>&nbsp;struct device_private&nbsp;*p;</FONT></P>
<P><FONT class=extract>&nbsp;struct kobject kobj;<BR>&nbsp;const char&nbsp;&nbsp;*init_name; /* initial name of the device */<BR>&nbsp;const struct device_type *type;</FONT></P>
<P><FONT class=extract>&nbsp;struct mutex&nbsp;&nbsp;mutex;&nbsp;/* mutex to synchronize calls to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * its driver.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</FONT></P>
<P><FONT class=extract>&nbsp;struct bus_type&nbsp;*bus;&nbsp;&nbsp;/* type of bus device is on */<BR>&nbsp;struct device_driver *driver;&nbsp;/* which driver has allocated this<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device */<BR>&nbsp;void&nbsp;&nbsp;*platform_data;&nbsp;/* Platform specific data, device<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; core doesn't touch it */<BR>&nbsp;void&nbsp;&nbsp;*driver_data;&nbsp;/* Driver data, set and get with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_set/get_drvdata */<BR>&nbsp;struct dev_pm_info&nbsp;power;<BR>&nbsp;struct dev_pm_domain&nbsp;*pm_domain;</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_PINCTRL<BR>&nbsp;struct dev_pin_info&nbsp;*pins;<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_NUMA<BR>&nbsp;int&nbsp;&nbsp;numa_node;&nbsp;/* NUMA node this device is close to */<BR>#endif<BR>&nbsp;u64&nbsp;&nbsp;*dma_mask;&nbsp;/* dma mask (if dma'able device) */<BR>&nbsp;u64&nbsp;&nbsp;coherent_dma_mask;/* Like dma_mask, but for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alloc_coherent mappings as<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not all hardware supports<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 bit addresses for consistent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocations such descriptors. */<BR>&nbsp;unsigned long&nbsp;dma_pfn_offset;</FONT></P>
<P><FONT class=extract>&nbsp;struct device_dma_parameters *dma_parms;</FONT></P>
<P><FONT class=extract>&nbsp;struct list_head&nbsp;dma_pools;&nbsp;/* dma pools (if dma'ble) */</FONT></P>
<P><FONT class=extract>&nbsp;struct dma_coherent_mem&nbsp;*dma_mem; /* internal for coherent mem<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; override */<BR>#ifdef CONFIG_DMA_CMA<BR>&nbsp;struct cma *cma_area;&nbsp;&nbsp;/* contiguous memory area for dma<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocations */<BR>#endif<BR>&nbsp;/* arch specific additions */<BR>&nbsp;struct dev_archdata&nbsp;archdata;</FONT></P>
<P><FONT class=extract>&nbsp;struct device_node&nbsp;*of_node; /* associated device tree node */<BR>&nbsp;struct fwnode_handle&nbsp;*fwnode; /* firmware device node */</FONT></P>
<P><FONT class=extract>&nbsp;dev_t&nbsp;&nbsp;&nbsp;devt;&nbsp;/* dev_t, creates the sysfs "dev" */<BR>&nbsp;u32&nbsp;&nbsp;&nbsp;id;&nbsp;/* device instance */</FONT></P>
<P><FONT class=extract>&nbsp;spinlock_t&nbsp;&nbsp;devres_lock;<BR>&nbsp;struct list_head&nbsp;devres_head;</FONT></P>
<P><FONT class=extract>&nbsp;struct klist_node&nbsp;knode_class;<BR>&nbsp;struct class&nbsp;&nbsp;*class;<BR>&nbsp;const struct attribute_group **groups;&nbsp;/* optional groups */</FONT></P>
<P><FONT class=extract>&nbsp;void&nbsp;(*release)(struct device *dev);<BR>&nbsp;struct iommu_group&nbsp;*iommu_group;</FONT></P>
<P><FONT class=extract>&nbsp;bool&nbsp;&nbsp;&nbsp;offline_disabled:1;<BR>&nbsp;bool&nbsp;&nbsp;&nbsp;offline:1;<BR>};</FONT></P>
<P><FONT class=extract>static inline struct device *kobj_to_dev(struct kobject *kobj)<BR>{<BR>&nbsp;return container_of(kobj, struct device, kobj);<BR>}</FONT></P>
<P><FONT class=extract>/* Get the wakeup routines, which depend on struct device */<BR>#include &lt;linux/pm_wakeup.h&gt;</FONT></P>
<P><FONT class=extract>static inline const char *dev_name(const struct device *dev)<BR>{<BR>&nbsp;/* Use the init name until the kobject becomes available */<BR>&nbsp;if (dev-&gt;init_name)<BR>&nbsp;&nbsp;return dev-&gt;init_name;</FONT></P>
<P><FONT class=extract>&nbsp;return kobject_name(&amp;dev-&gt;kobj);<BR>}</FONT></P>
<P><FONT class=extract>extern __printf(2, 3)<BR>int dev_set_name(struct device *dev, const char *name, ...);</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_NUMA<BR>static inline int dev_to_node(struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;numa_node;<BR>}<BR>static inline void set_dev_node(struct device *dev, int node)<BR>{<BR>&nbsp;dev-&gt;numa_node = node;<BR>}<BR>#else<BR>static inline int dev_to_node(struct device *dev)<BR>{<BR>&nbsp;return -1;<BR>}<BR>static inline void set_dev_node(struct device *dev, int node)<BR>{<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>static inline void *dev_get_drvdata(const struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;driver_data;<BR>}</FONT></P>
<P><FONT class=extract>static inline void dev_set_drvdata(struct device *dev, void *data)<BR>{<BR>&nbsp;dev-&gt;driver_data = data;<BR>}</FONT></P>
<P>static inline struct pm_subsys_data *dev_to_psd(struct device *dev)<BR>{<BR>&nbsp;return dev ? dev-&gt;power.subsys_data : NULL;<BR>}</P>
<P><FONT class=extract>static inline unsigned int dev_get_uevent_suppress(const struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;kobj.uevent_suppress;<BR>}</FONT></P>
<P><FONT class=extract>static inline void dev_set_uevent_suppress(struct device *dev, int val)<BR>{<BR>&nbsp;dev-&gt;kobj.uevent_suppress = val;<BR>}</FONT></P>
<P><FONT class=extract>static inline int device_is_registered(struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;kobj.state_in_sysfs;<BR>}</FONT></P>
<P>static inline void device_enable_async_suspend(struct device *dev)<BR>{<BR>&nbsp;if (!dev-&gt;power.is_prepared)<BR>&nbsp;&nbsp;dev-&gt;power.async_suspend = true;<BR>}</P>
<P>static inline void device_disable_async_suspend(struct device *dev)<BR>{<BR>&nbsp;if (!dev-&gt;power.is_prepared)<BR>&nbsp;&nbsp;dev-&gt;power.async_suspend = false;<BR>}</P>
<P>static inline bool device_async_suspend_enabled(struct device *dev)<BR>{<BR>&nbsp;return !!dev-&gt;power.async_suspend;<BR>}</P>
<P>static inline void pm_suspend_ignore_children(struct device *dev, bool enable)<BR>{<BR>&nbsp;dev-&gt;power.ignore_children = enable;<BR>}</P>
<P>static inline void dev_pm_syscore_device(struct device *dev, bool val)<BR>{<BR>#ifdef CONFIG_PM_SLEEP<BR>&nbsp;dev-&gt;power.syscore = val;<BR>#endif<BR>}</P>
<P><FONT class=extract>static inline void device_lock(struct device *dev)<BR>{<BR>&nbsp;mutex_lock(&amp;dev-&gt;mutex);<BR>}</FONT></P>
<P><FONT class=extract>static inline int device_trylock(struct device *dev)<BR>{<BR>&nbsp;return mutex_trylock(&amp;dev-&gt;mutex);<BR>}</FONT></P>
<P><FONT class=extract>static inline void device_unlock(struct device *dev)<BR>{<BR>&nbsp;mutex_unlock(&amp;dev-&gt;mutex);<BR>}</FONT></P>
<P>static inline void device_lock_assert(struct device *dev)<BR>{<BR>&nbsp;lockdep_assert_held(&amp;dev-&gt;mutex);<BR>}</P>
<P>static inline struct device_node *dev_of_node(struct device *dev)<BR>{<BR>&nbsp;if (!IS_ENABLED(CONFIG_OF))<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;return dev-&gt;of_node;<BR>}</P>
<P>void driver_init(void);</P>
<P>/*<BR>&nbsp;* High level routines for use by the bus drivers<BR>&nbsp;*/<BR>extern int __must_check device_register(struct device *dev);<BR>extern void device_unregister(struct device *dev);<BR>extern void device_initialize(struct device *dev);<BR>extern int __must_check device_add(struct device *dev);<BR>extern void device_del(struct device *dev);<BR>extern int device_for_each_child(struct device *dev, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*fn)(struct device *dev, void *data));<BR>extern struct device *device_find_child(struct device *dev, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;int (*match)(struct device *dev, void *data));<BR>extern int device_rename(struct device *dev, const char *new_name);<BR>extern int device_move(struct device *dev, struct device *new_parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum dpm_order dpm_order);<BR>extern const char *device_get_devnode(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umode_t *mode, kuid_t *uid, kgid_t *gid,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char **tmp);</P>
<P>static inline bool device_supports_offline(struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;offline &amp;&amp; dev-&gt;bus-&gt;online;<BR>}</P>
<P>extern void lock_device_hotplug(void);<BR>extern void unlock_device_hotplug(void);<BR>extern int lock_device_hotplug_sysfs(void);<BR>extern int device_offline(struct device *dev);<BR>extern int device_online(struct device *dev);<BR>extern void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);<BR>extern void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode);</P>
<P>/*<BR>&nbsp;* Root device objects for grouping under /sys/devices<BR>&nbsp;*/<BR>extern struct device *__root_device_register(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *owner);</P>
<P>/* This is a macro to avoid include problems with THIS_MODULE */<BR>#define root_device_register(name) \<BR>&nbsp;__root_device_register(name, THIS_MODULE)</P>
<P>extern void root_device_unregister(struct device *root);</P>
<P>static inline void *dev_get_platdata(const struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;platform_data;<BR>}</P>
<P>/*<BR>&nbsp;* Manual binding of a device to driver. See drivers/base/bus.c<BR>&nbsp;* for information on use.<BR>&nbsp;*/<BR>extern int __must_check device_bind_driver(struct device *dev);<BR>extern void device_release_driver(struct device *dev);<BR>extern int&nbsp; __must_check device_attach(struct device *dev);<BR>extern int __must_check driver_attach(struct device_driver *drv);<BR>extern void device_initial_probe(struct device *dev);<BR>extern int __must_check device_reprobe(struct device *dev);</P>
<P>/*<BR>&nbsp;* Easy functions for dynamically creating devices on the fly<BR>&nbsp;*/<BR>extern __printf(5, 0)<BR>struct device *device_create_vargs(struct class *cls, struct device *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_t devt, void *drvdata,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, va_list vargs);<BR>extern __printf(5, 6)<BR>struct device *device_create(struct class *cls, struct device *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_t devt, void *drvdata,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, ...);<BR>extern __printf(6, 7)<BR>struct device *device_create_with_groups(struct class *cls,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *parent, dev_t devt, void *drvdata,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, ...);<BR>extern void device_destroy(struct class *cls, dev_t devt);</P>
<P>/*<BR>&nbsp;* Platform "fixup" functions - allow the platform to have their say<BR>&nbsp;* about devices and actions that the general device layer doesn't<BR>&nbsp;* know about.<BR>&nbsp;*/<BR>/* Notify platform of device discovery */<BR>extern int (*platform_notify)(struct device *dev);</P>
<P>extern int (*platform_notify_remove)(struct device *dev);</P>
<P><BR>/*<BR>&nbsp;* get_device - atomically increment the reference count for the device.<BR>&nbsp;*<BR>&nbsp;*/<BR>extern struct device *get_device(struct device *dev);<BR>extern void put_device(struct device *dev);</P>
<P>#ifdef CONFIG_DEVTMPFS<BR>extern int devtmpfs_create_node(struct device *dev);<BR>extern int devtmpfs_delete_node(struct device *dev);<BR>extern int devtmpfs_mount(const char *mntdir);<BR>#else<BR>static inline int devtmpfs_create_node(struct device *dev) { return 0; }<BR>static inline int devtmpfs_delete_node(struct device *dev) { return 0; }<BR>static inline int devtmpfs_mount(const char *mountpoint) { return 0; }<BR>#endif</P>
<P>/* drivers/base/power/shutdown.c */<BR>extern void device_shutdown(void);</P>
<P>/* debugging and troubleshooting/diagnostic helpers. */<BR>extern const char *dev_driver_string(const struct device *dev);</P>
<P><BR>#ifdef CONFIG_PRINTK</P>
<P>extern __printf(3, 0)<BR>int dev_vprintk_emit(int level, const struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, va_list args);<BR>extern __printf(3, 4)<BR>int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...);</P>
<P>extern __printf(3, 4)<BR>void dev_printk(const char *level, const struct device *dev,<BR>&nbsp;&nbsp;const char *fmt, ...);<BR>extern __printf(2, 3)<BR>void dev_emerg(const struct device *dev, const char *fmt, ...);<BR>extern __printf(2, 3)<BR>void dev_alert(const struct device *dev, const char *fmt, ...);<BR>extern __printf(2, 3)<BR>void dev_crit(const struct device *dev, const char *fmt, ...);<BR>extern __printf(2, 3)<BR>void dev_err(const struct device *dev, const char *fmt, ...);<BR>extern __printf(2, 3)<BR>void dev_warn(const struct device *dev, const char *fmt, ...);<BR>extern __printf(2, 3)<BR>void dev_notice(const struct device *dev, const char *fmt, ...);<BR>extern __printf(2, 3)<BR>void _dev_info(const struct device *dev, const char *fmt, ...);</P>
<P>#else</P>
<P>static inline __printf(3, 0)<BR>int dev_vprintk_emit(int level, const struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, va_list args)<BR>{ return 0; }<BR>static inline __printf(3, 4)<BR>int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)<BR>{ return 0; }</P>
<P>static inline void __dev_printk(const char *level, const struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct va_format *vaf)<BR>{}<BR>static inline __printf(3, 4)<BR>void dev_printk(const char *level, const struct device *dev,<BR>&nbsp;&nbsp;const char *fmt, ...)<BR>{}</P>
<P>static inline __printf(2, 3)<BR>void dev_emerg(const struct device *dev, const char *fmt, ...)<BR>{}<BR>static inline __printf(2, 3)<BR>void dev_crit(const struct device *dev, const char *fmt, ...)<BR>{}<BR>static inline __printf(2, 3)<BR>void dev_alert(const struct device *dev, const char *fmt, ...)<BR>{}<BR>static inline __printf(2, 3)<BR>void dev_err(const struct device *dev, const char *fmt, ...)<BR>{}<BR>static inline __printf(2, 3)<BR>void dev_warn(const struct device *dev, const char *fmt, ...)<BR>{}<BR>static inline __printf(2, 3)<BR>void dev_notice(const struct device *dev, const char *fmt, ...)<BR>{}<BR>static inline __printf(2, 3)<BR>void _dev_info(const struct device *dev, const char *fmt, ...)<BR>{}</P>
<P>#endif</P>
<P>/*<BR>&nbsp;* Stupid hackaround for existing uses of non-printk uses dev_info<BR>&nbsp;*<BR>&nbsp;* Note that the definition of dev_info below is actually _dev_info<BR>&nbsp;* and a macro is used to avoid redefining dev_info<BR>&nbsp;*/</P>
<P>#define dev_info(dev, fmt, arg...) _dev_info(dev, fmt, ##arg)</P>
<P>#if defined(CONFIG_DYNAMIC_DEBUG)<BR>#define dev_dbg(dev, format, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;dynamic_dev_dbg(dev, format, ##__VA_ARGS__); \<BR>} while (0)<BR>#elif defined(DEBUG)<BR>#define dev_dbg(dev, format, arg...)&nbsp;&nbsp;\<BR>&nbsp;dev_printk(KERN_DEBUG, dev, format, ##arg)<BR>#else<BR>#define dev_dbg(dev, format, arg...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;dev_printk(KERN_DEBUG, dev, format, ##arg);&nbsp;\<BR>})<BR>#endif</P>
<P>#ifdef CONFIG_PRINTK<BR>#define dev_level_once(dev_level, dev, fmt, ...)&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static bool __print_once __read_mostly;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!__print_once) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__print_once = true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;dev_level(dev, fmt, ##__VA_ARGS__);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>} while (0)<BR>#else<BR>#define dev_level_once(dev_level, dev, fmt, ...)&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;dev_level(dev, fmt, ##__VA_ARGS__);&nbsp;&nbsp;&nbsp;\<BR>} while (0)<BR>#endif</P>
<P>#define dev_emerg_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_emerg, dev, fmt, ##__VA_ARGS__)<BR>#define dev_alert_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_alert, dev, fmt, ##__VA_ARGS__)<BR>#define dev_crit_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_crit, dev, fmt, ##__VA_ARGS__)<BR>#define dev_err_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_err, dev, fmt, ##__VA_ARGS__)<BR>#define dev_warn_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_warn, dev, fmt, ##__VA_ARGS__)<BR>#define dev_notice_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_notice, dev, fmt, ##__VA_ARGS__)<BR>#define dev_info_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_info, dev, fmt, ##__VA_ARGS__)<BR>#define dev_dbg_once(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_once(dev_dbg, dev, fmt, ##__VA_ARGS__)</P>
<P>#define dev_level_ratelimited(dev_level, dev, fmt, ...)&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static DEFINE_RATELIMIT_STATE(_rs,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_RATELIMIT_INTERVAL,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_RATELIMIT_BURST);&nbsp;&nbsp;\<BR>&nbsp;if (__ratelimit(&amp;_rs))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;dev_level(dev, fmt, ##__VA_ARGS__);&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>#define dev_emerg_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_ratelimited(dev_emerg, dev, fmt, ##__VA_ARGS__)<BR>#define dev_alert_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_ratelimited(dev_alert, dev, fmt, ##__VA_ARGS__)<BR>#define dev_crit_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_ratelimited(dev_crit, dev, fmt, ##__VA_ARGS__)<BR>#define dev_err_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_ratelimited(dev_err, dev, fmt, ##__VA_ARGS__)<BR>#define dev_warn_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_ratelimited(dev_warn, dev, fmt, ##__VA_ARGS__)<BR>#define dev_notice_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_ratelimited(dev_notice, dev, fmt, ##__VA_ARGS__)<BR>#define dev_info_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;dev_level_ratelimited(dev_info, dev, fmt, ##__VA_ARGS__)<BR>#if defined(CONFIG_DYNAMIC_DEBUG)<BR>/* descriptor check is first to prevent flooding with "callbacks suppressed" */<BR>#define dev_dbg_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static DEFINE_RATELIMIT_STATE(_rs,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_RATELIMIT_INTERVAL,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_RATELIMIT_BURST);&nbsp;&nbsp;\<BR>&nbsp;DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (unlikely(descriptor.flags &amp; _DPRINTK_FLAGS_PRINT) &amp;&amp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp; __ratelimit(&amp;_rs))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__dynamic_dev_dbg(&amp;descriptor, dev, fmt,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##__VA_ARGS__);&nbsp;&nbsp;&nbsp;\<BR>} while (0)<BR>#elif defined(DEBUG)<BR>#define dev_dbg_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static DEFINE_RATELIMIT_STATE(_rs,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_RATELIMIT_INTERVAL,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_RATELIMIT_BURST);&nbsp;&nbsp;\<BR>&nbsp;if (__ratelimit(&amp;_rs))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__);&nbsp;\<BR>} while (0)<BR>#else<BR>#define dev_dbg_ratelimited(dev, fmt, ...)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)<BR>#endif</P>
<P>#ifdef VERBOSE_DEBUG<BR>#define dev_vdbg&nbsp;dev_dbg<BR>#else<BR>#define dev_vdbg(dev, format, arg...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;dev_printk(KERN_DEBUG, dev, format, ##arg);&nbsp;\<BR>})<BR>#endif</P>
<P>/*<BR>&nbsp;* dev_WARN*() acts like dev_printk(), but with the key difference of<BR>&nbsp;* using WARN/WARN_ONCE to include file/line information and a backtrace.<BR>&nbsp;*/<BR>#define dev_WARN(dev, format, arg...) \<BR>&nbsp;WARN(1, "%s %s: " format, dev_driver_string(dev), dev_name(dev), ## arg);</P>
<P>#define dev_WARN_ONCE(dev, condition, format, arg...) \<BR>&nbsp;WARN_ONCE(condition, "%s %s: " format, \<BR>&nbsp;&nbsp;&nbsp;dev_driver_string(dev), dev_name(dev), ## arg)</P>
<P>/* Create alias, so I can be autoloaded. */<BR>#define MODULE_ALIAS_CHARDEV(major,minor) \<BR>&nbsp;MODULE_ALIAS("char-major-" __stringify(major) "-" __stringify(minor))<BR>#define MODULE_ALIAS_CHARDEV_MAJOR(major) \<BR>&nbsp;MODULE_ALIAS("char-major-" __stringify(major) "-*")</P>
<P>#ifdef CONFIG_SYSFS_DEPRECATED<BR>extern long sysfs_deprecated;<BR>#else<BR>#define sysfs_deprecated 0<BR>#endif</P>
<P>/**<BR>&nbsp;* module_driver() - Helper macro for drivers that don't do anything<BR>&nbsp;* special in module init/exit. This eliminates a lot of boilerplate.<BR>&nbsp;* Each module may only use this macro once, and calling it replaces<BR>&nbsp;* module_init() and module_exit().<BR>&nbsp;*<BR>&nbsp;* @__driver: driver name<BR>&nbsp;* @__register: register function for this driver type<BR>&nbsp;* @__unregister: unregister function for this driver type<BR>&nbsp;* @...: Additional arguments to be passed to __register and __unregister.<BR>&nbsp;*<BR>&nbsp;* Use this macro to construct bus specific macros for registering<BR>&nbsp;* drivers, and do not use it on its own.<BR>&nbsp;*/<BR>#define module_driver(__driver, __register, __unregister, ...) \<BR>static int __init __driver##_init(void) \<BR>{ \<BR>&nbsp;return __register(&amp;(__driver) , ##__VA_ARGS__); \<BR>} \<BR>module_init(__driver##_init); \<BR>static void __exit __driver##_exit(void) \<BR>{ \<BR>&nbsp;__unregister(&amp;(__driver) , ##__VA_ARGS__); \<BR>} \<BR>module_exit(__driver##_exit);</P>
<P>/**<BR>&nbsp;* builtin_driver() - Helper macro for drivers that don't do anything<BR>&nbsp;* special in init and have no exit. This eliminates some boilerplate.<BR>&nbsp;* Each driver may only use this macro once, and calling it replaces<BR>&nbsp;* device_initcall (or in some cases, the legacy __initcall).&nbsp; This is<BR>&nbsp;* meant to be a direct parallel of module_driver() above but without<BR>&nbsp;* the __exit stuff that is not used for builtin cases.<BR>&nbsp;*<BR>&nbsp;* @__driver: driver name<BR>&nbsp;* @__register: register function for this driver type<BR>&nbsp;* @...: Additional arguments to be passed to __register<BR>&nbsp;*<BR>&nbsp;* Use this macro to construct bus specific macros for registering<BR>&nbsp;* drivers, and do not use it on its own.<BR>&nbsp;*/<BR>#define builtin_driver(__driver, __register, ...) \<BR>static int __init __driver##_init(void) \<BR>{ \<BR>&nbsp;return __register(&amp;(__driver) , ##__VA_ARGS__); \<BR>} \<BR>device_initcall(__driver##_init);</P>
<P>#endif /* _DEVICE_H_ */