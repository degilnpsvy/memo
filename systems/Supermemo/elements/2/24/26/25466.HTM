kernel/workqueue.c 
<P></P>
<P>&nbsp;</P>
<P>/*<BR>&nbsp;* kernel/workqueue.c - generic async execution with shared worker pool<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2002&nbsp;&nbsp;Ingo Molnar<BR>&nbsp;*<BR>&nbsp;*&nbsp;&nbsp; Derived from the taskqueue/keventd code by:<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; David Woodhouse &lt;<A href="mailto:dwmw2@infradead.org">dwmw2@infradead.org</A>&gt;<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; Andrew Morton<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; Kai Petzke &lt;<A href="mailto:wpp@marie.physik.tu-berlin.de">wpp@marie.physik.tu-berlin.de</A>&gt;<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; Theodore Ts'o &lt;<A href="mailto:tytso@mit.edu">tytso@mit.edu</A>&gt;<BR>&nbsp;*<BR>&nbsp;* Made to use alloc_percpu by Christoph Lameter.<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2010&nbsp;&nbsp;SUSE Linux Products GmbH<BR>&nbsp;* Copyright (C) 2010&nbsp;&nbsp;Tejun Heo &lt;<A href="mailto:tj@kernel.org">tj@kernel.org</A>&gt;<BR>&nbsp;*<BR>&nbsp;* This is the generic async execution mechanism.&nbsp; Work items as are<BR>&nbsp;* executed in process context.&nbsp; The worker pool is shared and<BR>&nbsp;* automatically managed.&nbsp; There are two worker pools for each CPU (one for<BR>&nbsp;* normal work items and the other for high priority ones) and some extra<BR>&nbsp;* pools for workqueues which are not bound to any specific CPU - the<BR>&nbsp;* number of these backing pools is dynamic.<BR>&nbsp;*<BR>&nbsp;* Please read Documentation/workqueue.txt for details.<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/sched.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/signal.h&gt;<BR>#include &lt;linux/completion.h&gt;<BR>#include &lt;linux/workqueue.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/cpu.h&gt;<BR>#include &lt;linux/notifier.h&gt;<BR>#include &lt;linux/kthread.h&gt;<BR>#include &lt;linux/hardirq.h&gt;<BR>#include &lt;linux/mempolicy.h&gt;<BR>#include &lt;linux/freezer.h&gt;<BR>#include &lt;linux/kallsyms.h&gt;<BR>#include &lt;linux/debug_locks.h&gt;<BR>#include &lt;linux/lockdep.h&gt;<BR>#include &lt;linux/idr.h&gt;<BR>#include &lt;linux/jhash.h&gt;<BR>#include &lt;linux/hashtable.h&gt;<BR>#include &lt;linux/rculist.h&gt;<BR>#include &lt;linux/nodemask.h&gt;<BR>#include &lt;linux/moduleparam.h&gt;<BR>#include &lt;linux/uaccess.h&gt;</P>
<P>#include "workqueue_internal.h"</P>
<P>enum {<BR>&nbsp;/*<BR>&nbsp; * worker_pool flags<BR>&nbsp; *<BR>&nbsp; * A bound pool is either associated or disassociated with its CPU.<BR>&nbsp; * While associated (!DISASSOCIATED), all workers are bound to the<BR>&nbsp; * CPU and none has %WORKER_UNBOUND set and concurrency management<BR>&nbsp; * is in effect.<BR>&nbsp; *<BR>&nbsp; * While DISASSOCIATED, the cpu may be offline and all workers have<BR>&nbsp; * %WORKER_UNBOUND set and concurrency management disabled, and may<BR>&nbsp; * be executing on any CPU.&nbsp; The pool behaves as an unbound one.<BR>&nbsp; *<BR>&nbsp; * Note that DISASSOCIATED should be flipped only while holding<BR>&nbsp; * attach_mutex to avoid changing binding state while<BR>&nbsp; * worker_attach_to_pool() is in progress.<BR>&nbsp; */<BR>&nbsp;POOL_DISASSOCIATED&nbsp;= 1 &lt;&lt; 2,&nbsp;/* cpu can't serve workers */</P>
<P>&nbsp;/* worker flags */<BR>&nbsp;WORKER_DIE&nbsp;&nbsp;= 1 &lt;&lt; 1,&nbsp;/* die die die */<BR>&nbsp;WORKER_IDLE&nbsp;&nbsp;= 1 &lt;&lt; 2,&nbsp;/* is idle */<BR>&nbsp;WORKER_PREP&nbsp;&nbsp;= 1 &lt;&lt; 3,&nbsp;/* preparing to run works */<BR>&nbsp;WORKER_CPU_INTENSIVE&nbsp;= 1 &lt;&lt; 6,&nbsp;/* cpu intensive */<BR>&nbsp;WORKER_UNBOUND&nbsp;&nbsp;= 1 &lt;&lt; 7,&nbsp;/* worker is unbound */<BR>&nbsp;WORKER_REBOUND&nbsp;&nbsp;= 1 &lt;&lt; 8,&nbsp;/* worker was rebound */</P>
<P>&nbsp;WORKER_NOT_RUNNING&nbsp;= WORKER_PREP | WORKER_CPU_INTENSIVE |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORKER_UNBOUND | WORKER_REBOUND,</P>
<P>&nbsp;NR_STD_WORKER_POOLS&nbsp;= 2,&nbsp;&nbsp;/* # standard pools per cpu */</P>
<P>&nbsp;UNBOUND_POOL_HASH_ORDER&nbsp;= 6,&nbsp;&nbsp;/* hashed by pool-&gt;attrs */<BR>&nbsp;BUSY_WORKER_HASH_ORDER&nbsp;= 6,&nbsp;&nbsp;/* 64 pointers */</P>
<P>&nbsp;MAX_IDLE_WORKERS_RATIO&nbsp;= 4,&nbsp;&nbsp;/* 1/4 of busy can be idle */<BR>&nbsp;IDLE_WORKER_TIMEOUT&nbsp;= 300 * HZ,&nbsp;/* keep idle ones for 5 mins */</P>
<P>&nbsp;MAYDAY_INITIAL_TIMEOUT&nbsp; = HZ / 100 &gt;= 2 ? HZ / 100 : 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* call for help after 10ms<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (min two ticks) */<BR>&nbsp;MAYDAY_INTERVAL&nbsp;&nbsp;= HZ / 10,&nbsp;/* and then every 100ms */<BR>&nbsp;CREATE_COOLDOWN&nbsp;&nbsp;= HZ,&nbsp;&nbsp;/* time to breath after fail */</P>
<P>&nbsp;/*<BR>&nbsp; * Rescue workers are used only on emergencies and shared by<BR>&nbsp; * all cpus.&nbsp; Give MIN_NICE.<BR>&nbsp; */<BR>&nbsp;RESCUER_NICE_LEVEL&nbsp;= MIN_NICE,<BR>&nbsp;HIGHPRI_NICE_LEVEL&nbsp;= MIN_NICE,</P>
<P>&nbsp;WQ_NAME_LEN&nbsp;&nbsp;= 24,<BR>};</P>
<P><FONT class=extract>/*<BR>&nbsp;* Structure fields follow one of the following exclusion rules.<BR>&nbsp;*<BR>&nbsp;* I: Modifiable by initialization/destruction paths and read-only for<BR>&nbsp;*&nbsp;&nbsp;&nbsp; everyone else.<BR>&nbsp;*<BR>&nbsp;* P: Preemption protected.&nbsp; Disabling preemption is enough and should<BR>&nbsp;*&nbsp;&nbsp;&nbsp; only be modified and accessed from the local cpu.<BR>&nbsp;*<BR>&nbsp;* L: pool-&gt;lock protected.&nbsp; Access with pool-&gt;lock held.<BR>&nbsp;*<BR>&nbsp;* X: During normal operation, modification requires pool-&gt;lock and should<BR>&nbsp;*&nbsp;&nbsp;&nbsp; be done only from local cpu.&nbsp; Either disabling preemption on local<BR>&nbsp;*&nbsp;&nbsp;&nbsp; cpu or grabbing pool-&gt;lock is enough for read access.&nbsp; If<BR>&nbsp;*&nbsp;&nbsp;&nbsp; POOL_DISASSOCIATED is set, it's identical to L.<BR>&nbsp;*<BR>&nbsp;* A: pool-&gt;attach_mutex protected.<BR>&nbsp;*<BR>&nbsp;* PL: wq_pool_mutex protected.<BR>&nbsp;*<BR>&nbsp;* PR: wq_pool_mutex protected for writes.&nbsp; Sched-RCU protected for reads.<BR>&nbsp;*<BR>&nbsp;* PW: wq_pool_mutex and wq-&gt;mutex protected for writes.&nbsp; Either for reads.<BR>&nbsp;*<BR>&nbsp;* PWR: wq_pool_mutex and wq-&gt;mutex protected for writes.&nbsp; Either or<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sched-RCU for reads.<BR>&nbsp;*<BR>&nbsp;* WQ: wq-&gt;mutex protected.<BR>&nbsp;*<BR>&nbsp;* WR: wq-&gt;mutex protected for writes.&nbsp; Sched-RCU protected for reads.<BR>&nbsp;*<BR>&nbsp;* MD: wq_mayday_lock protected.<BR>&nbsp;*/</FONT></P>
<P>/* struct worker is defined in workqueue_internal.h */</P>
<P>struct worker_pool {<BR>&nbsp;spinlock_t&nbsp;&nbsp;lock;&nbsp;&nbsp;/* the pool lock */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;cpu;&nbsp;&nbsp;/* I: the associated cpu */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;node;&nbsp;&nbsp;/* I: the associated node ID */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;id;&nbsp;&nbsp;/* I: pool ID */<BR>&nbsp;unsigned int&nbsp;&nbsp;flags;&nbsp;&nbsp;/* X: flags */</P>
<P>&nbsp;struct list_head&nbsp;worklist;&nbsp;/* L: list of pending works */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;nr_workers;&nbsp;/* L: total number of workers */</P>
<P>&nbsp;/* nr_idle includes the ones off idle_list for rebinding */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;nr_idle;&nbsp;/* L: currently idle ones */</P>
<P>&nbsp;struct list_head&nbsp;idle_list;&nbsp;/* X: list of idle workers */<BR>&nbsp;struct timer_list&nbsp;idle_timer;&nbsp;/* L: worker idle timeout */<BR>&nbsp;struct timer_list&nbsp;mayday_timer;&nbsp;/* L: SOS timer for workers */</P>
<P>&nbsp;/* a workers is either on busy_hash or idle_list, or the manager */<BR>&nbsp;DECLARE_HASHTABLE(busy_hash, BUSY_WORKER_HASH_ORDER);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* L: hash of busy workers */</P>
<P>&nbsp;/* see manage_workers() for details on the two manager mutexes */<BR>&nbsp;struct mutex&nbsp;&nbsp;manager_arb;&nbsp;/* manager arbitration */<BR>&nbsp;struct worker&nbsp;&nbsp;*manager;&nbsp;/* L: purely informational */<BR>&nbsp;struct mutex&nbsp;&nbsp;attach_mutex;&nbsp;/* attach/detach exclusion */<BR>&nbsp;struct list_head&nbsp;workers;&nbsp;/* A: attached workers */<BR>&nbsp;struct completion&nbsp;*detach_completion; /* all workers detached */</P>
<P>&nbsp;struct ida&nbsp;&nbsp;worker_ida;&nbsp;/* worker IDs for task name */</P>
<P>&nbsp;struct workqueue_attrs&nbsp;*attrs;&nbsp;&nbsp;/* I: worker attributes */<BR>&nbsp;struct hlist_node&nbsp;hash_node;&nbsp;/* PL: unbound_pool_hash node */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;refcnt;&nbsp;&nbsp;/* PL: refcnt for unbound pools */</P>
<P>&nbsp;/*<BR>&nbsp; * The current concurrency level.&nbsp; As it's likely to be accessed<BR>&nbsp; * from other CPUs during try_to_wake_up(), put it in a separate<BR>&nbsp; * cacheline.<BR>&nbsp; */<BR>&nbsp;atomic_t&nbsp;&nbsp;nr_running ____cacheline_aligned_in_smp;</P>
<P>&nbsp;/*<BR>&nbsp; * Destruction of pool is sched-RCU protected to allow dereferences<BR>&nbsp; * from get_work_pool().<BR>&nbsp; */<BR>&nbsp;struct rcu_head&nbsp;&nbsp;rcu;<BR>} ____cacheline_aligned_in_smp;</P>
<P><FONT class=extract>/*<BR>&nbsp;* The per-pool workqueue.&nbsp; While queued, the lower WORK_STRUCT_FLAG_BITS<BR>&nbsp;* of work_struct-&gt;data are used for flags and the remaining high bits<BR>&nbsp;* point to the pwq; thus, pwqs need to be aligned at two's power of the<BR>&nbsp;* number of flag bits.<BR>&nbsp;*/<BR>struct pool_workqueue {<BR>&nbsp;struct worker_pool&nbsp;*pool;&nbsp;&nbsp;/* I: the associated pool */<BR>&nbsp;struct workqueue_struct *wq;&nbsp;&nbsp;/* I: the owning workqueue */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;work_color;&nbsp;/* L: current color */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;flush_color;&nbsp;/* L: flushing color */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;refcnt;&nbsp;&nbsp;/* L: reference count */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;nr_in_flight[WORK_NR_COLORS];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* L: nr of in_flight works */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;nr_active;&nbsp;/* L: nr of active works */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;max_active;&nbsp;/* L: max active works */<BR>&nbsp;struct list_head&nbsp;delayed_works;&nbsp;/* L: delayed works */<BR>&nbsp;struct list_head&nbsp;pwqs_node;&nbsp;/* WR: node on wq-&gt;pwqs */<BR>&nbsp;struct list_head&nbsp;mayday_node;&nbsp;/* MD: node on wq-&gt;maydays */</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * Release of unbound pwq is punted to system_wq.&nbsp; See put_pwq()<BR>&nbsp; * and pwq_unbound_release_workfn() for details.&nbsp; pool_workqueue<BR>&nbsp; * itself is also sched-RCU protected so that the first pwq can be<BR>&nbsp; * determined without grabbing wq-&gt;mutex.<BR>&nbsp; */<BR>&nbsp;struct work_struct&nbsp;unbound_release_work;<BR>&nbsp;struct rcu_head&nbsp;&nbsp;rcu;<BR>} __aligned(1 &lt;&lt; WORK_STRUCT_FLAG_BITS);</FONT></P>
<P>/*<BR>&nbsp;* Structure used to wait for workqueue flush.<BR>&nbsp;*/<BR>struct wq_flusher {<BR>&nbsp;struct list_head&nbsp;list;&nbsp;&nbsp;/* WQ: list of flushers */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;flush_color;&nbsp;/* WQ: flush color waiting for */<BR>&nbsp;struct completion&nbsp;done;&nbsp;&nbsp;/* flush completion */<BR>};</P>
<P>struct wq_device;</P>
<P><FONT class=extract>/*<BR>&nbsp;* The externally visible workqueue.&nbsp; It relays the issued work items to<BR>&nbsp;* the appropriate worker_pool through its pool_workqueues.<BR>&nbsp;*/<BR>struct workqueue_struct {<BR>&nbsp;struct list_head&nbsp;pwqs;&nbsp;&nbsp;/* WR: all pwqs of this wq */<BR>&nbsp;struct list_head&nbsp;list;&nbsp;&nbsp;/* PR: list of all workqueues */</FONT></P>
<P><FONT class=extract>&nbsp;struct mutex&nbsp;&nbsp;mutex;&nbsp;&nbsp;/* protects this wq */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;work_color;&nbsp;/* WQ: current work color */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;flush_color;&nbsp;/* WQ: current flush color */<BR>&nbsp;atomic_t&nbsp;&nbsp;nr_pwqs_to_flush; /* flush in progress */<BR>&nbsp;struct wq_flusher&nbsp;*first_flusher;&nbsp;/* WQ: first flusher */<BR>&nbsp;struct list_head&nbsp;flusher_queue;&nbsp;/* WQ: flush waiters */<BR>&nbsp;struct list_head&nbsp;flusher_overflow; /* WQ: flush overflow list */</FONT></P>
<P><FONT class=extract>&nbsp;struct list_head&nbsp;maydays;&nbsp;/* MD: pwqs requesting rescue */<BR>&nbsp;struct worker&nbsp;&nbsp;*rescuer;&nbsp;/* I: rescue worker */</FONT></P>
<P><FONT class=extract>&nbsp;int&nbsp;&nbsp;&nbsp;nr_drainers;&nbsp;/* WQ: drain in progress */<BR>&nbsp;int&nbsp;&nbsp;&nbsp;saved_max_active; /* WQ: saved pwq max_active */</FONT></P>
<P><FONT class=extract>&nbsp;struct workqueue_attrs&nbsp;*unbound_attrs;&nbsp;/* PW: only for unbound wqs */<BR>&nbsp;struct pool_workqueue&nbsp;*dfl_pwq;&nbsp;/* PW: only for unbound wqs */</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_SYSFS<BR>&nbsp;struct wq_device&nbsp;*wq_dev;&nbsp;/* I: for sysfs interface */<BR>#endif<BR>#ifdef CONFIG_LOCKDEP<BR>&nbsp;struct lockdep_map&nbsp;lockdep_map;<BR>#endif<BR>&nbsp;char&nbsp;&nbsp;&nbsp;name[WQ_NAME_LEN]; /* I: workqueue name */</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * Destruction of workqueue_struct is sched-RCU protected to allow<BR>&nbsp; * walking the workqueues list without grabbing wq_pool_mutex.<BR>&nbsp; * This is used to dump all workqueues from sysrq.<BR>&nbsp; */<BR>&nbsp;struct rcu_head&nbsp;&nbsp;rcu;</FONT></P>
<P><FONT class=extract>&nbsp;/* hot fields used during command issue, aligned to cacheline */<BR>&nbsp;unsigned int&nbsp;&nbsp;flags ____cacheline_aligned; /* WQ: WQ_* flags */<BR>&nbsp;struct pool_workqueue __percpu *cpu_pwqs; /* I: per-cpu pwqs */<BR>&nbsp;struct pool_workqueue __rcu *numa_pwq_tbl[]; /* PWR: unbound pwqs indexed by node */<BR>};</FONT></P>
<P>static struct kmem_cache *pwq_cache;</P>
<P>static cpumask_var_t *wq_numa_possible_cpumask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* possible CPUs of each node */</P>
<P>static bool wq_disable_numa;<BR>module_param_named(disable_numa, wq_disable_numa, bool, 0444);</P>
<P>/* see the comment above the definition of WQ_POWER_EFFICIENT */<BR>static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);<BR>module_param_named(power_efficient, wq_power_efficient, bool, 0444);</P>
<P>static bool wq_numa_enabled;&nbsp;&nbsp;/* unbound NUMA affinity enabled */</P>
<P>/* buf for wq_update_unbound_numa_attrs(), protected by CPU hotplug exclusion */<BR>static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;</P>
<P>static DEFINE_MUTEX(wq_pool_mutex);&nbsp;/* protects pools and workqueues list */<BR>static DEFINE_SPINLOCK(wq_mayday_lock);&nbsp;/* protects wq-&gt;maydays list */</P>
<P>static LIST_HEAD(workqueues);&nbsp;&nbsp;/* PR: list of all workqueues */<BR>static bool workqueue_freezing;&nbsp;&nbsp;/* PL: have wqs started freezing? */</P>
<P>static cpumask_var_t wq_unbound_cpumask; /* PL: low level cpumask for all unbound wqs */</P>
<P>/* the per-cpu worker pools */<BR>static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_worker_pools);</P>
<P>static DEFINE_IDR(worker_pool_idr);&nbsp;/* PR: idr of all pools */</P>
<P>/* PL: hash of all unbound pools keyed by pool-&gt;attrs */<BR>static DEFINE_HASHTABLE(unbound_pool_hash, UNBOUND_POOL_HASH_ORDER);</P>
<P>/* I: attributes used when instantiating standard unbound pools on demand */<BR>static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];</P>
<P>/* I: attributes used when instantiating ordered pools on demand */<BR>static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];</P>
<P><FONT class=extract>struct workqueue_struct *system_wq __read_mostly;<BR>EXPORT_SYMBOL(system_wq);<BR>struct workqueue_struct *system_highpri_wq __read_mostly;<BR>EXPORT_SYMBOL_GPL(system_highpri_wq);<BR>struct workqueue_struct *system_long_wq __read_mostly;<BR>EXPORT_SYMBOL_GPL(system_long_wq);<BR>struct workqueue_struct *system_unbound_wq __read_mostly;<BR>EXPORT_SYMBOL_GPL(system_unbound_wq);<BR>struct workqueue_struct *system_freezable_wq __read_mostly;<BR>EXPORT_SYMBOL_GPL(system_freezable_wq);<BR>struct workqueue_struct *system_power_efficient_wq __read_mostly;<BR>EXPORT_SYMBOL_GPL(system_power_efficient_wq);<BR>struct workqueue_struct *system_freezable_power_efficient_wq __read_mostly;<BR>EXPORT_SYMBOL_GPL(system_freezable_power_efficient_wq);</FONT></P>
<P>static int worker_thread(void *__worker);<BR>static void workqueue_sysfs_unregister(struct workqueue_struct *wq);</P>
<P>#define CREATE_TRACE_POINTS<BR>#include &lt;trace/events/workqueue.h&gt;</P>
<P>#define assert_rcu_or_pool_mutex()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;rcu_lockdep_assert(rcu_read_lock_sched_held() ||&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lockdep_is_held(&amp;wq_pool_mutex),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "sched RCU or wq_pool_mutex should be held")</P>
<P>#define assert_rcu_or_wq_mutex(wq)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;rcu_lockdep_assert(rcu_read_lock_sched_held() ||&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lockdep_is_held(&amp;wq-&gt;mutex),&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "sched RCU or wq-&gt;mutex should be held")</P>
<P>#define assert_rcu_or_wq_mutex_or_pool_mutex(wq)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;rcu_lockdep_assert(rcu_read_lock_sched_held() ||&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lockdep_is_held(&amp;wq-&gt;mutex) ||&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lockdep_is_held(&amp;wq_pool_mutex),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "sched RCU, wq-&gt;mutex or wq_pool_mutex should be held")</P>
<P>#define for_each_cpu_worker_pool(pool, cpu)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for ((pool) = &amp;per_cpu(cpu_worker_pools, cpu)[0];&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pool) &lt; &amp;per_cpu(cpu_worker_pools, cpu)[NR_STD_WORKER_POOLS]; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pool)++)</P>
<P>/**<BR>&nbsp;* for_each_pool - iterate through all worker_pools in the system<BR>&nbsp;* @pool: iteration cursor<BR>&nbsp;* @pi: integer used for iteration<BR>&nbsp;*<BR>&nbsp;* This must be called either with wq_pool_mutex held or sched RCU read<BR>&nbsp;* locked.&nbsp; If the pool needs to be used beyond the locking in effect, the<BR>&nbsp;* caller is responsible for guaranteeing that the pool stays online.<BR>&nbsp;*<BR>&nbsp;* The if/else clause exists only for the lockdep assertion and can be<BR>&nbsp;* ignored.<BR>&nbsp;*/<BR>#define for_each_pool(pool, pi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;idr_for_each_entry(&amp;worker_pool_idr, pool, pi)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (({ assert_rcu_or_pool_mutex(); false; })) { }&nbsp;\<BR>&nbsp;&nbsp;else</P>
<P>/**<BR>&nbsp;* for_each_pool_worker - iterate through all workers of a worker_pool<BR>&nbsp;* @worker: iteration cursor<BR>&nbsp;* @pool: worker_pool to iterate workers of<BR>&nbsp;*<BR>&nbsp;* This must be called with @pool-&gt;attach_mutex.<BR>&nbsp;*<BR>&nbsp;* The if/else clause exists only for the lockdep assertion and can be<BR>&nbsp;* ignored.<BR>&nbsp;*/<BR>#define for_each_pool_worker(worker, pool)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;list_for_each_entry((worker), &amp;(pool)-&gt;workers, node)&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (({ lockdep_assert_held(&amp;pool-&gt;attach_mutex); false; })) { } \<BR>&nbsp;&nbsp;else</P>
<P>/**<BR>&nbsp;* for_each_pwq - iterate through all pool_workqueues of the specified workqueue<BR>&nbsp;* @pwq: iteration cursor<BR>&nbsp;* @wq: the target workqueue<BR>&nbsp;*<BR>&nbsp;* This must be called either with wq-&gt;mutex held or sched RCU read locked.<BR>&nbsp;* If the pwq needs to be used beyond the locking in effect, the caller is<BR>&nbsp;* responsible for guaranteeing that the pwq stays online.<BR>&nbsp;*<BR>&nbsp;* The if/else clause exists only for the lockdep assertion and can be<BR>&nbsp;* ignored.<BR>&nbsp;*/<BR>#define for_each_pwq(pwq, wq)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;list_for_each_entry_rcu((pwq), &amp;(wq)-&gt;pwqs, pwqs_node)&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (({ assert_rcu_or_wq_mutex(wq); false; })) { }&nbsp;\<BR>&nbsp;&nbsp;else</P>
<P>#ifdef CONFIG_DEBUG_OBJECTS_WORK</P>
<P>static struct debug_obj_descr work_debug_descr;</P>
<P>static void *work_debug_hint(void *addr)<BR>{<BR>&nbsp;return ((struct work_struct *) addr)-&gt;func;<BR>}</P>
<P>/*<BR>&nbsp;* fixup_init is called when:<BR>&nbsp;* - an active object is initialized<BR>&nbsp;*/<BR>static int work_fixup_init(void *addr, enum debug_obj_state state)<BR>{<BR>&nbsp;struct work_struct *work = addr;</P>
<P>&nbsp;switch (state) {<BR>&nbsp;case ODEBUG_STATE_ACTIVE:<BR>&nbsp;&nbsp;cancel_work_sync(work);<BR>&nbsp;&nbsp;debug_object_init(work, &amp;work_debug_descr);<BR>&nbsp;&nbsp;return 1;<BR>&nbsp;default:<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}<BR>}</P>
<P>/*<BR>&nbsp;* fixup_activate is called when:<BR>&nbsp;* - an active object is activated<BR>&nbsp;* - an unknown object is activated (might be a statically initialized object)<BR>&nbsp;*/<BR>static int work_fixup_activate(void *addr, enum debug_obj_state state)<BR>{<BR>&nbsp;struct work_struct *work = addr;</P>
<P>&nbsp;switch (state) {</P>
<P>&nbsp;case ODEBUG_STATE_NOTAVAILABLE:<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * This is not really a fixup. The work struct was<BR>&nbsp;&nbsp; * statically initialized. We just make sure that it<BR>&nbsp;&nbsp; * is tracked in the object tracker.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (test_bit(WORK_STRUCT_STATIC_BIT, work_data_bits(work))) {<BR>&nbsp;&nbsp;&nbsp;debug_object_init(work, &amp;work_debug_descr);<BR>&nbsp;&nbsp;&nbsp;debug_object_activate(work, &amp;work_debug_descr);<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;WARN_ON_ONCE(1);<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;case ODEBUG_STATE_ACTIVE:<BR>&nbsp;&nbsp;WARN_ON(1);</P>
<P>&nbsp;default:<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}<BR>}</P>
<P>/*<BR>&nbsp;* fixup_free is called when:<BR>&nbsp;* - an active object is freed<BR>&nbsp;*/<BR>static int work_fixup_free(void *addr, enum debug_obj_state state)<BR>{<BR>&nbsp;struct work_struct *work = addr;</P>
<P>&nbsp;switch (state) {<BR>&nbsp;case ODEBUG_STATE_ACTIVE:<BR>&nbsp;&nbsp;cancel_work_sync(work);<BR>&nbsp;&nbsp;debug_object_free(work, &amp;work_debug_descr);<BR>&nbsp;&nbsp;return 1;<BR>&nbsp;default:<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}<BR>}</P>
<P>static struct debug_obj_descr work_debug_descr = {<BR>&nbsp;.name&nbsp;&nbsp;= "work_struct",<BR>&nbsp;.debug_hint&nbsp;= work_debug_hint,<BR>&nbsp;.fixup_init&nbsp;= work_fixup_init,<BR>&nbsp;.fixup_activate&nbsp;= work_fixup_activate,<BR>&nbsp;.fixup_free&nbsp;= work_fixup_free,<BR>};</P>
<P>static inline void debug_work_activate(struct work_struct *work)<BR>{<BR>&nbsp;debug_object_activate(work, &amp;work_debug_descr);<BR>}</P>
<P>static inline void debug_work_deactivate(struct work_struct *work)<BR>{<BR>&nbsp;debug_object_deactivate(work, &amp;work_debug_descr);<BR>}</P>
<P>void __init_work(struct work_struct *work, int onstack)<BR>{<BR>&nbsp;if (onstack)<BR>&nbsp;&nbsp;debug_object_init_on_stack(work, &amp;work_debug_descr);<BR>&nbsp;else<BR>&nbsp;&nbsp;debug_object_init(work, &amp;work_debug_descr);<BR>}<BR>EXPORT_SYMBOL_GPL(__init_work);</P>
<P>void destroy_work_on_stack(struct work_struct *work)<BR>{<BR>&nbsp;debug_object_free(work, &amp;work_debug_descr);<BR>}<BR>EXPORT_SYMBOL_GPL(destroy_work_on_stack);</P>
<P>void destroy_delayed_work_on_stack(struct delayed_work *work)<BR>{<BR>&nbsp;destroy_timer_on_stack(&amp;work-&gt;timer);<BR>&nbsp;debug_object_free(&amp;work-&gt;work, &amp;work_debug_descr);<BR>}<BR>EXPORT_SYMBOL_GPL(destroy_delayed_work_on_stack);</P>
<P>#else<BR>static inline void debug_work_activate(struct work_struct *work) { }<BR>static inline void debug_work_deactivate(struct work_struct *work) { }<BR>#endif</P>
<P>/**<BR>&nbsp;* worker_pool_assign_id - allocate ID and assing it to @pool<BR>&nbsp;* @pool: the pool pointer of interest<BR>&nbsp;*<BR>&nbsp;* Returns 0 if ID in [0, WORK_OFFQ_POOL_NONE) is allocated and assigned<BR>&nbsp;* successfully, -errno on failure.<BR>&nbsp;*/<BR>static int worker_pool_assign_id(struct worker_pool *pool)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</P>
<P>&nbsp;ret = idr_alloc(&amp;worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,<BR>&nbsp;&nbsp;&nbsp;GFP_KERNEL);<BR>&nbsp;if (ret &gt;= 0) {<BR>&nbsp;&nbsp;pool-&gt;id = ret;<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;* unbound_pwq_by_node - return the unbound pool_workqueue for the given node<BR>&nbsp;* @wq: the target workqueue<BR>&nbsp;* @node: the node ID<BR>&nbsp;*<BR>&nbsp;* This must be called with any of wq_pool_mutex, wq-&gt;mutex or sched RCU<BR>&nbsp;* read locked.<BR>&nbsp;* If the pwq needs to be used beyond the locking in effect, the caller is<BR>&nbsp;* responsible for guaranteeing that the pwq stays online.<BR>&nbsp;*<BR>&nbsp;* Return: The unbound pool_workqueue for @node.<BR>&nbsp;*/<BR>static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int node)<BR>{<BR>&nbsp;assert_rcu_or_wq_mutex_or_pool_mutex(wq);<BR>&nbsp;return rcu_dereference_raw(wq-&gt;numa_pwq_tbl[node]);<BR>}</P>
<P>static unsigned int work_color_to_flags(int color)<BR>{<BR>&nbsp;return color &lt;&lt; WORK_STRUCT_COLOR_SHIFT;<BR>}</P>
<P>static int get_work_color(struct work_struct *work)<BR>{<BR>&nbsp;return (*work_data_bits(work) &gt;&gt; WORK_STRUCT_COLOR_SHIFT) &amp;<BR>&nbsp;&nbsp;((1 &lt;&lt; WORK_STRUCT_COLOR_BITS) - 1);<BR>}</P>
<P>static int work_next_color(int color)<BR>{<BR>&nbsp;return (color + 1) % WORK_NR_COLORS;<BR>}</P>
<P>/*<BR>&nbsp;* While queued, %WORK_STRUCT_PWQ is set and non flag bits of a work's data<BR>&nbsp;* contain the pointer to the queued pwq.&nbsp; Once execution starts, the flag<BR>&nbsp;* is cleared and the high bits contain OFFQ flags and pool ID.<BR>&nbsp;*<BR>&nbsp;* set_work_pwq(), set_work_pool_and_clear_pending(), mark_work_canceling()<BR>&nbsp;* and clear_work_data() can be used to set the pwq, pool or clear<BR>&nbsp;* work-&gt;data.&nbsp; These functions should only be called while the work is<BR>&nbsp;* owned - ie. while the PENDING bit is set.<BR>&nbsp;*<BR>&nbsp;* get_work_pool() and get_work_pwq() can be used to obtain the pool or pwq<BR>&nbsp;* corresponding to a work.&nbsp; Pool is available once the work has been<BR>&nbsp;* queued anywhere after initialization until it is sync canceled.&nbsp; pwq is<BR>&nbsp;* available only while the work item is queued.<BR>&nbsp;*<BR>&nbsp;* %WORK_OFFQ_CANCELING is used to mark a work item which is being<BR>&nbsp;* canceled.&nbsp; While being canceled, a work item may have its PENDING set<BR>&nbsp;* but stay off timer and worklist for arbitrarily long and nobody should<BR>&nbsp;* try to steal the PENDING bit.<BR>&nbsp;*/<BR>static inline void set_work_data(struct work_struct *work, unsigned long data,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long flags)<BR>{<BR>&nbsp;WARN_ON_ONCE(!work_pending(work));<BR>&nbsp;atomic_long_set(&amp;work-&gt;data, data | flags | work_static(work));<BR>}</P>
<P>static void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,<BR>&nbsp;&nbsp;&nbsp; unsigned long extra_flags)<BR>{<BR>&nbsp;set_work_data(work, (unsigned long)pwq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);<BR>}</P>
<P>static void set_work_pool_and_keep_pending(struct work_struct *work,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pool_id)<BR>{<BR>&nbsp;set_work_data(work, (unsigned long)pool_id &lt;&lt; WORK_OFFQ_POOL_SHIFT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORK_STRUCT_PENDING);<BR>}</P>
<P>static void set_work_pool_and_clear_pending(struct work_struct *work,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pool_id)<BR>{<BR>&nbsp;/*<BR>&nbsp; * The following wmb is paired with the implied mb in<BR>&nbsp; * test_and_set_bit(PENDING) and ensures all updates to @work made<BR>&nbsp; * here are visible to and precede any updates by the next PENDING<BR>&nbsp; * owner.<BR>&nbsp; */<BR>&nbsp;smp_wmb();<BR>&nbsp;set_work_data(work, (unsigned long)pool_id &lt;&lt; WORK_OFFQ_POOL_SHIFT, 0);<BR>}</P>
<P>static void clear_work_data(struct work_struct *work)<BR>{<BR>&nbsp;smp_wmb();&nbsp;/* see set_work_pool_and_clear_pending() */<BR>&nbsp;set_work_data(work, WORK_STRUCT_NO_POOL, 0);<BR>}</P>
<P>static struct pool_workqueue *get_work_pwq(struct work_struct *work)<BR>{<BR>&nbsp;unsigned long data = atomic_long_read(&amp;work-&gt;data);</P>
<P>&nbsp;if (data &amp; WORK_STRUCT_PWQ)<BR>&nbsp;&nbsp;return (void *)(data &amp; WORK_STRUCT_WQ_DATA_MASK);<BR>&nbsp;else<BR>&nbsp;&nbsp;return NULL;<BR>}</P>
<P>/**<BR>&nbsp;* get_work_pool - return the worker_pool a given work was associated with<BR>&nbsp;* @work: the work item of interest<BR>&nbsp;*<BR>&nbsp;* Pools are created and destroyed under wq_pool_mutex, and allows read<BR>&nbsp;* access under sched-RCU read lock.&nbsp; As such, this function should be<BR>&nbsp;* called under wq_pool_mutex or with preemption disabled.<BR>&nbsp;*<BR>&nbsp;* All fields of the returned pool are accessible as long as the above<BR>&nbsp;* mentioned locking is in effect.&nbsp; If the returned pool needs to be used<BR>&nbsp;* beyond the critical section, the caller is responsible for ensuring the<BR>&nbsp;* returned pool is and stays online.<BR>&nbsp;*<BR>&nbsp;* Return: The worker_pool @work was last associated with.&nbsp; %NULL if none.<BR>&nbsp;*/<BR>static struct worker_pool *get_work_pool(struct work_struct *work)<BR>{<BR>&nbsp;unsigned long data = atomic_long_read(&amp;work-&gt;data);<BR>&nbsp;int pool_id;</P>
<P>&nbsp;assert_rcu_or_pool_mutex();</P>
<P>&nbsp;if (data &amp; WORK_STRUCT_PWQ)<BR>&nbsp;&nbsp;return ((struct pool_workqueue *)<BR>&nbsp;&nbsp;&nbsp;(data &amp; WORK_STRUCT_WQ_DATA_MASK))-&gt;pool;</P>
<P>&nbsp;pool_id = data &gt;&gt; WORK_OFFQ_POOL_SHIFT;<BR>&nbsp;if (pool_id == WORK_OFFQ_POOL_NONE)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;return idr_find(&amp;worker_pool_idr, pool_id);<BR>}</P>
<P>/**<BR>&nbsp;* get_work_pool_id - return the worker pool ID a given work is associated with<BR>&nbsp;* @work: the work item of interest<BR>&nbsp;*<BR>&nbsp;* Return: The worker_pool ID @work was last associated with.<BR>&nbsp;* %WORK_OFFQ_POOL_NONE if none.<BR>&nbsp;*/<BR>static int get_work_pool_id(struct work_struct *work)<BR>{<BR>&nbsp;unsigned long data = atomic_long_read(&amp;work-&gt;data);</P>
<P>&nbsp;if (data &amp; WORK_STRUCT_PWQ)<BR>&nbsp;&nbsp;return ((struct pool_workqueue *)<BR>&nbsp;&nbsp;&nbsp;(data &amp; WORK_STRUCT_WQ_DATA_MASK))-&gt;pool-&gt;id;</P>
<P>&nbsp;return data &gt;&gt; WORK_OFFQ_POOL_SHIFT;<BR>}</P>
<P>static void mark_work_canceling(struct work_struct *work)<BR>{<BR>&nbsp;unsigned long pool_id = get_work_pool_id(work);</P>
<P>&nbsp;pool_id &lt;&lt;= WORK_OFFQ_POOL_SHIFT;<BR>&nbsp;set_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);<BR>}</P>
<P>static bool work_is_canceling(struct work_struct *work)<BR>{<BR>&nbsp;unsigned long data = atomic_long_read(&amp;work-&gt;data);</P>
<P>&nbsp;return !(data &amp; WORK_STRUCT_PWQ) &amp;&amp; (data &amp; WORK_OFFQ_CANCELING);<BR>}</P>
<P>/*<BR>&nbsp;* Policy functions.&nbsp; These define the policies on how the global worker<BR>&nbsp;* pools are managed.&nbsp; Unless noted otherwise, these functions assume that<BR>&nbsp;* they're being called with pool-&gt;lock held.<BR>&nbsp;*/</P>
<P>static bool __need_more_worker(struct worker_pool *pool)<BR>{<BR>&nbsp;return !atomic_read(&amp;pool-&gt;nr_running);<BR>}</P>
<P>/*<BR>&nbsp;* Need to wake up a worker?&nbsp; Called from anything but currently<BR>&nbsp;* running workers.<BR>&nbsp;*<BR>&nbsp;* Note that, because unbound workers never contribute to nr_running, this<BR>&nbsp;* function will always return %true for unbound pools as long as the<BR>&nbsp;* worklist isn't empty.<BR>&nbsp;*/<BR>static bool need_more_worker(struct worker_pool *pool)<BR>{<BR>&nbsp;return !list_empty(&amp;pool-&gt;worklist) &amp;&amp; __need_more_worker(pool);<BR>}</P>
<P>/* Can I start working?&nbsp; Called from busy but !running workers. */<BR>static bool may_start_working(struct worker_pool *pool)<BR>{<BR>&nbsp;return pool-&gt;nr_idle;<BR>}</P>
<P>/* Do I need to keep working?&nbsp; Called from currently running workers. */<BR>static bool keep_working(struct worker_pool *pool)<BR>{<BR>&nbsp;return !list_empty(&amp;pool-&gt;worklist) &amp;&amp;<BR>&nbsp;&nbsp;atomic_read(&amp;pool-&gt;nr_running) &lt;= 1;<BR>}</P>
<P>/* Do we need a new worker?&nbsp; Called from manager. */<BR>static bool need_to_create_worker(struct worker_pool *pool)<BR>{<BR>&nbsp;return need_more_worker(pool) &amp;&amp; !may_start_working(pool);<BR>}</P>
<P>/* Do we have too many workers and should some go away? */<BR>static bool too_many_workers(struct worker_pool *pool)<BR>{<BR>&nbsp;bool managing = mutex_is_locked(&amp;pool-&gt;manager_arb);<BR>&nbsp;int nr_idle = pool-&gt;nr_idle + managing; /* manager is considered idle */<BR>&nbsp;int nr_busy = pool-&gt;nr_workers - nr_idle;</P>
<P>&nbsp;return nr_idle &gt; 2 &amp;&amp; (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO &gt;= nr_busy;<BR>}</P>
<P>/*<BR>&nbsp;* Wake up functions.<BR>&nbsp;*/</P>
<P>/* Return the first idle worker.&nbsp; Safe with preemption disabled */<BR>static struct worker *first_idle_worker(struct worker_pool *pool)<BR>{<BR>&nbsp;if (unlikely(list_empty(&amp;pool-&gt;idle_list)))<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;return list_first_entry(&amp;pool-&gt;idle_list, struct worker, entry);<BR>}</P>
<P>/**<BR>&nbsp;* wake_up_worker - wake up an idle worker<BR>&nbsp;* @pool: worker pool to wake worker from<BR>&nbsp;*<BR>&nbsp;* Wake up the first idle worker of @pool.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void wake_up_worker(struct worker_pool *pool)<BR>{<BR>&nbsp;struct worker *worker = first_idle_worker(pool);</P>
<P>&nbsp;if (likely(worker))<BR>&nbsp;&nbsp;wake_up_process(worker-&gt;task);<BR>}</P>
<P>/**<BR>&nbsp;* wq_worker_waking_up - a worker is waking up<BR>&nbsp;* @task: task waking up<BR>&nbsp;* @cpu: CPU @task is waking up to<BR>&nbsp;*<BR>&nbsp;* This function is called during try_to_wake_up() when a worker is<BR>&nbsp;* being awoken.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(rq-&gt;lock)<BR>&nbsp;*/<BR>void wq_worker_waking_up(struct task_struct *task, int cpu)<BR>{<BR>&nbsp;struct worker *worker = kthread_data(task);</P>
<P>&nbsp;if (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) {<BR>&nbsp;&nbsp;WARN_ON_ONCE(worker-&gt;pool-&gt;cpu != cpu);<BR>&nbsp;&nbsp;atomic_inc(&amp;worker-&gt;pool-&gt;nr_running);<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* wq_worker_sleeping - a worker is going to sleep<BR>&nbsp;* @task: task going to sleep<BR>&nbsp;* @cpu: CPU in question, must be the current CPU number<BR>&nbsp;*<BR>&nbsp;* This function is called during schedule() when a busy worker is<BR>&nbsp;* going to sleep.&nbsp; Worker on the same cpu can be woken up by<BR>&nbsp;* returning pointer to its task.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(rq-&gt;lock)<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* Worker task on @cpu to wake up, %NULL if none.<BR>&nbsp;*/<BR>struct task_struct *wq_worker_sleeping(struct task_struct *task, int cpu)<BR>{<BR>&nbsp;struct worker *worker = kthread_data(task), *to_wakeup = NULL;<BR>&nbsp;struct worker_pool *pool;</P>
<P>&nbsp;/*<BR>&nbsp; * Rescuers, which may not have all the fields set up like normal<BR>&nbsp; * workers, also reach here, let's not access anything before<BR>&nbsp; * checking NOT_RUNNING.<BR>&nbsp; */<BR>&nbsp;if (worker-&gt;flags &amp; WORKER_NOT_RUNNING)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;pool = worker-&gt;pool;</P>
<P>&nbsp;/* this can only happen on the local cpu */<BR>&nbsp;if (WARN_ON_ONCE(cpu != raw_smp_processor_id() || pool-&gt;cpu != cpu))<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;/*<BR>&nbsp; * The counterpart of the following dec_and_test, implied mb,<BR>&nbsp; * worklist not empty test sequence is in insert_work().<BR>&nbsp; * Please read comment there.<BR>&nbsp; *<BR>&nbsp; * NOT_RUNNING is clear.&nbsp; This means that we're bound to and<BR>&nbsp; * running on the local cpu w/ rq lock held and preemption<BR>&nbsp; * disabled, which in turn means that none else could be<BR>&nbsp; * manipulating idle_list, so dereferencing idle_list without pool<BR>&nbsp; * lock is safe.<BR>&nbsp; */<BR>&nbsp;if (atomic_dec_and_test(&amp;pool-&gt;nr_running) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; !list_empty(&amp;pool-&gt;worklist))<BR>&nbsp;&nbsp;to_wakeup = first_idle_worker(pool);<BR>&nbsp;return to_wakeup ? to_wakeup-&gt;task : NULL;<BR>}</P>
<P>/**<BR>&nbsp;* worker_set_flags - set worker flags and adjust nr_running accordingly<BR>&nbsp;* @worker: self<BR>&nbsp;* @flags: flags to set<BR>&nbsp;*<BR>&nbsp;* Set @flags in @worker-&gt;flags and adjust nr_running accordingly.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock)<BR>&nbsp;*/<BR>static inline void worker_set_flags(struct worker *worker, unsigned int flags)<BR>{<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;</P>
<P>&nbsp;WARN_ON_ONCE(worker-&gt;task != current);</P>
<P>&nbsp;/* If transitioning into NOT_RUNNING, adjust nr_running. */<BR>&nbsp;if ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) {<BR>&nbsp;&nbsp;atomic_dec(&amp;pool-&gt;nr_running);<BR>&nbsp;}</P>
<P>&nbsp;worker-&gt;flags |= flags;<BR>}</P>
<P>/**<BR>&nbsp;* worker_clr_flags - clear worker flags and adjust nr_running accordingly<BR>&nbsp;* @worker: self<BR>&nbsp;* @flags: flags to clear<BR>&nbsp;*<BR>&nbsp;* Clear @flags in @worker-&gt;flags and adjust nr_running accordingly.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock)<BR>&nbsp;*/<BR>static inline void worker_clr_flags(struct worker *worker, unsigned int flags)<BR>{<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;<BR>&nbsp;unsigned int oflags = worker-&gt;flags;</P>
<P>&nbsp;WARN_ON_ONCE(worker-&gt;task != current);</P>
<P>&nbsp;worker-&gt;flags &amp;= ~flags;</P>
<P>&nbsp;/*<BR>&nbsp; * If transitioning out of NOT_RUNNING, increment nr_running.&nbsp; Note<BR>&nbsp; * that the nested NOT_RUNNING is not a noop.&nbsp; NOT_RUNNING is mask<BR>&nbsp; * of multiple flags, not a single flag.<BR>&nbsp; */<BR>&nbsp;if ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp; (oflags &amp; WORKER_NOT_RUNNING))<BR>&nbsp;&nbsp;if (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))<BR>&nbsp;&nbsp;&nbsp;atomic_inc(&amp;pool-&gt;nr_running);<BR>}</P>
<P>/**<BR>&nbsp;* find_worker_executing_work - find worker which is executing a work<BR>&nbsp;* @pool: pool of interest<BR>&nbsp;* @work: work to find worker for<BR>&nbsp;*<BR>&nbsp;* Find a worker which is executing @work on @pool by searching<BR>&nbsp;* @pool-&gt;busy_hash which is keyed by the address of @work.&nbsp; For a worker<BR>&nbsp;* to match, its current execution should match the address of @work and<BR>&nbsp;* its work function.&nbsp; This is to avoid unwanted dependency between<BR>&nbsp;* unrelated work executions through a work item being recycled while still<BR>&nbsp;* being executed.<BR>&nbsp;*<BR>&nbsp;* This is a bit tricky.&nbsp; A work item may be freed once its execution<BR>&nbsp;* starts and nothing prevents the freed area from being recycled for<BR>&nbsp;* another work item.&nbsp; If the same work item address ends up being reused<BR>&nbsp;* before the original execution finishes, workqueue will identify the<BR>&nbsp;* recycled work item as currently executing and make it wait until the<BR>&nbsp;* current execution finishes, introducing an unwanted dependency.<BR>&nbsp;*<BR>&nbsp;* This function checks the work item address and work function to avoid<BR>&nbsp;* false positives.&nbsp; Note that this isn't complete as one may construct a<BR>&nbsp;* work function which can introduce dependency onto itself through a<BR>&nbsp;* recycled work item.&nbsp; Well, if somebody wants to shoot oneself in the<BR>&nbsp;* foot that badly, there's only so much we can do, and if such deadlock<BR>&nbsp;* actually occurs, it should be easy to locate the culprit work function.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* Pointer to worker which is executing @work if found, %NULL<BR>&nbsp;* otherwise.<BR>&nbsp;*/<BR>static struct worker *find_worker_executing_work(struct worker_pool *pool,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct work_struct *work)<BR>{<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;hash_for_each_possible(pool-&gt;busy_hash, worker, hentry,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long)work)<BR>&nbsp;&nbsp;if (worker-&gt;current_work == work &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worker-&gt;current_func == work-&gt;func)<BR>&nbsp;&nbsp;&nbsp;return worker;</P>
<P>&nbsp;return NULL;<BR>}</P>
<P>/**<BR>&nbsp;* move_linked_works - move linked works to a list<BR>&nbsp;* @work: start of series of works to be scheduled<BR>&nbsp;* @head: target list to append @work to<BR>&nbsp;* @nextp: out parameter for nested worklist walking<BR>&nbsp;*<BR>&nbsp;* Schedule linked works starting from @work to @head.&nbsp; Work series to<BR>&nbsp;* be scheduled starts at @work and includes any consecutive work with<BR>&nbsp;* WORK_STRUCT_LINKED set in its predecessor.<BR>&nbsp;*<BR>&nbsp;* If @nextp is not NULL, it's updated to point to the next work of<BR>&nbsp;* the last scheduled work.&nbsp; This allows move_linked_works() to be<BR>&nbsp;* nested inside outer list_for_each_entry_safe().<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void move_linked_works(struct work_struct *work, struct list_head *head,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct work_struct **nextp)<BR>{<BR>&nbsp;struct work_struct *n;</P>
<P>&nbsp;/*<BR>&nbsp; * Linked worklist will always end before the end of the list,<BR>&nbsp; * use NULL for list head.<BR>&nbsp; */<BR>&nbsp;list_for_each_entry_safe_from(work, n, NULL, entry) {<BR>&nbsp;&nbsp;list_move_tail(&amp;work-&gt;entry, head);<BR>&nbsp;&nbsp;if (!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * If we're already inside safe list traversal and have moved<BR>&nbsp; * multiple works to the scheduled queue, the next position<BR>&nbsp; * needs to be updated.<BR>&nbsp; */<BR>&nbsp;if (nextp)<BR>&nbsp;&nbsp;*nextp = n;<BR>}</P>
<P>/**<BR>&nbsp;* get_pwq - get an extra reference on the specified pool_workqueue<BR>&nbsp;* @pwq: pool_workqueue to get<BR>&nbsp;*<BR>&nbsp;* Obtain an extra reference on @pwq.&nbsp; The caller should guarantee that<BR>&nbsp;* @pwq has positive refcnt and be holding the matching pool-&gt;lock.<BR>&nbsp;*/<BR>static void get_pwq(struct pool_workqueue *pwq)<BR>{<BR>&nbsp;lockdep_assert_held(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;WARN_ON_ONCE(pwq-&gt;refcnt &lt;= 0);<BR>&nbsp;pwq-&gt;refcnt++;<BR>}</P>
<P>/**<BR>&nbsp;* put_pwq - put a pool_workqueue reference<BR>&nbsp;* @pwq: pool_workqueue to put<BR>&nbsp;*<BR>&nbsp;* Drop a reference of @pwq.&nbsp; If its refcnt reaches zero, schedule its<BR>&nbsp;* destruction.&nbsp; The caller should be holding the matching pool-&gt;lock.<BR>&nbsp;*/<BR>static void put_pwq(struct pool_workqueue *pwq)<BR>{<BR>&nbsp;lockdep_assert_held(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;if (likely(--pwq-&gt;refcnt))<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (WARN_ON_ONCE(!(pwq-&gt;wq-&gt;flags &amp; WQ_UNBOUND)))<BR>&nbsp;&nbsp;return;<BR>&nbsp;/*<BR>&nbsp; * @pwq can't be released under pool-&gt;lock, bounce to<BR>&nbsp; * pwq_unbound_release_workfn().&nbsp; This never recurses on the same<BR>&nbsp; * pool-&gt;lock as this path is taken only for unbound workqueues and<BR>&nbsp; * the release work item is scheduled on a per-cpu workqueue.&nbsp; To<BR>&nbsp; * avoid lockdep warning, unbound pool-&gt;locks are given lockdep<BR>&nbsp; * subclass of 1 in get_unbound_pool().<BR>&nbsp; */<BR>&nbsp;schedule_work(&amp;pwq-&gt;unbound_release_work);<BR>}</P>
<P>/**<BR>&nbsp;* put_pwq_unlocked - put_pwq() with surrounding pool lock/unlock<BR>&nbsp;* @pwq: pool_workqueue to put (can be %NULL)<BR>&nbsp;*<BR>&nbsp;* put_pwq() with locking.&nbsp; This function also allows %NULL @pwq.<BR>&nbsp;*/<BR>static void put_pwq_unlocked(struct pool_workqueue *pwq)<BR>{<BR>&nbsp;if (pwq) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * As both pwqs and pools are sched-RCU protected, the<BR>&nbsp;&nbsp; * following lock operations are safe.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;spin_lock_irq(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;&nbsp;put_pwq(pwq);<BR>&nbsp;&nbsp;spin_unlock_irq(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;}<BR>}</P>
<P>static void pwq_activate_delayed_work(struct work_struct *work)<BR>{<BR>&nbsp;struct pool_workqueue *pwq = get_work_pwq(work);</P>
<P>&nbsp;trace_workqueue_activate_work(work);<BR>&nbsp;move_linked_works(work, &amp;pwq-&gt;pool-&gt;worklist, NULL);<BR>&nbsp;__clear_bit(WORK_STRUCT_DELAYED_BIT, work_data_bits(work));<BR>&nbsp;pwq-&gt;nr_active++;<BR>}</P>
<P>static void pwq_activate_first_delayed(struct pool_workqueue *pwq)<BR>{<BR>&nbsp;struct work_struct *work = list_first_entry(&amp;pwq-&gt;delayed_works,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct work_struct, entry);</P>
<P>&nbsp;pwq_activate_delayed_work(work);<BR>}</P>
<P>/**<BR>&nbsp;* pwq_dec_nr_in_flight - decrement pwq's nr_in_flight<BR>&nbsp;* @pwq: pwq of interest<BR>&nbsp;* @color: color of work which left the queue<BR>&nbsp;*<BR>&nbsp;* A work either has completed or is removed from pending queue,<BR>&nbsp;* decrement nr_in_flight of its pwq and handle workqueue flushing.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, int color)<BR>{<BR>&nbsp;/* uncolored work items don't participate in flushing or nr_active */<BR>&nbsp;if (color == WORK_NO_COLOR)<BR>&nbsp;&nbsp;goto out_put;</P>
<P>&nbsp;pwq-&gt;nr_in_flight[color]--;</P>
<P>&nbsp;pwq-&gt;nr_active--;<BR>&nbsp;if (!list_empty(&amp;pwq-&gt;delayed_works)) {<BR>&nbsp;&nbsp;/* one down, submit a delayed one */<BR>&nbsp;&nbsp;if (pwq-&gt;nr_active &lt; pwq-&gt;max_active)<BR>&nbsp;&nbsp;&nbsp;pwq_activate_first_delayed(pwq);<BR>&nbsp;}</P>
<P>&nbsp;/* is flush in progress and are we at the flushing tip? */<BR>&nbsp;if (likely(pwq-&gt;flush_color != color))<BR>&nbsp;&nbsp;goto out_put;</P>
<P>&nbsp;/* are there still in-flight works? */<BR>&nbsp;if (pwq-&gt;nr_in_flight[color])<BR>&nbsp;&nbsp;goto out_put;</P>
<P>&nbsp;/* this pwq is done, clear flush_color */<BR>&nbsp;pwq-&gt;flush_color = -1;</P>
<P>&nbsp;/*<BR>&nbsp; * If this was the last pwq, wake up the first flusher.&nbsp; It<BR>&nbsp; * will handle the rest.<BR>&nbsp; */<BR>&nbsp;if (atomic_dec_and_test(&amp;pwq-&gt;wq-&gt;nr_pwqs_to_flush))<BR>&nbsp;&nbsp;complete(&amp;pwq-&gt;wq-&gt;first_flusher-&gt;done);<BR>out_put:<BR>&nbsp;put_pwq(pwq);<BR>}</P>
<P>/**<BR>&nbsp;* try_to_grab_pending - steal work item from worklist and disable irq<BR>&nbsp;* @work: work item to steal<BR>&nbsp;* @is_dwork: @work is a delayed_work<BR>&nbsp;* @flags: place to store irq state<BR>&nbsp;*<BR>&nbsp;* Try to grab PENDING bit of @work.&nbsp; This function can handle @work in any<BR>&nbsp;* stable state - idle, on timer or on worklist.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;*&nbsp; 1&nbsp;&nbsp;if @work was pending and we successfully stole PENDING<BR>&nbsp;*&nbsp; 0&nbsp;&nbsp;if @work was idle and we claimed PENDING<BR>&nbsp;*&nbsp; -EAGAIN&nbsp;if PENDING couldn't be grabbed at the moment, safe to busy-retry<BR>&nbsp;*&nbsp; -ENOENT&nbsp;if someone else is canceling @work, this state may persist<BR>&nbsp;*&nbsp;&nbsp;for arbitrarily long<BR>&nbsp;*<BR>&nbsp;* Note:<BR>&nbsp;* On &gt;= 0 return, the caller owns @work's PENDING bit.&nbsp; To avoid getting<BR>&nbsp;* interrupted while holding PENDING and @work off queue, irq must be<BR>&nbsp;* disabled on entry.&nbsp; This, combined with delayed_work-&gt;timer being<BR>&nbsp;* irqsafe, ensures that we return -EAGAIN for finite short period of time.<BR>&nbsp;*<BR>&nbsp;* On successful return, &gt;= 0, irq is disabled and the caller is<BR>&nbsp;* responsible for releasing it using local_irq_restore(<A href="mailto:*@flags">*@flags</A>).<BR>&nbsp;*<BR>&nbsp;* This function is safe to call from any context including IRQ handler.<BR>&nbsp;*/<BR>static int try_to_grab_pending(struct work_struct *work, bool is_dwork,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *flags)<BR>{<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;struct pool_workqueue *pwq;</P>
<P>&nbsp;local_irq_save(*flags);</P>
<P>&nbsp;/* try to steal the timer if it exists */<BR>&nbsp;if (is_dwork) {<BR>&nbsp;&nbsp;struct delayed_work *dwork = to_delayed_work(work);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * dwork-&gt;timer is irqsafe.&nbsp; If del_timer() fails, it's<BR>&nbsp;&nbsp; * guaranteed that the timer is not queued anywhere and not<BR>&nbsp;&nbsp; * running on the local CPU.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (likely(del_timer(&amp;dwork-&gt;timer)))<BR>&nbsp;&nbsp;&nbsp;return 1;<BR>&nbsp;}</P>
<P>&nbsp;/* try to claim PENDING the normal way */<BR>&nbsp;if (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;/*<BR>&nbsp; * The queueing is in progress, or it is already queued. Try to<BR>&nbsp; * steal it from -&gt;worklist without clearing WORK_STRUCT_PENDING.<BR>&nbsp; */<BR>&nbsp;pool = get_work_pool(work);<BR>&nbsp;if (!pool)<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;spin_lock(&amp;pool-&gt;lock);<BR>&nbsp;/*<BR>&nbsp; * work-&gt;data is guaranteed to point to pwq only while the work<BR>&nbsp; * item is queued on pwq-&gt;wq, and both updating work-&gt;data to point<BR>&nbsp; * to pwq on queueing and to pool on dequeueing are done under<BR>&nbsp; * pwq-&gt;pool-&gt;lock.&nbsp; This in turn guarantees that, if work-&gt;data<BR>&nbsp; * points to pwq which is associated with a locked pool, the work<BR>&nbsp; * item is currently queued on that pool.<BR>&nbsp; */<BR>&nbsp;pwq = get_work_pwq(work);<BR>&nbsp;if (pwq &amp;&amp; pwq-&gt;pool == pool) {<BR>&nbsp;&nbsp;debug_work_deactivate(work);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * A delayed work item cannot be grabbed directly because<BR>&nbsp;&nbsp; * it might have linked NO_COLOR work items which, if left<BR>&nbsp;&nbsp; * on the delayed_list, will confuse pwq-&gt;nr_active<BR>&nbsp;&nbsp; * management later on and cause stall.&nbsp; Make sure the work<BR>&nbsp;&nbsp; * item is activated before grabbing.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (*work_data_bits(work) &amp; WORK_STRUCT_DELAYED)<BR>&nbsp;&nbsp;&nbsp;pwq_activate_delayed_work(work);</P>
<P>&nbsp;&nbsp;list_del_init(&amp;work-&gt;entry);<BR>&nbsp;&nbsp;pwq_dec_nr_in_flight(pwq, get_work_color(work));</P>
<P>&nbsp;&nbsp;/* work-&gt;data points to pwq iff queued, point to pool */<BR>&nbsp;&nbsp;set_work_pool_and_keep_pending(work, pool-&gt;id);</P>
<P>&nbsp;&nbsp;spin_unlock(&amp;pool-&gt;lock);<BR>&nbsp;&nbsp;return 1;<BR>&nbsp;}<BR>&nbsp;spin_unlock(&amp;pool-&gt;lock);<BR>fail:<BR>&nbsp;local_irq_restore(*flags);<BR>&nbsp;if (work_is_canceling(work))<BR>&nbsp;&nbsp;return -ENOENT;<BR>&nbsp;cpu_relax();<BR>&nbsp;return -EAGAIN;<BR>}</P>
<P>/**<BR>&nbsp;* insert_work - insert a work into a pool<BR>&nbsp;* @pwq: pwq @work belongs to<BR>&nbsp;* @work: work to insert<BR>&nbsp;* @head: insertion point<BR>&nbsp;* @extra_flags: extra WORK_STRUCT_* flags to set<BR>&nbsp;*<BR>&nbsp;* Insert @work which belongs to @pwq after @head.&nbsp; @extra_flags is or'd to<BR>&nbsp;* work_struct flags.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void insert_work(struct pool_workqueue *pwq, struct work_struct *work,<BR>&nbsp;&nbsp;&nbsp;struct list_head *head, unsigned int extra_flags)<BR>{<BR>&nbsp;struct worker_pool *pool = pwq-&gt;pool;</P>
<P>&nbsp;/* we own @work, set data and link */<BR>&nbsp;set_work_pwq(work, pwq, extra_flags);<BR>&nbsp;list_add_tail(&amp;work-&gt;entry, head);<BR>&nbsp;get_pwq(pwq);</P>
<P>&nbsp;/*<BR>&nbsp; * Ensure either wq_worker_sleeping() sees the above<BR>&nbsp; * list_add_tail() or we see zero nr_running to avoid workers lying<BR>&nbsp; * around lazily while there are works to be processed.<BR>&nbsp; */<BR>&nbsp;smp_mb();</P>
<P>&nbsp;if (__need_more_worker(pool))<BR>&nbsp;&nbsp;wake_up_worker(pool);<BR>}</P>
<P>/*<BR>&nbsp;* Test whether @work is being queued from another work executing on the<BR>&nbsp;* same workqueue.<BR>&nbsp;*/<BR>static bool is_chained_work(struct workqueue_struct *wq)<BR>{<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;worker = current_wq_worker();<BR>&nbsp;/*<BR>&nbsp; * Return %true iff I'm a worker execuing a work item on @wq.&nbsp; If<BR>&nbsp; * I'm @worker, it's safe to dereference it without locking.<BR>&nbsp; */<BR>&nbsp;return worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq;<BR>}</P>
<P>static void __queue_work(int cpu, struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp; struct work_struct *work)<BR>{<BR>&nbsp;struct pool_workqueue *pwq;<BR>&nbsp;struct worker_pool *last_pool;<BR>&nbsp;struct list_head *worklist;<BR>&nbsp;unsigned int work_flags;<BR>&nbsp;unsigned int req_cpu = cpu;</P>
<P>&nbsp;/*<BR>&nbsp; * While a work item is PENDING &amp;&amp; off queue, a task trying to<BR>&nbsp; * steal the PENDING will busy-loop waiting for it to either get<BR>&nbsp; * queued or lose PENDING.&nbsp; Grabbing PENDING and queueing should<BR>&nbsp; * happen with IRQ disabled.<BR>&nbsp; */<BR>&nbsp;WARN_ON_ONCE(!irqs_disabled());</P>
<P>&nbsp;debug_work_activate(work);</P>
<P>&nbsp;/* if draining, only works from the same workqueue are allowed */<BR>&nbsp;if (unlikely(wq-&gt;flags &amp; __WQ_DRAINING) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON_ONCE(!is_chained_work(wq)))<BR>&nbsp;&nbsp;return;<BR>retry:<BR>&nbsp;if (req_cpu == WORK_CPU_UNBOUND)<BR>&nbsp;&nbsp;cpu = raw_smp_processor_id();</P>
<P>&nbsp;/* pwq which will be used unless @work is executing elsewhere */<BR>&nbsp;if (!(wq-&gt;flags &amp; WQ_UNBOUND))<BR>&nbsp;&nbsp;pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);<BR>&nbsp;else<BR>&nbsp;&nbsp;pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</P>
<P>&nbsp;/*<BR>&nbsp; * If @work was previously on a different pool, it might still be<BR>&nbsp; * running there, in which case the work needs to be queued on that<BR>&nbsp; * pool to guarantee non-reentrancy.<BR>&nbsp; */<BR>&nbsp;last_pool = get_work_pool(work);<BR>&nbsp;if (last_pool &amp;&amp; last_pool != pwq-&gt;pool) {<BR>&nbsp;&nbsp;struct worker *worker;</P>
<P>&nbsp;&nbsp;spin_lock(&amp;last_pool-&gt;lock);</P>
<P>&nbsp;&nbsp;worker = find_worker_executing_work(last_pool, work);</P>
<P>&nbsp;&nbsp;if (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) {<BR>&nbsp;&nbsp;&nbsp;pwq = worker-&gt;current_pwq;<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;/* meh... not running there, queue here */<BR>&nbsp;&nbsp;&nbsp;spin_unlock(&amp;last_pool-&gt;lock);<BR>&nbsp;&nbsp;&nbsp;spin_lock(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;&nbsp;}<BR>&nbsp;} else {<BR>&nbsp;&nbsp;spin_lock(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * pwq is determined and locked.&nbsp; For unbound pools, we could have<BR>&nbsp; * raced with pwq release and it could already be dead.&nbsp; If its<BR>&nbsp; * refcnt is zero, repeat pwq selection.&nbsp; Note that pwqs never die<BR>&nbsp; * without another pwq replacing it in the numa_pwq_tbl or while<BR>&nbsp; * work items are executing on it, so the retrying is guaranteed to<BR>&nbsp; * make forward-progress.<BR>&nbsp; */<BR>&nbsp;if (unlikely(!pwq-&gt;refcnt)) {<BR>&nbsp;&nbsp;if (wq-&gt;flags &amp; WQ_UNBOUND) {<BR>&nbsp;&nbsp;&nbsp;spin_unlock(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;&nbsp;&nbsp;cpu_relax();<BR>&nbsp;&nbsp;&nbsp;goto retry;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;/* oops */<BR>&nbsp;&nbsp;WARN_ONCE(true, "workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt",<BR>&nbsp;&nbsp;&nbsp;&nbsp; wq-&gt;name, cpu);<BR>&nbsp;}</P>
<P>&nbsp;/* pwq determined, queue */<BR>&nbsp;trace_workqueue_queue_work(req_cpu, pwq, work);</P>
<P>&nbsp;if (WARN_ON(!list_empty(&amp;work-&gt;entry))) {<BR>&nbsp;&nbsp;spin_unlock(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;&nbsp;return;<BR>&nbsp;}</P>
<P>&nbsp;pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;<BR>&nbsp;work_flags = work_color_to_flags(pwq-&gt;work_color);</P>
<P>&nbsp;if (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) {<BR>&nbsp;&nbsp;trace_workqueue_activate_work(work);<BR>&nbsp;&nbsp;pwq-&gt;nr_active++;<BR>&nbsp;&nbsp;worklist = &amp;pwq-&gt;pool-&gt;worklist;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;work_flags |= WORK_STRUCT_DELAYED;<BR>&nbsp;&nbsp;worklist = &amp;pwq-&gt;delayed_works;<BR>&nbsp;}</P>
<P>&nbsp;insert_work(pwq, work, worklist, work_flags);</P>
<P>&nbsp;spin_unlock(&amp;pwq-&gt;pool-&gt;lock);<BR>}</P>
<P>/**<BR>&nbsp;* queue_work_on - queue work on specific cpu<BR>&nbsp;* @cpu: CPU number to execute work on<BR>&nbsp;* @wq: workqueue to use<BR>&nbsp;* @work: work to queue<BR>&nbsp;*<BR>&nbsp;* We queue the work to a specific CPU, the caller must ensure it<BR>&nbsp;* can't go away.<BR>&nbsp;*<BR>&nbsp;* Return: %false if @work was already on a queue, %true otherwise.<BR>&nbsp;*/<BR>bool queue_work_on(int cpu, struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct work_struct *work)<BR>{<BR>&nbsp;bool ret = false;<BR>&nbsp;unsigned long flags;</P>
<P>&nbsp;local_irq_save(flags);</P>
<P>&nbsp;if (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {<BR>&nbsp;&nbsp;__queue_work(cpu, wq, work);<BR>&nbsp;&nbsp;ret = true;<BR>&nbsp;}</P>
<P>&nbsp;local_irq_restore(flags);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(queue_work_on);</P>
<P>void delayed_work_timer_fn(unsigned long __data)<BR>{<BR>&nbsp;struct delayed_work *dwork = (struct delayed_work *)__data;</P>
<P>&nbsp;/* should have been called from irqsafe timer with irq already off */<BR>&nbsp;__queue_work(dwork-&gt;cpu, dwork-&gt;wq, &amp;dwork-&gt;work);<BR>}<BR>EXPORT_SYMBOL(delayed_work_timer_fn);</P>
<P>static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct delayed_work *dwork, unsigned long delay)<BR>{<BR>&nbsp;struct timer_list *timer = &amp;dwork-&gt;timer;<BR>&nbsp;struct work_struct *work = &amp;dwork-&gt;work;</P>
<P>&nbsp;WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer-&gt;data != (unsigned long)dwork);<BR>&nbsp;WARN_ON_ONCE(timer_pending(timer));<BR>&nbsp;WARN_ON_ONCE(!list_empty(&amp;work-&gt;entry));</P>
<P>&nbsp;/*<BR>&nbsp; * If @delay is 0, queue @dwork-&gt;work immediately.&nbsp; This is for<BR>&nbsp; * both optimization and correctness.&nbsp; The earliest @timer can<BR>&nbsp; * expire is on the closest next tick and delayed_work users depend<BR>&nbsp; * on that there's no such delay when @delay is 0.<BR>&nbsp; */<BR>&nbsp;if (!delay) {<BR>&nbsp;&nbsp;__queue_work(cpu, wq, &amp;dwork-&gt;work);<BR>&nbsp;&nbsp;return;<BR>&nbsp;}</P>
<P>&nbsp;timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);</P>
<P>&nbsp;dwork-&gt;wq = wq;<BR>&nbsp;dwork-&gt;cpu = cpu;<BR>&nbsp;timer-&gt;expires = jiffies + delay;</P>
<P>&nbsp;if (unlikely(cpu != WORK_CPU_UNBOUND))<BR>&nbsp;&nbsp;add_timer_on(timer, cpu);<BR>&nbsp;else<BR>&nbsp;&nbsp;add_timer(timer);<BR>}</P>
<P>/**<BR>&nbsp;* queue_delayed_work_on - queue work on specific CPU after delay<BR>&nbsp;* @cpu: CPU number to execute work on<BR>&nbsp;* @wq: workqueue to use<BR>&nbsp;* @dwork: work to queue<BR>&nbsp;* @delay: number of jiffies to wait before queueing<BR>&nbsp;*<BR>&nbsp;* Return: %false if @work was already on a queue, %true otherwise.&nbsp; If<BR>&nbsp;* @delay is zero and @dwork is idle, it will be scheduled for immediate<BR>&nbsp;* execution.<BR>&nbsp;*/<BR>bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct delayed_work *dwork, unsigned long delay)<BR>{<BR>&nbsp;struct work_struct *work = &amp;dwork-&gt;work;<BR>&nbsp;bool ret = false;<BR>&nbsp;unsigned long flags;</P>
<P>&nbsp;/* read the comment in __queue_work() */<BR>&nbsp;local_irq_save(flags);</P>
<P>&nbsp;if (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {<BR>&nbsp;&nbsp;__queue_delayed_work(cpu, wq, dwork, delay);<BR>&nbsp;&nbsp;ret = true;<BR>&nbsp;}</P>
<P>&nbsp;local_irq_restore(flags);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(queue_delayed_work_on);</P>
<P>/**<BR>&nbsp;* mod_delayed_work_on - modify delay of or queue a delayed work on specific CPU<BR>&nbsp;* @cpu: CPU number to execute work on<BR>&nbsp;* @wq: workqueue to use<BR>&nbsp;* @dwork: work to queue<BR>&nbsp;* @delay: number of jiffies to wait before queueing<BR>&nbsp;*<BR>&nbsp;* If @dwork is idle, equivalent to queue_delayed_work_on(); otherwise,<BR>&nbsp;* modify @dwork's timer so that it expires after @delay.&nbsp; If @delay is<BR>&nbsp;* zero, @work is guaranteed to be scheduled immediately regardless of its<BR>&nbsp;* current state.<BR>&nbsp;*<BR>&nbsp;* Return: %false if @dwork was idle and queued, %true if @dwork was<BR>&nbsp;* pending and its timer was modified.<BR>&nbsp;*<BR>&nbsp;* This function is safe to call from any context including IRQ handler.<BR>&nbsp;* See try_to_grab_pending() for details.<BR>&nbsp;*/<BR>bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp; struct delayed_work *dwork, unsigned long delay)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret;</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;ret = try_to_grab_pending(&amp;dwork-&gt;work, true, &amp;flags);<BR>&nbsp;} while (unlikely(ret == -EAGAIN));</P>
<P>&nbsp;if (likely(ret &gt;= 0)) {<BR>&nbsp;&nbsp;__queue_delayed_work(cpu, wq, dwork, delay);<BR>&nbsp;&nbsp;local_irq_restore(flags);<BR>&nbsp;}</P>
<P>&nbsp;/* -ENOENT from try_to_grab_pending() becomes %true */<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(mod_delayed_work_on);</P>
<P>/**<BR>&nbsp;* worker_enter_idle - enter idle state<BR>&nbsp;* @worker: worker which is entering idle state<BR>&nbsp;*<BR>&nbsp;* @worker is entering idle state.&nbsp; Update stats and idle timer if<BR>&nbsp;* necessary.<BR>&nbsp;*<BR>&nbsp;* LOCKING:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void worker_enter_idle(struct worker *worker)<BR>{<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;</P>
<P>&nbsp;if (WARN_ON_ONCE(worker-&gt;flags &amp; WORKER_IDLE) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp; (worker-&gt;hentry.next || worker-&gt;hentry.pprev)))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* can't use worker_set_flags(), also called from create_worker() */<BR>&nbsp;worker-&gt;flags |= WORKER_IDLE;<BR>&nbsp;pool-&gt;nr_idle++;<BR>&nbsp;worker-&gt;last_active = jiffies;</P>
<P>&nbsp;/* idle_list is LIFO */<BR>&nbsp;list_add(&amp;worker-&gt;entry, &amp;pool-&gt;idle_list);</P>
<P>&nbsp;if (too_many_workers(pool) &amp;&amp; !timer_pending(&amp;pool-&gt;idle_timer))<BR>&nbsp;&nbsp;mod_timer(&amp;pool-&gt;idle_timer, jiffies + IDLE_WORKER_TIMEOUT);</P>
<P>&nbsp;/*<BR>&nbsp; * Sanity check nr_running.&nbsp; Because wq_unbind_fn() releases<BR>&nbsp; * pool-&gt;lock between setting %WORKER_UNBOUND and zapping<BR>&nbsp; * nr_running, the warning may trigger spuriously.&nbsp; Check iff<BR>&nbsp; * unbind is not in progress.<BR>&nbsp; */<BR>&nbsp;WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool-&gt;nr_workers == pool-&gt;nr_idle &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_read(&amp;pool-&gt;nr_running));<BR>}</P>
<P>/**<BR>&nbsp;* worker_leave_idle - leave idle state<BR>&nbsp;* @worker: worker which is leaving idle state<BR>&nbsp;*<BR>&nbsp;* @worker is leaving idle state.&nbsp; Update stats.<BR>&nbsp;*<BR>&nbsp;* LOCKING:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void worker_leave_idle(struct worker *worker)<BR>{<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;</P>
<P>&nbsp;if (WARN_ON_ONCE(!(worker-&gt;flags &amp; WORKER_IDLE)))<BR>&nbsp;&nbsp;return;<BR>&nbsp;worker_clr_flags(worker, WORKER_IDLE);<BR>&nbsp;pool-&gt;nr_idle--;<BR>&nbsp;list_del_init(&amp;worker-&gt;entry);<BR>}</P>
<P>static struct worker *alloc_worker(int node)<BR>{<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;worker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);<BR>&nbsp;if (worker) {<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;worker-&gt;entry);<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;worker-&gt;scheduled);<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;worker-&gt;node);<BR>&nbsp;&nbsp;/* on creation a worker is in !idle &amp;&amp; prep state */<BR>&nbsp;&nbsp;worker-&gt;flags = WORKER_PREP;<BR>&nbsp;}<BR>&nbsp;return worker;<BR>}</P>
<P>/**<BR>&nbsp;* worker_attach_to_pool() - attach a worker to a pool<BR>&nbsp;* @worker: worker to be attached<BR>&nbsp;* @pool: the target pool<BR>&nbsp;*<BR>&nbsp;* Attach @worker to @pool.&nbsp; Once attached, the %WORKER_UNBOUND flag and<BR>&nbsp;* cpu-binding of @worker are kept coordinated with the pool across<BR>&nbsp;* cpu-[un]hotplugs.<BR>&nbsp;*/<BR>static void worker_attach_to_pool(struct worker *worker,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct worker_pool *pool)<BR>{<BR>&nbsp;mutex_lock(&amp;pool-&gt;attach_mutex);</P>
<P>&nbsp;/*<BR>&nbsp; * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any<BR>&nbsp; * online CPUs.&nbsp; It'll be re-applied when any of the CPUs come up.<BR>&nbsp; */<BR>&nbsp;set_cpus_allowed_ptr(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</P>
<P>&nbsp;/*<BR>&nbsp; * The pool-&gt;attach_mutex ensures %POOL_DISASSOCIATED remains<BR>&nbsp; * stable across this function.&nbsp; See the comments above the<BR>&nbsp; * flag definition for details.<BR>&nbsp; */<BR>&nbsp;if (pool-&gt;flags &amp; POOL_DISASSOCIATED)<BR>&nbsp;&nbsp;worker-&gt;flags |= WORKER_UNBOUND;</P>
<P>&nbsp;list_add_tail(&amp;worker-&gt;node, &amp;pool-&gt;workers);</P>
<P>&nbsp;mutex_unlock(&amp;pool-&gt;attach_mutex);<BR>}</P>
<P>/**<BR>&nbsp;* worker_detach_from_pool() - detach a worker from its pool<BR>&nbsp;* @worker: worker which is attached to its pool<BR>&nbsp;* @pool: the pool @worker is attached to<BR>&nbsp;*<BR>&nbsp;* Undo the attaching which had been done in worker_attach_to_pool().&nbsp; The<BR>&nbsp;* caller worker shouldn't access to the pool after detached except it has<BR>&nbsp;* other reference to the pool.<BR>&nbsp;*/<BR>static void worker_detach_from_pool(struct worker *worker,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct worker_pool *pool)<BR>{<BR>&nbsp;struct completion *detach_completion = NULL;</P>
<P>&nbsp;mutex_lock(&amp;pool-&gt;attach_mutex);<BR>&nbsp;list_del(&amp;worker-&gt;node);<BR>&nbsp;if (list_empty(&amp;pool-&gt;workers))<BR>&nbsp;&nbsp;detach_completion = pool-&gt;detach_completion;<BR>&nbsp;mutex_unlock(&amp;pool-&gt;attach_mutex);</P>
<P>&nbsp;/* clear leftover flags without pool-&gt;lock after it is detached */<BR>&nbsp;worker-&gt;flags &amp;= ~(WORKER_UNBOUND | WORKER_REBOUND);</P>
<P>&nbsp;if (detach_completion)<BR>&nbsp;&nbsp;complete(detach_completion);<BR>}</P>
<P>/**<BR>&nbsp;* create_worker - create a new workqueue worker<BR>&nbsp;* @pool: pool the new worker will belong to<BR>&nbsp;*<BR>&nbsp;* Create and start a new worker which is attached to @pool.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* Might sleep.&nbsp; Does GFP_KERNEL allocations.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* Pointer to the newly created worker.<BR>&nbsp;*/<BR>static struct worker *create_worker(struct worker_pool *pool)<BR>{<BR>&nbsp;struct worker *worker = NULL;<BR>&nbsp;int id = -1;<BR>&nbsp;char id_buf[16];</P>
<P>&nbsp;/* ID is needed to determine kthread name */<BR>&nbsp;id = ida_simple_get(&amp;pool-&gt;worker_ida, 0, 0, GFP_KERNEL);<BR>&nbsp;if (id &lt; 0)<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;worker = alloc_worker(pool-&gt;node);<BR>&nbsp;if (!worker)<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;worker-&gt;pool = pool;<BR>&nbsp;worker-&gt;id = id;</P>
<P>&nbsp;if (pool-&gt;cpu &gt;= 0)<BR>&nbsp;&nbsp;snprintf(id_buf, sizeof(id_buf), "%d:%d%s", pool-&gt;cpu, id,<BR>&nbsp;&nbsp;&nbsp; pool-&gt;attrs-&gt;nice &lt; 0&nbsp; ? "H" : "");<BR>&nbsp;else<BR>&nbsp;&nbsp;snprintf(id_buf, sizeof(id_buf), "u%d:%d", pool-&gt;id, id);</P>
<P>&nbsp;worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "kworker/%s", id_buf);<BR>&nbsp;if (IS_ERR(worker-&gt;task))<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</P>
<P>&nbsp;/* prevent userland from meddling with cpumask of workqueue workers */<BR>&nbsp;worker-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</P>
<P>&nbsp;/* successful, attach the worker to the pool */<BR>&nbsp;worker_attach_to_pool(worker, pool);</P>
<P>&nbsp;/* start the newly created worker */<BR>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);<BR>&nbsp;worker-&gt;pool-&gt;nr_workers++;<BR>&nbsp;worker_enter_idle(worker);<BR>&nbsp;wake_up_process(worker-&gt;task);<BR>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;return worker;</P>
<P>fail:<BR>&nbsp;if (id &gt;= 0)<BR>&nbsp;&nbsp;ida_simple_remove(&amp;pool-&gt;worker_ida, id);<BR>&nbsp;kfree(worker);<BR>&nbsp;return NULL;<BR>}</P>
<P>/**<BR>&nbsp;* destroy_worker - destroy a workqueue worker<BR>&nbsp;* @worker: worker to be destroyed<BR>&nbsp;*<BR>&nbsp;* Destroy @worker and adjust @pool stats accordingly.&nbsp; The worker should<BR>&nbsp;* be idle.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void destroy_worker(struct worker *worker)<BR>{<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;</P>
<P>&nbsp;lockdep_assert_held(&amp;pool-&gt;lock);</P>
<P>&nbsp;/* sanity check frenzy */<BR>&nbsp;if (WARN_ON(worker-&gt;current_work) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(!list_empty(&amp;worker-&gt;scheduled)) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(!(worker-&gt;flags &amp; WORKER_IDLE)))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;pool-&gt;nr_workers--;<BR>&nbsp;pool-&gt;nr_idle--;</P>
<P>&nbsp;list_del_init(&amp;worker-&gt;entry);<BR>&nbsp;worker-&gt;flags |= WORKER_DIE;<BR>&nbsp;wake_up_process(worker-&gt;task);<BR>}</P>
<P>static void idle_worker_timeout(unsigned long __pool)<BR>{<BR>&nbsp;struct worker_pool *pool = (void *)__pool;</P>
<P>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;while (too_many_workers(pool)) {<BR>&nbsp;&nbsp;struct worker *worker;<BR>&nbsp;&nbsp;unsigned long expires;</P>
<P>&nbsp;&nbsp;/* idle_list is kept in LIFO order, check the last one */<BR>&nbsp;&nbsp;worker = list_entry(pool-&gt;idle_list.prev, struct worker, entry);<BR>&nbsp;&nbsp;expires = worker-&gt;last_active + IDLE_WORKER_TIMEOUT;</P>
<P>&nbsp;&nbsp;if (time_before(jiffies, expires)) {<BR>&nbsp;&nbsp;&nbsp;mod_timer(&amp;pool-&gt;idle_timer, expires);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;destroy_worker(worker);<BR>&nbsp;}</P>
<P>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>}</P>
<P>static void send_mayday(struct work_struct *work)<BR>{<BR>&nbsp;struct pool_workqueue *pwq = get_work_pwq(work);<BR>&nbsp;struct workqueue_struct *wq = pwq-&gt;wq;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_mayday_lock);</P>
<P>&nbsp;if (!wq-&gt;rescuer)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* mayday mayday mayday */<BR>&nbsp;if (list_empty(&amp;pwq-&gt;mayday_node)) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * If @pwq is for an unbound wq, its base ref may be put at<BR>&nbsp;&nbsp; * any time due to an attribute change.&nbsp; Pin @pwq until the<BR>&nbsp;&nbsp; * rescuer is done with it.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;get_pwq(pwq);<BR>&nbsp;&nbsp;list_add_tail(&amp;pwq-&gt;mayday_node, &amp;wq-&gt;maydays);<BR>&nbsp;&nbsp;wake_up_process(wq-&gt;rescuer-&gt;task);<BR>&nbsp;}<BR>}</P>
<P>static void pool_mayday_timeout(unsigned long __pool)<BR>{<BR>&nbsp;struct worker_pool *pool = (void *)__pool;<BR>&nbsp;struct work_struct *work;</P>
<P>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);<BR>&nbsp;spin_lock(&amp;wq_mayday_lock);&nbsp;&nbsp;/* for wq-&gt;maydays */</P>
<P>&nbsp;if (need_to_create_worker(pool)) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * We've been trying to create a new worker but<BR>&nbsp;&nbsp; * haven't been successful.&nbsp; We might be hitting an<BR>&nbsp;&nbsp; * allocation deadlock.&nbsp; Send distress signals to<BR>&nbsp;&nbsp; * rescuers.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;list_for_each_entry(work, &amp;pool-&gt;worklist, entry)<BR>&nbsp;&nbsp;&nbsp;send_mayday(work);<BR>&nbsp;}</P>
<P>&nbsp;spin_unlock(&amp;wq_mayday_lock);<BR>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;mod_timer(&amp;pool-&gt;mayday_timer, jiffies + MAYDAY_INTERVAL);<BR>}</P>
<P>/**<BR>&nbsp;* maybe_create_worker - create a new worker if necessary<BR>&nbsp;* @pool: pool to create a new worker for<BR>&nbsp;*<BR>&nbsp;* Create a new worker for @pool if necessary.&nbsp; @pool is guaranteed to<BR>&nbsp;* have at least one idle worker on return from this function.&nbsp; If<BR>&nbsp;* creating a new worker takes longer than MAYDAY_INTERVAL, mayday is<BR>&nbsp;* sent to all rescuers with works scheduled on @pool to resolve<BR>&nbsp;* possible allocation deadlock.<BR>&nbsp;*<BR>&nbsp;* On return, need_to_create_worker() is guaranteed to be %false and<BR>&nbsp;* may_start_working() %true.<BR>&nbsp;*<BR>&nbsp;* LOCKING:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock) which may be released and regrabbed<BR>&nbsp;* multiple times.&nbsp; Does GFP_KERNEL allocations.&nbsp; Called only from<BR>&nbsp;* manager.<BR>&nbsp;*/<BR>static void maybe_create_worker(struct worker_pool *pool)<BR>__releases(&amp;pool-&gt;lock)<BR>__acquires(&amp;pool-&gt;lock)<BR>{<BR>restart:<BR>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */<BR>&nbsp;mod_timer(&amp;pool-&gt;mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);</P>
<P>&nbsp;while (true) {<BR>&nbsp;&nbsp;if (create_worker(pool) || !need_to_create_worker(pool))<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;schedule_timeout_interruptible(CREATE_COOLDOWN);</P>
<P>&nbsp;&nbsp;if (!need_to_create_worker(pool))<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;del_timer_sync(&amp;pool-&gt;mayday_timer);<BR>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);<BR>&nbsp;/*<BR>&nbsp; * This is necessary even after a new worker was just successfully<BR>&nbsp; * created as @pool-&gt;lock was dropped and the new worker might have<BR>&nbsp; * already become busy.<BR>&nbsp; */<BR>&nbsp;if (need_to_create_worker(pool))<BR>&nbsp;&nbsp;goto restart;<BR>}</P>
<P>/**<BR>&nbsp;* manage_workers - manage worker pool<BR>&nbsp;* @worker: self<BR>&nbsp;*<BR>&nbsp;* Assume the manager role and manage the worker pool @worker belongs<BR>&nbsp;* to.&nbsp; At any given time, there can be only zero or one manager per<BR>&nbsp;* pool.&nbsp; The exclusion is handled automatically by this function.<BR>&nbsp;*<BR>&nbsp;* The caller can safely start processing works on false return.&nbsp; On<BR>&nbsp;* true return, it's guaranteed that need_to_create_worker() is false<BR>&nbsp;* and may_start_working() is true.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock) which may be released and regrabbed<BR>&nbsp;* multiple times.&nbsp; Does GFP_KERNEL allocations.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %false if the pool doesn't need management and the caller can safely<BR>&nbsp;* start processing works, %true if management function was performed and<BR>&nbsp;* the conditions that the caller verified before calling the function may<BR>&nbsp;* no longer be true.<BR>&nbsp;*/<BR>static bool manage_workers(struct worker *worker)<BR>{<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;</P>
<P>&nbsp;/*<BR>&nbsp; * Anyone who successfully grabs manager_arb wins the arbitration<BR>&nbsp; * and becomes the manager.&nbsp; mutex_trylock() on pool-&gt;manager_arb<BR>&nbsp; * failure while holding pool-&gt;lock reliably indicates that someone<BR>&nbsp; * else is managing the pool and the worker which failed trylock<BR>&nbsp; * can proceed to executing work items.&nbsp; This means that anyone<BR>&nbsp; * grabbing manager_arb is responsible for actually performing<BR>&nbsp; * manager duties.&nbsp; If manager_arb is grabbed and released without<BR>&nbsp; * actual management, the pool may stall indefinitely.<BR>&nbsp; */<BR>&nbsp;if (!mutex_trylock(&amp;pool-&gt;manager_arb))<BR>&nbsp;&nbsp;return false;<BR>&nbsp;pool-&gt;manager = worker;</P>
<P>&nbsp;maybe_create_worker(pool);</P>
<P>&nbsp;pool-&gt;manager = NULL;<BR>&nbsp;mutex_unlock(&amp;pool-&gt;manager_arb);<BR>&nbsp;return true;<BR>}</P>
<P>/**<BR>&nbsp;* process_one_work - process single work<BR>&nbsp;* @worker: self<BR>&nbsp;* @work: work to process<BR>&nbsp;*<BR>&nbsp;* Process @work.&nbsp; This function contains all the logics necessary to<BR>&nbsp;* process a single work including synchronization against and<BR>&nbsp;* interaction with other workers on the same cpu, queueing and<BR>&nbsp;* flushing.&nbsp; As long as context requirement is met, any worker can<BR>&nbsp;* call this function to process a work.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock) which is released and regrabbed.<BR>&nbsp;*/<BR>static void process_one_work(struct worker *worker, struct work_struct *work)<BR>__releases(&amp;pool-&gt;lock)<BR>__acquires(&amp;pool-&gt;lock)<BR>{<BR>&nbsp;struct pool_workqueue *pwq = get_work_pwq(work);<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;<BR>&nbsp;bool cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;<BR>&nbsp;int work_color;<BR>&nbsp;struct worker *collision;<BR>#ifdef CONFIG_LOCKDEP<BR>&nbsp;/*<BR>&nbsp; * It is permissible to free the struct work_struct from<BR>&nbsp; * inside the function that is called from it, this we need to<BR>&nbsp; * take into account for lockdep too.&nbsp; To avoid bogus "held<BR>&nbsp; * lock freed" warnings as well as problems when looking into<BR>&nbsp; * work-&gt;lockdep_map, make a copy and use that here.<BR>&nbsp; */<BR>&nbsp;struct lockdep_map lockdep_map;</P>
<P>&nbsp;lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);<BR>#endif<BR>&nbsp;/* ensure we're on the correct CPU */<BR>&nbsp;WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_smp_processor_id() != pool-&gt;cpu);</P>
<P>&nbsp;/*<BR>&nbsp; * A single work shouldn't be executed concurrently by<BR>&nbsp; * multiple workers on a single cpu.&nbsp; Check whether anyone is<BR>&nbsp; * already processing the work.&nbsp; If so, defer the work to the<BR>&nbsp; * currently executing one.<BR>&nbsp; */<BR>&nbsp;collision = find_worker_executing_work(pool, work);<BR>&nbsp;if (unlikely(collision)) {<BR>&nbsp;&nbsp;move_linked_works(work, &amp;collision-&gt;scheduled, NULL);<BR>&nbsp;&nbsp;return;<BR>&nbsp;}</P>
<P>&nbsp;/* claim and dequeue */<BR>&nbsp;debug_work_deactivate(work);<BR>&nbsp;hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (unsigned long)work);<BR>&nbsp;worker-&gt;current_work = work;<BR>&nbsp;worker-&gt;current_func = work-&gt;func;<BR>&nbsp;worker-&gt;current_pwq = pwq;<BR>&nbsp;work_color = get_work_color(work);</P>
<P>&nbsp;list_del_init(&amp;work-&gt;entry);</P>
<P>&nbsp;/*<BR>&nbsp; * CPU intensive works don't participate in concurrency management.<BR>&nbsp; * They're the scheduler's responsibility.&nbsp; This takes @worker out<BR>&nbsp; * of concurrency management and the next code block will chain<BR>&nbsp; * execution of the pending work items.<BR>&nbsp; */<BR>&nbsp;if (unlikely(cpu_intensive))<BR>&nbsp;&nbsp;worker_set_flags(worker, WORKER_CPU_INTENSIVE);</P>
<P>&nbsp;/*<BR>&nbsp; * Wake up another worker if necessary.&nbsp; The condition is always<BR>&nbsp; * false for normal per-cpu workers since nr_running would always<BR>&nbsp; * be &gt;= 1 at this point.&nbsp; This is used to chain execution of the<BR>&nbsp; * pending work items for WORKER_NOT_RUNNING workers such as the<BR>&nbsp; * UNBOUND and CPU_INTENSIVE ones.<BR>&nbsp; */<BR>&nbsp;if (need_more_worker(pool))<BR>&nbsp;&nbsp;wake_up_worker(pool);</P>
<P>&nbsp;/*<BR>&nbsp; * Record the last pool and clear PENDING which should be the last<BR>&nbsp; * update to @work.&nbsp; Also, do this inside @pool-&gt;lock so that<BR>&nbsp; * PENDING and queued state changes happen together while IRQ is<BR>&nbsp; * disabled.<BR>&nbsp; */<BR>&nbsp;set_work_pool_and_clear_pending(work, pool-&gt;id);</P>
<P>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);<BR>&nbsp;lock_map_acquire(&amp;lockdep_map);<BR>&nbsp;trace_workqueue_execute_start(work);<BR>&nbsp;worker-&gt;current_func(work);<BR>&nbsp;/*<BR>&nbsp; * While we must be careful to not use "work" after this, the trace<BR>&nbsp; * point will only record its address.<BR>&nbsp; */<BR>&nbsp;trace_workqueue_execute_end(work);<BR>&nbsp;lock_map_release(&amp;lockdep_map);<BR>&nbsp;lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</P>
<P>&nbsp;if (unlikely(in_atomic() || lockdep_depth(current) &gt; 0)) {<BR>&nbsp;&nbsp;pr_err("BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp; last function: %pf\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current-&gt;comm, preempt_count(), task_pid_nr(current),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worker-&gt;current_func);<BR>&nbsp;&nbsp;debug_show_held_locks(current);<BR>&nbsp;&nbsp;dump_stack();<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * The following prevents a kworker from hogging CPU on !PREEMPT<BR>&nbsp; * kernels, where a requeueing work item waiting for something to<BR>&nbsp; * happen could deadlock with stop_machine as such work item could<BR>&nbsp; * indefinitely requeue itself while all other CPUs are trapped in<BR>&nbsp; * stop_machine. At the same time, report a quiescent RCU state so<BR>&nbsp; * the same condition doesn't freeze RCU.<BR>&nbsp; */<BR>&nbsp;cond_resched_rcu_qs();</P>
<P>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;/* clear cpu intensive status */<BR>&nbsp;if (unlikely(cpu_intensive))<BR>&nbsp;&nbsp;worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</P>
<P>&nbsp;/* we're done with it, release */<BR>&nbsp;hash_del(&amp;worker-&gt;hentry);<BR>&nbsp;worker-&gt;current_work = NULL;<BR>&nbsp;worker-&gt;current_func = NULL;<BR>&nbsp;worker-&gt;current_pwq = NULL;<BR>&nbsp;worker-&gt;desc_valid = false;<BR>&nbsp;pwq_dec_nr_in_flight(pwq, work_color);<BR>}</P>
<P>/**<BR>&nbsp;* process_scheduled_works - process scheduled works<BR>&nbsp;* @worker: self<BR>&nbsp;*<BR>&nbsp;* Process all scheduled works.&nbsp; Please note that the scheduled list<BR>&nbsp;* may change while processing a work, so this function repeatedly<BR>&nbsp;* fetches a work from the top and executes it.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock) which may be released and regrabbed<BR>&nbsp;* multiple times.<BR>&nbsp;*/<BR>static void process_scheduled_works(struct worker *worker)<BR>{<BR>&nbsp;while (!list_empty(&amp;worker-&gt;scheduled)) {<BR>&nbsp;&nbsp;struct work_struct *work = list_first_entry(&amp;worker-&gt;scheduled,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct work_struct, entry);<BR>&nbsp;&nbsp;process_one_work(worker, work);<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* worker_thread - the worker thread function<BR>&nbsp;* @__worker: self<BR>&nbsp;*<BR>&nbsp;* The worker thread function.&nbsp; All workers belong to a worker_pool -<BR>&nbsp;* either a per-cpu one or dynamic unbound one.&nbsp; These workers process all<BR>&nbsp;* work items regardless of their specific target workqueue.&nbsp; The only<BR>&nbsp;* exception is work items which belong to workqueues with a rescuer which<BR>&nbsp;* will be explained in rescuer_thread().<BR>&nbsp;*<BR>&nbsp;* Return: 0<BR>&nbsp;*/<BR>static int worker_thread(void *__worker)<BR>{<BR>&nbsp;struct worker *worker = __worker;<BR>&nbsp;struct worker_pool *pool = worker-&gt;pool;</P>
<P>&nbsp;/* tell the scheduler that this is a workqueue worker */<BR>&nbsp;worker-&gt;task-&gt;flags |= PF_WQ_WORKER;<BR>woke_up:<BR>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;/* am I supposed to die? */<BR>&nbsp;if (unlikely(worker-&gt;flags &amp; WORKER_DIE)) {<BR>&nbsp;&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>&nbsp;&nbsp;WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));<BR>&nbsp;&nbsp;worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</P>
<P>&nbsp;&nbsp;set_task_comm(worker-&gt;task, "kworker/dying");<BR>&nbsp;&nbsp;ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);<BR>&nbsp;&nbsp;worker_detach_from_pool(worker, pool);<BR>&nbsp;&nbsp;kfree(worker);<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>&nbsp;worker_leave_idle(worker);<BR>recheck:<BR>&nbsp;/* no more worker necessary? */<BR>&nbsp;if (!need_more_worker(pool))<BR>&nbsp;&nbsp;goto sleep;</P>
<P>&nbsp;/* do we need to manage? */<BR>&nbsp;if (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))<BR>&nbsp;&nbsp;goto recheck;</P>
<P>&nbsp;/*<BR>&nbsp; * -&gt;scheduled list can only be filled while a worker is<BR>&nbsp; * preparing to process a work or actually processing it.<BR>&nbsp; * Make sure nobody diddled with it while I was sleeping.<BR>&nbsp; */<BR>&nbsp;WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</P>
<P>&nbsp;/*<BR>&nbsp; * Finish PREP stage.&nbsp; We're guaranteed to have at least one idle<BR>&nbsp; * worker or that someone else has already assumed the manager<BR>&nbsp; * role.&nbsp; This is where @worker starts participating in concurrency<BR>&nbsp; * management if applicable and concurrency management is restored<BR>&nbsp; * after being rebound.&nbsp; See rebind_workers() for details.<BR>&nbsp; */<BR>&nbsp;worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;struct work_struct *work =<BR>&nbsp;&nbsp;&nbsp;list_first_entry(&amp;pool-&gt;worklist,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct work_struct, entry);</P>
<P>&nbsp;&nbsp;if (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) {<BR>&nbsp;&nbsp;&nbsp;/* optimization path, not strictly necessary */<BR>&nbsp;&nbsp;&nbsp;process_one_work(worker, work);<BR>&nbsp;&nbsp;&nbsp;if (unlikely(!list_empty(&amp;worker-&gt;scheduled)))<BR>&nbsp;&nbsp;&nbsp;&nbsp;process_scheduled_works(worker);<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;move_linked_works(work, &amp;worker-&gt;scheduled, NULL);<BR>&nbsp;&nbsp;&nbsp;process_scheduled_works(worker);<BR>&nbsp;&nbsp;}<BR>&nbsp;} while (keep_working(pool));</P>
<P>&nbsp;worker_set_flags(worker, WORKER_PREP);<BR>sleep:<BR>&nbsp;/*<BR>&nbsp; * pool-&gt;lock is held and there's no work to process and no need to<BR>&nbsp; * manage, sleep.&nbsp; Workers are woken up only while holding<BR>&nbsp; * pool-&gt;lock or from local cpu, so setting the current state<BR>&nbsp; * before releasing pool-&gt;lock is enough to prevent losing any<BR>&nbsp; * event.<BR>&nbsp; */<BR>&nbsp;worker_enter_idle(worker);<BR>&nbsp;__set_current_state(TASK_INTERRUPTIBLE);<BR>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>&nbsp;schedule();<BR>&nbsp;goto woke_up;<BR>}</P>
<P>/**<BR>&nbsp;* rescuer_thread - the rescuer thread function<BR>&nbsp;* @__rescuer: self<BR>&nbsp;*<BR>&nbsp;* Workqueue rescuer thread function.&nbsp; There's one rescuer for each<BR>&nbsp;* workqueue which has WQ_MEM_RECLAIM set.<BR>&nbsp;*<BR>&nbsp;* Regular work processing on a pool may block trying to create a new<BR>&nbsp;* worker which uses GFP_KERNEL allocation which has slight chance of<BR>&nbsp;* developing into deadlock if some works currently on the same queue<BR>&nbsp;* need to be processed to satisfy the GFP_KERNEL allocation.&nbsp; This is<BR>&nbsp;* the problem rescuer solves.<BR>&nbsp;*<BR>&nbsp;* When such condition is possible, the pool summons rescuers of all<BR>&nbsp;* workqueues which have works queued on the pool and let them process<BR>&nbsp;* those works so that forward progress can be guaranteed.<BR>&nbsp;*<BR>&nbsp;* This should happen rarely.<BR>&nbsp;*<BR>&nbsp;* Return: 0<BR>&nbsp;*/<BR>static int rescuer_thread(void *__rescuer)<BR>{<BR>&nbsp;struct worker *rescuer = __rescuer;<BR>&nbsp;struct workqueue_struct *wq = rescuer-&gt;rescue_wq;<BR>&nbsp;struct list_head *scheduled = &amp;rescuer-&gt;scheduled;<BR>&nbsp;bool should_stop;</P>
<P>&nbsp;set_user_nice(current, RESCUER_NICE_LEVEL);</P>
<P>&nbsp;/*<BR>&nbsp; * Mark rescuer as worker too.&nbsp; As WORKER_PREP is never cleared, it<BR>&nbsp; * doesn't participate in concurrency management.<BR>&nbsp; */<BR>&nbsp;rescuer-&gt;task-&gt;flags |= PF_WQ_WORKER;<BR>repeat:<BR>&nbsp;set_current_state(TASK_INTERRUPTIBLE);</P>
<P>&nbsp;/*<BR>&nbsp; * By the time the rescuer is requested to stop, the workqueue<BR>&nbsp; * shouldn't have any work pending, but @wq-&gt;maydays may still have<BR>&nbsp; * pwq(s) queued.&nbsp; This can happen by non-rescuer workers consuming<BR>&nbsp; * all the work items before the rescuer got to them.&nbsp; Go through<BR>&nbsp; * @wq-&gt;maydays processing before acting on should_stop so that the<BR>&nbsp; * list is always empty on exit.<BR>&nbsp; */<BR>&nbsp;should_stop = kthread_should_stop();</P>
<P>&nbsp;/* see whether any pwq is asking for help */<BR>&nbsp;spin_lock_irq(&amp;wq_mayday_lock);</P>
<P>&nbsp;while (!list_empty(&amp;wq-&gt;maydays)) {<BR>&nbsp;&nbsp;struct pool_workqueue *pwq = list_first_entry(&amp;wq-&gt;maydays,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct pool_workqueue, mayday_node);<BR>&nbsp;&nbsp;struct worker_pool *pool = pwq-&gt;pool;<BR>&nbsp;&nbsp;struct work_struct *work, *n;</P>
<P>&nbsp;&nbsp;__set_current_state(TASK_RUNNING);<BR>&nbsp;&nbsp;list_del_init(&amp;pwq-&gt;mayday_node);</P>
<P>&nbsp;&nbsp;spin_unlock_irq(&amp;wq_mayday_lock);</P>
<P>&nbsp;&nbsp;worker_attach_to_pool(rescuer, pool);</P>
<P>&nbsp;&nbsp;spin_lock_irq(&amp;pool-&gt;lock);<BR>&nbsp;&nbsp;rescuer-&gt;pool = pool;</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Slurp in all works issued via this workqueue and<BR>&nbsp;&nbsp; * process'em.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;WARN_ON_ONCE(!list_empty(scheduled));<BR>&nbsp;&nbsp;list_for_each_entry_safe(work, n, &amp;pool-&gt;worklist, entry)<BR>&nbsp;&nbsp;&nbsp;if (get_work_pwq(work) == pwq)<BR>&nbsp;&nbsp;&nbsp;&nbsp;move_linked_works(work, scheduled, &amp;n);</P>
<P>&nbsp;&nbsp;if (!list_empty(scheduled)) {<BR>&nbsp;&nbsp;&nbsp;process_scheduled_works(rescuer);</P>
<P>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * The above execution of rescued work items could<BR>&nbsp;&nbsp;&nbsp; * have created more to rescue through<BR>&nbsp;&nbsp;&nbsp; * pwq_activate_first_delayed() or chained<BR>&nbsp;&nbsp;&nbsp; * queueing.&nbsp; Let's put @pwq back on mayday list so<BR>&nbsp;&nbsp;&nbsp; * that such back-to-back work items, which may be<BR>&nbsp;&nbsp;&nbsp; * being used to relieve memory pressure, don't<BR>&nbsp;&nbsp;&nbsp; * incur MAYDAY_INTERVAL delay inbetween.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (need_to_create_worker(pool)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;wq_mayday_lock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;get_pwq(pwq);<BR>&nbsp;&nbsp;&nbsp;&nbsp;list_move_tail(&amp;pwq-&gt;mayday_node, &amp;wq-&gt;maydays);<BR>&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;wq_mayday_lock);<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Put the reference grabbed by send_mayday().&nbsp; @pool won't<BR>&nbsp;&nbsp; * go away while we're still attached to it.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;put_pwq(pwq);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Leave this pool.&nbsp; If need_more_worker() is %true, notify a<BR>&nbsp;&nbsp; * regular worker; otherwise, we end up with 0 concurrency<BR>&nbsp;&nbsp; * and stalling the execution.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (need_more_worker(pool))<BR>&nbsp;&nbsp;&nbsp;wake_up_worker(pool);</P>
<P>&nbsp;&nbsp;rescuer-&gt;pool = NULL;<BR>&nbsp;&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;&nbsp;worker_detach_from_pool(rescuer, pool);</P>
<P>&nbsp;&nbsp;spin_lock_irq(&amp;wq_mayday_lock);<BR>&nbsp;}</P>
<P>&nbsp;spin_unlock_irq(&amp;wq_mayday_lock);</P>
<P>&nbsp;if (should_stop) {<BR>&nbsp;&nbsp;__set_current_state(TASK_RUNNING);<BR>&nbsp;&nbsp;rescuer-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>&nbsp;/* rescuers should never participate in concurrency management */<BR>&nbsp;WARN_ON_ONCE(!(rescuer-&gt;flags &amp; WORKER_NOT_RUNNING));<BR>&nbsp;schedule();<BR>&nbsp;goto repeat;<BR>}</P>
<P>struct wq_barrier {<BR>&nbsp;struct work_struct&nbsp;work;<BR>&nbsp;struct completion&nbsp;done;<BR>&nbsp;struct task_struct&nbsp;*task;&nbsp;/* purely informational */<BR>};</P>
<P>static void wq_barrier_func(struct work_struct *work)<BR>{<BR>&nbsp;struct wq_barrier *barr = container_of(work, struct wq_barrier, work);<BR>&nbsp;complete(&amp;barr-&gt;done);<BR>}</P>
<P>/**<BR>&nbsp;* insert_wq_barrier - insert a barrier work<BR>&nbsp;* @pwq: pwq to insert barrier into<BR>&nbsp;* @barr: wq_barrier to insert<BR>&nbsp;* @target: target work to attach @barr to<BR>&nbsp;* @worker: worker currently executing @target, NULL if @target is not executing<BR>&nbsp;*<BR>&nbsp;* @barr is linked to @target such that @barr is completed only after<BR>&nbsp;* @target finishes execution.&nbsp; Please note that the ordering<BR>&nbsp;* guarantee is observed only with respect to @target and on the local<BR>&nbsp;* cpu.<BR>&nbsp;*<BR>&nbsp;* Currently, a queued barrier can't be canceled.&nbsp; This is because<BR>&nbsp;* try_to_grab_pending() can't determine whether the work to be<BR>&nbsp;* grabbed is at the head of the queue and thus can't clear LINKED<BR>&nbsp;* flag of the previous work while there must be a valid next work<BR>&nbsp;* after a work with LINKED flag set.<BR>&nbsp;*<BR>&nbsp;* Note that when @worker is non-NULL, @target may be modified<BR>&nbsp;* underneath us, so we can't reliably determine pwq from @target.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* spin_lock_irq(pool-&gt;lock).<BR>&nbsp;*/<BR>static void insert_wq_barrier(struct pool_workqueue *pwq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct wq_barrier *barr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct work_struct *target, struct worker *worker)<BR>{<BR>&nbsp;struct list_head *head;<BR>&nbsp;unsigned int linked = 0;</P>
<P>&nbsp;/*<BR>&nbsp; * debugobject calls are safe here even with pool-&gt;lock locked<BR>&nbsp; * as we know for sure that this will not trigger any of the<BR>&nbsp; * checks and call back into the fixup functions where we<BR>&nbsp; * might deadlock.<BR>&nbsp; */<BR>&nbsp;INIT_WORK_ONSTACK(&amp;barr-&gt;work, wq_barrier_func);<BR>&nbsp;__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&amp;barr-&gt;work));<BR>&nbsp;init_completion(&amp;barr-&gt;done);<BR>&nbsp;barr-&gt;task = current;</P>
<P>&nbsp;/*<BR>&nbsp; * If @target is currently being executed, schedule the<BR>&nbsp; * barrier to the worker; otherwise, put it after @target.<BR>&nbsp; */<BR>&nbsp;if (worker)<BR>&nbsp;&nbsp;head = worker-&gt;scheduled.next;<BR>&nbsp;else {<BR>&nbsp;&nbsp;unsigned long *bits = work_data_bits(target);</P>
<P>&nbsp;&nbsp;head = target-&gt;entry.next;<BR>&nbsp;&nbsp;/* there can already be other linked works, inherit and set */<BR>&nbsp;&nbsp;linked = *bits &amp; WORK_STRUCT_LINKED;<BR>&nbsp;&nbsp;__set_bit(WORK_STRUCT_LINKED_BIT, bits);<BR>&nbsp;}</P>
<P>&nbsp;debug_work_activate(&amp;barr-&gt;work);<BR>&nbsp;insert_work(pwq, &amp;barr-&gt;work, head,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_color_to_flags(WORK_NO_COLOR) | linked);<BR>}</P>
<P>/**<BR>&nbsp;* flush_workqueue_prep_pwqs - prepare pwqs for workqueue flushing<BR>&nbsp;* @wq: workqueue being flushed<BR>&nbsp;* @flush_color: new flush color, &lt; 0 for no-op<BR>&nbsp;* @work_color: new work color, &lt; 0 for no-op<BR>&nbsp;*<BR>&nbsp;* Prepare pwqs for workqueue flushing.<BR>&nbsp;*<BR>&nbsp;* If @flush_color is non-negative, flush_color on all pwqs should be<BR>&nbsp;* -1.&nbsp; If no pwq has in-flight commands at the specified color, all<BR>&nbsp;* pwq-&gt;flush_color's stay at -1 and %false is returned.&nbsp; If any pwq<BR>&nbsp;* has in flight commands, its pwq-&gt;flush_color is set to<BR>&nbsp;* @flush_color, @wq-&gt;nr_pwqs_to_flush is updated accordingly, pwq<BR>&nbsp;* wakeup logic is armed and %true is returned.<BR>&nbsp;*<BR>&nbsp;* The caller should have initialized @wq-&gt;first_flusher prior to<BR>&nbsp;* calling this function with non-negative @flush_color.&nbsp; If<BR>&nbsp;* @flush_color is negative, no flush color update is done and %false<BR>&nbsp;* is returned.<BR>&nbsp;*<BR>&nbsp;* If @work_color is non-negative, all pwqs should have the same<BR>&nbsp;* work_color which is previous to @work_color and all will be<BR>&nbsp;* advanced to @work_color.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* mutex_lock(wq-&gt;mutex).<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %true if @flush_color &gt;= 0 and there's something to flush.&nbsp; %false<BR>&nbsp;* otherwise.<BR>&nbsp;*/<BR>static bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int flush_color, int work_color)<BR>{<BR>&nbsp;bool wait = false;<BR>&nbsp;struct pool_workqueue *pwq;</P>
<P>&nbsp;if (flush_color &gt;= 0) {<BR>&nbsp;&nbsp;WARN_ON_ONCE(atomic_read(&amp;wq-&gt;nr_pwqs_to_flush));<BR>&nbsp;&nbsp;atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, 1);<BR>&nbsp;}</P>
<P>&nbsp;for_each_pwq(pwq, wq) {<BR>&nbsp;&nbsp;struct worker_pool *pool = pwq-&gt;pool;</P>
<P>&nbsp;&nbsp;spin_lock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;&nbsp;if (flush_color &gt;= 0) {<BR>&nbsp;&nbsp;&nbsp;WARN_ON_ONCE(pwq-&gt;flush_color != -1);</P>
<P>&nbsp;&nbsp;&nbsp;if (pwq-&gt;nr_in_flight[flush_color]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;pwq-&gt;flush_color = flush_color;<BR>&nbsp;&nbsp;&nbsp;&nbsp;atomic_inc(&amp;wq-&gt;nr_pwqs_to_flush);<BR>&nbsp;&nbsp;&nbsp;&nbsp;wait = true;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (work_color &gt;= 0) {<BR>&nbsp;&nbsp;&nbsp;WARN_ON_ONCE(work_color != work_next_color(pwq-&gt;work_color));<BR>&nbsp;&nbsp;&nbsp;pwq-&gt;work_color = work_color;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>&nbsp;}</P>
<P>&nbsp;if (flush_color &gt;= 0 &amp;&amp; atomic_dec_and_test(&amp;wq-&gt;nr_pwqs_to_flush))<BR>&nbsp;&nbsp;complete(&amp;wq-&gt;first_flusher-&gt;done);</P>
<P>&nbsp;return wait;<BR>}</P>
<P>/**<BR>&nbsp;* flush_workqueue - ensure that any scheduled work has run to completion.<BR>&nbsp;* @wq: workqueue to flush<BR>&nbsp;*<BR>&nbsp;* This function sleeps until all work items which were queued on entry<BR>&nbsp;* have finished execution, but it is not livelocked by new incoming ones.<BR>&nbsp;*/<BR>void flush_workqueue(struct workqueue_struct *wq)<BR>{<BR>&nbsp;struct wq_flusher this_flusher = {<BR>&nbsp;&nbsp;.list = LIST_HEAD_INIT(this_flusher.list),<BR>&nbsp;&nbsp;.flush_color = -1,<BR>&nbsp;&nbsp;.done = COMPLETION_INITIALIZER_ONSTACK(this_flusher.done),<BR>&nbsp;};<BR>&nbsp;int next_color;</P>
<P>&nbsp;lock_map_acquire(&amp;wq-&gt;lockdep_map);<BR>&nbsp;lock_map_release(&amp;wq-&gt;lockdep_map);</P>
<P>&nbsp;mutex_lock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;/*<BR>&nbsp; * Start-to-wait phase<BR>&nbsp; */<BR>&nbsp;next_color = work_next_color(wq-&gt;work_color);</P>
<P>&nbsp;if (next_color != wq-&gt;flush_color) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Color space is not full.&nbsp; The current work_color<BR>&nbsp;&nbsp; * becomes our flush_color and work_color is advanced<BR>&nbsp;&nbsp; * by one.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;WARN_ON_ONCE(!list_empty(&amp;wq-&gt;flusher_overflow));<BR>&nbsp;&nbsp;this_flusher.flush_color = wq-&gt;work_color;<BR>&nbsp;&nbsp;wq-&gt;work_color = next_color;</P>
<P>&nbsp;&nbsp;if (!wq-&gt;first_flusher) {<BR>&nbsp;&nbsp;&nbsp;/* no flush in progress, become the first flusher */<BR>&nbsp;&nbsp;&nbsp;WARN_ON_ONCE(wq-&gt;flush_color != this_flusher.flush_color);</P>
<P>&nbsp;&nbsp;&nbsp;wq-&gt;first_flusher = &amp;this_flusher;</P>
<P>&nbsp;&nbsp;&nbsp;if (!flush_workqueue_prep_pwqs(wq, wq-&gt;flush_color,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wq-&gt;work_color)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;/* nothing to flush, done */<BR>&nbsp;&nbsp;&nbsp;&nbsp;wq-&gt;flush_color = next_color;<BR>&nbsp;&nbsp;&nbsp;&nbsp;wq-&gt;first_flusher = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out_unlock;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;/* wait in queue */<BR>&nbsp;&nbsp;&nbsp;WARN_ON_ONCE(wq-&gt;flush_color == this_flusher.flush_color);<BR>&nbsp;&nbsp;&nbsp;list_add_tail(&amp;this_flusher.list, &amp;wq-&gt;flusher_queue);<BR>&nbsp;&nbsp;&nbsp;flush_workqueue_prep_pwqs(wq, -1, wq-&gt;work_color);<BR>&nbsp;&nbsp;}<BR>&nbsp;} else {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Oops, color space is full, wait on overflow queue.<BR>&nbsp;&nbsp; * The next flush completion will assign us<BR>&nbsp;&nbsp; * flush_color and transfer to flusher_queue.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;list_add_tail(&amp;this_flusher.list, &amp;wq-&gt;flusher_overflow);<BR>&nbsp;}</P>
<P>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;wait_for_completion(&amp;this_flusher.done);</P>
<P>&nbsp;/*<BR>&nbsp; * Wake-up-and-cascade phase<BR>&nbsp; *<BR>&nbsp; * First flushers are responsible for cascading flushes and<BR>&nbsp; * handling overflow.&nbsp; Non-first flushers can simply return.<BR>&nbsp; */<BR>&nbsp;if (wq-&gt;first_flusher != &amp;this_flusher)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;mutex_lock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;/* we might have raced, check again with mutex held */<BR>&nbsp;if (wq-&gt;first_flusher != &amp;this_flusher)<BR>&nbsp;&nbsp;goto out_unlock;</P>
<P>&nbsp;wq-&gt;first_flusher = NULL;</P>
<P>&nbsp;WARN_ON_ONCE(!list_empty(&amp;this_flusher.list));<BR>&nbsp;WARN_ON_ONCE(wq-&gt;flush_color != this_flusher.flush_color);</P>
<P>&nbsp;while (true) {<BR>&nbsp;&nbsp;struct wq_flusher *next, *tmp;</P>
<P>&nbsp;&nbsp;/* complete all the flushers sharing the current flush color */<BR>&nbsp;&nbsp;list_for_each_entry_safe(next, tmp, &amp;wq-&gt;flusher_queue, list) {<BR>&nbsp;&nbsp;&nbsp;if (next-&gt;flush_color != wq-&gt;flush_color)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;list_del_init(&amp;next-&gt;list);<BR>&nbsp;&nbsp;&nbsp;complete(&amp;next-&gt;done);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;WARN_ON_ONCE(!list_empty(&amp;wq-&gt;flusher_overflow) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wq-&gt;flush_color != work_next_color(wq-&gt;work_color));</P>
<P>&nbsp;&nbsp;/* this flush_color is finished, advance by one */<BR>&nbsp;&nbsp;wq-&gt;flush_color = work_next_color(wq-&gt;flush_color);</P>
<P>&nbsp;&nbsp;/* one color has been freed, handle overflow queue */<BR>&nbsp;&nbsp;if (!list_empty(&amp;wq-&gt;flusher_overflow)) {<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Assign the same color to all overflowed<BR>&nbsp;&nbsp;&nbsp; * flushers, advance work_color and append to<BR>&nbsp;&nbsp;&nbsp; * flusher_queue.&nbsp; This is the start-to-wait<BR>&nbsp;&nbsp;&nbsp; * phase for these overflowed flushers.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;list_for_each_entry(tmp, &amp;wq-&gt;flusher_overflow, list)<BR>&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;flush_color = wq-&gt;work_color;</P>
<P>&nbsp;&nbsp;&nbsp;wq-&gt;work_color = work_next_color(wq-&gt;work_color);</P>
<P>&nbsp;&nbsp;&nbsp;list_splice_tail_init(&amp;wq-&gt;flusher_overflow,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;wq-&gt;flusher_queue);<BR>&nbsp;&nbsp;&nbsp;flush_workqueue_prep_pwqs(wq, -1, wq-&gt;work_color);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (list_empty(&amp;wq-&gt;flusher_queue)) {<BR>&nbsp;&nbsp;&nbsp;WARN_ON_ONCE(wq-&gt;flush_color != wq-&gt;work_color);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Need to flush more colors.&nbsp; Make the next flusher<BR>&nbsp;&nbsp; * the new first flusher and arm pwqs.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;WARN_ON_ONCE(wq-&gt;flush_color == wq-&gt;work_color);<BR>&nbsp;&nbsp;WARN_ON_ONCE(wq-&gt;flush_color != next-&gt;flush_color);</P>
<P>&nbsp;&nbsp;list_del_init(&amp;next-&gt;list);<BR>&nbsp;&nbsp;wq-&gt;first_flusher = next;</P>
<P>&nbsp;&nbsp;if (flush_workqueue_prep_pwqs(wq, wq-&gt;flush_color, -1))<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Meh... this color is already done, clear first<BR>&nbsp;&nbsp; * flusher and repeat cascading.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;wq-&gt;first_flusher = NULL;<BR>&nbsp;}</P>
<P>out_unlock:<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>}<BR>EXPORT_SYMBOL_GPL(flush_workqueue);</P>
<P>/**<BR>&nbsp;* drain_workqueue - drain a workqueue<BR>&nbsp;* @wq: workqueue to drain<BR>&nbsp;*<BR>&nbsp;* Wait until the workqueue becomes empty.&nbsp; While draining is in progress,<BR>&nbsp;* only chain queueing is allowed.&nbsp; IOW, only currently pending or running<BR>&nbsp;* work items on @wq can queue further work items on it.&nbsp; @wq is flushed<BR>&nbsp;* repeatedly until it becomes empty.&nbsp; The number of flushing is determined<BR>&nbsp;* by the depth of chaining and should be relatively short.&nbsp; Whine if it<BR>&nbsp;* takes too long.<BR>&nbsp;*/<BR>void drain_workqueue(struct workqueue_struct *wq)<BR>{<BR>&nbsp;unsigned int flush_cnt = 0;<BR>&nbsp;struct pool_workqueue *pwq;</P>
<P>&nbsp;/*<BR>&nbsp; * __queue_work() needs to test whether there are drainers, is much<BR>&nbsp; * hotter than drain_workqueue() and already looks at @wq-&gt;flags.<BR>&nbsp; * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;if (!wq-&gt;nr_drainers++)<BR>&nbsp;&nbsp;wq-&gt;flags |= __WQ_DRAINING;<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>reflush:<BR>&nbsp;flush_workqueue(wq);</P>
<P>&nbsp;mutex_lock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;for_each_pwq(pwq, wq) {<BR>&nbsp;&nbsp;bool drained;</P>
<P>&nbsp;&nbsp;spin_lock_irq(&amp;pwq-&gt;pool-&gt;lock);<BR>&nbsp;&nbsp;drained = !pwq-&gt;nr_active &amp;&amp; list_empty(&amp;pwq-&gt;delayed_works);<BR>&nbsp;&nbsp;spin_unlock_irq(&amp;pwq-&gt;pool-&gt;lock);</P>
<P>&nbsp;&nbsp;if (drained)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;if (++flush_cnt == 10 ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (flush_cnt % 100 == 0 &amp;&amp; flush_cnt &lt;= 1000))<BR>&nbsp;&nbsp;&nbsp;pr_warn("workqueue %s: drain_workqueue() isn't complete after %u tries\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;wq-&gt;name, flush_cnt);</P>
<P>&nbsp;&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;&nbsp;goto reflush;<BR>&nbsp;}</P>
<P>&nbsp;if (!--wq-&gt;nr_drainers)<BR>&nbsp;&nbsp;wq-&gt;flags &amp;= ~__WQ_DRAINING;<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>}<BR>EXPORT_SYMBOL_GPL(drain_workqueue);</P>
<P>static bool start_flush_work(struct work_struct *work, struct wq_barrier *barr)<BR>{<BR>&nbsp;struct worker *worker = NULL;<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;struct pool_workqueue *pwq;</P>
<P>&nbsp;might_sleep();</P>
<P>&nbsp;local_irq_disable();<BR>&nbsp;pool = get_work_pool(work);<BR>&nbsp;if (!pool) {<BR>&nbsp;&nbsp;local_irq_enable();<BR>&nbsp;&nbsp;return false;<BR>&nbsp;}</P>
<P>&nbsp;spin_lock(&amp;pool-&gt;lock);<BR>&nbsp;/* see the comment in try_to_grab_pending() with the same code */<BR>&nbsp;pwq = get_work_pwq(work);<BR>&nbsp;if (pwq) {<BR>&nbsp;&nbsp;if (unlikely(pwq-&gt;pool != pool))<BR>&nbsp;&nbsp;&nbsp;goto already_gone;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;worker = find_worker_executing_work(pool, work);<BR>&nbsp;&nbsp;if (!worker)<BR>&nbsp;&nbsp;&nbsp;goto already_gone;<BR>&nbsp;&nbsp;pwq = worker-&gt;current_pwq;<BR>&nbsp;}</P>
<P>&nbsp;insert_wq_barrier(pwq, barr, work, worker);<BR>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;/*<BR>&nbsp; * If @max_active is 1 or rescuer is in use, flushing another work<BR>&nbsp; * item on the same workqueue may lead to deadlock.&nbsp; Make sure the<BR>&nbsp; * flusher is not running on the same workqueue by verifying write<BR>&nbsp; * access.<BR>&nbsp; */<BR>&nbsp;if (pwq-&gt;wq-&gt;saved_max_active == 1 || pwq-&gt;wq-&gt;rescuer)<BR>&nbsp;&nbsp;lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);<BR>&nbsp;else<BR>&nbsp;&nbsp;lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);<BR>&nbsp;lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</P>
<P>&nbsp;return true;<BR>already_gone:<BR>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>&nbsp;return false;<BR>}</P>
<P>/**<BR>&nbsp;* flush_work - wait for a work to finish executing the last queueing instance<BR>&nbsp;* @work: the work to flush<BR>&nbsp;*<BR>&nbsp;* Wait until @work has finished execution.&nbsp; @work is guaranteed to be idle<BR>&nbsp;* on return if it hasn't been requeued since flush started.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %true if flush_work() waited for the work to finish execution,<BR>&nbsp;* %false if it was already idle.<BR>&nbsp;*/<BR>bool flush_work(struct work_struct *work)<BR>{<BR>&nbsp;struct wq_barrier barr;</P>
<P>&nbsp;lock_map_acquire(&amp;work-&gt;lockdep_map);<BR>&nbsp;lock_map_release(&amp;work-&gt;lockdep_map);</P>
<P>&nbsp;if (start_flush_work(work, &amp;barr)) {<BR>&nbsp;&nbsp;wait_for_completion(&amp;barr.done);<BR>&nbsp;&nbsp;destroy_work_on_stack(&amp;barr.work);<BR>&nbsp;&nbsp;return true;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;return false;<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(flush_work);</P>
<P>struct cwt_wait {<BR>&nbsp;wait_queue_t&nbsp;&nbsp;wait;<BR>&nbsp;struct work_struct&nbsp;*work;<BR>};</P>
<P>static int cwt_wakefn(wait_queue_t *wait, unsigned mode, int sync, void *key)<BR>{<BR>&nbsp;struct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);</P>
<P>&nbsp;if (cwait-&gt;work != key)<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return autoremove_wake_function(wait, mode, sync, key);<BR>}</P>
<P>static bool __cancel_work_timer(struct work_struct *work, bool is_dwork)<BR>{<BR>&nbsp;static DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret;</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;ret = try_to_grab_pending(work, is_dwork, &amp;flags);<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * If someone else is already canceling, wait for it to<BR>&nbsp;&nbsp; * finish.&nbsp; flush_work() doesn't work for PREEMPT_NONE<BR>&nbsp;&nbsp; * because we may get scheduled between @work's completion<BR>&nbsp;&nbsp; * and the other canceling task resuming and clearing<BR>&nbsp;&nbsp; * CANCELING - flush_work() will return false immediately<BR>&nbsp;&nbsp; * as @work is no longer busy, try_to_grab_pending() will<BR>&nbsp;&nbsp; * return -ENOENT as @work is still being canceled and the<BR>&nbsp;&nbsp; * other canceling task won't be able to clear CANCELING as<BR>&nbsp;&nbsp; * we're hogging the CPU.<BR>&nbsp;&nbsp; *<BR>&nbsp;&nbsp; * Let's wait for completion using a waitqueue.&nbsp; As this<BR>&nbsp;&nbsp; * may lead to the thundering herd problem, use a custom<BR>&nbsp;&nbsp; * wake function which matches @work along with exclusive<BR>&nbsp;&nbsp; * wait and wakeup.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (unlikely(ret == -ENOENT)) {<BR>&nbsp;&nbsp;&nbsp;struct cwt_wait cwait;</P>
<P>&nbsp;&nbsp;&nbsp;init_wait(&amp;cwait.wait);<BR>&nbsp;&nbsp;&nbsp;cwait.wait.func = cwt_wakefn;<BR>&nbsp;&nbsp;&nbsp;cwait.work = work;</P>
<P>&nbsp;&nbsp;&nbsp;prepare_to_wait_exclusive(&amp;cancel_waitq, &amp;cwait.wait,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TASK_UNINTERRUPTIBLE);<BR>&nbsp;&nbsp;&nbsp;if (work_is_canceling(work))<BR>&nbsp;&nbsp;&nbsp;&nbsp;schedule();<BR>&nbsp;&nbsp;&nbsp;finish_wait(&amp;cancel_waitq, &amp;cwait.wait);<BR>&nbsp;&nbsp;}<BR>&nbsp;} while (unlikely(ret &lt; 0));</P>
<P>&nbsp;/* tell other tasks trying to grab @work to back off */<BR>&nbsp;mark_work_canceling(work);<BR>&nbsp;local_irq_restore(flags);</P>
<P>&nbsp;flush_work(work);<BR>&nbsp;clear_work_data(work);</P>
<P>&nbsp;/*<BR>&nbsp; * Paired with prepare_to_wait() above so that either<BR>&nbsp; * waitqueue_active() is visible here or !work_is_canceling() is<BR>&nbsp; * visible there.<BR>&nbsp; */<BR>&nbsp;smp_mb();<BR>&nbsp;if (waitqueue_active(&amp;cancel_waitq))<BR>&nbsp;&nbsp;__wake_up(&amp;cancel_waitq, TASK_NORMAL, 1, work);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;* cancel_work_sync - cancel a work and wait for it to finish<BR>&nbsp;* @work: the work to cancel<BR>&nbsp;*<BR>&nbsp;* Cancel @work and wait for its execution to finish.&nbsp; This function<BR>&nbsp;* can be used even if the work re-queues itself or migrates to<BR>&nbsp;* another workqueue.&nbsp; On return from this function, @work is<BR>&nbsp;* guaranteed to be not pending or executing on any CPU.<BR>&nbsp;*<BR>&nbsp;* cancel_work_sync(&amp;delayed_work-&gt;work) must not be used for<BR>&nbsp;* delayed_work's.&nbsp; Use cancel_delayed_work_sync() instead.<BR>&nbsp;*<BR>&nbsp;* The caller must ensure that the workqueue on which @work was last<BR>&nbsp;* queued can't be destroyed before this function returns.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %true if @work was pending, %false otherwise.<BR>&nbsp;*/<BR>bool cancel_work_sync(struct work_struct *work)<BR>{<BR>&nbsp;return __cancel_work_timer(work, false);<BR>}<BR>EXPORT_SYMBOL_GPL(cancel_work_sync);</P>
<P>/**<BR>&nbsp;* flush_delayed_work - wait for a dwork to finish executing the last queueing<BR>&nbsp;* @dwork: the delayed work to flush<BR>&nbsp;*<BR>&nbsp;* Delayed timer is cancelled and the pending work is queued for<BR>&nbsp;* immediate execution.&nbsp; Like flush_work(), this function only<BR>&nbsp;* considers the last queueing instance of @dwork.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %true if flush_work() waited for the work to finish execution,<BR>&nbsp;* %false if it was already idle.<BR>&nbsp;*/<BR>bool flush_delayed_work(struct delayed_work *dwork)<BR>{<BR>&nbsp;local_irq_disable();<BR>&nbsp;if (del_timer_sync(&amp;dwork-&gt;timer))<BR>&nbsp;&nbsp;__queue_work(dwork-&gt;cpu, dwork-&gt;wq, &amp;dwork-&gt;work);<BR>&nbsp;local_irq_enable();<BR>&nbsp;return flush_work(&amp;dwork-&gt;work);<BR>}<BR>EXPORT_SYMBOL(flush_delayed_work);</P>
<P>/**<BR>&nbsp;* cancel_delayed_work - cancel a delayed work<BR>&nbsp;* @dwork: delayed_work to cancel<BR>&nbsp;*<BR>&nbsp;* Kill off a pending delayed_work.<BR>&nbsp;*<BR>&nbsp;* Return: %true if @dwork was pending and canceled; %false if it wasn't<BR>&nbsp;* pending.<BR>&nbsp;*<BR>&nbsp;* Note:<BR>&nbsp;* The work callback function may still be running on return, unless<BR>&nbsp;* it returns %true and the work doesn't re-arm itself.&nbsp; Explicitly flush or<BR>&nbsp;* use cancel_delayed_work_sync() to wait on it.<BR>&nbsp;*<BR>&nbsp;* This function is safe to call from any context including IRQ handler.<BR>&nbsp;*/<BR>bool cancel_delayed_work(struct delayed_work *dwork)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret;</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;ret = try_to_grab_pending(&amp;dwork-&gt;work, true, &amp;flags);<BR>&nbsp;} while (unlikely(ret == -EAGAIN));</P>
<P>&nbsp;if (unlikely(ret &lt; 0))<BR>&nbsp;&nbsp;return false;</P>
<P>&nbsp;set_work_pool_and_clear_pending(&amp;dwork-&gt;work,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get_work_pool_id(&amp;dwork-&gt;work));<BR>&nbsp;local_irq_restore(flags);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(cancel_delayed_work);</P>
<P>/**<BR>&nbsp;* cancel_delayed_work_sync - cancel a delayed work and wait for it to finish<BR>&nbsp;* @dwork: the delayed work cancel<BR>&nbsp;*<BR>&nbsp;* This is cancel_work_sync() for delayed works.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %true if @dwork was pending, %false otherwise.<BR>&nbsp;*/<BR>bool cancel_delayed_work_sync(struct delayed_work *dwork)<BR>{<BR>&nbsp;return __cancel_work_timer(&amp;dwork-&gt;work, true);<BR>}<BR>EXPORT_SYMBOL(cancel_delayed_work_sync);</P>
<P>/**<BR>&nbsp;* schedule_on_each_cpu - execute a function synchronously on each online CPU<BR>&nbsp;* @func: the function to call<BR>&nbsp;*<BR>&nbsp;* schedule_on_each_cpu() executes @func on each online CPU using the<BR>&nbsp;* system workqueue and blocks until all CPUs have completed.<BR>&nbsp;* schedule_on_each_cpu() is very slow.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* 0 on success, -errno on failure.<BR>&nbsp;*/<BR>int schedule_on_each_cpu(work_func_t func)<BR>{<BR>&nbsp;int cpu;<BR>&nbsp;struct work_struct __percpu *works;</P>
<P>&nbsp;works = alloc_percpu(struct work_struct);<BR>&nbsp;if (!works)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;get_online_cpus();</P>
<P>&nbsp;for_each_online_cpu(cpu) {<BR>&nbsp;&nbsp;struct work_struct *work = per_cpu_ptr(works, cpu);</P>
<P>&nbsp;&nbsp;INIT_WORK(work, func);<BR>&nbsp;&nbsp;schedule_work_on(cpu, work);<BR>&nbsp;}</P>
<P>&nbsp;for_each_online_cpu(cpu)<BR>&nbsp;&nbsp;flush_work(per_cpu_ptr(works, cpu));</P>
<P>&nbsp;put_online_cpus();<BR>&nbsp;free_percpu(works);<BR>&nbsp;return 0;<BR>}</P>
<P>/**<BR>&nbsp;* execute_in_process_context - reliably execute the routine with user context<BR>&nbsp;* @fn:&nbsp;&nbsp;the function to execute<BR>&nbsp;* @ew:&nbsp;&nbsp;guaranteed storage for the execute work structure (must<BR>&nbsp;*&nbsp;&nbsp;be available when the work executes)<BR>&nbsp;*<BR>&nbsp;* Executes the function immediately if process context is available,<BR>&nbsp;* otherwise schedules the function for delayed execution.<BR>&nbsp;*<BR>&nbsp;* Return:&nbsp;0 - function was executed<BR>&nbsp;*&nbsp;&nbsp;1 - function was scheduled for execution<BR>&nbsp;*/<BR>int execute_in_process_context(work_func_t fn, struct execute_work *ew)<BR>{<BR>&nbsp;if (!in_interrupt()) {<BR>&nbsp;&nbsp;fn(&amp;ew-&gt;work);<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>&nbsp;INIT_WORK(&amp;ew-&gt;work, fn);<BR>&nbsp;schedule_work(&amp;ew-&gt;work);</P>
<P>&nbsp;return 1;<BR>}<BR>EXPORT_SYMBOL_GPL(execute_in_process_context);</P>
<P>/**<BR>&nbsp;* free_workqueue_attrs - free a workqueue_attrs<BR>&nbsp;* @attrs: workqueue_attrs to free<BR>&nbsp;*<BR>&nbsp;* Undo alloc_workqueue_attrs().<BR>&nbsp;*/<BR>void free_workqueue_attrs(struct workqueue_attrs *attrs)<BR>{<BR>&nbsp;if (attrs) {<BR>&nbsp;&nbsp;free_cpumask_var(attrs-&gt;cpumask);<BR>&nbsp;&nbsp;kfree(attrs);<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* alloc_workqueue_attrs - allocate a workqueue_attrs<BR>&nbsp;* @gfp_mask: allocation mask to use<BR>&nbsp;*<BR>&nbsp;* Allocate a new workqueue_attrs, initialize with default settings and<BR>&nbsp;* return it.<BR>&nbsp;*<BR>&nbsp;* Return: The allocated new workqueue_attr on success. %NULL on failure.<BR>&nbsp;*/<BR>struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)<BR>{<BR>&nbsp;struct workqueue_attrs *attrs;</P>
<P>&nbsp;attrs = kzalloc(sizeof(*attrs), gfp_mask);<BR>&nbsp;if (!attrs)<BR>&nbsp;&nbsp;goto fail;<BR>&nbsp;if (!alloc_cpumask_var(&amp;attrs-&gt;cpumask, gfp_mask))<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;cpumask_copy(attrs-&gt;cpumask, cpu_possible_mask);<BR>&nbsp;return attrs;<BR>fail:<BR>&nbsp;free_workqueue_attrs(attrs);<BR>&nbsp;return NULL;<BR>}</P>
<P>static void copy_workqueue_attrs(struct workqueue_attrs *to,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct workqueue_attrs *from)<BR>{<BR>&nbsp;to-&gt;nice = from-&gt;nice;<BR>&nbsp;cpumask_copy(to-&gt;cpumask, from-&gt;cpumask);<BR>&nbsp;/*<BR>&nbsp; * Unlike hash and equality test, this function doesn't ignore<BR>&nbsp; * -&gt;no_numa as it is used for both pool and wq attrs.&nbsp; Instead,<BR>&nbsp; * get_unbound_pool() explicitly clears -&gt;no_numa after copying.<BR>&nbsp; */<BR>&nbsp;to-&gt;no_numa = from-&gt;no_numa;<BR>}</P>
<P>/* hash value of the content of @attr */<BR>static u32 wqattrs_hash(const struct workqueue_attrs *attrs)<BR>{<BR>&nbsp;u32 hash = 0;</P>
<P>&nbsp;hash = jhash_1word(attrs-&gt;nice, hash);<BR>&nbsp;hash = jhash(cpumask_bits(attrs-&gt;cpumask),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);<BR>&nbsp;return hash;<BR>}</P>
<P>/* content equality test */<BR>static bool wqattrs_equal(const struct workqueue_attrs *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct workqueue_attrs *b)<BR>{<BR>&nbsp;if (a-&gt;nice != b-&gt;nice)<BR>&nbsp;&nbsp;return false;<BR>&nbsp;if (!cpumask_equal(a-&gt;cpumask, b-&gt;cpumask))<BR>&nbsp;&nbsp;return false;<BR>&nbsp;return true;<BR>}</P>
<P>/**<BR>&nbsp;* init_worker_pool - initialize a newly zalloc'd worker_pool<BR>&nbsp;* @pool: worker_pool to initialize<BR>&nbsp;*<BR>&nbsp;* Initialize a newly zalloc'd @pool.&nbsp; It also allocates @pool-&gt;attrs.<BR>&nbsp;*<BR>&nbsp;* Return: 0 on success, -errno on failure.&nbsp; Even on failure, all fields<BR>&nbsp;* inside @pool proper are initialized and put_unbound_pool() can be called<BR>&nbsp;* on @pool safely to release it.<BR>&nbsp;*/<BR>static int init_worker_pool(struct worker_pool *pool)<BR>{<BR>&nbsp;spin_lock_init(&amp;pool-&gt;lock);<BR>&nbsp;pool-&gt;id = -1;<BR>&nbsp;pool-&gt;cpu = -1;<BR>&nbsp;pool-&gt;node = NUMA_NO_NODE;<BR>&nbsp;pool-&gt;flags |= POOL_DISASSOCIATED;<BR>&nbsp;INIT_LIST_HEAD(&amp;pool-&gt;worklist);<BR>&nbsp;INIT_LIST_HEAD(&amp;pool-&gt;idle_list);<BR>&nbsp;hash_init(pool-&gt;busy_hash);</P>
<P>&nbsp;init_timer_deferrable(&amp;pool-&gt;idle_timer);<BR>&nbsp;pool-&gt;idle_timer.function = idle_worker_timeout;<BR>&nbsp;pool-&gt;idle_timer.data = (unsigned long)pool;</P>
<P>&nbsp;setup_timer(&amp;pool-&gt;mayday_timer, pool_mayday_timeout,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long)pool);</P>
<P>&nbsp;mutex_init(&amp;pool-&gt;manager_arb);<BR>&nbsp;mutex_init(&amp;pool-&gt;attach_mutex);<BR>&nbsp;INIT_LIST_HEAD(&amp;pool-&gt;workers);</P>
<P>&nbsp;ida_init(&amp;pool-&gt;worker_ida);<BR>&nbsp;INIT_HLIST_NODE(&amp;pool-&gt;hash_node);<BR>&nbsp;pool-&gt;refcnt = 1;</P>
<P>&nbsp;/* shouldn't fail above this point */<BR>&nbsp;pool-&gt;attrs = alloc_workqueue_attrs(GFP_KERNEL);<BR>&nbsp;if (!pool-&gt;attrs)<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;return 0;<BR>}</P>
<P>static void rcu_free_wq(struct rcu_head *rcu)<BR>{<BR>&nbsp;struct workqueue_struct *wq =<BR>&nbsp;&nbsp;container_of(rcu, struct workqueue_struct, rcu);</P>
<P>&nbsp;if (!(wq-&gt;flags &amp; WQ_UNBOUND))<BR>&nbsp;&nbsp;free_percpu(wq-&gt;cpu_pwqs);<BR>&nbsp;else<BR>&nbsp;&nbsp;free_workqueue_attrs(wq-&gt;unbound_attrs);</P>
<P>&nbsp;kfree(wq-&gt;rescuer);<BR>&nbsp;kfree(wq);<BR>}</P>
<P>static void rcu_free_pool(struct rcu_head *rcu)<BR>{<BR>&nbsp;struct worker_pool *pool = container_of(rcu, struct worker_pool, rcu);</P>
<P>&nbsp;ida_destroy(&amp;pool-&gt;worker_ida);<BR>&nbsp;free_workqueue_attrs(pool-&gt;attrs);<BR>&nbsp;kfree(pool);<BR>}</P>
<P>/**<BR>&nbsp;* put_unbound_pool - put a worker_pool<BR>&nbsp;* @pool: worker_pool to put<BR>&nbsp;*<BR>&nbsp;* Put @pool.&nbsp; If its refcnt reaches zero, it gets destroyed in sched-RCU<BR>&nbsp;* safe manner.&nbsp; get_unbound_pool() calls this function on its failure path<BR>&nbsp;* and this function should be able to release pools which went through,<BR>&nbsp;* successfully or not, init_worker_pool().<BR>&nbsp;*<BR>&nbsp;* Should be called with wq_pool_mutex held.<BR>&nbsp;*/<BR>static void put_unbound_pool(struct worker_pool *pool)<BR>{<BR>&nbsp;DECLARE_COMPLETION_ONSTACK(detach_completion);<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</P>
<P>&nbsp;if (--pool-&gt;refcnt)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* sanity checks */<BR>&nbsp;if (WARN_ON(!(pool-&gt;cpu &lt; 0)) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(!list_empty(&amp;pool-&gt;worklist)))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* release id and unhash */<BR>&nbsp;if (pool-&gt;id &gt;= 0)<BR>&nbsp;&nbsp;idr_remove(&amp;worker_pool_idr, pool-&gt;id);<BR>&nbsp;hash_del(&amp;pool-&gt;hash_node);</P>
<P>&nbsp;/*<BR>&nbsp; * Become the manager and destroy all workers.&nbsp; Grabbing<BR>&nbsp; * manager_arb prevents @pool's workers from blocking on<BR>&nbsp; * attach_mutex.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;pool-&gt;manager_arb);</P>
<P>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);<BR>&nbsp;while ((worker = first_idle_worker(pool)))<BR>&nbsp;&nbsp;destroy_worker(worker);<BR>&nbsp;WARN_ON(pool-&gt;nr_workers || pool-&gt;nr_idle);<BR>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;mutex_lock(&amp;pool-&gt;attach_mutex);<BR>&nbsp;if (!list_empty(&amp;pool-&gt;workers))<BR>&nbsp;&nbsp;pool-&gt;detach_completion = &amp;detach_completion;<BR>&nbsp;mutex_unlock(&amp;pool-&gt;attach_mutex);</P>
<P>&nbsp;if (pool-&gt;detach_completion)<BR>&nbsp;&nbsp;wait_for_completion(pool-&gt;detach_completion);</P>
<P>&nbsp;mutex_unlock(&amp;pool-&gt;manager_arb);</P>
<P>&nbsp;/* shut down the timers */<BR>&nbsp;del_timer_sync(&amp;pool-&gt;idle_timer);<BR>&nbsp;del_timer_sync(&amp;pool-&gt;mayday_timer);</P>
<P>&nbsp;/* sched-RCU protected to allow dereferences from get_work_pool() */<BR>&nbsp;call_rcu_sched(&amp;pool-&gt;rcu, rcu_free_pool);<BR>}</P>
<P>/**<BR>&nbsp;* get_unbound_pool - get a worker_pool with the specified attributes<BR>&nbsp;* @attrs: the attributes of the worker_pool to get<BR>&nbsp;*<BR>&nbsp;* Obtain a worker_pool which has the same attributes as @attrs, bump the<BR>&nbsp;* reference count and return it.&nbsp; If there already is a matching<BR>&nbsp;* worker_pool, it will be used; otherwise, this function attempts to<BR>&nbsp;* create a new one.<BR>&nbsp;*<BR>&nbsp;* Should be called with wq_pool_mutex held.<BR>&nbsp;*<BR>&nbsp;* Return: On success, a worker_pool with the same attributes as @attrs.<BR>&nbsp;* On failure, %NULL.<BR>&nbsp;*/<BR>static struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)<BR>{<BR>&nbsp;u32 hash = wqattrs_hash(attrs);<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;int node;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</P>
<P>&nbsp;/* do we already have a matching pool? */<BR>&nbsp;hash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {<BR>&nbsp;&nbsp;if (wqattrs_equal(pool-&gt;attrs, attrs)) {<BR>&nbsp;&nbsp;&nbsp;pool-&gt;refcnt++;<BR>&nbsp;&nbsp;&nbsp;return pool;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* nope, create a new one */<BR>&nbsp;pool = kzalloc(sizeof(*pool), GFP_KERNEL);<BR>&nbsp;if (!pool || init_worker_pool(pool) &lt; 0)<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;lockdep_set_subclass(&amp;pool-&gt;lock, 1);&nbsp;/* see put_pwq() */<BR>&nbsp;copy_workqueue_attrs(pool-&gt;attrs, attrs);</P>
<P>&nbsp;/*<BR>&nbsp; * no_numa isn't a worker_pool attribute, always clear it.&nbsp; See<BR>&nbsp; * 'struct workqueue_attrs' comments for detail.<BR>&nbsp; */<BR>&nbsp;pool-&gt;attrs-&gt;no_numa = false;</P>
<P>&nbsp;/* if cpumask is contained inside a NUMA node, we belong to that node */<BR>&nbsp;if (wq_numa_enabled) {<BR>&nbsp;&nbsp;for_each_node(node) {<BR>&nbsp;&nbsp;&nbsp;if (cpumask_subset(pool-&gt;attrs-&gt;cpumask,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wq_numa_possible_cpumask[node])) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;node = node;<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;if (worker_pool_assign_id(pool) &lt; 0)<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;/* create and start the initial worker */<BR>&nbsp;if (!create_worker(pool))<BR>&nbsp;&nbsp;goto fail;</P>
<P>&nbsp;/* install */<BR>&nbsp;hash_add(unbound_pool_hash, &amp;pool-&gt;hash_node, hash);</P>
<P>&nbsp;return pool;<BR>fail:<BR>&nbsp;if (pool)<BR>&nbsp;&nbsp;put_unbound_pool(pool);<BR>&nbsp;return NULL;<BR>}</P>
<P>static void rcu_free_pwq(struct rcu_head *rcu)<BR>{<BR>&nbsp;kmem_cache_free(pwq_cache,<BR>&nbsp;&nbsp;&nbsp;container_of(rcu, struct pool_workqueue, rcu));<BR>}</P>
<P>/*<BR>&nbsp;* Scheduled on system_wq by put_pwq() when an unbound pwq hits zero refcnt<BR>&nbsp;* and needs to be destroyed.<BR>&nbsp;*/<BR>static void pwq_unbound_release_workfn(struct work_struct *work)<BR>{<BR>&nbsp;struct pool_workqueue *pwq = container_of(work, struct pool_workqueue,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unbound_release_work);<BR>&nbsp;struct workqueue_struct *wq = pwq-&gt;wq;<BR>&nbsp;struct worker_pool *pool = pwq-&gt;pool;<BR>&nbsp;bool is_last;</P>
<P>&nbsp;if (WARN_ON_ONCE(!(wq-&gt;flags &amp; WQ_UNBOUND)))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;list_del_rcu(&amp;pwq-&gt;pwqs_node);<BR>&nbsp;is_last = list_empty(&amp;wq-&gt;pwqs);<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;mutex_lock(&amp;wq_pool_mutex);<BR>&nbsp;put_unbound_pool(pool);<BR>&nbsp;mutex_unlock(&amp;wq_pool_mutex);</P>
<P>&nbsp;call_rcu_sched(&amp;pwq-&gt;rcu, rcu_free_pwq);</P>
<P>&nbsp;/*<BR>&nbsp; * If we're the last pwq going away, @wq is already dead and no one<BR>&nbsp; * is gonna access it anymore.&nbsp; Schedule RCU free.<BR>&nbsp; */<BR>&nbsp;if (is_last)<BR>&nbsp;&nbsp;call_rcu_sched(&amp;wq-&gt;rcu, rcu_free_wq);<BR>}</P>
<P>/**<BR>&nbsp;* pwq_adjust_max_active - update a pwq's max_active to the current setting<BR>&nbsp;* @pwq: target pool_workqueue<BR>&nbsp;*<BR>&nbsp;* If @pwq isn't freezing, set @pwq-&gt;max_active to the associated<BR>&nbsp;* workqueue's saved_max_active and activate delayed work items<BR>&nbsp;* accordingly.&nbsp; If @pwq is freezing, clear @pwq-&gt;max_active to zero.<BR>&nbsp;*/<BR>static void pwq_adjust_max_active(struct pool_workqueue *pwq)<BR>{<BR>&nbsp;struct workqueue_struct *wq = pwq-&gt;wq;<BR>&nbsp;bool freezable = wq-&gt;flags &amp; WQ_FREEZABLE;</P>
<P>&nbsp;/* for @wq-&gt;saved_max_active */<BR>&nbsp;lockdep_assert_held(&amp;wq-&gt;mutex);</P>
<P>&nbsp;/* fast exit for non-freezable wqs */<BR>&nbsp;if (!freezable &amp;&amp; pwq-&gt;max_active == wq-&gt;saved_max_active)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;spin_lock_irq(&amp;pwq-&gt;pool-&gt;lock);</P>
<P>&nbsp;/*<BR>&nbsp; * During [un]freezing, the caller is responsible for ensuring that<BR>&nbsp; * this function is called at least once after @workqueue_freezing<BR>&nbsp; * is updated and visible.<BR>&nbsp; */<BR>&nbsp;if (!freezable || !workqueue_freezing) {<BR>&nbsp;&nbsp;pwq-&gt;max_active = wq-&gt;saved_max_active;</P>
<P>&nbsp;&nbsp;while (!list_empty(&amp;pwq-&gt;delayed_works) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwq-&gt;nr_active &lt; pwq-&gt;max_active)<BR>&nbsp;&nbsp;&nbsp;pwq_activate_first_delayed(pwq);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Need to kick a worker after thawed or an unbound wq's<BR>&nbsp;&nbsp; * max_active is bumped.&nbsp; It's a slow path.&nbsp; Do it always.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;wake_up_worker(pwq-&gt;pool);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;pwq-&gt;max_active = 0;<BR>&nbsp;}</P>
<P>&nbsp;spin_unlock_irq(&amp;pwq-&gt;pool-&gt;lock);<BR>}</P>
<P>/* initialize newly alloced @pwq which is associated with @wq and @pool */<BR>static void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct worker_pool *pool)<BR>{<BR>&nbsp;BUG_ON((unsigned long)pwq &amp; WORK_STRUCT_FLAG_MASK);</P>
<P>&nbsp;memset(pwq, 0, sizeof(*pwq));</P>
<P>&nbsp;pwq-&gt;pool = pool;<BR>&nbsp;pwq-&gt;wq = wq;<BR>&nbsp;pwq-&gt;flush_color = -1;<BR>&nbsp;pwq-&gt;refcnt = 1;<BR>&nbsp;INIT_LIST_HEAD(&amp;pwq-&gt;delayed_works);<BR>&nbsp;INIT_LIST_HEAD(&amp;pwq-&gt;pwqs_node);<BR>&nbsp;INIT_LIST_HEAD(&amp;pwq-&gt;mayday_node);<BR>&nbsp;INIT_WORK(&amp;pwq-&gt;unbound_release_work, pwq_unbound_release_workfn);<BR>}</P>
<P>/* sync @pwq with the current state of its associated wq and link it */<BR>static void link_pwq(struct pool_workqueue *pwq)<BR>{<BR>&nbsp;struct workqueue_struct *wq = pwq-&gt;wq;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq-&gt;mutex);</P>
<P>&nbsp;/* may be called multiple times, ignore if already linked */<BR>&nbsp;if (!list_empty(&amp;pwq-&gt;pwqs_node))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* set the matching work_color */<BR>&nbsp;pwq-&gt;work_color = wq-&gt;work_color;</P>
<P>&nbsp;/* sync max_active to the current setting */<BR>&nbsp;pwq_adjust_max_active(pwq);</P>
<P>&nbsp;/* link in @pwq */<BR>&nbsp;list_add_rcu(&amp;pwq-&gt;pwqs_node, &amp;wq-&gt;pwqs);<BR>}</P>
<P>/* obtain a pool matching @attr and create a pwq associating the pool and @wq */<BR>static struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const struct workqueue_attrs *attrs)<BR>{<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;struct pool_workqueue *pwq;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</P>
<P>&nbsp;pool = get_unbound_pool(attrs);<BR>&nbsp;if (!pool)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;pwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool-&gt;node);<BR>&nbsp;if (!pwq) {<BR>&nbsp;&nbsp;put_unbound_pool(pool);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}</P>
<P>&nbsp;init_pwq(pwq, wq, pool);<BR>&nbsp;return pwq;<BR>}</P>
<P>/**<BR>&nbsp;* wq_calc_node_cpumask - calculate a wq_attrs' cpumask for the specified node<BR>&nbsp;* @attrs: the wq_attrs of the default pwq of the target workqueue<BR>&nbsp;* @node: the target NUMA node<BR>&nbsp;* @cpu_going_down: if &gt;= 0, the CPU to consider as offline<BR>&nbsp;* @cpumask: outarg, the resulting cpumask<BR>&nbsp;*<BR>&nbsp;* Calculate the cpumask a workqueue with @attrs should use on @node.&nbsp; If<BR>&nbsp;* @cpu_going_down is &gt;= 0, that cpu is considered offline during<BR>&nbsp;* calculation.&nbsp; The result is stored in @cpumask.<BR>&nbsp;*<BR>&nbsp;* If NUMA affinity is not enabled, @attrs-&gt;cpumask is always used.&nbsp; If<BR>&nbsp;* enabled and @node has online CPUs requested by @attrs, the returned<BR>&nbsp;* cpumask is the intersection of the possible CPUs of @node and<BR>&nbsp;* @attrs-&gt;cpumask.<BR>&nbsp;*<BR>&nbsp;* The caller is responsible for ensuring that the cpumask of @node stays<BR>&nbsp;* stable.<BR>&nbsp;*<BR>&nbsp;* Return: %true if the resulting @cpumask is different from @attrs-&gt;cpumask,<BR>&nbsp;* %false if equal.<BR>&nbsp;*/<BR>static bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int cpu_going_down, cpumask_t *cpumask)<BR>{<BR>&nbsp;if (!wq_numa_enabled || attrs-&gt;no_numa)<BR>&nbsp;&nbsp;goto use_dfl;</P>
<P>&nbsp;/* does @node have any online CPUs @attrs wants? */<BR>&nbsp;cpumask_and(cpumask, cpumask_of_node(node), attrs-&gt;cpumask);<BR>&nbsp;if (cpu_going_down &gt;= 0)<BR>&nbsp;&nbsp;cpumask_clear_cpu(cpu_going_down, cpumask);</P>
<P>&nbsp;if (cpumask_empty(cpumask))<BR>&nbsp;&nbsp;goto use_dfl;</P>
<P>&nbsp;/* yeap, return possible CPUs in @node that @attrs wants */<BR>&nbsp;cpumask_and(cpumask, attrs-&gt;cpumask, wq_numa_possible_cpumask[node]);<BR>&nbsp;return !cpumask_equal(cpumask, attrs-&gt;cpumask);</P>
<P>use_dfl:<BR>&nbsp;cpumask_copy(cpumask, attrs-&gt;cpumask);<BR>&nbsp;return false;<BR>}</P>
<P>/* install @pwq into @wq's numa_pwq_tbl[] for @node and return the old pwq */<BR>static struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int node,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct pool_workqueue *pwq)<BR>{<BR>&nbsp;struct pool_workqueue *old_pwq;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);<BR>&nbsp;lockdep_assert_held(&amp;wq-&gt;mutex);</P>
<P>&nbsp;/* link_pwq() can handle duplicate calls */<BR>&nbsp;link_pwq(pwq);</P>
<P>&nbsp;old_pwq = rcu_access_pointer(wq-&gt;numa_pwq_tbl[node]);<BR>&nbsp;rcu_assign_pointer(wq-&gt;numa_pwq_tbl[node], pwq);<BR>&nbsp;return old_pwq;<BR>}</P>
<P>/* context to store the prepared attrs &amp; pwqs before applying */<BR>struct apply_wqattrs_ctx {<BR>&nbsp;struct workqueue_struct&nbsp;*wq;&nbsp;&nbsp;/* target workqueue */<BR>&nbsp;struct workqueue_attrs&nbsp;*attrs;&nbsp;&nbsp;/* attrs to apply */<BR>&nbsp;struct list_head&nbsp;list;&nbsp;&nbsp;/* queued for batching commit */<BR>&nbsp;struct pool_workqueue&nbsp;*dfl_pwq;<BR>&nbsp;struct pool_workqueue&nbsp;*pwq_tbl[];<BR>};</P>
<P>/* free the resources after success or abort */<BR>static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)<BR>{<BR>&nbsp;if (ctx) {<BR>&nbsp;&nbsp;int node;</P>
<P>&nbsp;&nbsp;for_each_node(node)<BR>&nbsp;&nbsp;&nbsp;put_pwq_unlocked(ctx-&gt;pwq_tbl[node]);<BR>&nbsp;&nbsp;put_pwq_unlocked(ctx-&gt;dfl_pwq);</P>
<P>&nbsp;&nbsp;free_workqueue_attrs(ctx-&gt;attrs);</P>
<P>&nbsp;&nbsp;kfree(ctx);<BR>&nbsp;}<BR>}</P>
<P>/* allocate the attrs and pwqs for later installation */<BR>static struct apply_wqattrs_ctx *<BR>apply_wqattrs_prepare(struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct workqueue_attrs *attrs)<BR>{<BR>&nbsp;struct apply_wqattrs_ctx *ctx;<BR>&nbsp;struct workqueue_attrs *new_attrs, *tmp_attrs;<BR>&nbsp;int node;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</P>
<P>&nbsp;ctx = kzalloc(sizeof(*ctx) + nr_node_ids * sizeof(ctx-&gt;pwq_tbl[0]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GFP_KERNEL);</P>
<P>&nbsp;new_attrs = alloc_workqueue_attrs(GFP_KERNEL);<BR>&nbsp;tmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);<BR>&nbsp;if (!ctx || !new_attrs || !tmp_attrs)<BR>&nbsp;&nbsp;goto out_free;</P>
<P>&nbsp;/*<BR>&nbsp; * Calculate the attrs of the default pwq.<BR>&nbsp; * If the user configured cpumask doesn't overlap with the<BR>&nbsp; * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.<BR>&nbsp; */<BR>&nbsp;copy_workqueue_attrs(new_attrs, attrs);<BR>&nbsp;cpumask_and(new_attrs-&gt;cpumask, new_attrs-&gt;cpumask, wq_unbound_cpumask);<BR>&nbsp;if (unlikely(cpumask_empty(new_attrs-&gt;cpumask)))<BR>&nbsp;&nbsp;cpumask_copy(new_attrs-&gt;cpumask, wq_unbound_cpumask);</P>
<P>&nbsp;/*<BR>&nbsp; * We may create multiple pwqs with differing cpumasks.&nbsp; Make a<BR>&nbsp; * copy of @new_attrs which will be modified and used to obtain<BR>&nbsp; * pools.<BR>&nbsp; */<BR>&nbsp;copy_workqueue_attrs(tmp_attrs, new_attrs);</P>
<P>&nbsp;/*<BR>&nbsp; * If something goes wrong during CPU up/down, we'll fall back to<BR>&nbsp; * the default pwq covering whole @attrs-&gt;cpumask.&nbsp; Always create<BR>&nbsp; * it even if we don't use it immediately.<BR>&nbsp; */<BR>&nbsp;ctx-&gt;dfl_pwq = alloc_unbound_pwq(wq, new_attrs);<BR>&nbsp;if (!ctx-&gt;dfl_pwq)<BR>&nbsp;&nbsp;goto out_free;</P>
<P>&nbsp;for_each_node(node) {<BR>&nbsp;&nbsp;if (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs-&gt;cpumask)) {<BR>&nbsp;&nbsp;&nbsp;ctx-&gt;pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);<BR>&nbsp;&nbsp;&nbsp;if (!ctx-&gt;pwq_tbl[node])<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out_free;<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;ctx-&gt;dfl_pwq-&gt;refcnt++;<BR>&nbsp;&nbsp;&nbsp;ctx-&gt;pwq_tbl[node] = ctx-&gt;dfl_pwq;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* save the user configured attrs and sanitize it. */<BR>&nbsp;copy_workqueue_attrs(new_attrs, attrs);<BR>&nbsp;cpumask_and(new_attrs-&gt;cpumask, new_attrs-&gt;cpumask, cpu_possible_mask);<BR>&nbsp;ctx-&gt;attrs = new_attrs;</P>
<P>&nbsp;ctx-&gt;wq = wq;<BR>&nbsp;free_workqueue_attrs(tmp_attrs);<BR>&nbsp;return ctx;</P>
<P>out_free:<BR>&nbsp;free_workqueue_attrs(tmp_attrs);<BR>&nbsp;free_workqueue_attrs(new_attrs);<BR>&nbsp;apply_wqattrs_cleanup(ctx);<BR>&nbsp;return NULL;<BR>}</P>
<P>/* set attrs and install prepared pwqs, @ctx points to old pwqs on return */<BR>static void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)<BR>{<BR>&nbsp;int node;</P>
<P>&nbsp;/* all pwqs have been created successfully, let's install'em */<BR>&nbsp;mutex_lock(&amp;ctx-&gt;wq-&gt;mutex);</P>
<P>&nbsp;copy_workqueue_attrs(ctx-&gt;wq-&gt;unbound_attrs, ctx-&gt;attrs);</P>
<P>&nbsp;/* save the previous pwq and install the new one */<BR>&nbsp;for_each_node(node)<BR>&nbsp;&nbsp;ctx-&gt;pwq_tbl[node] = numa_pwq_tbl_install(ctx-&gt;wq, node,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx-&gt;pwq_tbl[node]);</P>
<P>&nbsp;/* @dfl_pwq might not have been used, ensure it's linked */<BR>&nbsp;link_pwq(ctx-&gt;dfl_pwq);<BR>&nbsp;swap(ctx-&gt;wq-&gt;dfl_pwq, ctx-&gt;dfl_pwq);</P>
<P>&nbsp;mutex_unlock(&amp;ctx-&gt;wq-&gt;mutex);<BR>}</P>
<P>static void apply_wqattrs_lock(void)<BR>{<BR>&nbsp;/* CPUs should stay stable across pwq creations and installations */<BR>&nbsp;get_online_cpus();<BR>&nbsp;mutex_lock(&amp;wq_pool_mutex);<BR>}</P>
<P>static void apply_wqattrs_unlock(void)<BR>{<BR>&nbsp;mutex_unlock(&amp;wq_pool_mutex);<BR>&nbsp;put_online_cpus();<BR>}</P>
<P>static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const struct workqueue_attrs *attrs)<BR>{<BR>&nbsp;struct apply_wqattrs_ctx *ctx;<BR>&nbsp;int ret = -ENOMEM;</P>
<P>&nbsp;/* only unbound workqueues can change attributes */<BR>&nbsp;if (WARN_ON(!(wq-&gt;flags &amp; WQ_UNBOUND)))<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;/* creating multiple pwqs breaks ordering guarantee */<BR>&nbsp;if (WARN_ON((wq-&gt;flags &amp; __WQ_ORDERED) &amp;&amp; !list_empty(&amp;wq-&gt;pwqs)))<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;ctx = apply_wqattrs_prepare(wq, attrs);</P>
<P>&nbsp;/* the ctx has been prepared successfully, let's commit it */<BR>&nbsp;if (ctx) {<BR>&nbsp;&nbsp;apply_wqattrs_commit(ctx);<BR>&nbsp;&nbsp;ret = 0;<BR>&nbsp;}</P>
<P>&nbsp;apply_wqattrs_cleanup(ctx);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;* apply_workqueue_attrs - apply new workqueue_attrs to an unbound workqueue<BR>&nbsp;* @wq: the target workqueue<BR>&nbsp;* @attrs: the workqueue_attrs to apply, allocated with alloc_workqueue_attrs()<BR>&nbsp;*<BR>&nbsp;* Apply @attrs to an unbound workqueue @wq.&nbsp; Unless disabled, on NUMA<BR>&nbsp;* machines, this function maps a separate pwq to each NUMA node with<BR>&nbsp;* possibles CPUs in @attrs-&gt;cpumask so that work items are affine to the<BR>&nbsp;* NUMA node it was issued on.&nbsp; Older pwqs are released as in-flight work<BR>&nbsp;* items finish.&nbsp; Note that a work item which repeatedly requeues itself<BR>&nbsp;* back-to-back will stay on its current pwq.<BR>&nbsp;*<BR>&nbsp;* Performs GFP_KERNEL allocations.<BR>&nbsp;*<BR>&nbsp;* Return: 0 on success and -errno on failure.<BR>&nbsp;*/<BR>int apply_workqueue_attrs(struct workqueue_struct *wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct workqueue_attrs *attrs)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;apply_wqattrs_lock();<BR>&nbsp;ret = apply_workqueue_attrs_locked(wq, attrs);<BR>&nbsp;apply_wqattrs_unlock();</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;* wq_update_unbound_numa - update NUMA affinity of a wq for CPU hot[un]plug<BR>&nbsp;* @wq: the target workqueue<BR>&nbsp;* @cpu: the CPU coming up or going down<BR>&nbsp;* @online: whether @cpu is coming up or going down<BR>&nbsp;*<BR>&nbsp;* This function is to be called from %CPU_DOWN_PREPARE, %CPU_ONLINE and<BR>&nbsp;* %CPU_DOWN_FAILED.&nbsp; @cpu is being hot[un]plugged, update NUMA affinity of<BR>&nbsp;* @wq accordingly.<BR>&nbsp;*<BR>&nbsp;* If NUMA affinity can't be adjusted due to memory allocation failure, it<BR>&nbsp;* falls back to @wq-&gt;dfl_pwq which may not be optimal but is always<BR>&nbsp;* correct.<BR>&nbsp;*<BR>&nbsp;* Note that when the last allowed CPU of a NUMA node goes offline for a<BR>&nbsp;* workqueue with a cpumask spanning multiple nodes, the workers which were<BR>&nbsp;* already executing the work items for the workqueue will lose their CPU<BR>&nbsp;* affinity and may execute on any CPU.&nbsp; This is similar to how per-cpu<BR>&nbsp;* workqueues behave on CPU_DOWN.&nbsp; If a workqueue user wants strict<BR>&nbsp;* affinity, it's the user's responsibility to flush the work item from<BR>&nbsp;* CPU_DOWN_PREPARE.<BR>&nbsp;*/<BR>static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool online)<BR>{<BR>&nbsp;int node = cpu_to_node(cpu);<BR>&nbsp;int cpu_off = online ? -1 : cpu;<BR>&nbsp;struct pool_workqueue *old_pwq = NULL, *pwq;<BR>&nbsp;struct workqueue_attrs *target_attrs;<BR>&nbsp;cpumask_t *cpumask;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</P>
<P>&nbsp;if (!wq_numa_enabled || !(wq-&gt;flags &amp; WQ_UNBOUND) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; wq-&gt;unbound_attrs-&gt;no_numa)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/*<BR>&nbsp; * We don't wanna alloc/free wq_attrs for each wq for each CPU.<BR>&nbsp; * Let's use a preallocated one.&nbsp; The following buf is protected by<BR>&nbsp; * CPU hotplug exclusion.<BR>&nbsp; */<BR>&nbsp;target_attrs = wq_update_unbound_numa_attrs_buf;<BR>&nbsp;cpumask = target_attrs-&gt;cpumask;</P>
<P>&nbsp;copy_workqueue_attrs(target_attrs, wq-&gt;unbound_attrs);<BR>&nbsp;pwq = unbound_pwq_by_node(wq, node);</P>
<P>&nbsp;/*<BR>&nbsp; * Let's determine what needs to be done.&nbsp; If the target cpumask is<BR>&nbsp; * different from the default pwq's, we need to compare it to @pwq's<BR>&nbsp; * and create a new one if they don't match.&nbsp; If the target cpumask<BR>&nbsp; * equals the default pwq's, the default pwq should be used.<BR>&nbsp; */<BR>&nbsp;if (wq_calc_node_cpumask(wq-&gt;dfl_pwq-&gt;pool-&gt;attrs, node, cpu_off, cpumask)) {<BR>&nbsp;&nbsp;if (cpumask_equal(cpumask, pwq-&gt;pool-&gt;attrs-&gt;cpumask))<BR>&nbsp;&nbsp;&nbsp;return;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;goto use_dfl_pwq;<BR>&nbsp;}</P>
<P>&nbsp;/* create a new pwq */<BR>&nbsp;pwq = alloc_unbound_pwq(wq, target_attrs);<BR>&nbsp;if (!pwq) {<BR>&nbsp;&nbsp;pr_warn("workqueue: allocation failed while updating NUMA affinity of \"%s\"\n",<BR>&nbsp;&nbsp;&nbsp;wq-&gt;name);<BR>&nbsp;&nbsp;goto use_dfl_pwq;<BR>&nbsp;}</P>
<P>&nbsp;/* Install the new pwq. */<BR>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;old_pwq = numa_pwq_tbl_install(wq, node, pwq);<BR>&nbsp;goto out_unlock;</P>
<P>use_dfl_pwq:<BR>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;spin_lock_irq(&amp;wq-&gt;dfl_pwq-&gt;pool-&gt;lock);<BR>&nbsp;get_pwq(wq-&gt;dfl_pwq);<BR>&nbsp;spin_unlock_irq(&amp;wq-&gt;dfl_pwq-&gt;pool-&gt;lock);<BR>&nbsp;old_pwq = numa_pwq_tbl_install(wq, node, wq-&gt;dfl_pwq);<BR>out_unlock:<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;put_pwq_unlocked(old_pwq);<BR>}</P>
<P>static int alloc_and_link_pwqs(struct workqueue_struct *wq)<BR>{<BR>&nbsp;bool highpri = wq-&gt;flags &amp; WQ_HIGHPRI;<BR>&nbsp;int cpu, ret;</P>
<P>&nbsp;if (!(wq-&gt;flags &amp; WQ_UNBOUND)) {<BR>&nbsp;&nbsp;wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);<BR>&nbsp;&nbsp;if (!wq-&gt;cpu_pwqs)<BR>&nbsp;&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;&nbsp;for_each_possible_cpu(cpu) {<BR>&nbsp;&nbsp;&nbsp;struct pool_workqueue *pwq =<BR>&nbsp;&nbsp;&nbsp;&nbsp;per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);<BR>&nbsp;&nbsp;&nbsp;struct worker_pool *cpu_pools =<BR>&nbsp;&nbsp;&nbsp;&nbsp;per_cpu(cpu_worker_pools, cpu);</P>
<P>&nbsp;&nbsp;&nbsp;init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</P>
<P>&nbsp;&nbsp;&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;&nbsp;&nbsp;link_pwq(pwq);<BR>&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;} else if (wq-&gt;flags &amp; __WQ_ORDERED) {<BR>&nbsp;&nbsp;ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);<BR>&nbsp;&nbsp;/* there should only be single pwq for ordering guarantee */<BR>&nbsp;&nbsp;WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ordering guarantee broken for workqueue %s\n", wq-&gt;name);<BR>&nbsp;&nbsp;return ret;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;return apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);<BR>&nbsp;}<BR>}</P>
<P>static int wq_clamp_max_active(int max_active, unsigned int flags,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name)<BR>{<BR>&nbsp;int lim = flags &amp; WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;</P>
<P>&nbsp;if (max_active &lt; 1 || max_active &gt; lim)<BR>&nbsp;&nbsp;pr_warn("workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\n",<BR>&nbsp;&nbsp;&nbsp;max_active, name, 1, lim);</P>
<P>&nbsp;return clamp_val(max_active, 1, lim);<BR>}</P>
<P>struct workqueue_struct *__alloc_workqueue_key(const char *fmt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int flags,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int max_active,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct lock_class_key *key,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *lock_name, ...)<BR>{<BR>&nbsp;size_t tbl_size = 0;<BR>&nbsp;va_list args;<BR>&nbsp;struct workqueue_struct *wq;<BR>&nbsp;struct pool_workqueue *pwq;</P>
<P>&nbsp;/* see the comment above the definition of WQ_POWER_EFFICIENT */<BR>&nbsp;if ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)<BR>&nbsp;&nbsp;flags |= WQ_UNBOUND;</P>
<P>&nbsp;/* allocate wq and format name */<BR>&nbsp;if (flags &amp; WQ_UNBOUND)<BR>&nbsp;&nbsp;tbl_size = nr_node_ids * sizeof(wq-&gt;numa_pwq_tbl[0]);</P>
<P>&nbsp;wq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);<BR>&nbsp;if (!wq)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;if (flags &amp; WQ_UNBOUND) {<BR>&nbsp;&nbsp;wq-&gt;unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);<BR>&nbsp;&nbsp;if (!wq-&gt;unbound_attrs)<BR>&nbsp;&nbsp;&nbsp;goto err_free_wq;<BR>&nbsp;}</P>
<P>&nbsp;va_start(args, lock_name);<BR>&nbsp;vsnprintf(wq-&gt;name, sizeof(wq-&gt;name), fmt, args);<BR>&nbsp;va_end(args);</P>
<P>&nbsp;max_active = max_active ?: WQ_DFL_ACTIVE;<BR>&nbsp;max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</P>
<P>&nbsp;/* init wq */<BR>&nbsp;wq-&gt;flags = flags;<BR>&nbsp;wq-&gt;saved_max_active = max_active;<BR>&nbsp;mutex_init(&amp;wq-&gt;mutex);<BR>&nbsp;atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, 0);<BR>&nbsp;INIT_LIST_HEAD(&amp;wq-&gt;pwqs);<BR>&nbsp;INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);<BR>&nbsp;INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);<BR>&nbsp;INIT_LIST_HEAD(&amp;wq-&gt;maydays);</P>
<P>&nbsp;lockdep_init_map(&amp;wq-&gt;lockdep_map, lock_name, key, 0);<BR>&nbsp;INIT_LIST_HEAD(&amp;wq-&gt;list);</P>
<P>&nbsp;if (alloc_and_link_pwqs(wq) &lt; 0)<BR>&nbsp;&nbsp;goto err_free_wq;</P>
<P>&nbsp;/*<BR>&nbsp; * Workqueues which may be used during memory reclaim should<BR>&nbsp; * have a rescuer to guarantee forward progress.<BR>&nbsp; */<BR>&nbsp;if (flags &amp; WQ_MEM_RECLAIM) {<BR>&nbsp;&nbsp;struct worker *rescuer;</P>
<P>&nbsp;&nbsp;rescuer = alloc_worker(NUMA_NO_NODE);<BR>&nbsp;&nbsp;if (!rescuer)<BR>&nbsp;&nbsp;&nbsp;goto err_destroy;</P>
<P>&nbsp;&nbsp;rescuer-&gt;rescue_wq = wq;<BR>&nbsp;&nbsp;rescuer-&gt;task = kthread_create(rescuer_thread, rescuer, "%s",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wq-&gt;name);<BR>&nbsp;&nbsp;if (IS_ERR(rescuer-&gt;task)) {<BR>&nbsp;&nbsp;&nbsp;kfree(rescuer);<BR>&nbsp;&nbsp;&nbsp;goto err_destroy;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;wq-&gt;rescuer = rescuer;<BR>&nbsp;&nbsp;rescuer-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;<BR>&nbsp;&nbsp;wake_up_process(rescuer-&gt;task);<BR>&nbsp;}</P>
<P>&nbsp;if ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))<BR>&nbsp;&nbsp;goto err_destroy;</P>
<P>&nbsp;/*<BR>&nbsp; * wq_pool_mutex protects global freeze state and workqueues list.<BR>&nbsp; * Grab it, adjust max_active and add the new @wq to workqueues<BR>&nbsp; * list.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;wq_pool_mutex);</P>
<P>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;for_each_pwq(pwq, wq)<BR>&nbsp;&nbsp;pwq_adjust_max_active(pwq);<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;list_add_tail_rcu(&amp;wq-&gt;list, &amp;workqueues);</P>
<P>&nbsp;mutex_unlock(&amp;wq_pool_mutex);</P>
<P>&nbsp;return wq;</P>
<P>err_free_wq:<BR>&nbsp;free_workqueue_attrs(wq-&gt;unbound_attrs);<BR>&nbsp;kfree(wq);<BR>&nbsp;return NULL;<BR>err_destroy:<BR>&nbsp;destroy_workqueue(wq);<BR>&nbsp;return NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(__alloc_workqueue_key);</P>
<P>/**<BR>&nbsp;* destroy_workqueue - safely terminate a workqueue<BR>&nbsp;* @wq: target workqueue<BR>&nbsp;*<BR>&nbsp;* Safely destroy a workqueue. All work currently pending will be done first.<BR>&nbsp;*/<BR>void destroy_workqueue(struct workqueue_struct *wq)<BR>{<BR>&nbsp;struct pool_workqueue *pwq;<BR>&nbsp;int node;</P>
<P>&nbsp;/* drain it before proceeding with destruction */<BR>&nbsp;drain_workqueue(wq);</P>
<P>&nbsp;/* sanity checks */<BR>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;for_each_pwq(pwq, wq) {<BR>&nbsp;&nbsp;int i;</P>
<P>&nbsp;&nbsp;for (i = 0; i &lt; WORK_NR_COLORS; i++) {<BR>&nbsp;&nbsp;&nbsp;if (WARN_ON(pwq-&gt;nr_in_flight[i])) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (WARN_ON((pwq != wq-&gt;dfl_pwq) &amp;&amp; (pwq-&gt;refcnt &gt; 1)) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(pwq-&gt;nr_active) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(!list_empty(&amp;pwq-&gt;delayed_works))) {<BR>&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;&nbsp;&nbsp;return;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;/*<BR>&nbsp; * wq list is used to freeze wq, remove from list after<BR>&nbsp; * flushing is complete in case freeze races us.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;wq_pool_mutex);<BR>&nbsp;list_del_rcu(&amp;wq-&gt;list);<BR>&nbsp;mutex_unlock(&amp;wq_pool_mutex);</P>
<P>&nbsp;workqueue_sysfs_unregister(wq);</P>
<P>&nbsp;if (wq-&gt;rescuer)<BR>&nbsp;&nbsp;kthread_stop(wq-&gt;rescuer-&gt;task);</P>
<P>&nbsp;if (!(wq-&gt;flags &amp; WQ_UNBOUND)) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * The base ref is never dropped on per-cpu pwqs.&nbsp; Directly<BR>&nbsp;&nbsp; * schedule RCU free.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;call_rcu_sched(&amp;wq-&gt;rcu, rcu_free_wq);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * We're the sole accessor of @wq at this point.&nbsp; Directly<BR>&nbsp;&nbsp; * access numa_pwq_tbl[] and dfl_pwq to put the base refs.<BR>&nbsp;&nbsp; * @wq will be freed when the last pwq is released.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;for_each_node(node) {<BR>&nbsp;&nbsp;&nbsp;pwq = rcu_access_pointer(wq-&gt;numa_pwq_tbl[node]);<BR>&nbsp;&nbsp;&nbsp;RCU_INIT_POINTER(wq-&gt;numa_pwq_tbl[node], NULL);<BR>&nbsp;&nbsp;&nbsp;put_pwq_unlocked(pwq);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Put dfl_pwq.&nbsp; @wq may be freed any time after dfl_pwq is<BR>&nbsp;&nbsp; * put.&nbsp; Don't access it afterwards.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;pwq = wq-&gt;dfl_pwq;<BR>&nbsp;&nbsp;wq-&gt;dfl_pwq = NULL;<BR>&nbsp;&nbsp;put_pwq_unlocked(pwq);<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(destroy_workqueue);</P>
<P>/**<BR>&nbsp;* workqueue_set_max_active - adjust max_active of a workqueue<BR>&nbsp;* @wq: target workqueue<BR>&nbsp;* @max_active: new max_active value.<BR>&nbsp;*<BR>&nbsp;* Set max_active of @wq to @max_active.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* Don't call from IRQ context.<BR>&nbsp;*/<BR>void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)<BR>{<BR>&nbsp;struct pool_workqueue *pwq;</P>
<P>&nbsp;/* disallow meddling with max_active for ordered workqueues */<BR>&nbsp;if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;max_active = wq_clamp_max_active(max_active, wq-&gt;flags, wq-&gt;name);</P>
<P>&nbsp;mutex_lock(&amp;wq-&gt;mutex);</P>
<P>&nbsp;wq-&gt;saved_max_active = max_active;</P>
<P>&nbsp;for_each_pwq(pwq, wq)<BR>&nbsp;&nbsp;pwq_adjust_max_active(pwq);</P>
<P>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>}<BR>EXPORT_SYMBOL_GPL(workqueue_set_max_active);</P>
<P>/**<BR>&nbsp;* current_is_workqueue_rescuer - is %current workqueue rescuer?<BR>&nbsp;*<BR>&nbsp;* Determine whether %current is a workqueue rescuer.&nbsp; Can be used from<BR>&nbsp;* work functions to determine whether it's being run off the rescuer task.<BR>&nbsp;*<BR>&nbsp;* Return: %true if %current is a workqueue rescuer. %false otherwise.<BR>&nbsp;*/<BR>bool current_is_workqueue_rescuer(void)<BR>{<BR>&nbsp;struct worker *worker = current_wq_worker();</P>
<P>&nbsp;return worker &amp;&amp; worker-&gt;rescue_wq;<BR>}</P>
<P>/**<BR>&nbsp;* workqueue_congested - test whether a workqueue is congested<BR>&nbsp;* @cpu: CPU in question<BR>&nbsp;* @wq: target workqueue<BR>&nbsp;*<BR>&nbsp;* Test whether @wq's cpu workqueue for @cpu is congested.&nbsp; There is<BR>&nbsp;* no synchronization around this function and the test result is<BR>&nbsp;* unreliable and only useful as advisory hints or for debugging.<BR>&nbsp;*<BR>&nbsp;* If @cpu is WORK_CPU_UNBOUND, the test is performed on the local CPU.<BR>&nbsp;* Note that both per-cpu and unbound workqueues may be associated with<BR>&nbsp;* multiple pool_workqueues which have separate congested states.&nbsp; A<BR>&nbsp;* workqueue being congested on one CPU doesn't mean the workqueue is also<BR>&nbsp;* contested on other CPUs / NUMA nodes.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %true if congested, %false otherwise.<BR>&nbsp;*/<BR>bool workqueue_congested(int cpu, struct workqueue_struct *wq)<BR>{<BR>&nbsp;struct pool_workqueue *pwq;<BR>&nbsp;bool ret;</P>
<P>&nbsp;rcu_read_lock_sched();</P>
<P>&nbsp;if (cpu == WORK_CPU_UNBOUND)<BR>&nbsp;&nbsp;cpu = smp_processor_id();</P>
<P>&nbsp;if (!(wq-&gt;flags &amp; WQ_UNBOUND))<BR>&nbsp;&nbsp;pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);<BR>&nbsp;else<BR>&nbsp;&nbsp;pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</P>
<P>&nbsp;ret = !list_empty(&amp;pwq-&gt;delayed_works);<BR>&nbsp;rcu_read_unlock_sched();</P>
<P>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(workqueue_congested);</P>
<P>/**<BR>&nbsp;* work_busy - test whether a work is currently pending or running<BR>&nbsp;* @work: the work to be tested<BR>&nbsp;*<BR>&nbsp;* Test whether @work is currently pending or running.&nbsp; There is no<BR>&nbsp;* synchronization around this function and the test result is<BR>&nbsp;* unreliable and only useful as advisory hints or for debugging.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* OR'd bitmask of WORK_BUSY_* bits.<BR>&nbsp;*/<BR>unsigned int work_busy(struct work_struct *work)<BR>{<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;unsigned long flags;<BR>&nbsp;unsigned int ret = 0;</P>
<P>&nbsp;if (work_pending(work))<BR>&nbsp;&nbsp;ret |= WORK_BUSY_PENDING;</P>
<P>&nbsp;local_irq_save(flags);<BR>&nbsp;pool = get_work_pool(work);<BR>&nbsp;if (pool) {<BR>&nbsp;&nbsp;spin_lock(&amp;pool-&gt;lock);<BR>&nbsp;&nbsp;if (find_worker_executing_work(pool, work))<BR>&nbsp;&nbsp;&nbsp;ret |= WORK_BUSY_RUNNING;<BR>&nbsp;&nbsp;spin_unlock(&amp;pool-&gt;lock);<BR>&nbsp;}<BR>&nbsp;local_irq_restore(flags);</P>
<P>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(work_busy);</P>
<P>/**<BR>&nbsp;* set_worker_desc - set description for the current work item<BR>&nbsp;* @fmt: printf-style format string<BR>&nbsp;* @...: arguments for the format string<BR>&nbsp;*<BR>&nbsp;* This function can be called by a running work function to describe what<BR>&nbsp;* the work item is about.&nbsp; If the worker task gets dumped, this<BR>&nbsp;* information will be printed out together to help debugging.&nbsp; The<BR>&nbsp;* description can be at most WORKER_DESC_LEN including the trailing '\0'.<BR>&nbsp;*/<BR>void set_worker_desc(const char *fmt, ...)<BR>{<BR>&nbsp;struct worker *worker = current_wq_worker();<BR>&nbsp;va_list args;</P>
<P>&nbsp;if (worker) {<BR>&nbsp;&nbsp;va_start(args, fmt);<BR>&nbsp;&nbsp;vsnprintf(worker-&gt;desc, sizeof(worker-&gt;desc), fmt, args);<BR>&nbsp;&nbsp;va_end(args);<BR>&nbsp;&nbsp;worker-&gt;desc_valid = true;<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* print_worker_info - print out worker information and description<BR>&nbsp;* @log_lvl: the log level to use when printing<BR>&nbsp;* @task: target task<BR>&nbsp;*<BR>&nbsp;* If @task is a worker and currently executing a work item, print out the<BR>&nbsp;* name of the workqueue being serviced and worker description set with<BR>&nbsp;* set_worker_desc() by the currently executing work item.<BR>&nbsp;*<BR>&nbsp;* This function can be safely called on any task as long as the<BR>&nbsp;* task_struct itself is accessible.&nbsp; While safe, this function isn't<BR>&nbsp;* synchronized and may print out mixups or garbages of limited length.<BR>&nbsp;*/<BR>void print_worker_info(const char *log_lvl, struct task_struct *task)<BR>{<BR>&nbsp;work_func_t *fn = NULL;<BR>&nbsp;char name[WQ_NAME_LEN] = { };<BR>&nbsp;char desc[WORKER_DESC_LEN] = { };<BR>&nbsp;struct pool_workqueue *pwq = NULL;<BR>&nbsp;struct workqueue_struct *wq = NULL;<BR>&nbsp;bool desc_valid = false;<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;if (!(task-&gt;flags &amp; PF_WQ_WORKER))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/*<BR>&nbsp; * This function is called without any synchronization and @task<BR>&nbsp; * could be in any state.&nbsp; Be careful with dereferences.<BR>&nbsp; */<BR>&nbsp;worker = probe_kthread_data(task);</P>
<P>&nbsp;/*<BR>&nbsp; * Carefully copy the associated workqueue's workfn and name.&nbsp; Keep<BR>&nbsp; * the original last '\0' in case the original contains garbage.<BR>&nbsp; */<BR>&nbsp;probe_kernel_read(&amp;fn, &amp;worker-&gt;current_func, sizeof(fn));<BR>&nbsp;probe_kernel_read(&amp;pwq, &amp;worker-&gt;current_pwq, sizeof(pwq));<BR>&nbsp;probe_kernel_read(&amp;wq, &amp;pwq-&gt;wq, sizeof(wq));<BR>&nbsp;probe_kernel_read(name, wq-&gt;name, sizeof(name) - 1);</P>
<P>&nbsp;/* copy worker description */<BR>&nbsp;probe_kernel_read(&amp;desc_valid, &amp;worker-&gt;desc_valid, sizeof(desc_valid));<BR>&nbsp;if (desc_valid)<BR>&nbsp;&nbsp;probe_kernel_read(desc, worker-&gt;desc, sizeof(desc) - 1);</P>
<P>&nbsp;if (fn || name[0] || desc[0]) {<BR>&nbsp;&nbsp;printk("%sWorkqueue: %s %pf", log_lvl, name, fn);<BR>&nbsp;&nbsp;if (desc[0])<BR>&nbsp;&nbsp;&nbsp;pr_cont(" (%s)", desc);<BR>&nbsp;&nbsp;pr_cont("\n");<BR>&nbsp;}<BR>}</P>
<P>static void pr_cont_pool_info(struct worker_pool *pool)<BR>{<BR>&nbsp;pr_cont(" cpus=%*pbl", nr_cpumask_bits, pool-&gt;attrs-&gt;cpumask);<BR>&nbsp;if (pool-&gt;node != NUMA_NO_NODE)<BR>&nbsp;&nbsp;pr_cont(" node=%d", pool-&gt;node);<BR>&nbsp;pr_cont(" flags=0x%x nice=%d", pool-&gt;flags, pool-&gt;attrs-&gt;nice);<BR>}</P>
<P>static void pr_cont_work(bool comma, struct work_struct *work)<BR>{<BR>&nbsp;if (work-&gt;func == wq_barrier_func) {<BR>&nbsp;&nbsp;struct wq_barrier *barr;</P>
<P>&nbsp;&nbsp;barr = container_of(work, struct wq_barrier, work);</P>
<P>&nbsp;&nbsp;pr_cont("%s BAR(%d)", comma ? "," : "",<BR>&nbsp;&nbsp;&nbsp;task_pid_nr(barr-&gt;task));<BR>&nbsp;} else {<BR>&nbsp;&nbsp;pr_cont("%s %pf", comma ? "," : "", work-&gt;func);<BR>&nbsp;}<BR>}</P>
<P>static void show_pwq(struct pool_workqueue *pwq)<BR>{<BR>&nbsp;struct worker_pool *pool = pwq-&gt;pool;<BR>&nbsp;struct work_struct *work;<BR>&nbsp;struct worker *worker;<BR>&nbsp;bool has_in_flight = false, has_pending = false;<BR>&nbsp;int bkt;</P>
<P>&nbsp;pr_info("&nbsp; pwq %d:", pool-&gt;id);<BR>&nbsp;pr_cont_pool_info(pool);</P>
<P>&nbsp;pr_cont(" active=%d/%d%s\n", pwq-&gt;nr_active, pwq-&gt;max_active,<BR>&nbsp;&nbsp;!list_empty(&amp;pwq-&gt;mayday_node) ? " MAYDAY" : "");</P>
<P>&nbsp;hash_for_each(pool-&gt;busy_hash, bkt, worker, hentry) {<BR>&nbsp;&nbsp;if (worker-&gt;current_pwq == pwq) {<BR>&nbsp;&nbsp;&nbsp;has_in_flight = true;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;if (has_in_flight) {<BR>&nbsp;&nbsp;bool comma = false;</P>
<P>&nbsp;&nbsp;pr_info("&nbsp;&nbsp;&nbsp; in-flight:");<BR>&nbsp;&nbsp;hash_for_each(pool-&gt;busy_hash, bkt, worker, hentry) {<BR>&nbsp;&nbsp;&nbsp;if (worker-&gt;current_pwq != pwq)<BR>&nbsp;&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;&nbsp;pr_cont("%s %d%s:%pf", comma ? "," : "",<BR>&nbsp;&nbsp;&nbsp;&nbsp;task_pid_nr(worker-&gt;task),<BR>&nbsp;&nbsp;&nbsp;&nbsp;worker == pwq-&gt;wq-&gt;rescuer ? "(RESCUER)" : "",<BR>&nbsp;&nbsp;&nbsp;&nbsp;worker-&gt;current_func);<BR>&nbsp;&nbsp;&nbsp;list_for_each_entry(work, &amp;worker-&gt;scheduled, entry)<BR>&nbsp;&nbsp;&nbsp;&nbsp;pr_cont_work(false, work);<BR>&nbsp;&nbsp;&nbsp;comma = true;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;pr_cont("\n");<BR>&nbsp;}</P>
<P>&nbsp;list_for_each_entry(work, &amp;pool-&gt;worklist, entry) {<BR>&nbsp;&nbsp;if (get_work_pwq(work) == pwq) {<BR>&nbsp;&nbsp;&nbsp;has_pending = true;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;if (has_pending) {<BR>&nbsp;&nbsp;bool comma = false;</P>
<P>&nbsp;&nbsp;pr_info("&nbsp;&nbsp;&nbsp; pending:");<BR>&nbsp;&nbsp;list_for_each_entry(work, &amp;pool-&gt;worklist, entry) {<BR>&nbsp;&nbsp;&nbsp;if (get_work_pwq(work) != pwq)<BR>&nbsp;&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;&nbsp;pr_cont_work(comma, work);<BR>&nbsp;&nbsp;&nbsp;comma = !(*work_data_bits(work) &amp; WORK_STRUCT_LINKED);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;pr_cont("\n");<BR>&nbsp;}</P>
<P>&nbsp;if (!list_empty(&amp;pwq-&gt;delayed_works)) {<BR>&nbsp;&nbsp;bool comma = false;</P>
<P>&nbsp;&nbsp;pr_info("&nbsp;&nbsp;&nbsp; delayed:");<BR>&nbsp;&nbsp;list_for_each_entry(work, &amp;pwq-&gt;delayed_works, entry) {<BR>&nbsp;&nbsp;&nbsp;pr_cont_work(comma, work);<BR>&nbsp;&nbsp;&nbsp;comma = !(*work_data_bits(work) &amp; WORK_STRUCT_LINKED);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;pr_cont("\n");<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* show_workqueue_state - dump workqueue state<BR>&nbsp;*<BR>&nbsp;* Called from a sysrq handler and prints out all busy workqueues and<BR>&nbsp;* pools.<BR>&nbsp;*/<BR>void show_workqueue_state(void)<BR>{<BR>&nbsp;struct workqueue_struct *wq;<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;unsigned long flags;<BR>&nbsp;int pi;</P>
<P>&nbsp;rcu_read_lock_sched();</P>
<P>&nbsp;pr_info("Showing busy workqueues and worker pools:\n");</P>
<P>&nbsp;list_for_each_entry_rcu(wq, &amp;workqueues, list) {<BR>&nbsp;&nbsp;struct pool_workqueue *pwq;<BR>&nbsp;&nbsp;bool idle = true;</P>
<P>&nbsp;&nbsp;for_each_pwq(pwq, wq) {<BR>&nbsp;&nbsp;&nbsp;if (pwq-&gt;nr_active || !list_empty(&amp;pwq-&gt;delayed_works)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;idle = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if (idle)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;pr_info("workqueue %s: flags=0x%x\n", wq-&gt;name, wq-&gt;flags);</P>
<P>&nbsp;&nbsp;for_each_pwq(pwq, wq) {<BR>&nbsp;&nbsp;&nbsp;spin_lock_irqsave(&amp;pwq-&gt;pool-&gt;lock, flags);<BR>&nbsp;&nbsp;&nbsp;if (pwq-&gt;nr_active || !list_empty(&amp;pwq-&gt;delayed_works))<BR>&nbsp;&nbsp;&nbsp;&nbsp;show_pwq(pwq);<BR>&nbsp;&nbsp;&nbsp;spin_unlock_irqrestore(&amp;pwq-&gt;pool-&gt;lock, flags);<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;for_each_pool(pool, pi) {<BR>&nbsp;&nbsp;struct worker *worker;<BR>&nbsp;&nbsp;bool first = true;</P>
<P>&nbsp;&nbsp;spin_lock_irqsave(&amp;pool-&gt;lock, flags);<BR>&nbsp;&nbsp;if (pool-&gt;nr_workers == pool-&gt;nr_idle)<BR>&nbsp;&nbsp;&nbsp;goto next_pool;</P>
<P>&nbsp;&nbsp;pr_info("pool %d:", pool-&gt;id);<BR>&nbsp;&nbsp;pr_cont_pool_info(pool);<BR>&nbsp;&nbsp;pr_cont(" workers=%d", pool-&gt;nr_workers);<BR>&nbsp;&nbsp;if (pool-&gt;manager)<BR>&nbsp;&nbsp;&nbsp;pr_cont(" manager: %d",<BR>&nbsp;&nbsp;&nbsp;&nbsp;task_pid_nr(pool-&gt;manager-&gt;task));<BR>&nbsp;&nbsp;list_for_each_entry(worker, &amp;pool-&gt;idle_list, entry) {<BR>&nbsp;&nbsp;&nbsp;pr_cont(" %s%d", first ? "idle: " : "",<BR>&nbsp;&nbsp;&nbsp;&nbsp;task_pid_nr(worker-&gt;task));<BR>&nbsp;&nbsp;&nbsp;first = false;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;pr_cont("\n");<BR>&nbsp;next_pool:<BR>&nbsp;&nbsp;spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);<BR>&nbsp;}</P>
<P>&nbsp;rcu_read_unlock_sched();<BR>}</P>
<P>/*<BR>&nbsp;* CPU hotplug.<BR>&nbsp;*<BR>&nbsp;* There are two challenges in supporting CPU hotplug.&nbsp; Firstly, there<BR>&nbsp;* are a lot of assumptions on strong associations among work, pwq and<BR>&nbsp;* pool which make migrating pending and scheduled works very<BR>&nbsp;* difficult to implement without impacting hot paths.&nbsp; Secondly,<BR>&nbsp;* worker pools serve mix of short, long and very long running works making<BR>&nbsp;* blocked draining impractical.<BR>&nbsp;*<BR>&nbsp;* This is solved by allowing the pools to be disassociated from the CPU<BR>&nbsp;* running as an unbound one and allowing it to be reattached later if the<BR>&nbsp;* cpu comes back online.<BR>&nbsp;*/</P>
<P>static void wq_unbind_fn(struct work_struct *work)<BR>{<BR>&nbsp;int cpu = smp_processor_id();<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;for_each_cpu_worker_pool(pool, cpu) {<BR>&nbsp;&nbsp;mutex_lock(&amp;pool-&gt;attach_mutex);<BR>&nbsp;&nbsp;spin_lock_irq(&amp;pool-&gt;lock);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * We've blocked all attach/detach operations. Make all workers<BR>&nbsp;&nbsp; * unbound and set DISASSOCIATED.&nbsp; Before this, all workers<BR>&nbsp;&nbsp; * except for the ones which are still executing works from<BR>&nbsp;&nbsp; * before the last CPU down must be on the cpu.&nbsp; After<BR>&nbsp;&nbsp; * this, they may become diasporas.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;for_each_pool_worker(worker, pool)<BR>&nbsp;&nbsp;&nbsp;worker-&gt;flags |= WORKER_UNBOUND;</P>
<P>&nbsp;&nbsp;pool-&gt;flags |= POOL_DISASSOCIATED;</P>
<P>&nbsp;&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>&nbsp;&nbsp;mutex_unlock(&amp;pool-&gt;attach_mutex);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Call schedule() so that we cross rq-&gt;lock and thus can<BR>&nbsp;&nbsp; * guarantee sched callbacks see the %WORKER_UNBOUND flag.<BR>&nbsp;&nbsp; * This is necessary as scheduler callbacks may be invoked<BR>&nbsp;&nbsp; * from other cpus.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;schedule();</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Sched callbacks are disabled now.&nbsp; Zap nr_running.<BR>&nbsp;&nbsp; * After this, nr_running stays zero and need_more_worker()<BR>&nbsp;&nbsp; * and keep_working() are always true as long as the<BR>&nbsp;&nbsp; * worklist is not empty.&nbsp; This pool now behaves as an<BR>&nbsp;&nbsp; * unbound (in terms of concurrency management) pool which<BR>&nbsp;&nbsp; * are served by workers tied to the pool.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;atomic_set(&amp;pool-&gt;nr_running, 0);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * With concurrency management just turned off, a busy<BR>&nbsp;&nbsp; * worker blocking could lead to lengthy stalls.&nbsp; Kick off<BR>&nbsp;&nbsp; * unbound chain execution of currently pending work items.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;spin_lock_irq(&amp;pool-&gt;lock);<BR>&nbsp;&nbsp;wake_up_worker(pool);<BR>&nbsp;&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* rebind_workers - rebind all workers of a pool to the associated CPU<BR>&nbsp;* @pool: pool of interest<BR>&nbsp;*<BR>&nbsp;* @pool-&gt;cpu is coming online.&nbsp; Rebind all workers to the CPU.<BR>&nbsp;*/<BR>static void rebind_workers(struct worker_pool *pool)<BR>{<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;lockdep_assert_held(&amp;pool-&gt;attach_mutex);</P>
<P>&nbsp;/*<BR>&nbsp; * Restore CPU affinity of all workers.&nbsp; As all idle workers should<BR>&nbsp; * be on the run-queue of the associated CPU before any local<BR>&nbsp; * wake-ups for concurrency management happen, restore CPU affinity<BR>&nbsp; * of all workers first and then clear UNBOUND.&nbsp; As we're called<BR>&nbsp; * from CPU_ONLINE, the following shouldn't fail.<BR>&nbsp; */<BR>&nbsp;for_each_pool_worker(worker, pool)<BR>&nbsp;&nbsp;WARN_ON_ONCE(set_cpus_allowed_ptr(worker-&gt;task,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool-&gt;attrs-&gt;cpumask) &lt; 0);</P>
<P>&nbsp;spin_lock_irq(&amp;pool-&gt;lock);<BR>&nbsp;pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</P>
<P>&nbsp;for_each_pool_worker(worker, pool) {<BR>&nbsp;&nbsp;unsigned int worker_flags = worker-&gt;flags;</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * A bound idle worker should actually be on the runqueue<BR>&nbsp;&nbsp; * of the associated CPU for local wake-ups targeting it to<BR>&nbsp;&nbsp; * work.&nbsp; Kick all idle workers so that they migrate to the<BR>&nbsp;&nbsp; * associated CPU.&nbsp; Doing this in the same loop as<BR>&nbsp;&nbsp; * replacing UNBOUND with REBOUND is safe as no worker will<BR>&nbsp;&nbsp; * be bound before @pool-&gt;lock is released.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (worker_flags &amp; WORKER_IDLE)<BR>&nbsp;&nbsp;&nbsp;wake_up_process(worker-&gt;task);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * We want to clear UNBOUND but can't directly call<BR>&nbsp;&nbsp; * worker_clr_flags() or adjust nr_running.&nbsp; Atomically<BR>&nbsp;&nbsp; * replace UNBOUND with another NOT_RUNNING flag REBOUND.<BR>&nbsp;&nbsp; * @worker will clear REBOUND using worker_clr_flags() when<BR>&nbsp;&nbsp; * it initiates the next execution cycle thus restoring<BR>&nbsp;&nbsp; * concurrency management.&nbsp; Note that when or whether<BR>&nbsp;&nbsp; * @worker clears REBOUND doesn't affect correctness.<BR>&nbsp;&nbsp; *<BR>&nbsp;&nbsp; * ACCESS_ONCE() is necessary because @worker-&gt;flags may be<BR>&nbsp;&nbsp; * tested without holding any lock in<BR>&nbsp;&nbsp; * wq_worker_waking_up().&nbsp; Without it, NOT_RUNNING test may<BR>&nbsp;&nbsp; * fail incorrectly leading to premature concurrency<BR>&nbsp;&nbsp; * management operations.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;WARN_ON_ONCE(!(worker_flags &amp; WORKER_UNBOUND));<BR>&nbsp;&nbsp;worker_flags |= WORKER_REBOUND;<BR>&nbsp;&nbsp;worker_flags &amp;= ~WORKER_UNBOUND;<BR>&nbsp;&nbsp;ACCESS_ONCE(worker-&gt;flags) = worker_flags;<BR>&nbsp;}</P>
<P>&nbsp;spin_unlock_irq(&amp;pool-&gt;lock);<BR>}</P>
<P>/**<BR>&nbsp;* restore_unbound_workers_cpumask - restore cpumask of unbound workers<BR>&nbsp;* @pool: unbound pool of interest<BR>&nbsp;* @cpu: the CPU which is coming up<BR>&nbsp;*<BR>&nbsp;* An unbound pool may end up with a cpumask which doesn't have any online<BR>&nbsp;* CPUs.&nbsp; When a worker of such pool get scheduled, the scheduler resets<BR>&nbsp;* its cpus_allowed.&nbsp; If @cpu is in @pool's cpumask which didn't have any<BR>&nbsp;* online CPU before, cpus_allowed of all its workers should be restored.<BR>&nbsp;*/<BR>static void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)<BR>{<BR>&nbsp;static cpumask_t cpumask;<BR>&nbsp;struct worker *worker;</P>
<P>&nbsp;lockdep_assert_held(&amp;pool-&gt;attach_mutex);</P>
<P>&nbsp;/* is @cpu allowed for @pool? */<BR>&nbsp;if (!cpumask_test_cpu(cpu, pool-&gt;attrs-&gt;cpumask))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* is @cpu the only online CPU? */<BR>&nbsp;cpumask_and(&amp;cpumask, pool-&gt;attrs-&gt;cpumask, cpu_online_mask);<BR>&nbsp;if (cpumask_weight(&amp;cpumask) != 1)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* as we're called from CPU_ONLINE, the following shouldn't fail */<BR>&nbsp;for_each_pool_worker(worker, pool)<BR>&nbsp;&nbsp;WARN_ON_ONCE(set_cpus_allowed_ptr(worker-&gt;task,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool-&gt;attrs-&gt;cpumask) &lt; 0);<BR>}</P>
<P>/*<BR>&nbsp;* Workqueues should be brought up before normal priority CPU notifiers.<BR>&nbsp;* This will be registered high priority CPU notifier.<BR>&nbsp;*/<BR>static int workqueue_cpu_up_callback(struct notifier_block *nfb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long action,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *hcpu)<BR>{<BR>&nbsp;int cpu = (unsigned long)hcpu;<BR>&nbsp;struct worker_pool *pool;<BR>&nbsp;struct workqueue_struct *wq;<BR>&nbsp;int pi;</P>
<P>&nbsp;switch (action &amp; ~CPU_TASKS_FROZEN) {<BR>&nbsp;case CPU_UP_PREPARE:<BR>&nbsp;&nbsp;for_each_cpu_worker_pool(pool, cpu) {<BR>&nbsp;&nbsp;&nbsp;if (pool-&gt;nr_workers)<BR>&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;&nbsp;if (!create_worker(pool))<BR>&nbsp;&nbsp;&nbsp;&nbsp;return NOTIFY_BAD;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;break;</P>
<P>&nbsp;case CPU_DOWN_FAILED:<BR>&nbsp;case CPU_ONLINE:<BR>&nbsp;&nbsp;mutex_lock(&amp;wq_pool_mutex);</P>
<P>&nbsp;&nbsp;for_each_pool(pool, pi) {<BR>&nbsp;&nbsp;&nbsp;mutex_lock(&amp;pool-&gt;attach_mutex);</P>
<P>&nbsp;&nbsp;&nbsp;if (pool-&gt;cpu == cpu)<BR>&nbsp;&nbsp;&nbsp;&nbsp;rebind_workers(pool);<BR>&nbsp;&nbsp;&nbsp;else if (pool-&gt;cpu &lt; 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;restore_unbound_workers_cpumask(pool, cpu);</P>
<P>&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;pool-&gt;attach_mutex);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* update NUMA affinity of unbound workqueues */<BR>&nbsp;&nbsp;list_for_each_entry(wq, &amp;workqueues, list)<BR>&nbsp;&nbsp;&nbsp;wq_update_unbound_numa(wq, cpu, true);</P>
<P>&nbsp;&nbsp;mutex_unlock(&amp;wq_pool_mutex);<BR>&nbsp;&nbsp;break;<BR>&nbsp;}<BR>&nbsp;return NOTIFY_OK;<BR>}</P>
<P>/*<BR>&nbsp;* Workqueues should be brought down after normal priority CPU notifiers.<BR>&nbsp;* This will be registered as low priority CPU notifier.<BR>&nbsp;*/<BR>static int workqueue_cpu_down_callback(struct notifier_block *nfb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long action,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *hcpu)<BR>{<BR>&nbsp;int cpu = (unsigned long)hcpu;<BR>&nbsp;struct work_struct unbind_work;<BR>&nbsp;struct workqueue_struct *wq;</P>
<P>&nbsp;switch (action &amp; ~CPU_TASKS_FROZEN) {<BR>&nbsp;case CPU_DOWN_PREPARE:<BR>&nbsp;&nbsp;/* unbinding per-cpu workers should happen on the local CPU */<BR>&nbsp;&nbsp;INIT_WORK_ONSTACK(&amp;unbind_work, wq_unbind_fn);<BR>&nbsp;&nbsp;queue_work_on(cpu, system_highpri_wq, &amp;unbind_work);</P>
<P>&nbsp;&nbsp;/* update NUMA affinity of unbound workqueues */<BR>&nbsp;&nbsp;mutex_lock(&amp;wq_pool_mutex);<BR>&nbsp;&nbsp;list_for_each_entry(wq, &amp;workqueues, list)<BR>&nbsp;&nbsp;&nbsp;wq_update_unbound_numa(wq, cpu, false);<BR>&nbsp;&nbsp;mutex_unlock(&amp;wq_pool_mutex);</P>
<P>&nbsp;&nbsp;/* wait for per-cpu unbinding to finish */<BR>&nbsp;&nbsp;flush_work(&amp;unbind_work);<BR>&nbsp;&nbsp;destroy_work_on_stack(&amp;unbind_work);<BR>&nbsp;&nbsp;break;<BR>&nbsp;}<BR>&nbsp;return NOTIFY_OK;<BR>}</P>
<P><FONT class=extract>#ifdef CONFIG_SMP</FONT></P>
<P><FONT class=extract>struct work_for_cpu {<BR>&nbsp;struct work_struct work;<BR>&nbsp;long (*fn)(void *);<BR>&nbsp;void *arg;<BR>&nbsp;long ret;<BR>};</FONT></P>
<P><FONT class=extract>static void work_for_cpu_fn(struct work_struct *work)<BR>{<BR>&nbsp;struct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);</FONT></P>
<P><FONT class=extract>&nbsp;wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* work_on_cpu - run a function in user context on a particular cpu<BR>&nbsp;* @cpu: the cpu to run on<BR>&nbsp;* @fn: the function to run<BR>&nbsp;* @arg: the function arg<BR>&nbsp;*<BR>&nbsp;* It is up to the caller to ensure that the cpu doesn't go offline.<BR>&nbsp;* The caller must not hold any locks which would prevent @fn from completing.<BR>&nbsp;*<BR>&nbsp;* Return: The value @fn returns.<BR>&nbsp;*/<BR>long work_on_cpu(int cpu, long (*fn)(void *), void *arg)<BR>{<BR>&nbsp;struct work_for_cpu wfc = { .fn = fn, .arg = arg };</FONT></P>
<P><FONT class=extract>&nbsp;INIT_WORK_ONSTACK(&amp;wfc.work, work_for_cpu_fn);<BR>&nbsp;schedule_work_on(cpu, &amp;wfc.work);<BR>&nbsp;flush_work(&amp;wfc.work);<BR>&nbsp;destroy_work_on_stack(&amp;wfc.work);<BR>&nbsp;return wfc.ret;<BR>}<BR>EXPORT_SYMBOL_GPL(work_on_cpu);<BR>#endif /* CONFIG_SMP */</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_FREEZER</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* freeze_workqueues_begin - begin freezing workqueues<BR>&nbsp;*<BR>&nbsp;* Start freezing workqueues.&nbsp; After this function returns, all freezable<BR>&nbsp;* workqueues will queue new works to their delayed_works list instead of<BR>&nbsp;* pool-&gt;worklist.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* Grabs and releases wq_pool_mutex, wq-&gt;mutex and pool-&gt;lock's.<BR>&nbsp;*/<BR>void freeze_workqueues_begin(void)<BR>{<BR>&nbsp;struct workqueue_struct *wq;<BR>&nbsp;struct pool_workqueue *pwq;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;wq_pool_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;WARN_ON_ONCE(workqueue_freezing);<BR>&nbsp;workqueue_freezing = true;</FONT></P>
<P><FONT class=extract>&nbsp;list_for_each_entry(wq, &amp;workqueues, list) {<BR>&nbsp;&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;&nbsp;for_each_pwq(pwq, wq)<BR>&nbsp;&nbsp;&nbsp;pwq_adjust_max_active(pwq);<BR>&nbsp;&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;mutex_unlock(&amp;wq_pool_mutex);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* freeze_workqueues_busy - are freezable workqueues still busy?<BR>&nbsp;*<BR>&nbsp;* Check whether freezing is complete.&nbsp; This function must be called<BR>&nbsp;* between freeze_workqueues_begin() and thaw_workqueues().<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* Grabs and releases wq_pool_mutex.<BR>&nbsp;*<BR>&nbsp;* Return:<BR>&nbsp;* %true if some freezable workqueues are still busy.&nbsp; %false if freezing<BR>&nbsp;* is complete.<BR>&nbsp;*/<BR>bool freeze_workqueues_busy(void)<BR>{<BR>&nbsp;bool busy = false;<BR>&nbsp;struct workqueue_struct *wq;<BR>&nbsp;struct pool_workqueue *pwq;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;wq_pool_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;WARN_ON_ONCE(!workqueue_freezing);</FONT></P>
<P><FONT class=extract>&nbsp;list_for_each_entry(wq, &amp;workqueues, list) {<BR>&nbsp;&nbsp;if (!(wq-&gt;flags &amp; WQ_FREEZABLE))<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * nr_active is monotonically decreasing.&nbsp; It's safe<BR>&nbsp;&nbsp; * to peek without lock.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;rcu_read_lock_sched();<BR>&nbsp;&nbsp;for_each_pwq(pwq, wq) {<BR>&nbsp;&nbsp;&nbsp;WARN_ON_ONCE(pwq-&gt;nr_active &lt; 0);<BR>&nbsp;&nbsp;&nbsp;if (pwq-&gt;nr_active) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;busy = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;rcu_read_unlock_sched();<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out_unlock;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;rcu_read_unlock_sched();<BR>&nbsp;}<BR>out_unlock:<BR>&nbsp;mutex_unlock(&amp;wq_pool_mutex);<BR>&nbsp;return busy;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* thaw_workqueues - thaw workqueues<BR>&nbsp;*<BR>&nbsp;* Thaw workqueues.&nbsp; Normal queueing is restored and all collected<BR>&nbsp;* frozen works are transferred to their respective pool worklists.<BR>&nbsp;*<BR>&nbsp;* CONTEXT:<BR>&nbsp;* Grabs and releases wq_pool_mutex, wq-&gt;mutex and pool-&gt;lock's.<BR>&nbsp;*/<BR>void thaw_workqueues(void)<BR>{<BR>&nbsp;struct workqueue_struct *wq;<BR>&nbsp;struct pool_workqueue *pwq;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;wq_pool_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;if (!workqueue_freezing)<BR>&nbsp;&nbsp;goto out_unlock;</FONT></P>
<P><FONT class=extract>&nbsp;workqueue_freezing = false;</FONT></P>
<P><FONT class=extract>&nbsp;/* restore max_active and repopulate worklist */<BR>&nbsp;list_for_each_entry(wq, &amp;workqueues, list) {<BR>&nbsp;&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;&nbsp;for_each_pwq(pwq, wq)<BR>&nbsp;&nbsp;&nbsp;pwq_adjust_max_active(pwq);<BR>&nbsp;&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>out_unlock:<BR>&nbsp;mutex_unlock(&amp;wq_pool_mutex);<BR>}<BR>#endif /* CONFIG_FREEZER */</FONT></P>
<P>static int workqueue_apply_unbound_cpumask(void)<BR>{<BR>&nbsp;LIST_HEAD(ctxs);<BR>&nbsp;int ret = 0;<BR>&nbsp;struct workqueue_struct *wq;<BR>&nbsp;struct apply_wqattrs_ctx *ctx, *n;</P>
<P>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</P>
<P>&nbsp;list_for_each_entry(wq, &amp;workqueues, list) {<BR>&nbsp;&nbsp;if (!(wq-&gt;flags &amp; WQ_UNBOUND))<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;/* creating multiple pwqs breaks ordering guarantee */<BR>&nbsp;&nbsp;if (wq-&gt;flags &amp; __WQ_ORDERED)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;ctx = apply_wqattrs_prepare(wq, wq-&gt;unbound_attrs);<BR>&nbsp;&nbsp;if (!ctx) {<BR>&nbsp;&nbsp;&nbsp;ret = -ENOMEM;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;list_add_tail(&amp;ctx-&gt;list, &amp;ctxs);<BR>&nbsp;}</P>
<P>&nbsp;list_for_each_entry_safe(ctx, n, &amp;ctxs, list) {<BR>&nbsp;&nbsp;if (!ret)<BR>&nbsp;&nbsp;&nbsp;apply_wqattrs_commit(ctx);<BR>&nbsp;&nbsp;apply_wqattrs_cleanup(ctx);<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp; workqueue_set_unbound_cpumask - Set the low-level unbound cpumask<BR>&nbsp;*&nbsp; @cpumask: the cpumask to set<BR>&nbsp;*<BR>&nbsp;*&nbsp; The low-level workqueues cpumask is a global cpumask that limits<BR>&nbsp;*&nbsp; the affinity of all unbound workqueues.&nbsp; This function check the @cpumask<BR>&nbsp;*&nbsp; and apply it to all unbound workqueues and updates all pwqs of them.<BR>&nbsp;*<BR>&nbsp;*&nbsp; Retun:&nbsp;0&nbsp;- Success<BR>&nbsp;*&nbsp; &nbsp;&nbsp;-EINVAL&nbsp;- Invalid @cpumask<BR>&nbsp;*&nbsp; &nbsp;&nbsp;-ENOMEM&nbsp;- Failed to allocate memory for attrs or pwqs.<BR>&nbsp;*/<BR>int workqueue_set_unbound_cpumask(cpumask_var_t cpumask)<BR>{<BR>&nbsp;int ret = -EINVAL;<BR>&nbsp;cpumask_var_t saved_cpumask;</P>
<P>&nbsp;if (!zalloc_cpumask_var(&amp;saved_cpumask, GFP_KERNEL))<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;cpumask_and(cpumask, cpumask, cpu_possible_mask);<BR>&nbsp;if (!cpumask_empty(cpumask)) {<BR>&nbsp;&nbsp;apply_wqattrs_lock();</P>
<P>&nbsp;&nbsp;/* save the old wq_unbound_cpumask. */<BR>&nbsp;&nbsp;cpumask_copy(saved_cpumask, wq_unbound_cpumask);</P>
<P>&nbsp;&nbsp;/* update wq_unbound_cpumask at first and apply it to wqs. */<BR>&nbsp;&nbsp;cpumask_copy(wq_unbound_cpumask, cpumask);<BR>&nbsp;&nbsp;ret = workqueue_apply_unbound_cpumask();</P>
<P>&nbsp;&nbsp;/* restore the wq_unbound_cpumask when failed. */<BR>&nbsp;&nbsp;if (ret &lt; 0)<BR>&nbsp;&nbsp;&nbsp;cpumask_copy(wq_unbound_cpumask, saved_cpumask);</P>
<P>&nbsp;&nbsp;apply_wqattrs_unlock();<BR>&nbsp;}</P>
<P>&nbsp;free_cpumask_var(saved_cpumask);<BR>&nbsp;return ret;<BR>}</P>
<P><FONT class=extract>#ifdef CONFIG_SYSFS<BR>/*<BR>&nbsp;* Workqueues with WQ_SYSFS flag set is visible to userland via<BR>&nbsp;* /sys/bus/workqueue/devices/WQ_NAME.&nbsp; All visible workqueues have the<BR>&nbsp;* following attributes.<BR>&nbsp;*<BR>&nbsp;*&nbsp; per_cpu&nbsp;RO bool&nbsp;: whether the workqueue is per-cpu or unbound<BR>&nbsp;*&nbsp; max_active&nbsp;RW int&nbsp;: maximum number of in-flight work items<BR>&nbsp;*<BR>&nbsp;* Unbound workqueues have the following extra attributes.<BR>&nbsp;*<BR>&nbsp;*&nbsp; id&nbsp;&nbsp;RO int&nbsp;: the associated pool ID<BR>&nbsp;*&nbsp; nice&nbsp;RW int&nbsp;: nice value of the workers<BR>&nbsp;*&nbsp; cpumask&nbsp;RW mask&nbsp;: bitmask of allowed CPUs for the workers<BR>&nbsp;*/<BR>struct wq_device {<BR>&nbsp;struct workqueue_struct&nbsp;&nbsp;*wq;<BR>&nbsp;struct device&nbsp;&nbsp;&nbsp;dev;<BR>};</FONT></P>
<P><FONT class=extract>static struct workqueue_struct *dev_to_wq(struct device *dev)<BR>{<BR>&nbsp;struct wq_device *wq_dev = container_of(dev, struct wq_device, dev);</FONT></P>
<P><FONT class=extract>&nbsp;return wq_dev-&gt;wq;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t per_cpu_show(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);</FONT></P>
<P><FONT class=extract>&nbsp;return scnprintf(buf, PAGE_SIZE, "%d\n", (bool)!(wq-&gt;flags &amp; WQ_UNBOUND));<BR>}<BR>static DEVICE_ATTR_RO(per_cpu);</FONT></P>
<P><FONT class=extract>static ssize_t max_active_show(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_attribute *attr, char *buf)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);</FONT></P>
<P><FONT class=extract>&nbsp;return scnprintf(buf, PAGE_SIZE, "%d\n", wq-&gt;saved_max_active);<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t max_active_store(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct device_attribute *attr, const char *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;size_t count)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;int val;</FONT></P>
<P><FONT class=extract>&nbsp;if (sscanf(buf, "%d", &amp;val) != 1 || val &lt;= 0)<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;workqueue_set_max_active(wq, val);<BR>&nbsp;return count;<BR>}<BR>static DEVICE_ATTR_RW(max_active);</FONT></P>
<P><FONT class=extract>static struct attribute *wq_sysfs_attrs[] = {<BR>&nbsp;&amp;dev_attr_per_cpu.attr,<BR>&nbsp;&amp;dev_attr_max_active.attr,<BR>&nbsp;NULL,<BR>};<BR>ATTRIBUTE_GROUPS(wq_sysfs);</FONT></P>
<P><FONT class=extract>static ssize_t wq_pool_ids_show(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct device_attribute *attr, char *buf)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;const char *delim = "";<BR>&nbsp;int node, written = 0;</FONT></P>
<P><FONT class=extract>&nbsp;rcu_read_lock_sched();<BR>&nbsp;for_each_node(node) {<BR>&nbsp;&nbsp;written += scnprintf(buf + written, PAGE_SIZE - written,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s%d:%d", delim, node,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unbound_pwq_by_node(wq, node)-&gt;pool-&gt;id);<BR>&nbsp;&nbsp;delim = " ";<BR>&nbsp;}<BR>&nbsp;written += scnprintf(buf + written, PAGE_SIZE - written, "\n");<BR>&nbsp;rcu_read_unlock_sched();</FONT></P>
<P><FONT class=extract>&nbsp;return written;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t wq_nice_show(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;int written;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;written = scnprintf(buf, PAGE_SIZE, "%d\n", wq-&gt;unbound_attrs-&gt;nice);<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);</FONT></P>
<P><FONT class=extract>&nbsp;return written;<BR>}</FONT></P>
<P><FONT class=extract>/* prepare workqueue_attrs for sysfs store operations */<BR>static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)<BR>{<BR>&nbsp;struct workqueue_attrs *attrs;</FONT></P>
<P><FONT class=extract>&nbsp;lockdep_assert_held(&amp;wq_pool_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;attrs = alloc_workqueue_attrs(GFP_KERNEL);<BR>&nbsp;if (!attrs)<BR>&nbsp;&nbsp;return NULL;</FONT></P>
<P><FONT class=extract>&nbsp;copy_workqueue_attrs(attrs, wq-&gt;unbound_attrs);<BR>&nbsp;return attrs;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t wq_nice_store(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;struct workqueue_attrs *attrs;<BR>&nbsp;int ret = -ENOMEM;</FONT></P>
<P><FONT class=extract>&nbsp;apply_wqattrs_lock();</FONT></P>
<P><FONT class=extract>&nbsp;attrs = wq_sysfs_prep_attrs(wq);<BR>&nbsp;if (!attrs)<BR>&nbsp;&nbsp;goto out_unlock;</FONT></P>
<P><FONT class=extract>&nbsp;if (sscanf(buf, "%d", &amp;attrs-&gt;nice) == 1 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; attrs-&gt;nice &gt;= MIN_NICE &amp;&amp; attrs-&gt;nice &lt;= MAX_NICE)<BR>&nbsp;&nbsp;ret = apply_workqueue_attrs_locked(wq, attrs);<BR>&nbsp;else<BR>&nbsp;&nbsp;ret = -EINVAL;</FONT></P>
<P><FONT class=extract>out_unlock:<BR>&nbsp;apply_wqattrs_unlock();<BR>&nbsp;free_workqueue_attrs(attrs);<BR>&nbsp;return ret ?: count;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t wq_cpumask_show(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_attribute *attr, char *buf)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;int written;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;written = scnprintf(buf, PAGE_SIZE, "%*pb\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpumask_pr_args(wq-&gt;unbound_attrs-&gt;cpumask));<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);<BR>&nbsp;return written;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t wq_cpumask_store(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const char *buf, size_t count)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;struct workqueue_attrs *attrs;<BR>&nbsp;int ret = -ENOMEM;</FONT></P>
<P><FONT class=extract>&nbsp;apply_wqattrs_lock();</FONT></P>
<P><FONT class=extract>&nbsp;attrs = wq_sysfs_prep_attrs(wq);<BR>&nbsp;if (!attrs)<BR>&nbsp;&nbsp;goto out_unlock;</FONT></P>
<P><FONT class=extract>&nbsp;ret = cpumask_parse(buf, attrs-&gt;cpumask);<BR>&nbsp;if (!ret)<BR>&nbsp;&nbsp;ret = apply_workqueue_attrs_locked(wq, attrs);</FONT></P>
<P><FONT class=extract>out_unlock:<BR>&nbsp;apply_wqattrs_unlock();<BR>&nbsp;free_workqueue_attrs(attrs);<BR>&nbsp;return ret ?: count;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t wq_numa_show(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;int written;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;wq-&gt;mutex);<BR>&nbsp;written = scnprintf(buf, PAGE_SIZE, "%d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !wq-&gt;unbound_attrs-&gt;no_numa);<BR>&nbsp;mutex_unlock(&amp;wq-&gt;mutex);</FONT></P>
<P><FONT class=extract>&nbsp;return written;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t wq_numa_store(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct workqueue_struct *wq = dev_to_wq(dev);<BR>&nbsp;struct workqueue_attrs *attrs;<BR>&nbsp;int v, ret = -ENOMEM;</FONT></P>
<P><FONT class=extract>&nbsp;apply_wqattrs_lock();</FONT></P>
<P><FONT class=extract>&nbsp;attrs = wq_sysfs_prep_attrs(wq);<BR>&nbsp;if (!attrs)<BR>&nbsp;&nbsp;goto out_unlock;</FONT></P>
<P><FONT class=extract>&nbsp;ret = -EINVAL;<BR>&nbsp;if (sscanf(buf, "%d", &amp;v) == 1) {<BR>&nbsp;&nbsp;attrs-&gt;no_numa = !v;<BR>&nbsp;&nbsp;ret = apply_workqueue_attrs_locked(wq, attrs);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>out_unlock:<BR>&nbsp;apply_wqattrs_unlock();<BR>&nbsp;free_workqueue_attrs(attrs);<BR>&nbsp;return ret ?: count;<BR>}</FONT></P>
<P><FONT class=extract>static struct device_attribute wq_sysfs_unbound_attrs[] = {<BR>&nbsp;__ATTR(pool_ids, 0444, wq_pool_ids_show, NULL),<BR>&nbsp;__ATTR(nice, 0644, wq_nice_show, wq_nice_store),<BR>&nbsp;__ATTR(cpumask, 0644, wq_cpumask_show, wq_cpumask_store),<BR>&nbsp;__ATTR(numa, 0644, wq_numa_show, wq_numa_store),<BR>&nbsp;__ATTR_NULL,<BR>};</FONT></P>
<P><FONT class=extract>static struct bus_type wq_subsys = {<BR>&nbsp;.name&nbsp;&nbsp;&nbsp;&nbsp;= "workqueue",<BR>&nbsp;.dev_groups&nbsp;&nbsp;&nbsp;= wq_sysfs_groups,<BR>};</FONT></P>
<P><FONT class=extract>static ssize_t wq_unbound_cpumask_show(struct device *dev,<BR>&nbsp;&nbsp;struct device_attribute *attr, char *buf)<BR>{<BR>&nbsp;int written;</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;wq_pool_mutex);<BR>&nbsp;written = scnprintf(buf, PAGE_SIZE, "%*pb\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpumask_pr_args(wq_unbound_cpumask));<BR>&nbsp;mutex_unlock(&amp;wq_pool_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;return written;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t wq_unbound_cpumask_store(struct device *dev,<BR>&nbsp;&nbsp;struct device_attribute *attr, const char *buf, size_t count)<BR>{<BR>&nbsp;cpumask_var_t cpumask;<BR>&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;if (!zalloc_cpumask_var(&amp;cpumask, GFP_KERNEL))<BR>&nbsp;&nbsp;return -ENOMEM;</FONT></P>
<P><FONT class=extract>&nbsp;ret = cpumask_parse(buf, cpumask);<BR>&nbsp;if (!ret)<BR>&nbsp;&nbsp;ret = workqueue_set_unbound_cpumask(cpumask);</FONT></P>
<P><FONT class=extract>&nbsp;free_cpumask_var(cpumask);<BR>&nbsp;return ret ? ret : count;<BR>}</FONT></P>
<P><FONT class=extract>static struct device_attribute wq_sysfs_cpumask_attr =<BR>&nbsp;__ATTR(cpumask, 0644, wq_unbound_cpumask_show,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wq_unbound_cpumask_store);</FONT></P>
<P><FONT class=extract>static int __init wq_sysfs_init(void)<BR>{<BR>&nbsp;int err;</FONT></P>
<P><FONT class=extract>&nbsp;err = subsys_virtual_register(&amp;wq_subsys, NULL);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</FONT></P>
<P><FONT class=extract>&nbsp;return device_create_file(wq_subsys.dev_root, &amp;wq_sysfs_cpumask_attr);<BR>}<BR>core_initcall(wq_sysfs_init);</FONT></P>
<P><FONT class=extract>static void wq_device_release(struct device *dev)<BR>{<BR>&nbsp;struct wq_device *wq_dev = container_of(dev, struct wq_device, dev);</FONT></P>
<P><FONT class=extract>&nbsp;kfree(wq_dev);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* workqueue_sysfs_register - make a workqueue visible in sysfs<BR>&nbsp;* @wq: the workqueue to register<BR>&nbsp;*<BR>&nbsp;* Expose @wq in sysfs under /sys/bus/workqueue/devices.<BR>&nbsp;* alloc_workqueue*() automatically calls this function if WQ_SYSFS is set<BR>&nbsp;* which is the preferred method.<BR>&nbsp;*<BR>&nbsp;* Workqueue user should use this function directly iff it wants to apply<BR>&nbsp;* workqueue_attrs before making the workqueue visible in sysfs; otherwise,<BR>&nbsp;* apply_workqueue_attrs() may race against userland updating the<BR>&nbsp;* attributes.<BR>&nbsp;*<BR>&nbsp;* Return: 0 on success, -errno on failure.<BR>&nbsp;*/<BR>int workqueue_sysfs_register(struct workqueue_struct *wq)<BR>{<BR>&nbsp;struct wq_device *wq_dev;<BR>&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * Adjusting max_active or creating new pwqs by applying<BR>&nbsp; * attributes breaks ordering guarantee.&nbsp; Disallow exposing ordered<BR>&nbsp; * workqueues.<BR>&nbsp; */<BR>&nbsp;if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED))<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;wq-&gt;wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);<BR>&nbsp;if (!wq_dev)<BR>&nbsp;&nbsp;return -ENOMEM;</FONT></P>
<P><FONT class=extract>&nbsp;wq_dev-&gt;wq = wq;<BR>&nbsp;wq_dev-&gt;dev.bus = &amp;wq_subsys;<BR>&nbsp;wq_dev-&gt;dev.init_name = wq-&gt;name;<BR>&nbsp;wq_dev-&gt;dev.release = wq_device_release;</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * unbound_attrs are created separately.&nbsp; Suppress uevent until<BR>&nbsp; * everything is ready.<BR>&nbsp; */<BR>&nbsp;dev_set_uevent_suppress(&amp;wq_dev-&gt;dev, true);</FONT></P>
<P><FONT class=extract>&nbsp;ret = device_register(&amp;wq_dev-&gt;dev);<BR>&nbsp;if (ret) {<BR>&nbsp;&nbsp;kfree(wq_dev);<BR>&nbsp;&nbsp;wq-&gt;wq_dev = NULL;<BR>&nbsp;&nbsp;return ret;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;if (wq-&gt;flags &amp; WQ_UNBOUND) {<BR>&nbsp;&nbsp;struct device_attribute *attr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;for (attr = wq_sysfs_unbound_attrs; attr-&gt;attr.name; attr++) {<BR>&nbsp;&nbsp;&nbsp;ret = device_create_file(&amp;wq_dev-&gt;dev, attr);<BR>&nbsp;&nbsp;&nbsp;if (ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;device_unregister(&amp;wq_dev-&gt;dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;wq-&gt;wq_dev = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;return ret;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;dev_set_uevent_suppress(&amp;wq_dev-&gt;dev, false);<BR>&nbsp;kobject_uevent(&amp;wq_dev-&gt;dev.kobj, KOBJ_ADD);<BR>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* workqueue_sysfs_unregister - undo workqueue_sysfs_register()<BR>&nbsp;* @wq: the workqueue to unregister<BR>&nbsp;*<BR>&nbsp;* If @wq is registered to sysfs by workqueue_sysfs_register(), unregister.<BR>&nbsp;*/<BR>static void workqueue_sysfs_unregister(struct workqueue_struct *wq)<BR>{<BR>&nbsp;struct wq_device *wq_dev = wq-&gt;wq_dev;</FONT></P>
<P><FONT class=extract>&nbsp;if (!wq-&gt;wq_dev)<BR>&nbsp;&nbsp;return;</FONT></P>
<P><FONT class=extract>&nbsp;wq-&gt;wq_dev = NULL;<BR>&nbsp;device_unregister(&amp;wq_dev-&gt;dev);<BR>}<BR>#else&nbsp;/* CONFIG_SYSFS */<BR>static void workqueue_sysfs_unregister(struct workqueue_struct *wq)&nbsp;{ }<BR>#endif&nbsp;/* CONFIG_SYSFS */</FONT></P>
<P>static void __init wq_numa_init(void)<BR>{<BR>&nbsp;cpumask_var_t *tbl;<BR>&nbsp;int node, cpu;</P>
<P>&nbsp;if (num_possible_nodes() &lt;= 1)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;if (wq_disable_numa) {<BR>&nbsp;&nbsp;pr_info("workqueue: NUMA affinity support disabled\n");<BR>&nbsp;&nbsp;return;<BR>&nbsp;}</P>
<P>&nbsp;wq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs(GFP_KERNEL);<BR>&nbsp;BUG_ON(!wq_update_unbound_numa_attrs_buf);</P>
<P>&nbsp;/*<BR>&nbsp; * We want masks of possible CPUs of each node which isn't readily<BR>&nbsp; * available.&nbsp; Build one from cpu_to_node() which should have been<BR>&nbsp; * fully initialized by now.<BR>&nbsp; */<BR>&nbsp;tbl = kzalloc(nr_node_ids * sizeof(tbl[0]), GFP_KERNEL);<BR>&nbsp;BUG_ON(!tbl);</P>
<P>&nbsp;for_each_node(node)<BR>&nbsp;&nbsp;BUG_ON(!zalloc_cpumask_var_node(&amp;tbl[node], GFP_KERNEL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;node_online(node) ? node : NUMA_NO_NODE));</P>
<P>&nbsp;for_each_possible_cpu(cpu) {<BR>&nbsp;&nbsp;node = cpu_to_node(cpu);<BR>&nbsp;&nbsp;if (WARN_ON(node == NUMA_NO_NODE)) {<BR>&nbsp;&nbsp;&nbsp;pr_warn("workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\n", cpu);<BR>&nbsp;&nbsp;&nbsp;/* happens iff arch is bonkers, let's just proceed */<BR>&nbsp;&nbsp;&nbsp;return;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;cpumask_set_cpu(cpu, tbl[node]);<BR>&nbsp;}</P>
<P>&nbsp;wq_numa_possible_cpumask = tbl;<BR>&nbsp;wq_numa_enabled = true;<BR>}</P>
<P>static int __init init_workqueues(void)<BR>{<BR>&nbsp;int std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };<BR>&nbsp;int i, cpu;</P>
<P>&nbsp;WARN_ON(__alignof__(struct pool_workqueue) &lt; __alignof__(long long));</P>
<P>&nbsp;BUG_ON(!alloc_cpumask_var(&amp;wq_unbound_cpumask, GFP_KERNEL));<BR>&nbsp;cpumask_copy(wq_unbound_cpumask, cpu_possible_mask);</P>
<P>&nbsp;pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);</P>
<P>&nbsp;cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);<BR>&nbsp;hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);</P>
<P>&nbsp;wq_numa_init();</P>
<P>&nbsp;/* initialize CPU pools */<BR>&nbsp;for_each_possible_cpu(cpu) {<BR>&nbsp;&nbsp;struct worker_pool *pool;</P>
<P>&nbsp;&nbsp;i = 0;<BR>&nbsp;&nbsp;for_each_cpu_worker_pool(pool, cpu) {<BR>&nbsp;&nbsp;&nbsp;BUG_ON(init_worker_pool(pool));<BR>&nbsp;&nbsp;&nbsp;pool-&gt;cpu = cpu;<BR>&nbsp;&nbsp;&nbsp;cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));<BR>&nbsp;&nbsp;&nbsp;pool-&gt;attrs-&gt;nice = std_nice[i++];<BR>&nbsp;&nbsp;&nbsp;pool-&gt;node = cpu_to_node(cpu);</P>
<P>&nbsp;&nbsp;&nbsp;/* alloc pool ID */<BR>&nbsp;&nbsp;&nbsp;mutex_lock(&amp;wq_pool_mutex);<BR>&nbsp;&nbsp;&nbsp;BUG_ON(worker_pool_assign_id(pool));<BR>&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;wq_pool_mutex);<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* create the initial worker */<BR>&nbsp;for_each_online_cpu(cpu) {<BR>&nbsp;&nbsp;struct worker_pool *pool;</P>
<P>&nbsp;&nbsp;for_each_cpu_worker_pool(pool, cpu) {<BR>&nbsp;&nbsp;&nbsp;pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;<BR>&nbsp;&nbsp;&nbsp;BUG_ON(!create_worker(pool));<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* create default unbound and ordered wq attrs */<BR>&nbsp;for (i = 0; i &lt; NR_STD_WORKER_POOLS; i++) {<BR>&nbsp;&nbsp;struct workqueue_attrs *attrs;</P>
<P>&nbsp;&nbsp;BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));<BR>&nbsp;&nbsp;attrs-&gt;nice = std_nice[i];<BR>&nbsp;&nbsp;unbound_std_wq_attrs[i] = attrs;</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * An ordered wq should have only one pwq as ordering is<BR>&nbsp;&nbsp; * guaranteed by max_active which is enforced by pwqs.<BR>&nbsp;&nbsp; * Turn off NUMA so that dfl_pwq is used for all nodes.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));<BR>&nbsp;&nbsp;attrs-&gt;nice = std_nice[i];<BR>&nbsp;&nbsp;attrs-&gt;no_numa = true;<BR>&nbsp;&nbsp;ordered_wq_attrs[i] = attrs;<BR>&nbsp;}</P>
<P>&nbsp;system_wq = alloc_workqueue("events", 0, 0);<BR>&nbsp;system_highpri_wq = alloc_workqueue("events_highpri", WQ_HIGHPRI, 0);<BR>&nbsp;system_long_wq = alloc_workqueue("events_long", 0, 0);<BR>&nbsp;system_unbound_wq = alloc_workqueue("events_unbound", WQ_UNBOUND,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WQ_UNBOUND_MAX_ACTIVE);<BR>&nbsp;system_freezable_wq = alloc_workqueue("events_freezable",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WQ_FREEZABLE, 0);<BR>&nbsp;system_power_efficient_wq = alloc_workqueue("events_power_efficient",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WQ_POWER_EFFICIENT, 0);<BR>&nbsp;system_freezable_power_efficient_wq = alloc_workqueue("events_freezable_power_efficient",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WQ_FREEZABLE | WQ_POWER_EFFICIENT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);<BR>&nbsp;BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !system_unbound_wq || !system_freezable_wq ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !system_power_efficient_wq ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !system_freezable_power_efficient_wq);<BR>&nbsp;return 0;<BR>}<BR>early_initcall(init_workqueues);