include/linux/ioport.h 
<P></P>
<P>/*<BR>&nbsp;* ioport.h&nbsp;Definitions of routines for detecting, reserving and<BR>&nbsp;*&nbsp;&nbsp;allocating system resources.<BR>&nbsp;*<BR>&nbsp;* Authors:&nbsp;Linus Torvalds<BR>&nbsp;*/</P>
<P></P>
<P>#ifndef _LINUX_IOPORT_H<BR>#define _LINUX_IOPORT_H</P>
<P>#ifndef __ASSEMBLY__<BR>#include &lt;linux/compiler.h&gt;<BR>#include &lt;linux/types.h&gt;<BR><FONT class=extract>/*<BR>&nbsp;* Resources are tree-like, allowing<BR>&nbsp;* nesting etc..<BR>&nbsp;*/<BR>struct resource {<BR>&nbsp;resource_size_t start;<BR>&nbsp;resource_size_t end;<BR>&nbsp;const char *name;<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct resource *parent, *sibling, *child;<BR>};</FONT></P>
<P>/*<BR>&nbsp;* IO resources have these defined flags.<BR>&nbsp;*/<BR>#define IORESOURCE_BITS&nbsp;&nbsp;0x000000ff&nbsp;/* Bus-specific bits */</P>
<P>#define IORESOURCE_TYPE_BITS&nbsp;0x00001f00&nbsp;/* Resource type */<BR>#define IORESOURCE_IO&nbsp;&nbsp;0x00000100&nbsp;/* PCI/ISA I/O ports */<BR>#define IORESOURCE_MEM&nbsp;&nbsp;0x00000200<BR>#define IORESOURCE_REG&nbsp;&nbsp;0x00000300&nbsp;/* Register offsets */<BR>#define IORESOURCE_IRQ&nbsp;&nbsp;0x00000400<BR>#define IORESOURCE_DMA&nbsp;&nbsp;0x00000800<BR>#define IORESOURCE_BUS&nbsp;&nbsp;0x00001000</P>
<P>#define IORESOURCE_PREFETCH&nbsp;0x00002000&nbsp;/* No side effects */<BR>#define IORESOURCE_READONLY&nbsp;0x00004000<BR>#define IORESOURCE_CACHEABLE&nbsp;0x00008000<BR>#define IORESOURCE_RANGELENGTH&nbsp;0x00010000<BR>#define IORESOURCE_SHADOWABLE&nbsp;0x00020000</P>
<P>#define IORESOURCE_SIZEALIGN&nbsp;0x00040000&nbsp;/* size indicates alignment */<BR>#define IORESOURCE_STARTALIGN&nbsp;0x00080000&nbsp;/* start field is alignment */</P>
<P>#define IORESOURCE_MEM_64&nbsp;0x00100000<BR>#define IORESOURCE_WINDOW&nbsp;0x00200000&nbsp;/* forwarded by bridge */<BR>#define IORESOURCE_MUXED&nbsp;0x00400000&nbsp;/* Resource is software muxed */</P>
<P>#define IORESOURCE_EXCLUSIVE&nbsp;0x08000000&nbsp;/* Userland may not map this resource */<BR>#define IORESOURCE_DISABLED&nbsp;0x10000000<BR>#define IORESOURCE_UNSET&nbsp;0x20000000&nbsp;/* No address assigned yet */<BR>#define IORESOURCE_AUTO&nbsp;&nbsp;0x40000000<BR>#define IORESOURCE_BUSY&nbsp;&nbsp;0x80000000&nbsp;/* Driver has marked this resource busy */</P>
<P>/* PnP IRQ specific bits (IORESOURCE_BITS) */<BR>#define IORESOURCE_IRQ_HIGHEDGE&nbsp;&nbsp;(1&lt;&lt;0)<BR>#define IORESOURCE_IRQ_LOWEDGE&nbsp;&nbsp;(1&lt;&lt;1)<BR>#define IORESOURCE_IRQ_HIGHLEVEL&nbsp;(1&lt;&lt;2)<BR>#define IORESOURCE_IRQ_LOWLEVEL&nbsp;&nbsp;(1&lt;&lt;3)<BR>#define IORESOURCE_IRQ_SHAREABLE&nbsp;(1&lt;&lt;4)<BR>#define IORESOURCE_IRQ_OPTIONAL &nbsp;(1&lt;&lt;5)</P>
<P>/* PnP DMA specific bits (IORESOURCE_BITS) */<BR>#define IORESOURCE_DMA_TYPE_MASK&nbsp;(3&lt;&lt;0)<BR>#define IORESOURCE_DMA_8BIT&nbsp;&nbsp;(0&lt;&lt;0)<BR>#define IORESOURCE_DMA_8AND16BIT&nbsp;(1&lt;&lt;0)<BR>#define IORESOURCE_DMA_16BIT&nbsp;&nbsp;(2&lt;&lt;0)</P>
<P>#define IORESOURCE_DMA_MASTER&nbsp;&nbsp;(1&lt;&lt;2)<BR>#define IORESOURCE_DMA_BYTE&nbsp;&nbsp;(1&lt;&lt;3)<BR>#define IORESOURCE_DMA_WORD&nbsp;&nbsp;(1&lt;&lt;4)</P>
<P>#define IORESOURCE_DMA_SPEED_MASK&nbsp;(3&lt;&lt;6)<BR>#define IORESOURCE_DMA_COMPATIBLE&nbsp;(0&lt;&lt;6)<BR>#define IORESOURCE_DMA_TYPEA&nbsp;&nbsp;(1&lt;&lt;6)<BR>#define IORESOURCE_DMA_TYPEB&nbsp;&nbsp;(2&lt;&lt;6)<BR>#define IORESOURCE_DMA_TYPEF&nbsp;&nbsp;(3&lt;&lt;6)</P>
<P>/* PnP memory I/O specific bits (IORESOURCE_BITS) */<BR>#define IORESOURCE_MEM_WRITEABLE&nbsp;(1&lt;&lt;0)&nbsp;/* dup: IORESOURCE_READONLY */<BR>#define IORESOURCE_MEM_CACHEABLE&nbsp;(1&lt;&lt;1)&nbsp;/* dup: IORESOURCE_CACHEABLE */<BR>#define IORESOURCE_MEM_RANGELENGTH&nbsp;(1&lt;&lt;2)&nbsp;/* dup: IORESOURCE_RANGELENGTH */<BR>#define IORESOURCE_MEM_TYPE_MASK&nbsp;(3&lt;&lt;3)<BR>#define IORESOURCE_MEM_8BIT&nbsp;&nbsp;(0&lt;&lt;3)<BR>#define IORESOURCE_MEM_16BIT&nbsp;&nbsp;(1&lt;&lt;3)<BR>#define IORESOURCE_MEM_8AND16BIT&nbsp;(2&lt;&lt;3)<BR>#define IORESOURCE_MEM_32BIT&nbsp;&nbsp;(3&lt;&lt;3)<BR>#define IORESOURCE_MEM_SHADOWABLE&nbsp;(1&lt;&lt;5)&nbsp;/* dup: IORESOURCE_SHADOWABLE */<BR>#define IORESOURCE_MEM_EXPANSIONROM&nbsp;(1&lt;&lt;6)</P>
<P>/* PnP I/O specific bits (IORESOURCE_BITS) */<BR>#define IORESOURCE_IO_16BIT_ADDR&nbsp;(1&lt;&lt;0)<BR>#define IORESOURCE_IO_FIXED&nbsp;&nbsp;(1&lt;&lt;1)</P>
<P>/* PCI ROM control bits (IORESOURCE_BITS) */<BR>#define IORESOURCE_ROM_ENABLE&nbsp;&nbsp;(1&lt;&lt;0)&nbsp;/* ROM is enabled, same as PCI_ROM_ADDRESS_ENABLE */<BR>#define IORESOURCE_ROM_SHADOW&nbsp;&nbsp;(1&lt;&lt;1)&nbsp;/* ROM is copy at C000:0 */<BR>#define IORESOURCE_ROM_COPY&nbsp;&nbsp;(1&lt;&lt;2)&nbsp;/* ROM is alloc'd copy, resource field overlaid */<BR>#define IORESOURCE_ROM_BIOS_COPY&nbsp;(1&lt;&lt;3)&nbsp;/* ROM is BIOS copy, resource field overlaid */</P>
<P>/* PCI control bits.&nbsp; Shares IORESOURCE_BITS with above PCI ROM.&nbsp; */<BR>#define IORESOURCE_PCI_FIXED&nbsp;&nbsp;(1&lt;&lt;4)&nbsp;/* Do not move resource */</P>
<P><BR>/* helpers to define resources */<BR>#define DEFINE_RES_NAMED(_start, _size, _name, _flags)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.start = (_start),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.end = (_start) + (_size) - 1,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.name = (_name),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.flags = (_flags),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}</P>
<P>#define DEFINE_RES_IO_NAMED(_start, _size, _name)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_NAMED((_start), (_size), (_name), IORESOURCE_IO)<BR>#define DEFINE_RES_IO(_start, _size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_IO_NAMED((_start), (_size), NULL)</P>
<P>#define DEFINE_RES_MEM_NAMED(_start, _size, _name)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_NAMED((_start), (_size), (_name), IORESOURCE_MEM)<BR>#define DEFINE_RES_MEM(_start, _size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_MEM_NAMED((_start), (_size), NULL)</P>
<P>#define DEFINE_RES_IRQ_NAMED(_irq, _name)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_NAMED((_irq), 1, (_name), IORESOURCE_IRQ)<BR>#define DEFINE_RES_IRQ(_irq)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_IRQ_NAMED((_irq), NULL)</P>
<P>#define DEFINE_RES_DMA_NAMED(_dma, _name)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_NAMED((_dma), 1, (_name), IORESOURCE_DMA)<BR>#define DEFINE_RES_DMA(_dma)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_RES_DMA_NAMED((_dma), NULL)</P>
<P>/* PC/ISA/whatever - the normal PC address spaces: IO and memory */<BR>extern struct resource ioport_resource;<BR>extern struct resource iomem_resource;</P>
<P>extern struct resource *request_resource_conflict(struct resource *root, struct resource *new);<BR>extern int request_resource(struct resource *root, struct resource *new);<BR>extern int release_resource(struct resource *new);<BR>void release_child_resources(struct resource *new);<BR>extern void reserve_region_with_split(struct resource *root,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t start, resource_size_t end,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name);<BR>extern struct resource *insert_resource_conflict(struct resource *parent, struct resource *new);<BR>extern int insert_resource(struct resource *parent, struct resource *new);<BR>extern void insert_resource_expand_to_fit(struct resource *root, struct resource *new);<BR>extern void arch_remove_reservations(struct resource *avail);<BR>extern int allocate_resource(struct resource *root, struct resource *new,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t size, resource_size_t min,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t max, resource_size_t align,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t (*alignf)(void *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct resource *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *alignf_data);<BR>struct resource *lookup_resource(struct resource *root, resource_size_t start);<BR>int adjust_resource(struct resource *res, resource_size_t start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t size);<BR>resource_size_t resource_alignment(struct resource *res);<BR>static inline resource_size_t resource_size(const struct resource *res)<BR>{<BR>&nbsp;return res-&gt;end - res-&gt;start + 1;<BR>}<BR>static inline unsigned long resource_type(const struct resource *res)<BR>{<BR>&nbsp;return res-&gt;flags &amp; IORESOURCE_TYPE_BITS;<BR>}<BR>/* True iff r1 completely contains r2 */<BR>static inline bool resource_contains(struct resource *r1, struct resource *r2)<BR>{<BR>&nbsp;if (resource_type(r1) != resource_type(r2))<BR>&nbsp;&nbsp;return false;<BR>&nbsp;if (r1-&gt;flags &amp; IORESOURCE_UNSET || r2-&gt;flags &amp; IORESOURCE_UNSET)<BR>&nbsp;&nbsp;return false;<BR>&nbsp;return r1-&gt;start &lt;= r2-&gt;start &amp;&amp; r1-&gt;end &gt;= r2-&gt;end;<BR>}</P>
<P><BR>/* Convenience shorthand with allocation */<BR>#define request_region(start,n,name)&nbsp;&nbsp;__request_region(&amp;ioport_resource, (start), (n), (name), 0)<BR>#define request_muxed_region(start,n,name)&nbsp;__request_region(&amp;ioport_resource, (start), (n), (name), IORESOURCE_MUXED)<BR>#define __request_mem_region(start,n,name, excl) __request_region(&amp;iomem_resource, (start), (n), (name), excl)<BR>#define request_mem_region(start,n,name) __request_region(&amp;iomem_resource, (start), (n), (name), 0)<BR>#define request_mem_region_exclusive(start,n,name) \<BR>&nbsp;__request_region(&amp;iomem_resource, (start), (n), (name), IORESOURCE_EXCLUSIVE)<BR>#define rename_region(region, newname) do { (region)-&gt;name = (newname); } while (0)</P>
<P>extern struct resource * __request_region(struct resource *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resource_size_t start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resource_size_t n,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *name, int flags);</P>
<P>/* Compatibility cruft */<BR>#define release_region(start,n)&nbsp;__release_region(&amp;ioport_resource, (start), (n))<BR>#define release_mem_region(start,n)&nbsp;__release_region(&amp;iomem_resource, (start), (n))</P>
<P>extern void __release_region(struct resource *, resource_size_t,<BR>&nbsp;&nbsp;&nbsp;&nbsp;resource_size_t);<BR>#ifdef CONFIG_MEMORY_HOTREMOVE<BR>extern int release_mem_region_adjustable(struct resource *, resource_size_t,<BR>&nbsp;&nbsp;&nbsp;&nbsp;resource_size_t);<BR>#endif</P>
<P>/* Wrappers for managed devices */<BR>struct device;</P>
<P>extern int devm_request_resource(struct device *dev, struct resource *root,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct resource *new);<BR>extern void devm_release_resource(struct device *dev, struct resource *new);</P>
<P>#define devm_request_region(dev,start,n,name) \<BR>&nbsp;__devm_request_region(dev, &amp;ioport_resource, (start), (n), (name))<BR>#define devm_request_mem_region(dev,start,n,name) \<BR>&nbsp;__devm_request_region(dev, &amp;iomem_resource, (start), (n), (name))</P>
<P>extern struct resource * __devm_request_region(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct resource *parent, resource_size_t start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;resource_size_t n, const char *name);</P>
<P>#define devm_release_region(dev, start, n) \<BR>&nbsp;__devm_release_region(dev, &amp;ioport_resource, (start), (n))<BR>#define devm_release_mem_region(dev, start, n) \<BR>&nbsp;__devm_release_region(dev, &amp;iomem_resource, (start), (n))</P>
<P>extern void __devm_release_region(struct device *dev, struct resource *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_size_t start, resource_size_t n);<BR>extern int iomem_map_sanity_check(resource_size_t addr, unsigned long size);<BR>extern int iomem_is_exclusive(u64 addr);</P>
<P>extern int<BR>walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,<BR>&nbsp;&nbsp;void *arg, int (*func)(unsigned long, unsigned long, void *));<BR>extern int<BR>walk_system_ram_res(u64 start, u64 end, void *arg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*func)(u64, u64, void *));<BR>extern int<BR>walk_iomem_res(char *name, unsigned long flags, u64 start, u64 end, void *arg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*func)(u64, u64, void *));</P>
<P>/* True if any part of r1 overlaps r2 */<BR>static inline bool resource_overlaps(struct resource *r1, struct resource *r2)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (r1-&gt;start &lt;= r2-&gt;end &amp;&amp; r1-&gt;end &gt;= r2-&gt;start);<BR>}</P>
<P><BR>#endif /* __ASSEMBLY__ */<BR>#endif&nbsp;/* _LINUX_IOPORT_H */