/*<BR>&nbsp;* General tracing related utility functions - trace_printk(),<BR>&nbsp;* tracing_on/tracing_off and tracing_start()/tracing_stop<BR>&nbsp;*<BR>&nbsp;* Use tracing_on/tracing_off when you want to quickly turn on or off<BR>&nbsp;* tracing. It simply enables or disables the recording of the trace events.<BR>&nbsp;* This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on<BR>&nbsp;* file, which gives a means for the kernel and userspace to interact.<BR>&nbsp;* Place a tracing_off() in the kernel where you want tracing to end.<BR>&nbsp;* From user space, examine the trace, and then echo 1 &gt; tracing_on<BR>&nbsp;* to continue tracing.<BR>&nbsp;*<BR>&nbsp;* tracing_stop/tracing_start has slightly more overhead. It is used<BR>&nbsp;* by things like suspend to ram where disabling the recording of the<BR>&nbsp;* trace is not enough, but tracing must actually stop because things<BR>&nbsp;* like calling smp_processor_id() may crash the system.<BR>&nbsp;*<BR>&nbsp;* Most likely, you want to use tracing_on/tracing_off.<BR>&nbsp;*/
<P></P>
<P>enum ftrace_dump_mode {<BR>&nbsp;DUMP_NONE,<BR>&nbsp;DUMP_ALL,<BR>&nbsp;DUMP_ORIG,<BR>};</P>
<P>#ifdef CONFIG_TRACING<BR>void tracing_on(void);<BR>void tracing_off(void);<BR>int tracing_is_on(void);<BR>void tracing_snapshot(void);<BR>void tracing_snapshot_alloc(void);</P>
<P>extern void tracing_start(void);<BR>extern void tracing_stop(void);</P>
<P>static inline __printf(1, 2)<BR>void ____trace_printk_check_format(const char *fmt, ...)<BR>{<BR>}<BR>#define __trace_printk_check_format(fmt, args...)&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;____trace_printk_check_format(fmt, ##args);&nbsp;&nbsp;\<BR>} while (0)</P>
<P>/**<BR>&nbsp;* trace_printk - printf formatting in the ftrace buffer<BR>&nbsp;* @fmt: the printf format for printing<BR>&nbsp;*<BR>&nbsp;* Note: __trace_printk is an internal function for trace_printk and<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the @ip is passed in via the trace_printk macro.<BR>&nbsp;*<BR>&nbsp;* This function allows a kernel developer to debug fast path sections<BR>&nbsp;* that printk is not appropriate for. By scattering in various<BR>&nbsp;* printk like tracing in the code, a developer can quickly see<BR>&nbsp;* where problems are occurring.<BR>&nbsp;*<BR>&nbsp;* This is intended as a debugging tool for the developer only.<BR>&nbsp;* Please refrain from leaving trace_printks scattered around in<BR>&nbsp;* your code. (Extra memory is used for special buffers that are<BR>&nbsp;* allocated when trace_printk() is used)<BR>&nbsp;*<BR>&nbsp;* A little optization trick is done here. If there's only one<BR>&nbsp;* argument, there's no need to scan the string for printf formats.<BR>&nbsp;* The trace_puts() will suffice. But how can we take advantage of<BR>&nbsp;* using trace_puts() when trace_printk() has only one argument?<BR>&nbsp;* By stringifying the args and checking the size we can tell<BR>&nbsp;* whether or not there are args. __stringify((__VA_ARGS__)) will<BR>&nbsp;* turn into "()\0" with a size of 3 when there are no args, anything<BR>&nbsp;* else will be bigger. All we need to do is define a string to this,<BR>&nbsp;* and then take its size and compare to 3. If it's bigger, use<BR>&nbsp;* do_trace_printk() otherwise, optimize it to trace_puts(). Then just<BR>&nbsp;* let gcc optimize the rest.<BR>&nbsp;*/</P>
<P>#define trace_printk(fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;char _______STR[] = __stringify((__VA_ARGS__));&nbsp;\<BR>&nbsp;if (sizeof(_______STR) &gt; 3)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;do_trace_printk(fmt, ##__VA_ARGS__);&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;trace_puts(fmt);&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>#define do_trace_printk(fmt, args...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static const char *trace_printk_fmt&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__attribute__((section("__trace_printk_fmt"))) =&nbsp;\<BR>&nbsp;&nbsp;__builtin_constant_p(fmt) ? fmt : NULL;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__trace_printk_check_format(fmt, ##args);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (__builtin_constant_p(fmt))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_printk(_THIS_IP_, fmt, ##args);&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>extern __printf(2, 3)<BR>int __trace_bprintk(unsigned long ip, const char *fmt, ...);</P>
<P>extern __printf(2, 3)<BR>int __trace_printk(unsigned long ip, const char *fmt, ...);</P>
<P>/**<BR>&nbsp;* trace_puts - write a string into the ftrace buffer<BR>&nbsp;* @str: the string to record<BR>&nbsp;*<BR>&nbsp;* Note: __trace_bputs is an internal function for trace_puts and<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the @ip is passed in via the trace_puts macro.<BR>&nbsp;*<BR>&nbsp;* This is similar to trace_printk() but is made for those really fast<BR>&nbsp;* paths that a developer wants the least amount of "Heisenbug" affects,<BR>&nbsp;* where the processing of the print format is still too much.<BR>&nbsp;*<BR>&nbsp;* This function allows a kernel developer to debug fast path sections<BR>&nbsp;* that printk is not appropriate for. By scattering in various<BR>&nbsp;* printk like tracing in the code, a developer can quickly see<BR>&nbsp;* where problems are occurring.<BR>&nbsp;*<BR>&nbsp;* This is intended as a debugging tool for the developer only.<BR>&nbsp;* Please refrain from leaving trace_puts scattered around in<BR>&nbsp;* your code. (Extra memory is used for special buffers that are<BR>&nbsp;* allocated when trace_puts() is used)<BR>&nbsp;*<BR>&nbsp;* Returns: 0 if nothing was written, positive # if string was.<BR>&nbsp;*&nbsp; (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)<BR>&nbsp;*/</P>
<P>#define trace_puts(str) ({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static const char *trace_printk_fmt&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__attribute__((section("__trace_printk_fmt"))) =&nbsp;\<BR>&nbsp;&nbsp;__builtin_constant_p(str) ? str : NULL;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (__builtin_constant_p(str))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_bputs(_THIS_IP_, trace_printk_fmt);&nbsp;&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_puts(_THIS_IP_, str, strlen(str));&nbsp;&nbsp;\<BR>})<BR>extern int __trace_bputs(unsigned long ip, const char *str);<BR>extern int __trace_puts(unsigned long ip, const char *str, int size);</P>
<P>extern void trace_dump_stack(int skip);</P>
<P>/*<BR>&nbsp;* The double __builtin_constant_p is because gcc will give us an error<BR>&nbsp;* if we try to allocate the static variable to fmt if it is not a<BR>&nbsp;* constant. Even with the outer if statement.<BR>&nbsp;*/<BR>#define ftrace_vprintk(fmt, vargs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (__builtin_constant_p(fmt)) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;static const char *trace_printk_fmt&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp; __attribute__((section("__trace_printk_fmt"))) =&nbsp;\<BR>&nbsp;&nbsp;&nbsp;__builtin_constant_p(fmt) ? fmt : NULL;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);&nbsp;\<BR>&nbsp;} else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ftrace_vprintk(_THIS_IP_, fmt, vargs);&nbsp;&nbsp;\<BR>} while (0)</P>
<P>extern __printf(2, 0) int<BR>__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);</P>
<P>extern __printf(2, 0) int<BR>__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);</P>
<P>extern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);<BR>#else<BR>static inline void tracing_start(void) { }<BR>static inline void tracing_stop(void) { }<BR>static inline void trace_dump_stack(int skip) { }</P>
<P>static inline void tracing_on(void) { }<BR>static inline void tracing_off(void) { }<BR>static inline int tracing_is_on(void) { return 0; }<BR>static inline void tracing_snapshot(void) { }<BR>static inline void tracing_snapshot_alloc(void) { }</P>
<P>static inline __printf(1, 2)<BR>int trace_printk(const char *fmt, ...)<BR>{<BR>&nbsp;return 0;<BR>}<BR>static __printf(1, 0) inline int<BR>ftrace_vprintk(const char *fmt, va_list ap)<BR>{<BR>&nbsp;return 0;<BR>}<BR>static inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }<BR>#endif /* CONFIG_TRACING */