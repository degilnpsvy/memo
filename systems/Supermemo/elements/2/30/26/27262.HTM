/*<BR>&nbsp;* panic_cpu is used for synchronizing panic() and crash_kexec() execution. It<BR>&nbsp;* holds a CPU number which is executing panic() currently. A value of<BR>&nbsp;* PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().<BR>&nbsp;*/<BR>extern atomic_t panic_cpu;<BR>#define PANIC_CPU_INVALID&nbsp;-1
<P></P>
<P>/*<BR>&nbsp;* A variant of panic() called from NMI context. We return if we've already<BR>&nbsp;* panicked on this CPU. If another CPU already panicked, loop in<BR>&nbsp;* nmi_panic_self_stop() which can provide architecture dependent code such<BR>&nbsp;* as saving register state for crash dump.<BR>&nbsp;*/<BR>#define nmi_panic(regs, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int old_cpu, cpu;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;cpu = raw_smp_processor_id();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;old_cpu = atomic_cmpxchg(&amp;panic_cpu, PANIC_CPU_INVALID, cpu);&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (old_cpu == PANIC_CPU_INVALID)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;panic(fmt, ##__VA_ARGS__);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;else if (old_cpu != cpu)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;nmi_panic_self_stop(regs);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>/*<BR>&nbsp;* Only to be used by arch init code. If the user over-wrote the default<BR>&nbsp;* CONFIG_PANIC_TIMEOUT, honor it.<BR>&nbsp;*/<BR>static inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)<BR>{<BR>&nbsp;if (panic_timeout == arch_default_timeout)<BR>&nbsp;&nbsp;panic_timeout = timeout;<BR>}