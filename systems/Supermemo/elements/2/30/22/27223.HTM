3.4) Instruction Reference <FONT class=extract>********* Function call * call &lt;ret&gt; &lt;params&gt; ptr call function 'ptr' (pointer type) &lt;ret&gt; optional 32 bit or 64 bit return value &lt;params&gt; optional 32 bit or 64 bit parameters</FONT> <FONT class=extract>********* Jumps/Labels * set_label $label Define label 'label' at the current program point. * br $label Jump to label. * brcond_i32/i64 t0, t1, cond, label Conditional jump if t0 cond t1 is true. cond can be: TCG_COND_EQ TCG_COND_NE TCG_COND_LT /* signed */ TCG_COND_GE /* signed */ TCG_COND_LE /* signed */ TCG_COND_GT /* signed */ TCG_COND_LTU /* unsigned */ TCG_COND_GEU /* unsigned */ TCG_COND_LEU /* unsigned */ TCG_COND_GTU /* unsigned */</FONT> <FONT class=extract>********* Arithmetic * add_i32/i64 t0, t1, t2 t0=t1+t2 * sub_i32/i64 t0, t1, t2 t0=t1-t2 * neg_i32/i64 t0, t1 t0=-t1 (two's complement) * mul_i32/i64 t0, t1, t2 t0=t1*t2 * div_i32/i64 t0, t1, t2 t0=t1/t2 (signed). Undefined behavior if division by zero or overflow. * divu_i32/i64 t0, t1, t2 t0=t1/t2 (unsigned). Undefined behavior if division by zero. * rem_i32/i64 t0, t1, t2 t0=t1%t2 (signed). Undefined behavior if division by zero or overflow. * remu_i32/i64 t0, t1, t2 t0=t1%t2 (unsigned). Undefined behavior if division by zero.</FONT> <FONT class=extract>********* Logical * and_i32/i64 t0, t1, t2 t0=t1&amp;t2 * or_i32/i64 t0, t1, t2 t0=t1|t2 * xor_i32/i64 t0, t1, t2 t0=t1^t2 * not_i32/i64 t0, t1 t0=~t1 * andc_i32/i64 t0, t1, t2 t0=t1&amp;~t2 * eqv_i32/i64 t0, t1, t2 t0=~(t1^t2), or equivalently, t0=t1^~t2 * nand_i32/i64 t0, t1, t2 t0=~(t1&amp;t2) * nor_i32/i64 t0, t1, t2 t0=~(t1|t2) * orc_i32/i64 t0, t1, t2 t0=t1|~t2</FONT> <FONT class=extract>********* Shifts/Rotates * shl_i32/i64 t0, t1, t2 t0=t1 &lt;&lt; t2. Unspecified behavior if t2 &lt; 0 or t2 &gt;= 32 (resp 64) * shr_i32/i64 t0, t1, t2 t0=t1 &gt;&gt; t2 (unsigned). Unspecified behavior if t2 &lt; 0 or t2 &gt;= 32 (resp 64) * sar_i32/i64 t0, t1, t2 t0=t1 &gt;&gt; t2 (signed). Unspecified behavior if t2 &lt; 0 or t2 &gt;= 32 (resp 64) * rotl_i32/i64 t0, t1, t2 Rotation of t2 bits to the left. Unspecified behavior if t2 &lt; 0 or t2 &gt;= 32 (resp 64) * rotr_i32/i64 t0, t1, t2 Rotation of t2 bits to the right. Unspecified behavior if t2 &lt; 0 or t2 &gt;= 32 (resp 64)</FONT> <FONT class=extract>********* Misc * mov_i32/i64 t0, t1 t0 = t1 Move t1 to t0 (both operands must have the same type). * ext8s_i32/i64 t0, t1 ext8u_i32/i64 t0, t1 ext16s_i32/i64 t0, t1 ext16u_i32/i64 t0, t1 ext32s_i64 t0, t1 ext32u_i64 t0, t1 8, 16 or 32 bit sign/zero extension (both operands must have the same type) * bswap16_i32/i64 t0, t1 16 bit byte swap on a 32/64 bit value. It assumes that the two/six high order bytes are set to zero. * bswap32_i32/i64 t0, t1 32 bit byte swap on a 32/64 bit value. With a 64 bit value, it assumes that the four high order bytes are set to zero. * bswap64_i64 t0, t1 64 bit byte swap * discard_i32/i64 t0 Indicate that the value of t0 won't be used later. It is useful to force dead code elimination. * deposit_i32/i64 dest, t1, t2, pos, len Deposit T2 as a bitfield into T1, placing the result in DEST. The bitfield is described by POS/LEN, which are immediate values: LEN - the length of the bitfield POS - the position of the first bit, counting from the LSB For example, pos=8, len=4 indicates a 4-bit field at bit 8. This operation would be equivalent to dest = (t1 &amp; ~0x0f00) | ((t2 &lt;&lt; 8) &amp; 0x0f00) * extrl_i64_i32 t0, t1 For 64-bit hosts only, extract the low 32-bits of input T1 and place it into 32-bit output T0. Depending on the host, this may be a simple move, or may require additional canonicalization. * extrh_i64_i32 t0, t1 For 64-bit hosts only, extract the high 32-bits of input T1 and place it into 32-bit output T0. Depending on the host, this may be a simple shift, or may require additional canonicalization.</FONT> <FONT class=extract>********* Conditional moves * setcond_i32/i64 dest, t1, t2, cond dest = (t1 cond t2) Set DEST to 1 if (T1 cond T2) is true, otherwise set to 0. * movcond_i32/i64 dest, c1, c2, v1, v2, cond dest = (c1 cond c2 ? v1 : v2) Set DEST to V1 if (C1 cond C2) is true, otherwise set to V2.</FONT> <FONT class=extract>********* Type conversions * ext_i32_i64 t0, t1 Convert t1 (32 bit) to t0 (64 bit) and does sign extension * extu_i32_i64 t0, t1 Convert t1 (32 bit) to t0 (64 bit) and does zero extension * trunc_i64_i32 t0, t1 Truncate t1 (64 bit) to t0 (32 bit) * concat_i32_i64 t0, t1, t2 Construct t0 (64-bit) taking the low half from t1 (32 bit) and the high half from t2 (32 bit). * concat32_i64 t0, t1, t2 Construct t0 (64-bit) taking the low half from t1 (64 bit) and the high half from t2 (64 bit).</FONT> <FONT class=extract>********* Load/Store * ld_i32/i64 t0, t1, offset ld8s_i32/i64 t0, t1, offset ld8u_i32/i64 t0, t1, offset ld16s_i32/i64 t0, t1, offset ld16u_i32/i64 t0, t1, offset ld32s_i64 t0, t1, offset ld32u_i64 t0, t1, offset t0 = read(t1 + offset) Load 8, 16, 32 or 64 bits with or without sign extension from host memory. offset must be a constant. * st_i32/i64 t0, t1, offset st8_i32/i64 t0, t1, offset st16_i32/i64 t0, t1, offset st32_i64 t0, t1, offset write(t0, t1 + offset) Write 8, 16, 32 or 64 bits to host memory. All this opcodes assume that the pointed host memory doesn't correspond to a global. In the latter case the behaviour is unpredictable.</FONT> <FONT class=extract>********* Multiword arithmetic support * add2_i32/i64 t0_low, t0_high, t1_low, t1_high, t2_low, t2_high * sub2_i32/i64 t0_low, t0_high, t1_low, t1_high, t2_low, t2_high Similar to add/sub, except that the double-word inputs T1 and T2 are formed from two single-word arguments, and the double-word output T0 is returned in two single-word outputs. * mulu2_i32/i64 t0_low, t0_high, t1, t2 Similar to mul, except two unsigned inputs T1 and T2 yielding the full double-word product T0. The later is returned in two single-word outputs. * muls2_i32/i64 t0_low, t0_high, t1, t2 Similar to mulu2, except the two inputs T1 and T2 are signed.</FONT> <FONT class=extract>********* 64-bit guest on 32-bit host support The following opcodes are internal to TCG. Thus they are to be implemented by 32-bit host code generators, but are not to be emitted by guest translators. They are emitted as needed by inline functions within "tcg-op.h". * brcond2_i32 t0_low, t0_high, t1_low, t1_high, cond, label Similar to brcond, except that the 64-bit values T0 and T1 are formed from two 32-bit arguments. * setcond2_i32 dest, t1_low, t1_high, t2_low, t2_high, cond Similar to setcond, except that the 64-bit values T1 and T2 are formed from two 32-bit arguments. The result is a 32-bit value.</FONT> <FONT class=extract>********* QEMU specific operations * exit_tb t0 Exit the current TB and return the value t0 (word type). * goto_tb index Exit the current TB and jump to the TB index 'index' (constant) if the current TB was linked to this TB. Otherwise execute the next instructions. Only indices 0 and 1 are valid and tcg_gen_goto_tb may be issued at most once with each slot index per TB. * qemu_ld_i32/i64 t0, t1, flags, memidx * qemu_st_i32/i64 t0, t1, flags, memidx Load data at the guest address t1 into t0, or store data in t0 at guest address t1. The _i32/_i64 size applies to the size of the input/output register t0 only. The address t1 is always sized according to the guest, and the width of the memory operation is controlled by flags. Both t0 and t1 may be split into little-endian ordered pairs of registers if dealing with 64-bit quantities on a 32-bit host. The memidx selects the qemu tlb index to use (e.g. user or kernel access). The flags are the TCGMemOp bits, selecting the sign, width, and endianness of the memory access. For a 32-bit host, qemu_ld/st_i64 is guaranteed to only be used with a 64-bit memory access specified in flags.</FONT> ********* <FONT class=extract>Note 1: Some shortcuts are defined when the last operand is known to be a constant (e.g. addi for add, movi for mov).</FONT> <FONT class=extract>Note 2: When using TCG, the opcodes must never be generated directly as some of them may not be available as "real" opcodes. Always use the function tcg_gen_xxx(args).</FONT>