********* Misc 
<P></P>
<P>* mov_i32/i64 t0, t1 </P>
<P>t0 = t1 </P>
<P>Move t1 to t0 (both operands must have the same type). </P>
<P>&nbsp;</P>
<P>* ext8s_i32/i64 t0, t1 </P>
<P>ext8u_i32/i64 t0, t1 </P>
<P>ext16s_i32/i64 t0, t1 </P>
<P>ext16u_i32/i64 t0, t1 </P>
<P>ext32s_i64 t0, t1 </P>
<P>ext32u_i64 t0, t1 </P>
<P>8, 16 or 32 bit sign/zero extension (both operands must have the same type) </P>
<P>&nbsp;</P>
<P>* bswap16_i32/i64 t0, t1 </P>
<P>16 bit byte swap on a 32/64 bit value. It assumes that the two/six high order bytes are set to zero. </P>
<P>&nbsp;</P>
<P>* bswap32_i32/i64 t0, t1 </P>
<P>32 bit byte swap on a 32/64 bit value. With a 64 bit value, it assumes that the four high order bytes are set to zero. </P>
<P>&nbsp;</P>
<P>* bswap64_i64 t0, t1 </P>
<P>64 bit byte swap </P>
<P>&nbsp;</P>
<P>* discard_i32/i64 t0 </P>
<P>Indicate that the value of t0 won't be used later. It is useful to force dead code elimination. </P>
<P>&nbsp;</P>
<P>* deposit_i32/i64 dest, t1, t2, pos, len </P>
<P>Deposit T2 as a bitfield into T1, placing the result in DEST. </P>
<P>The bitfield is described by POS/LEN, which are immediate values: </P>
<P>LEN - the length of the bitfield </P>
<P>POS - the position of the first bit, counting from the LSB </P>
<P>For example, pos=8, len=4 indicates a 4-bit field at bit 8. </P>
<P>This operation would be equivalent to </P>
<P>dest = (t1 &amp; ~0x0f00) | ((t2 &lt;&lt; 8) &amp; 0x0f00) </P>
<P>&nbsp;</P>
<P>* extrl_i64_i32 t0, t1 </P>
<P>For 64-bit hosts only, extract the low 32-bits of input T1 and place it into 32-bit output T0. Depending on the host, this may be a simple move, or may require additional canonicalization. </P>
<P>&nbsp;</P>
<P>* extrh_i64_i32 t0, t1 </P>
<P>For 64-bit hosts only, extract the high 32-bits of input T1 and place it into 32-bit output T0. Depending on the host, this may be a simple shift, or may require additional canonicalization.