#Linux 4.5-rc6/linux/lib/vsprintf.c 
<P></P>
<P>/*<BR>&nbsp;*&nbsp; linux/lib/vsprintf.c<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (C) 1991, 1992&nbsp; Linus Torvalds<BR>&nbsp;*/ </P>
<P></P>
<P>/* vsprintf.c -- Lars Wirzenius &amp; Linus Torvalds. */<BR>/*<BR>&nbsp;* Wirzenius wrote this portably, Torvalds fucked it up :-)<BR>&nbsp;*/</P>
<P>/*<BR>&nbsp;* Fri Jul 13 2001 Crutcher Dunnavant &lt;<A href="mailto:crutcher+kernel@datastacks.com">crutcher+kernel@datastacks.com</A>&gt;<BR>&nbsp;* - changed to provide snprintf and vsnprintf functions<BR>&nbsp;* So Feb&nbsp; 1 16:51:32 CET 2004 Juergen Quade &lt;<A href="mailto:quade@hsnr.de">quade@hsnr.de</A>&gt;<BR>&nbsp;* - scnprintf and vscnprintf<BR>&nbsp;*/</P>
<P>#include &lt;stdarg.h&gt;<BR>#include &lt;linux/clk.h&gt;<BR>#include &lt;linux/clk-provider.h&gt;<BR>#include &lt;linux/module.h&gt;&nbsp;/* for KSYM_SYMBOL_LEN */<BR>#include &lt;linux/types.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/ctype.h&gt;<BR>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/kallsyms.h&gt;<BR>#include &lt;linux/math64.h&gt;<BR>#include &lt;linux/uaccess.h&gt;<BR>#include &lt;linux/ioport.h&gt;<BR>#include &lt;linux/dcache.h&gt;<BR>#include &lt;linux/cred.h&gt;<BR>#include &lt;net/addrconf.h&gt;<BR>#ifdef CONFIG_BLOCK<BR>#include &lt;linux/blkdev.h&gt;<BR>#endif</P>
<P>#include &lt;asm/page.h&gt;&nbsp;&nbsp;/* for PAGE_SIZE */<BR>#include &lt;asm/sections.h&gt;&nbsp;/* for dereference_function_descriptor() */<BR>#include &lt;asm/byteorder.h&gt;&nbsp;/* cpu_to_le16 */</P>
<P>#include &lt;linux/string_helpers.h&gt;<BR>#include "kstrtox.h"</P>
<P><FONT class=extract>/**<BR>&nbsp;* simple_strtoull - convert a string to an unsigned long long<BR>&nbsp;* @cp: The start of the string<BR>&nbsp;* @endp: A pointer to the end of the parsed string will be placed here<BR>&nbsp;* @base: The number base to use<BR>&nbsp;*<BR>&nbsp;* This function is obsolete. Please use kstrtoull instead.<BR>&nbsp;*/<BR>unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)<BR>{<BR>&nbsp;unsigned long long result;<BR>&nbsp;unsigned int rv;</FONT></P>
<P><FONT class=extract>&nbsp;cp = _parse_integer_fixup_radix(cp, &amp;base);<BR>&nbsp;rv = _parse_integer(cp, base, &amp;result);<BR>&nbsp;/* FIXME */<BR>&nbsp;cp += (rv &amp; ~KSTRTOX_OVERFLOW);</FONT></P>
<P><FONT class=extract>&nbsp;if (endp)<BR>&nbsp;&nbsp;*endp = (char *)cp;</FONT></P>
<P><FONT class=extract>&nbsp;return result;<BR>}<BR>EXPORT_SYMBOL(simple_strtoull);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* simple_strtoul - convert a string to an unsigned long<BR>&nbsp;* @cp: The start of the string<BR>&nbsp;* @endp: A pointer to the end of the parsed string will be placed here<BR>&nbsp;* @base: The number base to use<BR>&nbsp;*<BR>&nbsp;* This function is obsolete. Please use kstrtoul instead.<BR>&nbsp;*/<BR>unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)<BR>{<BR>&nbsp;return simple_strtoull(cp, endp, base);<BR>}<BR>EXPORT_SYMBOL(simple_strtoul);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* simple_strtol - convert a string to a signed long<BR>&nbsp;* @cp: The start of the string<BR>&nbsp;* @endp: A pointer to the end of the parsed string will be placed here<BR>&nbsp;* @base: The number base to use<BR>&nbsp;*<BR>&nbsp;* This function is obsolete. Please use kstrtol instead.<BR>&nbsp;*/<BR>long simple_strtol(const char *cp, char **endp, unsigned int base)<BR>{<BR>&nbsp;if (*cp == '-')<BR>&nbsp;&nbsp;return -simple_strtoul(cp + 1, endp, base);</FONT></P>
<P><FONT class=extract>&nbsp;return simple_strtoul(cp, endp, base);<BR>}<BR>EXPORT_SYMBOL(simple_strtol);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* simple_strtoll - convert a string to a signed long long<BR>&nbsp;* @cp: The start of the string<BR>&nbsp;* @endp: A pointer to the end of the parsed string will be placed here<BR>&nbsp;* @base: The number base to use<BR>&nbsp;*<BR>&nbsp;* This function is obsolete. Please use kstrtoll instead.<BR>&nbsp;*/<BR>long long simple_strtoll(const char *cp, char **endp, unsigned int base)<BR>{<BR>&nbsp;if (*cp == '-')<BR>&nbsp;&nbsp;return -simple_strtoull(cp + 1, endp, base);</FONT></P>
<P><FONT class=extract>&nbsp;return simple_strtoull(cp, endp, base);<BR>}<BR>EXPORT_SYMBOL(simple_strtoll);</FONT></P>
<P><FONT class=extract>static noinline_for_stack<BR>int skip_atoi(const char **s)<BR>{<BR>&nbsp;int i = 0;</FONT></P>
<P><FONT class=extract>&nbsp;do {<BR>&nbsp;&nbsp;i = i*10 + *((*s)++) - '0';<BR>&nbsp;} while (isdigit(**s));</FONT></P>
<P><FONT class=extract>&nbsp;return i;<BR>}</FONT></P>
<P>/*<BR>&nbsp;* Decimal conversion is by far the most typical, and is used for<BR>&nbsp;* /proc and /sys data. This directly impacts e.g. top performance<BR>&nbsp;* with many processes running. We optimize it for speed by emitting<BR>&nbsp;* two characters at a time, using a 200 byte lookup table. This<BR>&nbsp;* roughly halves the number of multiplications compared to computing<BR>&nbsp;* the digits one at a time. Implementation strongly inspired by the<BR>&nbsp;* previous version, which in turn used ideas described at<BR>&nbsp;* &lt;<A href="http://www.cs.uiowa.edu/~jones/bcd/divide.html">http://www.cs.uiowa.edu/~jones/bcd/divide.html</A>&gt; (with permission<BR>&nbsp;* from the author, Douglas W. Jones).<BR>&nbsp;*<BR>&nbsp;* It turns out there is precisely one 26 bit fixed-point<BR>&nbsp;* approximation a of 64/100 for which x/100 == (x * (u64)a) &gt;&gt; 32<BR>&nbsp;* holds for all x in [0, 10^8-1], namely a = 0x28f5c29. The actual<BR>&nbsp;* range happens to be somewhat larger (x &lt;= 1073741898), but that's<BR>&nbsp;* irrelevant for our purpose.<BR>&nbsp;*<BR>&nbsp;* For dividing a number in the range [10^4, 10^6-1] by 100, we still<BR>&nbsp;* need a 32x32-&gt;64 bit multiply, so we simply use the same constant.<BR>&nbsp;*<BR>&nbsp;* For dividing a number in the range [100, 10^4-1] by 100, there are<BR>&nbsp;* several options. The simplest is (x * 0x147b) &gt;&gt; 19, which is valid<BR>&nbsp;* for all x &lt;= 43698.<BR>&nbsp;*/</P>
<P>static const u16 decpair[100] = {<BR>#define _(x) (__force u16) cpu_to_le16(((x % 10) | ((x / 10) &lt;&lt; 8)) + 0x3030)<BR>&nbsp;_( 0), _( 1), _( 2), _( 3), _( 4), _( 5), _( 6), _( 7), _( 8), _( 9),<BR>&nbsp;_(10), _(11), _(12), _(13), _(14), _(15), _(16), _(17), _(18), _(19),<BR>&nbsp;_(20), _(21), _(22), _(23), _(24), _(25), _(26), _(27), _(28), _(29),<BR>&nbsp;_(30), _(31), _(32), _(33), _(34), _(35), _(36), _(37), _(38), _(39),<BR>&nbsp;_(40), _(41), _(42), _(43), _(44), _(45), _(46), _(47), _(48), _(49),<BR>&nbsp;_(50), _(51), _(52), _(53), _(54), _(55), _(56), _(57), _(58), _(59),<BR>&nbsp;_(60), _(61), _(62), _(63), _(64), _(65), _(66), _(67), _(68), _(69),<BR>&nbsp;_(70), _(71), _(72), _(73), _(74), _(75), _(76), _(77), _(78), _(79),<BR>&nbsp;_(80), _(81), _(82), _(83), _(84), _(85), _(86), _(87), _(88), _(89),<BR>&nbsp;_(90), _(91), _(92), _(93), _(94), _(95), _(96), _(97), _(98), _(99),<BR>#undef _<BR>};</P>
<P>/*<BR>&nbsp;* This will print a single '0' even if r == 0, since we would<BR>&nbsp;* immediately jump to out_r where two 0s would be written but only<BR>&nbsp;* one of them accounted for in buf. This is needed by ip4_string<BR>&nbsp;* below. All other callers pass a non-zero value of r.<BR>*/<BR>static noinline_for_stack<BR>char *put_dec_trunc8(char *buf, unsigned r)<BR>{<BR>&nbsp;unsigned q;</P>
<P>&nbsp;/* 1 &lt;= r &lt; 10^8 */<BR>&nbsp;if (r &lt; 100)<BR>&nbsp;&nbsp;goto out_r;</P>
<P>&nbsp;/* 100 &lt;= r &lt; 10^8 */<BR>&nbsp;q = (r * (u64)0x28f5c29) &gt;&gt; 32;<BR>&nbsp;*((u16 *)buf) = decpair[r - 100*q];<BR>&nbsp;buf += 2;</P>
<P>&nbsp;/* 1 &lt;= q &lt; 10^6 */<BR>&nbsp;if (q &lt; 100)<BR>&nbsp;&nbsp;goto out_q;</P>
<P>&nbsp;/*&nbsp; 100 &lt;= q &lt; 10^6 */<BR>&nbsp;r = (q * (u64)0x28f5c29) &gt;&gt; 32;<BR>&nbsp;*((u16 *)buf) = decpair[q - 100*r];<BR>&nbsp;buf += 2;</P>
<P>&nbsp;/* 1 &lt;= r &lt; 10^4 */<BR>&nbsp;if (r &lt; 100)<BR>&nbsp;&nbsp;goto out_r;</P>
<P>&nbsp;/* 100 &lt;= r &lt; 10^4 */<BR>&nbsp;q = (r * 0x147b) &gt;&gt; 19;<BR>&nbsp;*((u16 *)buf) = decpair[r - 100*q];<BR>&nbsp;buf += 2;<BR>out_q:<BR>&nbsp;/* 1 &lt;= q &lt; 100 */<BR>&nbsp;r = q;<BR>out_r:<BR>&nbsp;/* 1 &lt;= r &lt; 100 */<BR>&nbsp;*((u16 *)buf) = decpair[r];<BR>&nbsp;buf += r &lt; 10 ? 1 : 2;<BR>&nbsp;return buf;<BR>}</P>
<P>#if BITS_PER_LONG == 64 &amp;&amp; BITS_PER_LONG_LONG == 64<BR>static noinline_for_stack<BR>char *put_dec_full8(char *buf, unsigned r)<BR>{<BR>&nbsp;unsigned q;</P>
<P>&nbsp;/* 0 &lt;= r &lt; 10^8 */<BR>&nbsp;q = (r * (u64)0x28f5c29) &gt;&gt; 32;<BR>&nbsp;*((u16 *)buf) = decpair[r - 100*q];<BR>&nbsp;buf += 2;</P>
<P>&nbsp;/* 0 &lt;= q &lt; 10^6 */<BR>&nbsp;r = (q * (u64)0x28f5c29) &gt;&gt; 32;<BR>&nbsp;*((u16 *)buf) = decpair[q - 100*r];<BR>&nbsp;buf += 2;</P>
<P>&nbsp;/* 0 &lt;= r &lt; 10^4 */<BR>&nbsp;q = (r * 0x147b) &gt;&gt; 19;<BR>&nbsp;*((u16 *)buf) = decpair[r - 100*q];<BR>&nbsp;buf += 2;</P>
<P>&nbsp;/* 0 &lt;= q &lt; 100 */<BR>&nbsp;*((u16 *)buf) = decpair[q];<BR>&nbsp;buf += 2;<BR>&nbsp;return buf;<BR>}</P>
<P>static noinline_for_stack<BR>char *put_dec(char *buf, unsigned long long n)<BR>{<BR>&nbsp;if (n &gt;= 100*1000*1000)<BR>&nbsp;&nbsp;buf = put_dec_full8(buf, do_div(n, 100*1000*1000));<BR>&nbsp;/* 1 &lt;= n &lt;= 1.6e11 */<BR>&nbsp;if (n &gt;= 100*1000*1000)<BR>&nbsp;&nbsp;buf = put_dec_full8(buf, do_div(n, 100*1000*1000));<BR>&nbsp;/* 1 &lt;= n &lt; 1e8 */<BR>&nbsp;return put_dec_trunc8(buf, n);<BR>}</P>
<P>#elif BITS_PER_LONG == 32 &amp;&amp; BITS_PER_LONG_LONG == 64</P>
<P>static void<BR>put_dec_full4(char *buf, unsigned r)<BR>{<BR>&nbsp;unsigned q;</P>
<P>&nbsp;/* 0 &lt;= r &lt; 10^4 */<BR>&nbsp;q = (r * 0x147b) &gt;&gt; 19;<BR>&nbsp;*((u16 *)buf) = decpair[r - 100*q];<BR>&nbsp;buf += 2;<BR>&nbsp;/* 0 &lt;= q &lt; 100 */<BR>&nbsp;*((u16 *)buf) = decpair[q];<BR>}</P>
<P>/*<BR>&nbsp;* Call put_dec_full4 on x % 10000, return x / 10000.<BR>&nbsp;* The approximation x/10000 == (x * 0x346DC5D7) &gt;&gt; 43<BR>&nbsp;* holds for all x &lt; 1,128,869,999.&nbsp; The largest value this<BR>&nbsp;* helper will ever be asked to convert is 1,125,520,955.<BR>&nbsp;* (second call in the put_dec code, assuming n is all-ones).<BR>&nbsp;*/<BR>static noinline_for_stack<BR>unsigned put_dec_helper4(char *buf, unsigned x)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t q = (x * (uint64_t)0x346DC5D7) &gt;&gt; 43;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; put_dec_full4(buf, x - q * 10000);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q;<BR>}</P>
<P>/* Based on code by Douglas W. Jones found at<BR>&nbsp;* &lt;<A href="http://www.cs.uiowa.edu/~jones/bcd/decimal.html#sixtyfour">http://www.cs.uiowa.edu/~jones/bcd/decimal.html#sixtyfour</A>&gt;<BR>&nbsp;* (with permission from the author).<BR>&nbsp;* Performs no 64-bit division and hence should be fast on 32-bit machines.<BR>&nbsp;*/<BR>static<BR>char *put_dec(char *buf, unsigned long long n)<BR>{<BR>&nbsp;uint32_t d3, d2, d1, q, h;</P>
<P>&nbsp;if (n &lt; 100*1000*1000)<BR>&nbsp;&nbsp;return put_dec_trunc8(buf, n);</P>
<P>&nbsp;d1&nbsp; = ((uint32_t)n &gt;&gt; 16); /* implicit "&amp; 0xffff" */<BR>&nbsp;h&nbsp;&nbsp; = (n &gt;&gt; 32);<BR>&nbsp;d2&nbsp; = (h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) &amp; 0xffff;<BR>&nbsp;d3&nbsp; = (h &gt;&gt; 16); /* implicit "&amp; 0xffff" */</P>
<P>&nbsp;/* n = 2^48 d3 + 2^32 d2 + 2^16 d1 + d0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 281_4749_7671_0656 d3 + 42_9496_7296 d2 + 6_5536 d1 + d0 */<BR>&nbsp;q&nbsp;&nbsp; = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n &amp; 0xffff);<BR>&nbsp;q = put_dec_helper4(buf, q);</P>
<P>&nbsp;q += 7671 * d3 + 9496 * d2 + 6 * d1;<BR>&nbsp;q = put_dec_helper4(buf+4, q);</P>
<P>&nbsp;q += 4749 * d3 + 42 * d2;<BR>&nbsp;q = put_dec_helper4(buf+8, q);</P>
<P>&nbsp;q += 281 * d3;<BR>&nbsp;buf += 12;<BR>&nbsp;if (q)<BR>&nbsp;&nbsp;buf = put_dec_trunc8(buf, q);<BR>&nbsp;else while (buf[-1] == '0')<BR>&nbsp;&nbsp;--buf;</P>
<P>&nbsp;return buf;<BR>}</P>
<P>#endif</P>
<P>/*<BR>&nbsp;* Convert passed number to decimal string.<BR>&nbsp;* Returns the length of string.&nbsp; On buffer overflow, returns 0.<BR>&nbsp;*<BR>&nbsp;* If speed is not important, use snprintf(). It's easy to read the code.<BR>&nbsp;*/<BR>int num_to_str(char *buf, int size, unsigned long long num)<BR>{<BR>&nbsp;/* put_dec requires 2-byte alignment of the buffer. */<BR>&nbsp;char tmp[sizeof(num) * 3] __aligned(2);<BR>&nbsp;int idx, len;</P>
<P>&nbsp;/* put_dec() may work incorrectly for num = 0 (generate "", not "0") */<BR>&nbsp;if (num &lt;= 9) {<BR>&nbsp;&nbsp;tmp[0] = '0' + num;<BR>&nbsp;&nbsp;len = 1;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;len = put_dec(tmp, num) - tmp;<BR>&nbsp;}</P>
<P>&nbsp;if (len &gt; size)<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;for (idx = 0; idx &lt; len; ++idx)<BR>&nbsp;&nbsp;buf[idx] = tmp[len - idx - 1];<BR>&nbsp;return len;<BR>}</P>
<P>#define SIGN&nbsp;1&nbsp;&nbsp;/* unsigned/signed, must be 1 */<BR>#define LEFT&nbsp;2&nbsp;&nbsp;/* left justified */<BR>#define PLUS&nbsp;4&nbsp;&nbsp;/* show plus */<BR>#define SPACE&nbsp;8&nbsp;&nbsp;/* space if plus */<BR>#define ZEROPAD&nbsp;16&nbsp;&nbsp;/* pad with zero, must be 16 == '0' - ' ' */<BR>#define SMALL&nbsp;32&nbsp;&nbsp;/* use lowercase in hex (must be 32 == 0x20) */<BR>#define SPECIAL&nbsp;64&nbsp;&nbsp;/* prefix hex with "0x", octal with "0" */</P>
<P>enum format_type {<BR>&nbsp;FORMAT_TYPE_NONE, /* Just a string part */<BR>&nbsp;FORMAT_TYPE_WIDTH,<BR>&nbsp;FORMAT_TYPE_PRECISION,<BR>&nbsp;FORMAT_TYPE_CHAR,<BR>&nbsp;FORMAT_TYPE_STR,<BR>&nbsp;FORMAT_TYPE_PTR,<BR>&nbsp;FORMAT_TYPE_PERCENT_CHAR,<BR>&nbsp;FORMAT_TYPE_INVALID,<BR>&nbsp;FORMAT_TYPE_LONG_LONG,<BR>&nbsp;FORMAT_TYPE_ULONG,<BR>&nbsp;FORMAT_TYPE_LONG,<BR>&nbsp;FORMAT_TYPE_UBYTE,<BR>&nbsp;FORMAT_TYPE_BYTE,<BR>&nbsp;FORMAT_TYPE_USHORT,<BR>&nbsp;FORMAT_TYPE_SHORT,<BR>&nbsp;FORMAT_TYPE_UINT,<BR>&nbsp;FORMAT_TYPE_INT,<BR>&nbsp;FORMAT_TYPE_SIZE_T,<BR>&nbsp;FORMAT_TYPE_PTRDIFF<BR>};</P>
<P>struct printf_spec {<BR>&nbsp;unsigned int&nbsp;type:8;&nbsp;&nbsp;/* format_type enum */<BR>&nbsp;signed int&nbsp;field_width:24;&nbsp;/* width of output field */<BR>&nbsp;unsigned int&nbsp;flags:8;&nbsp;/* flags to number() */<BR>&nbsp;unsigned int&nbsp;base:8;&nbsp;&nbsp;/* number base, 8, 10 or 16 only */<BR>&nbsp;signed int&nbsp;precision:16;&nbsp;/* # of digits/chars */<BR>} __packed;<BR>#define FIELD_WIDTH_MAX ((1 &lt;&lt; 23) - 1)<BR>#define PRECISION_MAX ((1 &lt;&lt; 15) - 1)</P>
<P>static noinline_for_stack<BR>char *number(char *buf, char *end, unsigned long long num,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct printf_spec spec)<BR>{<BR>&nbsp;/* put_dec requires 2-byte alignment of the buffer. */<BR>&nbsp;char tmp[3 * sizeof(num)] __aligned(2);<BR>&nbsp;char sign;<BR>&nbsp;char locase;<BR>&nbsp;int need_pfx = ((spec.flags &amp; SPECIAL) &amp;&amp; spec.base != 10);<BR>&nbsp;int i;<BR>&nbsp;bool is_zero = num == 0LL;<BR>&nbsp;int field_width = spec.field_width;<BR>&nbsp;int precision = spec.precision;</P>
<P>&nbsp;BUILD_BUG_ON(sizeof(struct printf_spec) != 8);</P>
<P>&nbsp;/* locase = 0 or 0x20. ORing digits or letters with 'locase'<BR>&nbsp; * produces same digits or (maybe lowercased) letters */<BR>&nbsp;locase = (spec.flags &amp; SMALL);<BR>&nbsp;if (spec.flags &amp; LEFT)<BR>&nbsp;&nbsp;spec.flags &amp;= ~ZEROPAD;<BR>&nbsp;sign = 0;<BR>&nbsp;if (spec.flags &amp; SIGN) {<BR>&nbsp;&nbsp;if ((signed long long)num &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;sign = '-';<BR>&nbsp;&nbsp;&nbsp;num = -(signed long long)num;<BR>&nbsp;&nbsp;&nbsp;field_width--;<BR>&nbsp;&nbsp;} else if (spec.flags &amp; PLUS) {<BR>&nbsp;&nbsp;&nbsp;sign = '+';<BR>&nbsp;&nbsp;&nbsp;field_width--;<BR>&nbsp;&nbsp;} else if (spec.flags &amp; SPACE) {<BR>&nbsp;&nbsp;&nbsp;sign = ' ';<BR>&nbsp;&nbsp;&nbsp;field_width--;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;if (need_pfx) {<BR>&nbsp;&nbsp;if (spec.base == 16)<BR>&nbsp;&nbsp;&nbsp;field_width -= 2;<BR>&nbsp;&nbsp;else if (!is_zero)<BR>&nbsp;&nbsp;&nbsp;field_width--;<BR>&nbsp;}</P>
<P>&nbsp;/* generate full string in tmp[], in reverse order */<BR>&nbsp;i = 0;<BR>&nbsp;if (num &lt; spec.base)<BR>&nbsp;&nbsp;tmp[i++] = hex_asc_upper[num] | locase;<BR>&nbsp;else if (spec.base != 10) { /* 8 or 16 */<BR>&nbsp;&nbsp;int mask = spec.base - 1;<BR>&nbsp;&nbsp;int shift = 3;</P>
<P>&nbsp;&nbsp;if (spec.base == 16)<BR>&nbsp;&nbsp;&nbsp;shift = 4;<BR>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;tmp[i++] = (hex_asc_upper[((unsigned char)num) &amp; mask] | locase);<BR>&nbsp;&nbsp;&nbsp;num &gt;&gt;= shift;<BR>&nbsp;&nbsp;} while (num);<BR>&nbsp;} else { /* base 10 */<BR>&nbsp;&nbsp;i = put_dec(tmp, num) - tmp;<BR>&nbsp;}</P>
<P>&nbsp;/* printing 100 using %2d gives "100", not "00" */<BR>&nbsp;if (i &gt; precision)<BR>&nbsp;&nbsp;precision = i;<BR>&nbsp;/* leading space padding */<BR>&nbsp;field_width -= precision;<BR>&nbsp;if (!(spec.flags &amp; (ZEROPAD | LEFT))) {<BR>&nbsp;&nbsp;while (--field_width &gt;= 0) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = ' ';<BR>&nbsp;&nbsp;&nbsp;++buf;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;/* sign */<BR>&nbsp;if (sign) {<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = sign;<BR>&nbsp;&nbsp;++buf;<BR>&nbsp;}<BR>&nbsp;/* "0x" / "0" prefix */<BR>&nbsp;if (need_pfx) {<BR>&nbsp;&nbsp;if (spec.base == 16 || !is_zero) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = '0';<BR>&nbsp;&nbsp;&nbsp;++buf;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if (spec.base == 16) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = ('X' | locase);<BR>&nbsp;&nbsp;&nbsp;++buf;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;/* zero or space padding */<BR>&nbsp;if (!(spec.flags &amp; LEFT)) {<BR>&nbsp;&nbsp;char c = ' ' + (spec.flags &amp; ZEROPAD);<BR>&nbsp;&nbsp;BUILD_BUG_ON(' ' + ZEROPAD != '0');<BR>&nbsp;&nbsp;while (--field_width &gt;= 0) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = c;<BR>&nbsp;&nbsp;&nbsp;++buf;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;/* hmm even more zero padding? */<BR>&nbsp;while (i &lt;= --precision) {<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = '0';<BR>&nbsp;&nbsp;++buf;<BR>&nbsp;}<BR>&nbsp;/* actual digits of result */<BR>&nbsp;while (--i &gt;= 0) {<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = tmp[i];<BR>&nbsp;&nbsp;++buf;<BR>&nbsp;}<BR>&nbsp;/* trailing space padding */<BR>&nbsp;while (--field_width &gt;= 0) {<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = ' ';<BR>&nbsp;&nbsp;++buf;<BR>&nbsp;}</P>
<P>&nbsp;return buf;<BR>}</P>
<P>static noinline_for_stack<BR>char *special_hex_number(char *buf, char *end, unsigned long long num, int size)<BR>{<BR>&nbsp;struct printf_spec spec;</P>
<P>&nbsp;spec.type = FORMAT_TYPE_PTR;<BR>&nbsp;spec.field_width = 2 + 2 * size;&nbsp;/* 0x + hex */<BR>&nbsp;spec.flags = SPECIAL | SMALL | ZEROPAD;<BR>&nbsp;spec.base = 16;<BR>&nbsp;spec.precision = -1;</P>
<P>&nbsp;return number(buf, end, num, spec);<BR>}</P>
<P>static void move_right(char *buf, char *end, unsigned len, unsigned spaces)<BR>{<BR>&nbsp;size_t size;<BR>&nbsp;if (buf &gt;= end)&nbsp;/* nowhere to put anything */<BR>&nbsp;&nbsp;return;<BR>&nbsp;size = end - buf;<BR>&nbsp;if (size &lt;= spaces) {<BR>&nbsp;&nbsp;memset(buf, ' ', size);<BR>&nbsp;&nbsp;return;<BR>&nbsp;}<BR>&nbsp;if (len) {<BR>&nbsp;&nbsp;if (len &gt; size - spaces)<BR>&nbsp;&nbsp;&nbsp;len = size - spaces;<BR>&nbsp;&nbsp;memmove(buf + spaces, buf, len);<BR>&nbsp;}<BR>&nbsp;memset(buf, ' ', spaces);<BR>}</P>
<P>/*<BR>&nbsp;* Handle field width padding for a string.<BR>&nbsp;* @buf: current buffer position<BR>&nbsp;* @n: length of string<BR>&nbsp;* @end: end of output buffer<BR>&nbsp;* @spec: for field width and flags<BR>&nbsp;* Returns: new buffer position after padding.<BR>&nbsp;*/<BR>static noinline_for_stack<BR>char *widen_string(char *buf, int n, char *end, struct printf_spec spec)<BR>{<BR>&nbsp;unsigned spaces;</P>
<P>&nbsp;if (likely(n &gt;= spec.field_width))<BR>&nbsp;&nbsp;return buf;<BR>&nbsp;/* we want to pad the sucker */<BR>&nbsp;spaces = spec.field_width - n;<BR>&nbsp;if (!(spec.flags &amp; LEFT)) {<BR>&nbsp;&nbsp;move_right(buf - n, end, n, spaces);<BR>&nbsp;&nbsp;return buf + spaces;<BR>&nbsp;}<BR>&nbsp;while (spaces--) {<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = ' ';<BR>&nbsp;&nbsp;++buf;<BR>&nbsp;}<BR>&nbsp;return buf;<BR>}</P>
<P>static noinline_for_stack<BR>char *string(char *buf, char *end, const char *s, struct printf_spec spec)<BR>{<BR>&nbsp;int len = 0;<BR>&nbsp;size_t lim = spec.precision;</P>
<P>&nbsp;if ((unsigned long)s &lt; PAGE_SIZE)<BR>&nbsp;&nbsp;s = "(null)";</P>
<P>&nbsp;while (lim--) {<BR>&nbsp;&nbsp;char c = *s++;<BR>&nbsp;&nbsp;if (!c)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = c;<BR>&nbsp;&nbsp;++buf;<BR>&nbsp;&nbsp;++len;<BR>&nbsp;}<BR>&nbsp;return widen_string(buf, len, end, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *dentry_name(char *buf, char *end, const struct dentry *d, struct printf_spec spec,<BR>&nbsp;&nbsp;&nbsp; const char *fmt)<BR>{<BR>&nbsp;const char *array[4], *s;<BR>&nbsp;const struct dentry *p;<BR>&nbsp;int depth;<BR>&nbsp;int i, n;</P>
<P>&nbsp;switch (fmt[1]) {<BR>&nbsp;&nbsp;case '2': case '3': case '4':<BR>&nbsp;&nbsp;&nbsp;depth = fmt[1] - '0';<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;depth = 1;<BR>&nbsp;}</P>
<P>&nbsp;rcu_read_lock();<BR>&nbsp;for (i = 0; i &lt; depth; i++, d = p) {<BR>&nbsp;&nbsp;p = ACCESS_ONCE(d-&gt;d_parent);<BR>&nbsp;&nbsp;array[i] = ACCESS_ONCE(d-&gt;d_name.name);<BR>&nbsp;&nbsp;if (p == d) {<BR>&nbsp;&nbsp;&nbsp;if (i)<BR>&nbsp;&nbsp;&nbsp;&nbsp;array[i] = "";<BR>&nbsp;&nbsp;&nbsp;i++;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;s = array[--i];<BR>&nbsp;for (n = 0; n != spec.precision; n++, buf++) {<BR>&nbsp;&nbsp;char c = *s++;<BR>&nbsp;&nbsp;if (!c) {<BR>&nbsp;&nbsp;&nbsp;if (!i)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;c = '/';<BR>&nbsp;&nbsp;&nbsp;s = array[--i];<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = c;<BR>&nbsp;}<BR>&nbsp;rcu_read_unlock();<BR>&nbsp;return widen_string(buf, n, end, spec);<BR>}</P>
<P>#ifdef CONFIG_BLOCK<BR>static noinline_for_stack<BR>char *bdev_name(char *buf, char *end, struct block_device *bdev,<BR>&nbsp;&nbsp;struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;struct gendisk *hd = bdev-&gt;bd_disk;<BR>&nbsp;<BR>&nbsp;buf = string(buf, end, hd-&gt;disk_name, spec);<BR>&nbsp;if (bdev-&gt;bd_part-&gt;partno) {<BR>&nbsp;&nbsp;if (isdigit(hd-&gt;disk_name[strlen(hd-&gt;disk_name)-1])) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = 'p';<BR>&nbsp;&nbsp;&nbsp;buf++;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;buf = number(buf, end, bdev-&gt;bd_part-&gt;partno, spec);<BR>&nbsp;}<BR>&nbsp;return buf;<BR>}<BR>#endif</P>
<P>static noinline_for_stack<BR>char *symbol_string(char *buf, char *end, void *ptr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;unsigned long value;<BR>#ifdef CONFIG_KALLSYMS<BR>&nbsp;char sym[KSYM_SYMBOL_LEN];<BR>#endif</P>
<P>&nbsp;if (fmt[1] == 'R')<BR>&nbsp;&nbsp;ptr = __builtin_extract_return_addr(ptr);<BR>&nbsp;value = (unsigned long)ptr;</P>
<P>#ifdef CONFIG_KALLSYMS<BR>&nbsp;if (*fmt == 'B')<BR>&nbsp;&nbsp;sprint_backtrace(sym, value);<BR>&nbsp;else if (*fmt != 'f' &amp;&amp; *fmt != 's')<BR>&nbsp;&nbsp;sprint_symbol(sym, value);<BR>&nbsp;else<BR>&nbsp;&nbsp;sprint_symbol_no_offset(sym, value);</P>
<P>&nbsp;return string(buf, end, sym, spec);<BR>#else<BR>&nbsp;return special_hex_number(buf, end, value, sizeof(void *));<BR>#endif<BR>}</P>
<P>static noinline_for_stack<BR>char *resource_string(char *buf, char *end, struct resource *res,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>#ifndef IO_RSRC_PRINTK_SIZE<BR>#define IO_RSRC_PRINTK_SIZE&nbsp;6<BR>#endif</P>
<P>#ifndef MEM_RSRC_PRINTK_SIZE<BR>#define MEM_RSRC_PRINTK_SIZE&nbsp;10<BR>#endif<BR>&nbsp;static const struct printf_spec io_spec = {<BR>&nbsp;&nbsp;.base = 16,<BR>&nbsp;&nbsp;.field_width = IO_RSRC_PRINTK_SIZE,<BR>&nbsp;&nbsp;.precision = -1,<BR>&nbsp;&nbsp;.flags = SPECIAL | SMALL | ZEROPAD,<BR>&nbsp;};<BR>&nbsp;static const struct printf_spec mem_spec = {<BR>&nbsp;&nbsp;.base = 16,<BR>&nbsp;&nbsp;.field_width = MEM_RSRC_PRINTK_SIZE,<BR>&nbsp;&nbsp;.precision = -1,<BR>&nbsp;&nbsp;.flags = SPECIAL | SMALL | ZEROPAD,<BR>&nbsp;};<BR>&nbsp;static const struct printf_spec bus_spec = {<BR>&nbsp;&nbsp;.base = 16,<BR>&nbsp;&nbsp;.field_width = 2,<BR>&nbsp;&nbsp;.precision = -1,<BR>&nbsp;&nbsp;.flags = SMALL | ZEROPAD,<BR>&nbsp;};<BR>&nbsp;static const struct printf_spec dec_spec = {<BR>&nbsp;&nbsp;.base = 10,<BR>&nbsp;&nbsp;.precision = -1,<BR>&nbsp;&nbsp;.flags = 0,<BR>&nbsp;};<BR>&nbsp;static const struct printf_spec str_spec = {<BR>&nbsp;&nbsp;.field_width = -1,<BR>&nbsp;&nbsp;.precision = 10,<BR>&nbsp;&nbsp;.flags = LEFT,<BR>&nbsp;};<BR>&nbsp;static const struct printf_spec flag_spec = {<BR>&nbsp;&nbsp;.base = 16,<BR>&nbsp;&nbsp;.precision = -1,<BR>&nbsp;&nbsp;.flags = SPECIAL | SMALL,<BR>&nbsp;};</P>
<P>&nbsp;/* 32-bit res (sizeof==4): 10 chars in dec, 10 in hex ("0x" + 8)<BR>&nbsp; * 64-bit res (sizeof==8): 20 chars in dec, 18 in hex ("0x" + 16) */<BR>#define RSRC_BUF_SIZE&nbsp;&nbsp;((2 * sizeof(resource_size_t)) + 4)<BR>#define FLAG_BUF_SIZE&nbsp;&nbsp;(2 * sizeof(res-&gt;flags))<BR>#define DECODED_BUF_SIZE&nbsp;sizeof("[mem - 64bit pref window disabled]")<BR>#define RAW_BUF_SIZE&nbsp;&nbsp;sizeof("[mem - flags 0x]")<BR>&nbsp;char sym[max(2*RSRC_BUF_SIZE + DECODED_BUF_SIZE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2*RSRC_BUF_SIZE + FLAG_BUF_SIZE + RAW_BUF_SIZE)];</P>
<P>&nbsp;char *p = sym, *pend = sym + sizeof(sym);<BR>&nbsp;int decode = (fmt[0] == 'R') ? 1 : 0;<BR>&nbsp;const struct printf_spec *specp;</P>
<P>&nbsp;*p++ = '[';<BR>&nbsp;if (res-&gt;flags &amp; IORESOURCE_IO) {<BR>&nbsp;&nbsp;p = string(p, pend, "io&nbsp; ", str_spec);<BR>&nbsp;&nbsp;specp = &amp;io_spec;<BR>&nbsp;} else if (res-&gt;flags &amp; IORESOURCE_MEM) {<BR>&nbsp;&nbsp;p = string(p, pend, "mem ", str_spec);<BR>&nbsp;&nbsp;specp = &amp;mem_spec;<BR>&nbsp;} else if (res-&gt;flags &amp; IORESOURCE_IRQ) {<BR>&nbsp;&nbsp;p = string(p, pend, "irq ", str_spec);<BR>&nbsp;&nbsp;specp = &amp;dec_spec;<BR>&nbsp;} else if (res-&gt;flags &amp; IORESOURCE_DMA) {<BR>&nbsp;&nbsp;p = string(p, pend, "dma ", str_spec);<BR>&nbsp;&nbsp;specp = &amp;dec_spec;<BR>&nbsp;} else if (res-&gt;flags &amp; IORESOURCE_BUS) {<BR>&nbsp;&nbsp;p = string(p, pend, "bus ", str_spec);<BR>&nbsp;&nbsp;specp = &amp;bus_spec;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;p = string(p, pend, "??? ", str_spec);<BR>&nbsp;&nbsp;specp = &amp;mem_spec;<BR>&nbsp;&nbsp;decode = 0;<BR>&nbsp;}<BR>&nbsp;if (decode &amp;&amp; res-&gt;flags &amp; IORESOURCE_UNSET) {<BR>&nbsp;&nbsp;p = string(p, pend, "size ", str_spec);<BR>&nbsp;&nbsp;p = number(p, pend, resource_size(res), *specp);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;p = number(p, pend, res-&gt;start, *specp);<BR>&nbsp;&nbsp;if (res-&gt;start != res-&gt;end) {<BR>&nbsp;&nbsp;&nbsp;*p++ = '-';<BR>&nbsp;&nbsp;&nbsp;p = number(p, pend, res-&gt;end, *specp);<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;if (decode) {<BR>&nbsp;&nbsp;if (res-&gt;flags &amp; IORESOURCE_MEM_64)<BR>&nbsp;&nbsp;&nbsp;p = string(p, pend, " 64bit", str_spec);<BR>&nbsp;&nbsp;if (res-&gt;flags &amp; IORESOURCE_PREFETCH)<BR>&nbsp;&nbsp;&nbsp;p = string(p, pend, " pref", str_spec);<BR>&nbsp;&nbsp;if (res-&gt;flags &amp; IORESOURCE_WINDOW)<BR>&nbsp;&nbsp;&nbsp;p = string(p, pend, " window", str_spec);<BR>&nbsp;&nbsp;if (res-&gt;flags &amp; IORESOURCE_DISABLED)<BR>&nbsp;&nbsp;&nbsp;p = string(p, pend, " disabled", str_spec);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;p = string(p, pend, " flags ", str_spec);<BR>&nbsp;&nbsp;p = number(p, pend, res-&gt;flags, flag_spec);<BR>&nbsp;}<BR>&nbsp;*p++ = ']';<BR>&nbsp;*p = '\0';</P>
<P>&nbsp;return string(buf, end, sym, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *hex_string(char *buf, char *end, u8 *addr, struct printf_spec spec,<BR>&nbsp;&nbsp; const char *fmt)<BR>{<BR>&nbsp;int i, len = 1;&nbsp;&nbsp;/* if we pass '%ph[CDN]', field width remains<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; negative value, fallback to the default */<BR>&nbsp;char separator;</P>
<P>&nbsp;if (spec.field_width == 0)<BR>&nbsp;&nbsp;/* nothing to print */<BR>&nbsp;&nbsp;return buf;</P>
<P>&nbsp;if (ZERO_OR_NULL_PTR(addr))<BR>&nbsp;&nbsp;/* NULL pointer */<BR>&nbsp;&nbsp;return string(buf, end, NULL, spec);</P>
<P>&nbsp;switch (fmt[1]) {<BR>&nbsp;case 'C':<BR>&nbsp;&nbsp;separator = ':';<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 'D':<BR>&nbsp;&nbsp;separator = '-';<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 'N':<BR>&nbsp;&nbsp;separator = 0;<BR>&nbsp;&nbsp;break;<BR>&nbsp;default:<BR>&nbsp;&nbsp;separator = ' ';<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;if (spec.field_width &gt; 0)<BR>&nbsp;&nbsp;len = min_t(int, spec.field_width, 64);</P>
<P>&nbsp;for (i = 0; i &lt; len; ++i) {<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = hex_asc_hi(addr[i]);<BR>&nbsp;&nbsp;++buf;<BR>&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;*buf = hex_asc_lo(addr[i]);<BR>&nbsp;&nbsp;++buf;</P>
<P>&nbsp;&nbsp;if (separator &amp;&amp; i != len - 1) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = separator;<BR>&nbsp;&nbsp;&nbsp;++buf;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;return buf;<BR>}</P>
<P>static noinline_for_stack<BR>char *bitmap_string(char *buf, char *end, unsigned long *bitmap,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;const int CHUNKSZ = 32;<BR>&nbsp;int nr_bits = max_t(int, spec.field_width, 0);<BR>&nbsp;int i, chunksz;<BR>&nbsp;bool first = true;</P>
<P>&nbsp;/* reused to print numbers */<BR>&nbsp;spec = (struct printf_spec){ .flags = SMALL | ZEROPAD, .base = 16 };</P>
<P>&nbsp;chunksz = nr_bits &amp; (CHUNKSZ - 1);<BR>&nbsp;if (chunksz == 0)<BR>&nbsp;&nbsp;chunksz = CHUNKSZ;</P>
<P>&nbsp;i = ALIGN(nr_bits, CHUNKSZ) - CHUNKSZ;<BR>&nbsp;for (; i &gt;= 0; i -= CHUNKSZ) {<BR>&nbsp;&nbsp;u32 chunkmask, val;<BR>&nbsp;&nbsp;int word, bit;</P>
<P>&nbsp;&nbsp;chunkmask = ((1ULL &lt;&lt; chunksz) - 1);<BR>&nbsp;&nbsp;word = i / BITS_PER_LONG;<BR>&nbsp;&nbsp;bit = i % BITS_PER_LONG;<BR>&nbsp;&nbsp;val = (bitmap[word] &gt;&gt; bit) &amp; chunkmask;</P>
<P>&nbsp;&nbsp;if (!first) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = ',';<BR>&nbsp;&nbsp;&nbsp;buf++;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;first = false;</P>
<P>&nbsp;&nbsp;spec.field_width = DIV_ROUND_UP(chunksz, 4);<BR>&nbsp;&nbsp;buf = number(buf, end, val, spec);</P>
<P>&nbsp;&nbsp;chunksz = CHUNKSZ;<BR>&nbsp;}<BR>&nbsp;return buf;<BR>}</P>
<P>static noinline_for_stack<BR>char *bitmap_list_string(char *buf, char *end, unsigned long *bitmap,<BR>&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;int nr_bits = max_t(int, spec.field_width, 0);<BR>&nbsp;/* current bit is 'cur', most recently seen range is [rbot, rtop] */<BR>&nbsp;int cur, rbot, rtop;<BR>&nbsp;bool first = true;</P>
<P>&nbsp;/* reused to print numbers */<BR>&nbsp;spec = (struct printf_spec){ .base = 10 };</P>
<P>&nbsp;rbot = cur = find_first_bit(bitmap, nr_bits);<BR>&nbsp;while (cur &lt; nr_bits) {<BR>&nbsp;&nbsp;rtop = cur;<BR>&nbsp;&nbsp;cur = find_next_bit(bitmap, nr_bits, cur + 1);<BR>&nbsp;&nbsp;if (cur &lt; nr_bits &amp;&amp; cur &lt;= rtop + 1)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;if (!first) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = ',';<BR>&nbsp;&nbsp;&nbsp;buf++;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;first = false;</P>
<P>&nbsp;&nbsp;buf = number(buf, end, rbot, spec);<BR>&nbsp;&nbsp;if (rbot &lt; rtop) {<BR>&nbsp;&nbsp;&nbsp;if (buf &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*buf = '-';<BR>&nbsp;&nbsp;&nbsp;buf++;</P>
<P>&nbsp;&nbsp;&nbsp;buf = number(buf, end, rtop, spec);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;rbot = cur;<BR>&nbsp;}<BR>&nbsp;return buf;<BR>}</P>
<P>static noinline_for_stack<BR>char *mac_address_string(char *buf, char *end, u8 *addr,<BR>&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;char mac_addr[sizeof("xx:xx:xx:xx:xx:xx")];<BR>&nbsp;char *p = mac_addr;<BR>&nbsp;int i;<BR>&nbsp;char separator;<BR>&nbsp;bool reversed = false;</P>
<P>&nbsp;switch (fmt[1]) {<BR>&nbsp;case 'F':<BR>&nbsp;&nbsp;separator = '-';<BR>&nbsp;&nbsp;break;</P>
<P>&nbsp;case 'R':<BR>&nbsp;&nbsp;reversed = true;<BR>&nbsp;&nbsp;/* fall through */</P>
<P>&nbsp;default:<BR>&nbsp;&nbsp;separator = ':';<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;for (i = 0; i &lt; 6; i++) {<BR>&nbsp;&nbsp;if (reversed)<BR>&nbsp;&nbsp;&nbsp;p = hex_byte_pack(p, addr[5 - i]);<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;p = hex_byte_pack(p, addr[i]);</P>
<P>&nbsp;&nbsp;if (fmt[0] == 'M' &amp;&amp; i != 5)<BR>&nbsp;&nbsp;&nbsp;*p++ = separator;<BR>&nbsp;}<BR>&nbsp;*p = '\0';</P>
<P>&nbsp;return string(buf, end, mac_addr, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *ip4_string(char *p, const u8 *addr, const char *fmt)<BR>{<BR>&nbsp;int i;<BR>&nbsp;bool leading_zeros = (fmt[0] == 'i');<BR>&nbsp;int index;<BR>&nbsp;int step;</P>
<P>&nbsp;switch (fmt[2]) {<BR>&nbsp;case 'h':<BR>#ifdef __BIG_ENDIAN<BR>&nbsp;&nbsp;index = 0;<BR>&nbsp;&nbsp;step = 1;<BR>#else<BR>&nbsp;&nbsp;index = 3;<BR>&nbsp;&nbsp;step = -1;<BR>#endif<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 'l':<BR>&nbsp;&nbsp;index = 3;<BR>&nbsp;&nbsp;step = -1;<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 'n':<BR>&nbsp;case 'b':<BR>&nbsp;default:<BR>&nbsp;&nbsp;index = 0;<BR>&nbsp;&nbsp;step = 1;<BR>&nbsp;&nbsp;break;<BR>&nbsp;}<BR>&nbsp;for (i = 0; i &lt; 4; i++) {<BR>&nbsp;&nbsp;char temp[4] __aligned(2);&nbsp;/* hold each IP quad in reverse order */<BR>&nbsp;&nbsp;int digits = put_dec_trunc8(temp, addr[index]) - temp;<BR>&nbsp;&nbsp;if (leading_zeros) {<BR>&nbsp;&nbsp;&nbsp;if (digits &lt; 3)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*p++ = '0';<BR>&nbsp;&nbsp;&nbsp;if (digits &lt; 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*p++ = '0';<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;/* reverse the digits in the quad */<BR>&nbsp;&nbsp;while (digits--)<BR>&nbsp;&nbsp;&nbsp;*p++ = temp[digits];<BR>&nbsp;&nbsp;if (i &lt; 3)<BR>&nbsp;&nbsp;&nbsp;*p++ = '.';<BR>&nbsp;&nbsp;index += step;<BR>&nbsp;}<BR>&nbsp;*p = '\0';</P>
<P>&nbsp;return p;<BR>}</P>
<P>static noinline_for_stack<BR>char *ip6_compressed_string(char *p, const char *addr)<BR>{<BR>&nbsp;int i, j, range;<BR>&nbsp;unsigned char zerolength[8];<BR>&nbsp;int longest = 1;<BR>&nbsp;int colonpos = -1;<BR>&nbsp;u16 word;<BR>&nbsp;u8 hi, lo;<BR>&nbsp;bool needcolon = false;<BR>&nbsp;bool useIPv4;<BR>&nbsp;struct in6_addr in6;</P>
<P>&nbsp;memcpy(&amp;in6, addr, sizeof(struct in6_addr));</P>
<P>&nbsp;useIPv4 = ipv6_addr_v4mapped(&amp;in6) || ipv6_addr_is_isatap(&amp;in6);</P>
<P>&nbsp;memset(zerolength, 0, sizeof(zerolength));</P>
<P>&nbsp;if (useIPv4)<BR>&nbsp;&nbsp;range = 6;<BR>&nbsp;else<BR>&nbsp;&nbsp;range = 8;</P>
<P>&nbsp;/* find position of longest 0 run */<BR>&nbsp;for (i = 0; i &lt; range; i++) {<BR>&nbsp;&nbsp;for (j = i; j &lt; range; j++) {<BR>&nbsp;&nbsp;&nbsp;if (in6.s6_addr16[j] != 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;zerolength[i]++;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;for (i = 0; i &lt; range; i++) {<BR>&nbsp;&nbsp;if (zerolength[i] &gt; longest) {<BR>&nbsp;&nbsp;&nbsp;longest = zerolength[i];<BR>&nbsp;&nbsp;&nbsp;colonpos = i;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;if (longest == 1)&nbsp;&nbsp;/* don't compress a single 0 */<BR>&nbsp;&nbsp;colonpos = -1;</P>
<P>&nbsp;/* emit address */<BR>&nbsp;for (i = 0; i &lt; range; i++) {<BR>&nbsp;&nbsp;if (i == colonpos) {<BR>&nbsp;&nbsp;&nbsp;if (needcolon || i == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*p++ = ':';<BR>&nbsp;&nbsp;&nbsp;*p++ = ':';<BR>&nbsp;&nbsp;&nbsp;needcolon = false;<BR>&nbsp;&nbsp;&nbsp;i += longest - 1;<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if (needcolon) {<BR>&nbsp;&nbsp;&nbsp;*p++ = ':';<BR>&nbsp;&nbsp;&nbsp;needcolon = false;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;/* hex u16 without leading 0s */<BR>&nbsp;&nbsp;word = ntohs(in6.s6_addr16[i]);<BR>&nbsp;&nbsp;hi = word &gt;&gt; 8;<BR>&nbsp;&nbsp;lo = word &amp; 0xff;<BR>&nbsp;&nbsp;if (hi) {<BR>&nbsp;&nbsp;&nbsp;if (hi &gt; 0x0f)<BR>&nbsp;&nbsp;&nbsp;&nbsp;p = hex_byte_pack(p, hi);<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;*p++ = hex_asc_lo(hi);<BR>&nbsp;&nbsp;&nbsp;p = hex_byte_pack(p, lo);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;else if (lo &gt; 0x0f)<BR>&nbsp;&nbsp;&nbsp;p = hex_byte_pack(p, lo);<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;*p++ = hex_asc_lo(lo);<BR>&nbsp;&nbsp;needcolon = true;<BR>&nbsp;}</P>
<P>&nbsp;if (useIPv4) {<BR>&nbsp;&nbsp;if (needcolon)<BR>&nbsp;&nbsp;&nbsp;*p++ = ':';<BR>&nbsp;&nbsp;p = ip4_string(p, &amp;in6.s6_addr[12], "I4");<BR>&nbsp;}<BR>&nbsp;*p = '\0';</P>
<P>&nbsp;return p;<BR>}</P>
<P>static noinline_for_stack<BR>char *ip6_string(char *p, const char *addr, const char *fmt)<BR>{<BR>&nbsp;int i;</P>
<P>&nbsp;for (i = 0; i &lt; 8; i++) {<BR>&nbsp;&nbsp;p = hex_byte_pack(p, *addr++);<BR>&nbsp;&nbsp;p = hex_byte_pack(p, *addr++);<BR>&nbsp;&nbsp;if (fmt[0] == 'I' &amp;&amp; i != 7)<BR>&nbsp;&nbsp;&nbsp;*p++ = ':';<BR>&nbsp;}<BR>&nbsp;*p = '\0';</P>
<P>&nbsp;return p;<BR>}</P>
<P>static noinline_for_stack<BR>char *ip6_addr_string(char *buf, char *end, const u8 *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;char ip6_addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255")];</P>
<P>&nbsp;if (fmt[0] == 'I' &amp;&amp; fmt[2] == 'c')<BR>&nbsp;&nbsp;ip6_compressed_string(ip6_addr, addr);<BR>&nbsp;else<BR>&nbsp;&nbsp;ip6_string(ip6_addr, addr, fmt);</P>
<P>&nbsp;return string(buf, end, ip6_addr, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *ip4_addr_string(char *buf, char *end, const u8 *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;char ip4_addr[sizeof("255.255.255.255")];</P>
<P>&nbsp;ip4_string(ip4_addr, addr, fmt);</P>
<P>&nbsp;return string(buf, end, ip4_addr, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *ip6_addr_string_sa(char *buf, char *end, const struct sockaddr_in6 *sa,<BR>&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;bool have_p = false, have_s = false, have_f = false, have_c = false;<BR>&nbsp;char ip6_addr[sizeof("[xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255]") +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(":12345") + sizeof("/123456789") +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof("%1234567890")];<BR>&nbsp;char *p = ip6_addr, *pend = ip6_addr + sizeof(ip6_addr);<BR>&nbsp;const u8 *addr = (const u8 *) &amp;sa-&gt;sin6_addr;<BR>&nbsp;char fmt6[2] = { fmt[0], '6' };<BR>&nbsp;u8 off = 0;</P>
<P>&nbsp;fmt++;<BR>&nbsp;while (isalpha(*++fmt)) {<BR>&nbsp;&nbsp;switch (*fmt) {<BR>&nbsp;&nbsp;case 'p':<BR>&nbsp;&nbsp;&nbsp;have_p = true;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'f':<BR>&nbsp;&nbsp;&nbsp;have_f = true;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 's':<BR>&nbsp;&nbsp;&nbsp;have_s = true;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'c':<BR>&nbsp;&nbsp;&nbsp;have_c = true;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;if (have_p || have_s || have_f) {<BR>&nbsp;&nbsp;*p = '[';<BR>&nbsp;&nbsp;off = 1;<BR>&nbsp;}</P>
<P>&nbsp;if (fmt6[0] == 'I' &amp;&amp; have_c)<BR>&nbsp;&nbsp;p = ip6_compressed_string(ip6_addr + off, addr);<BR>&nbsp;else<BR>&nbsp;&nbsp;p = ip6_string(ip6_addr + off, addr, fmt6);</P>
<P>&nbsp;if (have_p || have_s || have_f)<BR>&nbsp;&nbsp;*p++ = ']';</P>
<P>&nbsp;if (have_p) {<BR>&nbsp;&nbsp;*p++ = ':';<BR>&nbsp;&nbsp;p = number(p, pend, ntohs(sa-&gt;sin6_port), spec);<BR>&nbsp;}<BR>&nbsp;if (have_f) {<BR>&nbsp;&nbsp;*p++ = '/';<BR>&nbsp;&nbsp;p = number(p, pend, ntohl(sa-&gt;sin6_flowinfo &amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPV6_FLOWINFO_MASK), spec);<BR>&nbsp;}<BR>&nbsp;if (have_s) {<BR>&nbsp;&nbsp;*p++ = '%';<BR>&nbsp;&nbsp;p = number(p, pend, sa-&gt;sin6_scope_id, spec);<BR>&nbsp;}<BR>&nbsp;*p = '\0';</P>
<P>&nbsp;return string(buf, end, ip6_addr, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *ip4_addr_string_sa(char *buf, char *end, const struct sockaddr_in *sa,<BR>&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;bool have_p = false;<BR>&nbsp;char *p, ip4_addr[sizeof("255.255.255.255") + sizeof(":12345")];<BR>&nbsp;char *pend = ip4_addr + sizeof(ip4_addr);<BR>&nbsp;const u8 *addr = (const u8 *) &amp;sa-&gt;sin_addr.s_addr;<BR>&nbsp;char fmt4[3] = { fmt[0], '4', 0 };</P>
<P>&nbsp;fmt++;<BR>&nbsp;while (isalpha(*++fmt)) {<BR>&nbsp;&nbsp;switch (*fmt) {<BR>&nbsp;&nbsp;case 'p':<BR>&nbsp;&nbsp;&nbsp;have_p = true;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'h':<BR>&nbsp;&nbsp;case 'l':<BR>&nbsp;&nbsp;case 'n':<BR>&nbsp;&nbsp;case 'b':<BR>&nbsp;&nbsp;&nbsp;fmt4[2] = *fmt;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;p = ip4_string(ip4_addr, addr, fmt4);<BR>&nbsp;if (have_p) {<BR>&nbsp;&nbsp;*p++ = ':';<BR>&nbsp;&nbsp;p = number(p, pend, ntohs(sa-&gt;sin_port), spec);<BR>&nbsp;}<BR>&nbsp;*p = '\0';</P>
<P>&nbsp;return string(buf, end, ip4_addr, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *escaped_string(char *buf, char *end, u8 *addr, struct printf_spec spec,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt)<BR>{<BR>&nbsp;bool found = true;<BR>&nbsp;int count = 1;<BR>&nbsp;unsigned int flags = 0;<BR>&nbsp;int len;</P>
<P>&nbsp;if (spec.field_width == 0)<BR>&nbsp;&nbsp;return buf;&nbsp;&nbsp;&nbsp;&nbsp;/* nothing to print */</P>
<P>&nbsp;if (ZERO_OR_NULL_PTR(addr))<BR>&nbsp;&nbsp;return string(buf, end, NULL, spec);&nbsp;/* NULL pointer */</P>
<P><BR>&nbsp;do {<BR>&nbsp;&nbsp;switch (fmt[count++]) {<BR>&nbsp;&nbsp;case 'a':<BR>&nbsp;&nbsp;&nbsp;flags |= ESCAPE_ANY;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'c':<BR>&nbsp;&nbsp;&nbsp;flags |= ESCAPE_SPECIAL;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'h':<BR>&nbsp;&nbsp;&nbsp;flags |= ESCAPE_HEX;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'n':<BR>&nbsp;&nbsp;&nbsp;flags |= ESCAPE_NULL;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'o':<BR>&nbsp;&nbsp;&nbsp;flags |= ESCAPE_OCTAL;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'p':<BR>&nbsp;&nbsp;&nbsp;flags |= ESCAPE_NP;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 's':<BR>&nbsp;&nbsp;&nbsp;flags |= ESCAPE_SPACE;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;found = false;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;} while (found);</P>
<P>&nbsp;if (!flags)<BR>&nbsp;&nbsp;flags = ESCAPE_ANY_NP;</P>
<P>&nbsp;len = spec.field_width &lt; 0 ? 1 : spec.field_width;</P>
<P>&nbsp;/*<BR>&nbsp; * string_escape_mem() writes as many characters as it can to<BR>&nbsp; * the given buffer, and returns the total size of the output<BR>&nbsp; * had the buffer been big enough.<BR>&nbsp; */<BR>&nbsp;buf += string_escape_mem(addr, len, buf, buf &lt; end ? end - buf : 0, flags, NULL);</P>
<P>&nbsp;return buf;<BR>}</P>
<P>static noinline_for_stack<BR>char *uuid_string(char *buf, char *end, const u8 *addr,<BR>&nbsp;&nbsp;&nbsp; struct printf_spec spec, const char *fmt)<BR>{<BR>&nbsp;char uuid[sizeof("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")];<BR>&nbsp;char *p = uuid;<BR>&nbsp;int i;<BR>&nbsp;static const u8 be[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};<BR>&nbsp;static const u8 le[16] = {3,2,1,0,5,4,7,6,8,9,10,11,12,13,14,15};<BR>&nbsp;const u8 *index = be;<BR>&nbsp;bool uc = false;</P>
<P>&nbsp;switch (*(++fmt)) {<BR>&nbsp;case 'L':<BR>&nbsp;&nbsp;uc = true;&nbsp;&nbsp;/* fall-through */<BR>&nbsp;case 'l':<BR>&nbsp;&nbsp;index = le;<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 'B':<BR>&nbsp;&nbsp;uc = true;<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;for (i = 0; i &lt; 16; i++) {<BR>&nbsp;&nbsp;p = hex_byte_pack(p, addr[index[i]]);<BR>&nbsp;&nbsp;switch (i) {<BR>&nbsp;&nbsp;case 3:<BR>&nbsp;&nbsp;case 5:<BR>&nbsp;&nbsp;case 7:<BR>&nbsp;&nbsp;case 9:<BR>&nbsp;&nbsp;&nbsp;*p++ = '-';<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;*p = 0;</P>
<P>&nbsp;if (uc) {<BR>&nbsp;&nbsp;p = uuid;<BR>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;*p = toupper(*p);<BR>&nbsp;&nbsp;} while (*(++p));<BR>&nbsp;}</P>
<P>&nbsp;return string(buf, end, uuid, spec);<BR>}</P>
<P>static noinline_for_stack<BR>char *netdev_bits(char *buf, char *end, const void *addr, const char *fmt)<BR>{<BR>&nbsp;unsigned long long num;<BR>&nbsp;int size;</P>
<P>&nbsp;switch (fmt[1]) {<BR>&nbsp;case 'F':<BR>&nbsp;&nbsp;num = *(const netdev_features_t *)addr;<BR>&nbsp;&nbsp;size = sizeof(netdev_features_t);<BR>&nbsp;&nbsp;break;<BR>&nbsp;default:<BR>&nbsp;&nbsp;num = (unsigned long)addr;<BR>&nbsp;&nbsp;size = sizeof(unsigned long);<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;return special_hex_number(buf, end, num, size);<BR>}</P>
<P>static noinline_for_stack<BR>char *address_val(char *buf, char *end, const void *addr, const char *fmt)<BR>{<BR>&nbsp;unsigned long long num;<BR>&nbsp;int size;</P>
<P>&nbsp;switch (fmt[1]) {<BR>&nbsp;case 'd':<BR>&nbsp;&nbsp;num = *(const dma_addr_t *)addr;<BR>&nbsp;&nbsp;size = sizeof(dma_addr_t);<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 'p':<BR>&nbsp;default:<BR>&nbsp;&nbsp;num = *(const phys_addr_t *)addr;<BR>&nbsp;&nbsp;size = sizeof(phys_addr_t);<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;return special_hex_number(buf, end, num, size);<BR>}</P>
<P>static noinline_for_stack<BR>char *clock(char *buf, char *end, struct clk *clk, struct printf_spec spec,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt)<BR>{<BR>&nbsp;if (!IS_ENABLED(CONFIG_HAVE_CLK) || !clk)<BR>&nbsp;&nbsp;return string(buf, end, NULL, spec);</P>
<P>&nbsp;switch (fmt[1]) {<BR>&nbsp;case 'r':<BR>&nbsp;&nbsp;return number(buf, end, clk_get_rate(clk), spec);</P>
<P>&nbsp;case 'n':<BR>&nbsp;default:<BR>#ifdef CONFIG_COMMON_CLK<BR>&nbsp;&nbsp;return string(buf, end, __clk_get_name(clk), spec);<BR>#else<BR>&nbsp;&nbsp;return special_hex_number(buf, end, (unsigned long)clk, sizeof(unsigned long));<BR>#endif<BR>&nbsp;}<BR>}</P>
<P>int kptr_restrict __read_mostly;</P>
<P>/*<BR>&nbsp;* Show a '%p' thing.&nbsp; A kernel extension is that the '%p' is followed<BR>&nbsp;* by an extra set of alphanumeric characters that are extended format<BR>&nbsp;* specifiers.<BR>&nbsp;*<BR>&nbsp;* Right now we handle:<BR>&nbsp;*<BR>&nbsp;* - 'F' For symbolic function descriptor pointers with offset<BR>&nbsp;* - 'f' For simple symbolic function names without offset<BR>&nbsp;* - 'S' For symbolic direct pointers with offset<BR>&nbsp;* - 's' For symbolic direct pointers without offset<BR>&nbsp;* - '[FfSs]R' as above with __builtin_extract_return_addr() translation<BR>&nbsp;* - 'B' For backtraced symbolic direct pointers with offset<BR>&nbsp;* - 'R' For decoded struct resource, e.g., [mem 0x0-0x1f 64bit pref]<BR>&nbsp;* - 'r' For raw struct resource, e.g., [mem 0x0-0x1f flags 0x201]<BR>&nbsp;* - 'b[l]' For a bitmap, the number of bits is determined by the field<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width which must be explicitly specified either as part of the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format string '%32b[l]' or through '%*b[l]', [l] selects<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range-list format instead of hex format<BR>&nbsp;* - 'M' For a 6-byte MAC address, it prints the address in the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usual colon-separated hex notation<BR>&nbsp;* - 'm' For a 6-byte MAC address, it prints the hex address without colons<BR>&nbsp;* - 'MF' For a 6-byte MAC FDDI address, it prints the address<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with a dash-separated hex notation<BR>&nbsp;* - '[mM]R' For a 6-byte MAC address, Reverse order (Bluetooth)<BR>&nbsp;* - 'I' [46] for IPv4/IPv6 addresses printed in the usual way<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPv4 uses dot-separated decimal without leading 0's (1.2.3.4)<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPv6 uses colon separated network-order 16 bit hex with leading 0's<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [S][pfs]<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generic IPv4/IPv6 address (struct sockaddr *) that falls back to<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [4] or [6] and is able to print port [p], flowinfo [f], scope [s]<BR>&nbsp;* - 'i' [46] for 'raw' IPv4/IPv6 addresses<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPv6 omits the colons (01020304...0f)<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPv4 uses dot-separated decimal with leading 0's (010.123.045.006)<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [S][pfs]<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generic IPv4/IPv6 address (struct sockaddr *) that falls back to<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [4] or [6] and is able to print port [p], flowinfo [f], scope [s]<BR>&nbsp;* - '[Ii][4S][hnbl]' IPv4 addresses in host, network, big or little endian order<BR>&nbsp;* - 'I[6S]c' for IPv6 addresses printed as specified by<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A href="http://tools.ietf.org/html/rfc5952">http://tools.ietf.org/html/rfc5952</A><BR>&nbsp;* - 'E[achnops]' For an escaped buffer, where rules are defined by combination<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the following flags (see string_escape_mem() for the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; details):<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a - ESCAPE_ANY<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c - ESCAPE_SPECIAL<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h - ESCAPE_HEX<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n - ESCAPE_NULL<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o - ESCAPE_OCTAL<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p - ESCAPE_NP<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s - ESCAPE_SPACE<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By default ESCAPE_ANY_NP is used.<BR>&nbsp;* - 'U' For a 16 byte UUID/GUID, it prints the UUID/GUID in the form<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Options for %pU are:<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b big endian lower case hex (default)<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B big endian UPPER case hex<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l little endian lower case hex<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L little endian UPPER case hex<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big endian output byte order is:<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0][1][2][3]-[4][5]-[6][7]-[8][9]-[10][11][12][13][14][15]<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; little endian output byte order is:<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [3][2][1][0]-[5][4]-[7][6]-[8][9]-[10][11][12][13][14][15]<BR>&nbsp;* - 'V' For a struct va_format which contains a format string * and va_list *,<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call vsnprintf(-&gt;format, *-&gt;va_list).<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Implements a "recursive vsnprintf".<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Do not use this feature without some mechanism to verify the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; correctness of the format string and va_list arguments.<BR>&nbsp;* - 'K' For a kernel pointer that should be hidden from unprivileged users<BR>&nbsp;* - 'NF' For a netdev_features_t<BR>&nbsp;* - 'h[CDN]' For a variable-length buffer, it prints it as a hex string with<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a certain separator (' ' by default):<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C colon<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D dash<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N no separator<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The maximum supported length is 64 bytes of the input. Consider<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to use print_hex_dump() for the larger input.<BR>&nbsp;* - 'a[pd]' For address types [p] phys_addr_t, [d] dma_addr_t and derivatives<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (default assumed to be phys_addr_t, passed by reference)<BR>&nbsp;* - 'd[234]' For a dentry name (optionally 2-4 last components)<BR>&nbsp;* - 'D[234]' Same as 'd' but for a struct file<BR>&nbsp;* - 'g' For block_device name (gendisk + partition number)<BR>&nbsp;* - 'C' For a clock, it prints the name (Common Clock Framework) or address<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (legacy clock framework) of the clock<BR>&nbsp;* - 'Cn' For a clock, it prints the name (Common Clock Framework) or address<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (legacy clock framework) of the clock<BR>&nbsp;* - 'Cr' For a clock, it prints the current rate of the clock<BR>&nbsp;*<BR>&nbsp;* ** Please update also Documentation/printk-formats.txt when making changes **<BR>&nbsp;*<BR>&nbsp;* Note: The difference between 'S' and 'F' is that on ia64 and ppc64<BR>&nbsp;* function pointers are really function descriptors, which contain a<BR>&nbsp;* pointer to the real address.<BR>&nbsp;*/<BR>static noinline_for_stack<BR>char *pointer(const char *fmt, char *buf, char *end, void *ptr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct printf_spec spec)<BR>{<BR>&nbsp;const int default_width = 2 * sizeof(void *);</P>
<P>&nbsp;if (!ptr &amp;&amp; *fmt != 'K') {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Print (null) with the same width as a pointer so it makes<BR>&nbsp;&nbsp; * tabular output look nice.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (spec.field_width == -1)<BR>&nbsp;&nbsp;&nbsp;spec.field_width = default_width;<BR>&nbsp;&nbsp;return string(buf, end, "(null)", spec);<BR>&nbsp;}</P>
<P>&nbsp;switch (*fmt) {<BR>&nbsp;case 'F':<BR>&nbsp;case 'f':<BR>&nbsp;&nbsp;ptr = dereference_function_descriptor(ptr);<BR>&nbsp;&nbsp;/* Fallthrough */<BR>&nbsp;case 'S':<BR>&nbsp;case 's':<BR>&nbsp;case 'B':<BR>&nbsp;&nbsp;return symbol_string(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'R':<BR>&nbsp;case 'r':<BR>&nbsp;&nbsp;return resource_string(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'h':<BR>&nbsp;&nbsp;return hex_string(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'b':<BR>&nbsp;&nbsp;switch (fmt[1]) {<BR>&nbsp;&nbsp;case 'l':<BR>&nbsp;&nbsp;&nbsp;return bitmap_list_string(buf, end, ptr, spec, fmt);<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;return bitmap_string(buf, end, ptr, spec, fmt);<BR>&nbsp;&nbsp;}<BR>&nbsp;case 'M':&nbsp;&nbsp;&nbsp;/* Colon separated: 00:01:02:03:04:05 */<BR>&nbsp;case 'm':&nbsp;&nbsp;&nbsp;/* Contiguous: 000102030405 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* [mM]F (FDDI) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* [mM]R (Reverse order; Bluetooth) */<BR>&nbsp;&nbsp;return mac_address_string(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'I':&nbsp;&nbsp;&nbsp;/* Formatted IP supported<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 4:&nbsp;1.2.3.4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 6:&nbsp;0001:0203:...:0708<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 6c:&nbsp;1::708 or 1::1.2.3.4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;case 'i':&nbsp;&nbsp;&nbsp;/* Contiguous:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 4:&nbsp;001.002.003.004<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 6:&nbsp;&nbsp; 000102...0f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;switch (fmt[1]) {<BR>&nbsp;&nbsp;case '6':<BR>&nbsp;&nbsp;&nbsp;return ip6_addr_string(buf, end, ptr, spec, fmt);<BR>&nbsp;&nbsp;case '4':<BR>&nbsp;&nbsp;&nbsp;return ip4_addr_string(buf, end, ptr, spec, fmt);<BR>&nbsp;&nbsp;case 'S': {<BR>&nbsp;&nbsp;&nbsp;const union {<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr&nbsp;&nbsp;raw;<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr_in&nbsp;v4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr_in6&nbsp;v6;<BR>&nbsp;&nbsp;&nbsp;} *sa = ptr;</P>
<P>&nbsp;&nbsp;&nbsp;switch (sa-&gt;raw.sa_family) {<BR>&nbsp;&nbsp;&nbsp;case AF_INET:<BR>&nbsp;&nbsp;&nbsp;&nbsp;return ip4_addr_string_sa(buf, end, &amp;sa-&gt;v4, spec, fmt);<BR>&nbsp;&nbsp;&nbsp;case AF_INET6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;return ip6_addr_string_sa(buf, end, &amp;sa-&gt;v6, spec, fmt);<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;return string(buf, end, "(invalid address)", spec);<BR>&nbsp;&nbsp;&nbsp;}}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 'E':<BR>&nbsp;&nbsp;return escaped_string(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'U':<BR>&nbsp;&nbsp;return uuid_string(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'V':<BR>&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;va_list va;</P>
<P>&nbsp;&nbsp;&nbsp;va_copy(va, *((struct va_format *)ptr)-&gt;va);<BR>&nbsp;&nbsp;&nbsp;buf += vsnprintf(buf, end &gt; buf ? end - buf : 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((struct va_format *)ptr)-&gt;fmt, va);<BR>&nbsp;&nbsp;&nbsp;va_end(va);<BR>&nbsp;&nbsp;&nbsp;return buf;<BR>&nbsp;&nbsp;}<BR>&nbsp;case 'K':<BR>&nbsp;&nbsp;switch (kptr_restrict) {<BR>&nbsp;&nbsp;case 0:<BR>&nbsp;&nbsp;&nbsp;/* Always print %pK values */<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 1: {<BR>&nbsp;&nbsp;&nbsp;const struct cred *cred;</P>
<P>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * kptr_restrict==1 cannot be used in IRQ context<BR>&nbsp;&nbsp;&nbsp; * because its test for CAP_SYSLOG would be meaningless.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (in_irq() || in_serving_softirq() || in_nmi()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (spec.field_width == -1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spec.field_width = default_width;<BR>&nbsp;&nbsp;&nbsp;&nbsp;return string(buf, end, "pK-error", spec);<BR>&nbsp;&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Only print the real pointer value if the current<BR>&nbsp;&nbsp;&nbsp; * process has CAP_SYSLOG and is running with the<BR>&nbsp;&nbsp;&nbsp; * same credentials it started with. This is because<BR>&nbsp;&nbsp;&nbsp; * access to files is checked at open() time, but %pK<BR>&nbsp;&nbsp;&nbsp; * checks permission at read() time. We don't want to<BR>&nbsp;&nbsp;&nbsp; * leak pointer values if a binary opens a file using<BR>&nbsp;&nbsp;&nbsp; * %pK and then elevates privileges before reading it.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;cred = current_cred();<BR>&nbsp;&nbsp;&nbsp;if (!has_capability_noaudit(current, CAP_SYSLOG) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !uid_eq(cred-&gt;euid, cred-&gt;uid) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !gid_eq(cred-&gt;egid, cred-&gt;gid))<BR>&nbsp;&nbsp;&nbsp;&nbsp;ptr = NULL;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;case 2:<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;/* Always print 0's for %pK */<BR>&nbsp;&nbsp;&nbsp;ptr = NULL;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;break;</P>
<P>&nbsp;case 'N':<BR>&nbsp;&nbsp;return netdev_bits(buf, end, ptr, fmt);<BR>&nbsp;case 'a':<BR>&nbsp;&nbsp;return address_val(buf, end, ptr, fmt);<BR>&nbsp;case 'd':<BR>&nbsp;&nbsp;return dentry_name(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'C':<BR>&nbsp;&nbsp;return clock(buf, end, ptr, spec, fmt);<BR>&nbsp;case 'D':<BR>&nbsp;&nbsp;return dentry_name(buf, end,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((const struct file *)ptr)-&gt;f_path.dentry,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spec, fmt);<BR>#ifdef CONFIG_BLOCK<BR>&nbsp;case 'g':<BR>&nbsp;&nbsp;return bdev_name(buf, end, ptr, spec, fmt);<BR>#endif</P>
<P>&nbsp;}<BR>&nbsp;spec.flags |= SMALL;<BR>&nbsp;if (spec.field_width == -1) {<BR>&nbsp;&nbsp;spec.field_width = default_width;<BR>&nbsp;&nbsp;spec.flags |= ZEROPAD;<BR>&nbsp;}<BR>&nbsp;spec.base = 16;</P>
<P>&nbsp;return number(buf, end, (unsigned long) ptr, spec);<BR>}</P>
<P>/*<BR>&nbsp;* Helper function to decode printf style format.<BR>&nbsp;* Each call decode a token from the format and return the<BR>&nbsp;* number of characters read (or likely the delta where it wants<BR>&nbsp;* to go on the next call).<BR>&nbsp;* The decoded token is returned through the parameters<BR>&nbsp;*<BR>&nbsp;* 'h', 'l', or 'L' for integer fields<BR>&nbsp;* 'z' support added 23/7/1999 S.H.<BR>&nbsp;* 'z' changed to 'Z' --davidm 1/25/99<BR>&nbsp;* 't' added for ptrdiff_t<BR>&nbsp;*<BR>&nbsp;* @fmt: the format string<BR>&nbsp;* @type of the token returned<BR>&nbsp;* @flags: various flags such as +, -, # tokens..<BR>&nbsp;* @field_width: overwritten width<BR>&nbsp;* @base: base of the number (octal, hex, ...)<BR>&nbsp;* @precision: precision of a number<BR>&nbsp;* @qualifier: qualifier of a number (long, size_t, ...)<BR>&nbsp;*/<BR>static noinline_for_stack<BR>int format_decode(const char *fmt, struct printf_spec *spec)<BR>{<BR>&nbsp;const char *start = fmt;<BR>&nbsp;char qualifier;</P>
<P>&nbsp;/* we finished early by reading the field width */<BR>&nbsp;if (spec-&gt;type == FORMAT_TYPE_WIDTH) {<BR>&nbsp;&nbsp;if (spec-&gt;field_width &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;spec-&gt;field_width = -spec-&gt;field_width;<BR>&nbsp;&nbsp;&nbsp;spec-&gt;flags |= LEFT;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_NONE;<BR>&nbsp;&nbsp;goto precision;<BR>&nbsp;}</P>
<P>&nbsp;/* we finished early by reading the precision */<BR>&nbsp;if (spec-&gt;type == FORMAT_TYPE_PRECISION) {<BR>&nbsp;&nbsp;if (spec-&gt;precision &lt; 0)<BR>&nbsp;&nbsp;&nbsp;spec-&gt;precision = 0;</P>
<P>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_NONE;<BR>&nbsp;&nbsp;goto qualifier;<BR>&nbsp;}</P>
<P>&nbsp;/* By default */<BR>&nbsp;spec-&gt;type = FORMAT_TYPE_NONE;</P>
<P>&nbsp;for (; *fmt ; ++fmt) {<BR>&nbsp;&nbsp;if (*fmt == '%')<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;/* Return the current non-format string */<BR>&nbsp;if (fmt != start || !*fmt)<BR>&nbsp;&nbsp;return fmt - start;</P>
<P>&nbsp;/* Process flags */<BR>&nbsp;spec-&gt;flags = 0;</P>
<P>&nbsp;while (1) { /* this also skips first '%' */<BR>&nbsp;&nbsp;bool found = true;</P>
<P>&nbsp;&nbsp;++fmt;</P>
<P>&nbsp;&nbsp;switch (*fmt) {<BR>&nbsp;&nbsp;case '-': spec-&gt;flags |= LEFT;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;case '+': spec-&gt;flags |= PLUS;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;case ' ': spec-&gt;flags |= SPACE;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;case '#': spec-&gt;flags |= SPECIAL; break;<BR>&nbsp;&nbsp;case '0': spec-&gt;flags |= ZEROPAD; break;<BR>&nbsp;&nbsp;default:&nbsp; found = false;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (!found)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;/* get field width */<BR>&nbsp;spec-&gt;field_width = -1;</P>
<P>&nbsp;if (isdigit(*fmt))<BR>&nbsp;&nbsp;spec-&gt;field_width = skip_atoi(&amp;fmt);<BR>&nbsp;else if (*fmt == '*') {<BR>&nbsp;&nbsp;/* it's the next argument */<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_WIDTH;<BR>&nbsp;&nbsp;return ++fmt - start;<BR>&nbsp;}</P>
<P>precision:<BR>&nbsp;/* get the precision */<BR>&nbsp;spec-&gt;precision = -1;<BR>&nbsp;if (*fmt == '.') {<BR>&nbsp;&nbsp;++fmt;<BR>&nbsp;&nbsp;if (isdigit(*fmt)) {<BR>&nbsp;&nbsp;&nbsp;spec-&gt;precision = skip_atoi(&amp;fmt);<BR>&nbsp;&nbsp;&nbsp;if (spec-&gt;precision &lt; 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;spec-&gt;precision = 0;<BR>&nbsp;&nbsp;} else if (*fmt == '*') {<BR>&nbsp;&nbsp;&nbsp;/* it's the next argument */<BR>&nbsp;&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_PRECISION;<BR>&nbsp;&nbsp;&nbsp;return ++fmt - start;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>qualifier:<BR>&nbsp;/* get the conversion qualifier */<BR>&nbsp;qualifier = 0;<BR>&nbsp;if (*fmt == 'h' || _tolower(*fmt) == 'l' ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; _tolower(*fmt) == 'z' || *fmt == 't') {<BR>&nbsp;&nbsp;qualifier = *fmt++;<BR>&nbsp;&nbsp;if (unlikely(qualifier == *fmt)) {<BR>&nbsp;&nbsp;&nbsp;if (qualifier == 'l') {<BR>&nbsp;&nbsp;&nbsp;&nbsp;qualifier = 'L';<BR>&nbsp;&nbsp;&nbsp;&nbsp;++fmt;<BR>&nbsp;&nbsp;&nbsp;} else if (qualifier == 'h') {<BR>&nbsp;&nbsp;&nbsp;&nbsp;qualifier = 'H';<BR>&nbsp;&nbsp;&nbsp;&nbsp;++fmt;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* default base */<BR>&nbsp;spec-&gt;base = 10;<BR>&nbsp;switch (*fmt) {<BR>&nbsp;case 'c':<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_CHAR;<BR>&nbsp;&nbsp;return ++fmt - start;</P>
<P>&nbsp;case 's':<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_STR;<BR>&nbsp;&nbsp;return ++fmt - start;</P>
<P>&nbsp;case 'p':<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_PTR;<BR>&nbsp;&nbsp;return ++fmt - start;</P>
<P>&nbsp;case '%':<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_PERCENT_CHAR;<BR>&nbsp;&nbsp;return ++fmt - start;</P>
<P>&nbsp;/* integer number formats - set up the flags and "break" */<BR>&nbsp;case 'o':<BR>&nbsp;&nbsp;spec-&gt;base = 8;<BR>&nbsp;&nbsp;break;</P>
<P>&nbsp;case 'x':<BR>&nbsp;&nbsp;spec-&gt;flags |= SMALL;</P>
<P>&nbsp;case 'X':<BR>&nbsp;&nbsp;spec-&gt;base = 16;<BR>&nbsp;&nbsp;break;</P>
<P>&nbsp;case 'd':<BR>&nbsp;case 'i':<BR>&nbsp;&nbsp;spec-&gt;flags |= SIGN;<BR>&nbsp;case 'u':<BR>&nbsp;&nbsp;break;</P>
<P>&nbsp;case 'n':<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Since %n poses a greater security risk than<BR>&nbsp;&nbsp; * utility, treat it as any other invalid or<BR>&nbsp;&nbsp; * unsupported format specifier.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;/* Fall-through */</P>
<P>&nbsp;default:<BR>&nbsp;&nbsp;WARN_ONCE(1, "Please remove unsupported %%%c in format string\n", *fmt);<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_INVALID;<BR>&nbsp;&nbsp;return fmt - start;<BR>&nbsp;}</P>
<P>&nbsp;if (qualifier == 'L')<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_LONG_LONG;<BR>&nbsp;else if (qualifier == 'l') {<BR>&nbsp;&nbsp;BUILD_BUG_ON(FORMAT_TYPE_ULONG + SIGN != FORMAT_TYPE_LONG);<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_ULONG + (spec-&gt;flags &amp; SIGN);<BR>&nbsp;} else if (_tolower(qualifier) == 'z') {<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_SIZE_T;<BR>&nbsp;} else if (qualifier == 't') {<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_PTRDIFF;<BR>&nbsp;} else if (qualifier == 'H') {<BR>&nbsp;&nbsp;BUILD_BUG_ON(FORMAT_TYPE_UBYTE + SIGN != FORMAT_TYPE_BYTE);<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_UBYTE + (spec-&gt;flags &amp; SIGN);<BR>&nbsp;} else if (qualifier == 'h') {<BR>&nbsp;&nbsp;BUILD_BUG_ON(FORMAT_TYPE_USHORT + SIGN != FORMAT_TYPE_SHORT);<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_USHORT + (spec-&gt;flags &amp; SIGN);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;BUILD_BUG_ON(FORMAT_TYPE_UINT + SIGN != FORMAT_TYPE_INT);<BR>&nbsp;&nbsp;spec-&gt;type = FORMAT_TYPE_UINT + (spec-&gt;flags &amp; SIGN);<BR>&nbsp;}</P>
<P>&nbsp;return ++fmt - start;<BR>}</P>
<P>static void<BR>set_field_width(struct printf_spec *spec, int width)<BR>{<BR>&nbsp;spec-&gt;field_width = width;<BR>&nbsp;if (WARN_ONCE(spec-&gt;field_width != width, "field width %d too large", width)) {<BR>&nbsp;&nbsp;spec-&gt;field_width = clamp(width, -FIELD_WIDTH_MAX, FIELD_WIDTH_MAX);<BR>&nbsp;}<BR>}</P>
<P>static void<BR>set_precision(struct printf_spec *spec, int prec)<BR>{<BR>&nbsp;spec-&gt;precision = prec;<BR>&nbsp;if (WARN_ONCE(spec-&gt;precision != prec, "precision %d too large", prec)) {<BR>&nbsp;&nbsp;spec-&gt;precision = clamp(prec, 0, PRECISION_MAX);<BR>&nbsp;}<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* vsnprintf - Format a string and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @size: The size of the buffer, including the trailing null space<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @args: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* This function generally follows C99 vsnprintf, but has some<BR>&nbsp;* extensions and a few limitations:<BR>&nbsp;*<BR>&nbsp;* %n is unsupported<BR>&nbsp;* %p* is handled by pointer()<BR>&nbsp;*<BR>&nbsp;* See pointer() or Documentation/printk-formats.txt for more<BR>&nbsp;* extensive description.<BR>&nbsp;*<BR>&nbsp;* ** Please update the documentation in both places when making changes **<BR>&nbsp;*<BR>&nbsp;* The return value is the number of characters which would<BR>&nbsp;* be generated for the given input, excluding the trailing<BR>&nbsp;* '\0', as per ISO C99. If you want to have the exact<BR>&nbsp;* number of characters written into @buf as return value<BR>&nbsp;* (not including the trailing '\0'), use vscnprintf(). If the<BR>&nbsp;* return is greater than or equal to @size, the resulting<BR>&nbsp;* string is truncated.<BR>&nbsp;*<BR>&nbsp;* If you're not already dealing with a va_list consider using snprintf().<BR>&nbsp;*/<BR>int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)<BR>{<BR>&nbsp;unsigned long long num;<BR>&nbsp;char *str, *end;<BR>&nbsp;struct printf_spec spec = {0};</FONT></P>
<P><FONT class=extract>&nbsp;/* Reject out-of-range values early.&nbsp; Large positive sizes are<BR>&nbsp;&nbsp;&nbsp; used for unknown buffer sizes. */<BR>&nbsp;if (WARN_ON_ONCE(size &gt; INT_MAX))<BR>&nbsp;&nbsp;return 0;</FONT></P>
<P><FONT class=extract>&nbsp;str = buf;<BR>&nbsp;end = buf + size;</FONT></P>
<P><FONT class=extract>&nbsp;/* Make sure end is always &gt;= buf */<BR>&nbsp;if (end &lt; buf) {<BR>&nbsp;&nbsp;end = ((void *)-1);<BR>&nbsp;&nbsp;size = end - buf;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;while (*fmt) {<BR>&nbsp;&nbsp;const char *old_fmt = fmt;<BR>&nbsp;&nbsp;int read = format_decode(fmt, &amp;spec);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;fmt += read;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;case FORMAT_TYPE_NONE: {<BR>&nbsp;&nbsp;&nbsp;int copy = read;<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (copy &gt; end - str)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy = end - str;<BR>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(str, old_fmt, copy);<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;str += read;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_WIDTH:<BR>&nbsp;&nbsp;&nbsp;set_field_width(&amp;spec, va_arg(args, int));<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_PRECISION:<BR>&nbsp;&nbsp;&nbsp;set_precision(&amp;spec, va_arg(args, int));<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_CHAR: {<BR>&nbsp;&nbsp;&nbsp;char c;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;if (!(spec.flags &amp; LEFT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++str;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;c = (unsigned char) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = c;<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_STR:<BR>&nbsp;&nbsp;&nbsp;str = string(str, end, va_arg(args, char *), spec);<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_PTR:<BR>&nbsp;&nbsp;&nbsp;str = pointer(fmt, str, end, va_arg(args, void *),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spec);<BR>&nbsp;&nbsp;&nbsp;while (isalnum(*fmt))<BR>&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_PERCENT_CHAR:<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = '%';<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_INVALID:<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Presumably the arguments passed gcc's type<BR>&nbsp;&nbsp;&nbsp; * checking, but there is no safe or sane way<BR>&nbsp;&nbsp;&nbsp; * for us to continue parsing the format and<BR>&nbsp;&nbsp;&nbsp; * fetching from the va_list; the remaining<BR>&nbsp;&nbsp;&nbsp; * specifiers and arguments would be out of<BR>&nbsp;&nbsp;&nbsp; * sync.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, long long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_ULONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, unsigned long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SIZE_T:<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (spec.flags &amp; SIGN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, ssize_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, size_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_PTRDIFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, ptrdiff_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UBYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (unsigned char) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_BYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (signed char) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_USHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (unsigned short) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (short) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_INT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (int) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, unsigned int);<BR>&nbsp;&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;str = number(str, end, num, spec);<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>out:<BR>&nbsp;if (size &gt; 0) {<BR>&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;*str = '\0';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;end[-1] = '\0';<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* the trailing null byte doesn't count towards the total */<BR>&nbsp;return str-buf;</FONT></P>
<P><FONT class=extract>}<BR>EXPORT_SYMBOL(vsnprintf);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* vscnprintf - Format a string and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @size: The size of the buffer, including the trailing null space<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @args: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The return value is the number of characters which have been written into<BR>&nbsp;* the @buf not including the trailing '\0'. If @size is == 0 the function<BR>&nbsp;* returns 0.<BR>&nbsp;*<BR>&nbsp;* If you're not already dealing with a va_list consider using scnprintf().<BR>&nbsp;*<BR>&nbsp;* See the vsnprintf() documentation for format string extensions over C99.<BR>&nbsp;*/<BR>int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)<BR>{<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;i = vsnprintf(buf, size, fmt, args);</FONT></P>
<P><FONT class=extract>&nbsp;if (likely(i &lt; size))<BR>&nbsp;&nbsp;return i;<BR>&nbsp;if (size != 0)<BR>&nbsp;&nbsp;return size - 1;<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL(vscnprintf);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* snprintf - Format a string and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @size: The size of the buffer, including the trailing null space<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @...: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The return value is the number of characters which would be<BR>&nbsp;* generated for the given input, excluding the trailing null,<BR>&nbsp;* as per ISO C99.&nbsp; If the return is greater than or equal to<BR>&nbsp;* @size, the resulting string is truncated.<BR>&nbsp;*<BR>&nbsp;* See the vsnprintf() documentation for format string extensions over C99.<BR>&nbsp;*/<BR>int snprintf(char *buf, size_t size, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;va_start(args, fmt);<BR>&nbsp;i = vsnprintf(buf, size, fmt, args);<BR>&nbsp;va_end(args);</FONT></P>
<P><FONT class=extract>&nbsp;return i;<BR>}<BR>EXPORT_SYMBOL(snprintf);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* scnprintf - Format a string and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @size: The size of the buffer, including the trailing null space<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @...: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The return value is the number of characters written into @buf not including<BR>&nbsp;* the trailing '\0'. If @size is == 0 the function returns 0.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>int scnprintf(char *buf, size_t size, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;va_start(args, fmt);<BR>&nbsp;i = vscnprintf(buf, size, fmt, args);<BR>&nbsp;va_end(args);</FONT></P>
<P><FONT class=extract>&nbsp;return i;<BR>}<BR>EXPORT_SYMBOL(scnprintf);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* vsprintf - Format a string and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @args: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The function returns the number of characters written<BR>&nbsp;* into @buf. Use vsnprintf() or vscnprintf() in order to avoid<BR>&nbsp;* buffer overflows.<BR>&nbsp;*<BR>&nbsp;* If you're not already dealing with a va_list consider using sprintf().<BR>&nbsp;*<BR>&nbsp;* See the vsnprintf() documentation for format string extensions over C99.<BR>&nbsp;*/<BR>int vsprintf(char *buf, const char *fmt, va_list args)<BR>{<BR>&nbsp;return vsnprintf(buf, INT_MAX, fmt, args);<BR>}<BR>EXPORT_SYMBOL(vsprintf);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* sprintf - Format a string and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @...: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The function returns the number of characters written<BR>&nbsp;* into @buf. Use snprintf() or scnprintf() in order to avoid<BR>&nbsp;* buffer overflows.<BR>&nbsp;*<BR>&nbsp;* See the vsnprintf() documentation for format string extensions over C99.<BR>&nbsp;*/<BR>int sprintf(char *buf, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;va_start(args, fmt);<BR>&nbsp;i = vsnprintf(buf, INT_MAX, fmt, args);<BR>&nbsp;va_end(args);</FONT></P>
<P><FONT class=extract>&nbsp;return i;<BR>}<BR>EXPORT_SYMBOL(sprintf);</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_BINARY_PRINTF<BR>/*<BR>&nbsp;* bprintf service:<BR>&nbsp;* vbin_printf() - VA arguments to binary data<BR>&nbsp;* bstr_printf() - Binary data to text string<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* vbin_printf - Parse a format string and place args' binary value in a buffer<BR>&nbsp;* @bin_buf: The buffer to place args' binary value<BR>&nbsp;* @size: The size of the buffer(by words(32bits), not characters)<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @args: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The format follows C99 vsnprintf, except %n is ignored, and its argument<BR>&nbsp;* is skipped.<BR>&nbsp;*<BR>&nbsp;* The return value is the number of words(32bits) which would be generated for<BR>&nbsp;* the given input.<BR>&nbsp;*<BR>&nbsp;* NOTE:<BR>&nbsp;* If the return value is greater than @size, the resulting bin_buf is NOT<BR>&nbsp;* valid for bstr_printf().<BR>&nbsp;*/<BR>int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args)<BR>{<BR>&nbsp;struct printf_spec spec = {0};<BR>&nbsp;char *str, *end;</FONT></P>
<P><FONT class=extract>&nbsp;str = (char *)bin_buf;<BR>&nbsp;end = (char *)(bin_buf + size);</FONT></P>
<P><FONT class=extract>#define save_arg(type)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (sizeof(type) == 8) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;unsigned long long value;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;str = PTR_ALIGN(str, sizeof(u32));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;value = va_arg(args, unsigned long long);&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (str + sizeof(type) &lt;= end) {&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;*(u32 *)str = *(u32 *)&amp;value;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;*(u32 *)(str + 4) = *((u32 *)&amp;value + 1);&nbsp;\<BR>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;} else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;unsigned long value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;str = PTR_ALIGN(str, sizeof(type));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;value = va_arg(args, int);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (str + sizeof(type) &lt;= end)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;*(typeof(type) *)str = (type)value;&nbsp;&nbsp;\<BR>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;str += sizeof(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>} while (0)</FONT></P>
<P><FONT class=extract>&nbsp;while (*fmt) {<BR>&nbsp;&nbsp;int read = format_decode(fmt, &amp;spec);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;fmt += read;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;case FORMAT_TYPE_NONE:<BR>&nbsp;&nbsp;case FORMAT_TYPE_PERCENT_CHAR:<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case FORMAT_TYPE_INVALID:<BR>&nbsp;&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_WIDTH:<BR>&nbsp;&nbsp;case FORMAT_TYPE_PRECISION:<BR>&nbsp;&nbsp;&nbsp;save_arg(int);<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_CHAR:<BR>&nbsp;&nbsp;&nbsp;save_arg(char);<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_STR: {<BR>&nbsp;&nbsp;&nbsp;const char *save_str = va_arg(args, char *);<BR>&nbsp;&nbsp;&nbsp;size_t len;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;if ((unsigned long)save_str &gt; (unsigned long)-PAGE_SIZE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (unsigned long)save_str &lt; PAGE_SIZE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_str = "(null)";<BR>&nbsp;&nbsp;&nbsp;len = strlen(save_str) + 1;<BR>&nbsp;&nbsp;&nbsp;if (str + len &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(str, save_str, len);<BR>&nbsp;&nbsp;&nbsp;str += len;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_PTR:<BR>&nbsp;&nbsp;&nbsp;save_arg(void *);<BR>&nbsp;&nbsp;&nbsp;/* skip all alphanumeric pointer suffixes */<BR>&nbsp;&nbsp;&nbsp;while (isalnum(*fmt))<BR>&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;switch (spec.type) {</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(long long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_ULONG:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(unsigned long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SIZE_T:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(size_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_PTRDIFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(ptrdiff_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UBYTE:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_BYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(char);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_USHORT:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(int);<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>out:<BR>&nbsp;return (u32 *)(PTR_ALIGN(str, sizeof(u32))) - bin_buf;<BR>#undef save_arg<BR>}<BR>EXPORT_SYMBOL_GPL(vbin_printf);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* bstr_printf - Format a string from binary arguments and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @size: The size of the buffer, including the trailing null space<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @bin_buf: Binary arguments for the format string<BR>&nbsp;*<BR>&nbsp;* This function like C99 vsnprintf, but the difference is that vsnprintf gets<BR>&nbsp;* arguments from stack, and bstr_printf gets arguments from @bin_buf which is<BR>&nbsp;* a binary buffer that generated by vbin_printf.<BR>&nbsp;*<BR>&nbsp;* The format follows C99 vsnprintf, but has some extensions:<BR>&nbsp;*&nbsp; see vsnprintf comment for details.<BR>&nbsp;*<BR>&nbsp;* The return value is the number of characters which would<BR>&nbsp;* be generated for the given input, excluding the trailing<BR>&nbsp;* '\0', as per ISO C99. If you want to have the exact<BR>&nbsp;* number of characters written into @buf as return value<BR>&nbsp;* (not including the trailing '\0'), use vscnprintf(). If the<BR>&nbsp;* return is greater than or equal to @size, the resulting<BR>&nbsp;* string is truncated.<BR>&nbsp;*/<BR>int bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf)<BR>{<BR>&nbsp;struct printf_spec spec = {0};<BR>&nbsp;char *str, *end;<BR>&nbsp;const char *args = (const char *)bin_buf;</FONT></P>
<P><FONT class=extract>&nbsp;if (WARN_ON_ONCE(size &gt; INT_MAX))<BR>&nbsp;&nbsp;return 0;</FONT></P>
<P><FONT class=extract>&nbsp;str = buf;<BR>&nbsp;end = buf + size;</FONT></P>
<P><FONT class=extract>#define get_arg(type)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(type) value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (sizeof(type) == 8) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;args = PTR_ALIGN(args, sizeof(u32));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;*(u32 *)&amp;value = *(u32 *)args;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;*((u32 *)&amp;value + 1) = *(u32 *)(args + 4);&nbsp;&nbsp;\<BR>&nbsp;} else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;args = PTR_ALIGN(args, sizeof(type));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;value = *(typeof(type) *)args;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;args += sizeof(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</FONT></P>
<P><FONT class=extract>&nbsp;/* Make sure end is always &gt;= buf */<BR>&nbsp;if (end &lt; buf) {<BR>&nbsp;&nbsp;end = ((void *)-1);<BR>&nbsp;&nbsp;size = end - buf;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;while (*fmt) {<BR>&nbsp;&nbsp;const char *old_fmt = fmt;<BR>&nbsp;&nbsp;int read = format_decode(fmt, &amp;spec);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;fmt += read;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;case FORMAT_TYPE_NONE: {<BR>&nbsp;&nbsp;&nbsp;int copy = read;<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (copy &gt; end - str)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy = end - str;<BR>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(str, old_fmt, copy);<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;str += read;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_WIDTH:<BR>&nbsp;&nbsp;&nbsp;set_field_width(&amp;spec, get_arg(int));<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_PRECISION:<BR>&nbsp;&nbsp;&nbsp;set_precision(&amp;spec, get_arg(int));<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_CHAR: {<BR>&nbsp;&nbsp;&nbsp;char c;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;if (!(spec.flags &amp; LEFT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;c = (unsigned char) get_arg(char);<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = c;<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_STR: {<BR>&nbsp;&nbsp;&nbsp;const char *str_arg = args;<BR>&nbsp;&nbsp;&nbsp;args += strlen(str_arg) + 1;<BR>&nbsp;&nbsp;&nbsp;str = string(str, end, (char *)str_arg, spec);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_PTR:<BR>&nbsp;&nbsp;&nbsp;str = pointer(fmt, str, end, get_arg(void *), spec);<BR>&nbsp;&nbsp;&nbsp;while (isalnum(*fmt))<BR>&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_PERCENT_CHAR:<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = '%';<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;break;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;case FORMAT_TYPE_INVALID:<BR>&nbsp;&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;default: {<BR>&nbsp;&nbsp;&nbsp;unsigned long long num;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;switch (spec.type) {</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(long long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_ULONG:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SIZE_T:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(size_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_PTRDIFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(ptrdiff_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UBYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned char);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_BYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(signed char);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_USHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UINT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(int);<BR>&nbsp;&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;str = number(str, end, num, spec);<BR>&nbsp;&nbsp;} /* default: */<BR>&nbsp;&nbsp;} /* switch(spec.type) */<BR>&nbsp;} /* while(*fmt) */</FONT></P>
<P><FONT class=extract>out:<BR>&nbsp;if (size &gt; 0) {<BR>&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;*str = '\0';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;end[-1] = '\0';<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>#undef get_arg</FONT></P>
<P><FONT class=extract>&nbsp;/* the trailing null byte doesn't count towards the total */<BR>&nbsp;return str - buf;<BR>}<BR>EXPORT_SYMBOL_GPL(bstr_printf);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* bprintf - Parse a format string and place args' binary value in a buffer<BR>&nbsp;* @bin_buf: The buffer to place args' binary value<BR>&nbsp;* @size: The size of the buffer(by words(32bits), not characters)<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @...: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The function returns the number of words(u32) written<BR>&nbsp;* into @bin_buf.<BR>&nbsp;*/<BR>int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int ret;</FONT></P>
<P><FONT class=extract>&nbsp;va_start(args, fmt);<BR>&nbsp;ret = vbin_printf(bin_buf, size, fmt, args);<BR>&nbsp;va_end(args);</FONT></P>
<P><FONT class=extract>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(bprintf);</FONT></P>
<P><FONT class=extract>#endif /* CONFIG_BINARY_PRINTF */</FONT></P>
<P>/**<BR>&nbsp;* vsscanf - Unformat a buffer into a list of arguments<BR>&nbsp;* @buf:&nbsp;input buffer<BR>&nbsp;* @fmt:&nbsp;format of buffer<BR>&nbsp;* @args:&nbsp;arguments<BR>&nbsp;*/<BR>int vsscanf(const char *buf, const char *fmt, va_list args)<BR>{<BR>&nbsp;const char *str = buf;<BR>&nbsp;char *next;<BR>&nbsp;char digit;<BR>&nbsp;int num = 0;<BR>&nbsp;u8 qualifier;<BR>&nbsp;unsigned int base;<BR>&nbsp;union {<BR>&nbsp;&nbsp;long long s;<BR>&nbsp;&nbsp;unsigned long long u;<BR>&nbsp;} val;<BR>&nbsp;s16 field_width;<BR>&nbsp;bool is_sign;</P>
<P>&nbsp;while (*fmt) {<BR>&nbsp;&nbsp;/* skip any white space in format */<BR>&nbsp;&nbsp;/* white space in format matchs any amount of<BR>&nbsp;&nbsp; * white space, including none, in the input.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (isspace(*fmt)) {<BR>&nbsp;&nbsp;&nbsp;fmt = skip_spaces(++fmt);<BR>&nbsp;&nbsp;&nbsp;str = skip_spaces(str);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* anything that is not a conversion must match exactly */<BR>&nbsp;&nbsp;if (*fmt != '%' &amp;&amp; *fmt) {<BR>&nbsp;&nbsp;&nbsp;if (*fmt++ != *str++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (!*fmt)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;++fmt;</P>
<P>&nbsp;&nbsp;/* skip this conversion.<BR>&nbsp;&nbsp; * advance both strings to next white space<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (*fmt == '*') {<BR>&nbsp;&nbsp;&nbsp;if (!*str)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;while (!isspace(*fmt) &amp;&amp; *fmt != '%' &amp;&amp; *fmt)<BR>&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;while (!isspace(*str) &amp;&amp; *str)<BR>&nbsp;&nbsp;&nbsp;&nbsp;str++;<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* get field width */<BR>&nbsp;&nbsp;field_width = -1;<BR>&nbsp;&nbsp;if (isdigit(*fmt)) {<BR>&nbsp;&nbsp;&nbsp;field_width = skip_atoi(&amp;fmt);<BR>&nbsp;&nbsp;&nbsp;if (field_width &lt;= 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* get conversion qualifier */<BR>&nbsp;&nbsp;qualifier = -1;<BR>&nbsp;&nbsp;if (*fmt == 'h' || _tolower(*fmt) == 'l' ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tolower(*fmt) == 'z') {<BR>&nbsp;&nbsp;&nbsp;qualifier = *fmt++;<BR>&nbsp;&nbsp;&nbsp;if (unlikely(qualifier == *fmt)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (qualifier == 'h') {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qualifier = 'H';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;} else if (qualifier == 'l') {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qualifier = 'L';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (!*fmt)<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;if (*fmt == 'n') {<BR>&nbsp;&nbsp;&nbsp;/* return number of characters read so far */<BR>&nbsp;&nbsp;&nbsp;*va_arg(args, int *) = str - buf;<BR>&nbsp;&nbsp;&nbsp;++fmt;<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (!*str)<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;base = 10;<BR>&nbsp;&nbsp;is_sign = false;</P>
<P>&nbsp;&nbsp;switch (*fmt++) {<BR>&nbsp;&nbsp;case 'c':<BR>&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;char *s = (char *)va_arg(args, char*);<BR>&nbsp;&nbsp;&nbsp;if (field_width == -1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;field_width = 1;<BR>&nbsp;&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;*s++ = *str++;<BR>&nbsp;&nbsp;&nbsp;} while (--field_width &gt; 0 &amp;&amp; *str);<BR>&nbsp;&nbsp;&nbsp;num++;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;case 's':<BR>&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;char *s = (char *)va_arg(args, char *);<BR>&nbsp;&nbsp;&nbsp;if (field_width == -1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;field_width = SHRT_MAX;<BR>&nbsp;&nbsp;&nbsp;/* first, skip leading white space in buffer */<BR>&nbsp;&nbsp;&nbsp;str = skip_spaces(str);</P>
<P>&nbsp;&nbsp;&nbsp;/* now copy until next white space */<BR>&nbsp;&nbsp;&nbsp;while (*str &amp;&amp; !isspace(*str) &amp;&amp; field_width--)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*s++ = *str++;<BR>&nbsp;&nbsp;&nbsp;*s = '\0';<BR>&nbsp;&nbsp;&nbsp;num++;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;case 'o':<BR>&nbsp;&nbsp;&nbsp;base = 8;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'x':<BR>&nbsp;&nbsp;case 'X':<BR>&nbsp;&nbsp;&nbsp;base = 16;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'i':<BR>&nbsp;&nbsp;&nbsp;base = 0;<BR>&nbsp;&nbsp;case 'd':<BR>&nbsp;&nbsp;&nbsp;is_sign = true;<BR>&nbsp;&nbsp;case 'u':<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case '%':<BR>&nbsp;&nbsp;&nbsp;/* looking for '%' in str */<BR>&nbsp;&nbsp;&nbsp;if (*str++ != '%')<BR>&nbsp;&nbsp;&nbsp;&nbsp;return num;<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;/* invalid format; stop here */<BR>&nbsp;&nbsp;&nbsp;return num;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* have some sort of integer conversion.<BR>&nbsp;&nbsp; * first, skip white space in buffer.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;str = skip_spaces(str);</P>
<P>&nbsp;&nbsp;digit = *str;<BR>&nbsp;&nbsp;if (is_sign &amp;&amp; digit == '-')<BR>&nbsp;&nbsp;&nbsp;digit = *(str + 1);</P>
<P>&nbsp;&nbsp;if (!digit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (base == 16 &amp;&amp; !isxdigit(digit))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (base == 10 &amp;&amp; !isdigit(digit))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (base == 8 &amp;&amp; (!isdigit(digit) || digit &gt; '7'))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (base == 0 &amp;&amp; !isdigit(digit)))<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;if (is_sign)<BR>&nbsp;&nbsp;&nbsp;val.s = qualifier != 'L' ?<BR>&nbsp;&nbsp;&nbsp;&nbsp;simple_strtol(str, &amp;next, base) :<BR>&nbsp;&nbsp;&nbsp;&nbsp;simple_strtoll(str, &amp;next, base);<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;val.u = qualifier != 'L' ?<BR>&nbsp;&nbsp;&nbsp;&nbsp;simple_strtoul(str, &amp;next, base) :<BR>&nbsp;&nbsp;&nbsp;&nbsp;simple_strtoull(str, &amp;next, base);</P>
<P>&nbsp;&nbsp;if (field_width &gt; 0 &amp;&amp; next - str &gt; field_width) {<BR>&nbsp;&nbsp;&nbsp;if (base == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;_parse_integer_fixup_radix(str, &amp;base);<BR>&nbsp;&nbsp;&nbsp;while (next - str &gt; field_width) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (is_sign)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val.s = div_s64(val.s, base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val.u = div_u64(val.u, base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;--next;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;switch (qualifier) {<BR>&nbsp;&nbsp;case 'H':&nbsp;/* that's 'hh' in format */<BR>&nbsp;&nbsp;&nbsp;if (is_sign)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, signed char *) = val.s;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, unsigned char *) = val.u;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'h':<BR>&nbsp;&nbsp;&nbsp;if (is_sign)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, short *) = val.s;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, unsigned short *) = val.u;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'l':<BR>&nbsp;&nbsp;&nbsp;if (is_sign)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, long *) = val.s;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, unsigned long *) = val.u;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'L':<BR>&nbsp;&nbsp;&nbsp;if (is_sign)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, long long *) = val.s;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, unsigned long long *) = val.u;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 'Z':<BR>&nbsp;&nbsp;case 'z':<BR>&nbsp;&nbsp;&nbsp;*va_arg(args, size_t *) = val.u;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;if (is_sign)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, int *) = val.s;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;*va_arg(args, unsigned int *) = val.u;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;num++;</P>
<P>&nbsp;&nbsp;if (!next)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;str = next;<BR>&nbsp;}</P>
<P>&nbsp;return num;<BR>}<BR>EXPORT_SYMBOL(vsscanf);</P>
<P>/**<BR>&nbsp;* sscanf - Unformat a buffer into a list of arguments<BR>&nbsp;* @buf:&nbsp;input buffer<BR>&nbsp;* @fmt:&nbsp;formatting of buffer<BR>&nbsp;* @...:&nbsp;resulting arguments<BR>&nbsp;*/<BR>int sscanf(const char *buf, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int i;</P>
<P>&nbsp;va_start(args, fmt);<BR>&nbsp;i = vsscanf(buf, fmt, args);<BR>&nbsp;va_end(args);</P>
<P>&nbsp;return i;<BR>}<BR>EXPORT_SYMBOL(sscanf);