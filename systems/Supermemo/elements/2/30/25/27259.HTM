extern int get_option(char **str, int *pint);<BR>extern char *get_options(const char *str, int nints, int *ints);<BR>extern unsigned long long memparse(const char *ptr, char **retptr);<BR>extern bool parse_option_str(const char *str, const char *option);
<P></P>
<P>&nbsp;</P>
<P>/*<BR>&nbsp;* linux/lib/cmdline.c<BR>&nbsp;* Helper functions generally used for parsing kernel command line<BR>&nbsp;* and module options.<BR>&nbsp;*<BR>&nbsp;* Code and copyrights come from init/main.c and arch/i386/kernel/setup.c.<BR>&nbsp;*<BR>&nbsp;* This source code is licensed under the GNU General Public License,<BR>&nbsp;* Version 2.&nbsp; See the file COPYING for more details.<BR>&nbsp;*<BR>&nbsp;* GNU Indent formatting options for this file: -kr -i8 -npsl -pcs<BR>&nbsp;*<BR>&nbsp;*/</P>
<P>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/string.h&gt;</P>
<P>/*<BR>&nbsp;*&nbsp;If a hyphen was found in get_option, this will handle the<BR>&nbsp;*&nbsp;range of numbers, M-N.&nbsp; This will expand the range and insert<BR>&nbsp;*&nbsp;the values[M, M+1, ..., N] into the ints array in get_options.<BR>&nbsp;*/</P>
<P>static int get_range(char **str, int *pint)<BR>{<BR>&nbsp;int x, inc_counter, upper_range;</P>
<P>&nbsp;(*str)++;<BR>&nbsp;upper_range = simple_strtol((*str), NULL, 0);<BR>&nbsp;inc_counter = upper_range - *pint;<BR>&nbsp;for (x = *pint; x &lt; upper_range; x++)<BR>&nbsp;&nbsp;*pint++ = x;<BR>&nbsp;return inc_counter;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;get_option - Parse integer from an option string<BR>&nbsp;*&nbsp;@str: option string<BR>&nbsp;*&nbsp;@pint: (output) integer value parsed from @str<BR>&nbsp;*<BR>&nbsp;*&nbsp;Read an int from an option string; if available accept a subsequent<BR>&nbsp;*&nbsp;comma as well.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Return values:<BR>&nbsp;*&nbsp;0 - no int in string<BR>&nbsp;*&nbsp;1 - int found, no subsequent comma<BR>&nbsp;*&nbsp;2 - int found including a subsequent comma<BR>&nbsp;*&nbsp;3 - hyphen found to denote a range<BR>&nbsp;*/</P>
<P>int get_option(char **str, int *pint)<BR>{<BR>&nbsp;char *cur = *str;</P>
<P>&nbsp;if (!cur || !(*cur))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;*pint = simple_strtol(cur, str, 0);<BR>&nbsp;if (cur == *str)<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;if (**str == ',') {<BR>&nbsp;&nbsp;(*str)++;<BR>&nbsp;&nbsp;return 2;<BR>&nbsp;}<BR>&nbsp;if (**str == '-')<BR>&nbsp;&nbsp;return 3;</P>
<P>&nbsp;return 1;<BR>}<BR>EXPORT_SYMBOL(get_option);</P>
<P>/**<BR>&nbsp;*&nbsp;get_options - Parse a string into a list of integers<BR>&nbsp;*&nbsp;@str: String to be parsed<BR>&nbsp;*&nbsp;@nints: size of integer array<BR>&nbsp;*&nbsp;@ints: integer array<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function parses a string containing a comma-separated<BR>&nbsp;*&nbsp;list of integers, a hyphen-separated range of _positive_ integers,<BR>&nbsp;*&nbsp;or a combination of both.&nbsp; The parse halts when the array is<BR>&nbsp;*&nbsp;full, or when no more numbers can be retrieved from the<BR>&nbsp;*&nbsp;string.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Return value is the character in the string which caused<BR>&nbsp;*&nbsp;the parse to end (typically a null terminator, if @str is<BR>&nbsp;*&nbsp;completely parseable).<BR>&nbsp;*/</P>
<P>char *get_options(const char *str, int nints, int *ints)<BR>{<BR>&nbsp;int res, i = 1;</P>
<P>&nbsp;while (i &lt; nints) {<BR>&nbsp;&nbsp;res = get_option((char **)&amp;str, ints + i);<BR>&nbsp;&nbsp;if (res == 0)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;if (res == 3) {<BR>&nbsp;&nbsp;&nbsp;int range_nums;<BR>&nbsp;&nbsp;&nbsp;range_nums = get_range((char **)&amp;str, ints + i);<BR>&nbsp;&nbsp;&nbsp;if (range_nums &lt; 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Decrement the result by one to leave out the<BR>&nbsp;&nbsp;&nbsp; * last number in the range.&nbsp; The next iteration<BR>&nbsp;&nbsp;&nbsp; * will handle the upper number in the range<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;i += (range_nums - 1);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;i++;<BR>&nbsp;&nbsp;if (res == 1)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}<BR>&nbsp;ints[0] = i - 1;<BR>&nbsp;return (char *)str;<BR>}<BR>EXPORT_SYMBOL(get_options);</P>
<P>/**<BR>&nbsp;*&nbsp;memparse - parse a string with mem suffixes into a number<BR>&nbsp;*&nbsp;@ptr: Where parse begins<BR>&nbsp;*&nbsp;@retptr: (output) Optional pointer to next char after parse completes<BR>&nbsp;*<BR>&nbsp;*&nbsp;Parses a string into a number.&nbsp; The number stored at @ptr is<BR>&nbsp;*&nbsp;potentially suffixed with K, M, G, T, P, E.<BR>&nbsp;*/</P>
<P>unsigned long long memparse(const char *ptr, char **retptr)<BR>{<BR>&nbsp;char *endptr;&nbsp;/* local pointer to end of parsed string */</P>
<P>&nbsp;unsigned long long ret = simple_strtoull(ptr, &amp;endptr, 0);</P>
<P>&nbsp;switch (*endptr) {<BR>&nbsp;case 'E':<BR>&nbsp;case 'e':<BR>&nbsp;&nbsp;ret &lt;&lt;= 10;<BR>&nbsp;case 'P':<BR>&nbsp;case 'p':<BR>&nbsp;&nbsp;ret &lt;&lt;= 10;<BR>&nbsp;case 'T':<BR>&nbsp;case 't':<BR>&nbsp;&nbsp;ret &lt;&lt;= 10;<BR>&nbsp;case 'G':<BR>&nbsp;case 'g':<BR>&nbsp;&nbsp;ret &lt;&lt;= 10;<BR>&nbsp;case 'M':<BR>&nbsp;case 'm':<BR>&nbsp;&nbsp;ret &lt;&lt;= 10;<BR>&nbsp;case 'K':<BR>&nbsp;case 'k':<BR>&nbsp;&nbsp;ret &lt;&lt;= 10;<BR>&nbsp;&nbsp;endptr++;<BR>&nbsp;default:<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;if (retptr)<BR>&nbsp;&nbsp;*retptr = endptr;</P>
<P>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(memparse);</P>
<P>/**<BR>&nbsp;*&nbsp;parse_option_str - Parse a string and check an option is set or not<BR>&nbsp;*&nbsp;@str: String to be parsed<BR>&nbsp;*&nbsp;@option: option name<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function parses a string containing a comma-separated list of<BR>&nbsp;*&nbsp;strings like a=b,c.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Return true if there's such option in the string, or return false.<BR>&nbsp;*/<BR>bool parse_option_str(const char *str, const char *option)<BR>{<BR>&nbsp;while (*str) {<BR>&nbsp;&nbsp;if (!strncmp(str, option, strlen(option))) {<BR>&nbsp;&nbsp;&nbsp;str += strlen(option);<BR>&nbsp;&nbsp;&nbsp;if (!*str || *str == ',')<BR>&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;while (*str &amp;&amp; *str != ',')<BR>&nbsp;&nbsp;&nbsp;str++;</P>
<P>&nbsp;&nbsp;if (*str == ',')<BR>&nbsp;&nbsp;&nbsp;str++;<BR>&nbsp;}</P>
<P>&nbsp;return false;<BR>}