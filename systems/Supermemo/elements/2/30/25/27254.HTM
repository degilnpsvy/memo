/**<BR>&nbsp;* <FONT class=clozed>reciprocal_scale</FONT> - "scale" a value into range [0, ep_ro)<BR>&nbsp;* @val: value<BR>&nbsp;* @ep_ro: right open interval endpoint<BR>&nbsp;*<BR>&nbsp;* Perform a "reciprocal multiplication" in order to "scale" a value into<BR>&nbsp;* range [0, ep_ro), where the upper interval endpoint is right-open.<BR>&nbsp;* This is useful, e.g. for accessing a index of an array containing<BR>&nbsp;* ep_ro elements, for example. Think of it as sort of modulus, only that<BR>&nbsp;* the result isn't that of modulo. ;) Note that if initial input is a<BR>&nbsp;* small value, then result will return 0.<BR>&nbsp;*<BR>&nbsp;* Return: a result based on val in interval [0, ep_ro).<BR>&nbsp;*/<BR>static inline u32 reciprocal_scale(u32 val, u32 ep_ro)<BR>{<BR>&nbsp;return (u32)(((u64) val * ep_ro) &gt;&gt; 32);<BR>}