#ifdef CONFIG_PREEMPT_VOLUNTARY<BR>extern int _cond_resched(void);<BR># define might_resched() _cond_resched()<BR>#else<BR># define might_resched() do { } while (0)<BR>#endif</P>
<P>#ifdef CONFIG_DEBUG_ATOMIC_SLEEP<BR>&nbsp; void ___might_sleep(const char *file, int line, int preempt_offset);<BR>&nbsp; void __might_sleep(const char *file, int line, int preempt_offset);<BR>/**<BR>&nbsp;* might_sleep - annotation for functions that can sleep<BR>&nbsp;*<BR>&nbsp;* this macro will print a stack trace if it is executed in an atomic<BR>&nbsp;* context (spinlock, irq-handler, ...).<BR>&nbsp;*<BR>&nbsp;* This is a useful debugging help to be able to catch problems early and not<BR>&nbsp;* be bitten later when the calling function happens to sleep when it is not<BR>&nbsp;* supposed to.<BR>&nbsp;*/<BR># define might_sleep() \<BR>&nbsp;do { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)<BR># define sched_annotate_sleep()&nbsp;(current-&gt;task_state_change = 0)<BR>#else<BR>&nbsp; static inline void ___might_sleep(const char *file, int line,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int preempt_offset) { }<BR>&nbsp; static inline void __might_sleep(const char *file, int line,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int preempt_offset) { }<BR># define might_sleep() do { might_resched(); } while (0)<BR># define sched_annotate_sleep() do { } while (0)<BR>#endif</P>
<P>#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)