/* Internal, do not use. */<BR>int __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);<BR>int __must_check _kstrtol(const char *s, unsigned int base, long *res); 
<P></P>
<P>int __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);<BR>int __must_check kstrtoll(const char *s, unsigned int base, long long *res);</P>
<P>/**<BR>&nbsp;* kstrtoul - convert a string to an unsigned long<BR>&nbsp;* @s: The start of the string. The string must be null-terminated, and may also<BR>&nbsp;*&nbsp; include a single newline before its terminating null. The first character<BR>&nbsp;*&nbsp; may also be a plus sign, but not a minus sign.<BR>&nbsp;* @base: The number base to use. The maximum supported base is 16. If base is<BR>&nbsp;*&nbsp; given as 0, then the base of the string is automatically detected with the<BR>&nbsp;*&nbsp; conventional semantics - If it begins with 0x the number will be parsed as a<BR>&nbsp;*&nbsp; hexadecimal (case insensitive), if it otherwise begins with 0, it will be<BR>&nbsp;*&nbsp; parsed as an octal number. Otherwise it will be parsed as a decimal.<BR>&nbsp;* @res: Where to write the result of the conversion on success.<BR>&nbsp;*<BR>&nbsp;* Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.<BR>&nbsp;* Used as a replacement for the obsolete simple_strtoull. Return code must<BR>&nbsp;* be checked.<BR>*/<BR>static inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)<BR>{<BR>&nbsp;/*<BR>&nbsp; * We want to shortcut function call, but<BR>&nbsp; * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.<BR>&nbsp; */<BR>&nbsp;if (sizeof(unsigned long) == sizeof(unsigned long long) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; __alignof__(unsigned long) == __alignof__(unsigned long long))<BR>&nbsp;&nbsp;return kstrtoull(s, base, (unsigned long long *)res);<BR>&nbsp;else<BR>&nbsp;&nbsp;return _kstrtoul(s, base, res);<BR>}</P>
<P>/**<BR>&nbsp;* kstrtol - convert a string to a long<BR>&nbsp;* @s: The start of the string. The string must be null-terminated, and may also<BR>&nbsp;*&nbsp; include a single newline before its terminating null. The first character<BR>&nbsp;*&nbsp; may also be a plus sign or a minus sign.<BR>&nbsp;* @base: The number base to use. The maximum supported base is 16. If base is<BR>&nbsp;*&nbsp; given as 0, then the base of the string is automatically detected with the<BR>&nbsp;*&nbsp; conventional semantics - If it begins with 0x the number will be parsed as a<BR>&nbsp;*&nbsp; hexadecimal (case insensitive), if it otherwise begins with 0, it will be<BR>&nbsp;*&nbsp; parsed as an octal number. Otherwise it will be parsed as a decimal.<BR>&nbsp;* @res: Where to write the result of the conversion on success.<BR>&nbsp;*<BR>&nbsp;* Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.<BR>&nbsp;* Used as a replacement for the obsolete simple_strtoull. Return code must<BR>&nbsp;* be checked.<BR>&nbsp;*/<BR>static inline int __must_check kstrtol(const char *s, unsigned int base, long *res)<BR>{<BR>&nbsp;/*<BR>&nbsp; * We want to shortcut function call, but<BR>&nbsp; * __builtin_types_compatible_p(long, long long) = 0.<BR>&nbsp; */<BR>&nbsp;if (sizeof(long) == sizeof(long long) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; __alignof__(long) == __alignof__(long long))<BR>&nbsp;&nbsp;return kstrtoll(s, base, (long long *)res);<BR>&nbsp;else<BR>&nbsp;&nbsp;return _kstrtol(s, base, res);<BR>}</P>
<P>int __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);<BR>int __must_check kstrtoint(const char *s, unsigned int base, int *res);</P>
<P>static inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)<BR>{<BR>&nbsp;return kstrtoull(s, base, res);<BR>}</P>
<P>static inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)<BR>{<BR>&nbsp;return kstrtoll(s, base, res);<BR>}</P>
<P>static inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)<BR>{<BR>&nbsp;return kstrtouint(s, base, res);<BR>}</P>
<P>static inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)<BR>{<BR>&nbsp;return kstrtoint(s, base, res);<BR>}</P>
<P>int __must_check kstrtou16(const char *s, unsigned int base, u16 *res);<BR>int __must_check kstrtos16(const char *s, unsigned int base, s16 *res);<BR>int __must_check kstrtou8(const char *s, unsigned int base, u8 *res);<BR>int __must_check kstrtos8(const char *s, unsigned int base, s8 *res);</P>
<P>int __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);<BR>int __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);<BR>int __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);<BR>int __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);<BR>int __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);<BR>int __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);<BR>int __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);<BR>int __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);<BR>int __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);<BR>int __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);</P>
<P>static inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)<BR>{<BR>&nbsp;return kstrtoull_from_user(s, count, base, res);<BR>}</P>
<P>static inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)<BR>{<BR>&nbsp;return kstrtoll_from_user(s, count, base, res);<BR>}</P>
<P>static inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)<BR>{<BR>&nbsp;return kstrtouint_from_user(s, count, base, res);<BR>}</P>
<P>static inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)<BR>{<BR>&nbsp;return kstrtoint_from_user(s, count, base, res);<BR>}</P>
<P>/* Obsolete, do not use.&nbsp; Use kstrto&lt;foo&gt; instead */</P>
<P>extern unsigned long simple_strtoul(const char *,char **,unsigned int);<BR>extern long simple_strtol(const char *,char **,unsigned int);<BR>extern unsigned long long simple_strtoull(const char *,char **,unsigned int);<BR>extern long long simple_strtoll(const char *,char **,unsigned int);</P>
<P>extern int num_to_str(char *buf, int size, unsigned long long num);