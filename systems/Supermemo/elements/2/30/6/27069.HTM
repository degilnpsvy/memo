/**<BR>&nbsp;*&nbsp;<FONT class=clozed>enable_irq</FONT> - enable handling of an irq<BR>&nbsp;*&nbsp;@irq: Interrupt to enable<BR>&nbsp;*<BR>&nbsp;*&nbsp;Undoes the effect of one call to disable_irq().&nbsp; If this<BR>&nbsp;*&nbsp;matches the last disable, processing of interrupts on this<BR>&nbsp;*&nbsp;IRQ line is re-enabled.<BR>&nbsp;*<BR><FONT class=extract>&nbsp;*&nbsp;This function may be called from IRQ context only when<BR>&nbsp;*&nbsp;desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !<BR></FONT>&nbsp;*/<BR>void enable_irq(unsigned int irq)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_buslock(irq, &amp;flags, IRQ_GET_DESC_CHECK_GLOBAL); 
<P></P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (WARN(!desc-&gt;irq_data.chip,<BR>&nbsp;&nbsp; KERN_ERR "enable_irq before setup/request_irq: irq %u\n", irq))<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;<SPAN class=cloze>[...]</SPAN>;<BR>out:<BR>&nbsp;irq_put_desc_busunlock(desc, flags);<BR>}<BR>EXPORT_SYMBOL(enable_irq);