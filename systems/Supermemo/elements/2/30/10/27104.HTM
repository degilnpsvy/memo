/*<BR>&nbsp;* Like get_user_pages_fast() except its IRQ-safe in that it won't fall<BR>&nbsp;* back to the regular GUP.<BR>&nbsp;* If the architecture not support this function, simply return with no<BR>&nbsp;* page pinned<BR>&nbsp;*/<BR>int __weak __get_user_pages_fast(unsigned long start,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int nr_pages, int write, struct page **pages)<BR>{<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(__get_user_pages_fast); 
<P></P>
<P>/**<BR>&nbsp;* get_user_pages_fast() - pin user pages in memory<BR>&nbsp;* @start:&nbsp;starting user address<BR>&nbsp;* @nr_pages:&nbsp;number of pages from start to pin<BR>&nbsp;* @write:&nbsp;whether pages will be written to<BR>&nbsp;* @pages:&nbsp;array that receives pointers to the pages pinned.<BR>&nbsp;*&nbsp;&nbsp;Should be at least nr_pages long.<BR>&nbsp;*<BR>&nbsp;* Returns number of pages pinned. This may be fewer than the number<BR>&nbsp;* requested. If nr_pages is 0 or negative, returns 0. If no pages<BR>&nbsp;* were pinned, returns -errno.<BR>&nbsp;*<BR>&nbsp;* get_user_pages_fast provides equivalent functionality to get_user_pages,<BR>&nbsp;* operating on current and current-&gt;mm, with force=0 and vma=NULL. However<BR>&nbsp;* unlike get_user_pages, it must be called without mmap_sem held.<BR>&nbsp;*<BR>&nbsp;* get_user_pages_fast may take mmap_sem and page table locks, so no<BR>&nbsp;* assumptions can be made about lack of locking. get_user_pages_fast is to be<BR>&nbsp;* implemented in a way that is advantageous (vs get_user_pages()) when the<BR>&nbsp;* user memory area is already faulted in and present in ptes. However if the<BR>&nbsp;* pages have to be faulted in, it may turn out to be slightly slower so<BR>&nbsp;* callers need to carefully consider what to use. On many architectures,<BR>&nbsp;* get_user_pages_fast simply falls back to get_user_pages.<BR>&nbsp;*/<BR>int __weak get_user_pages_fast(unsigned long start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;int nr_pages, int write, struct page **pages)<BR>{<BR>&nbsp;struct mm_struct *mm = current-&gt;mm;<BR>&nbsp;return get_user_pages_unlocked(current, mm, start, nr_pages,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write, 0, pages);<BR>}<BR>EXPORT_SYMBOL_GPL(get_user_pages_fast);