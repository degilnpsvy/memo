/*<BR>&nbsp;* Divide positive or negative dividend by positive divisor and round<BR>&nbsp;* to closest integer. Result is undefined for negative divisors and<BR>&nbsp;* for negative dividends if the divisor variable type is unsigned.<BR>&nbsp;*/<BR>#define <FONT class=clozed>DIV_ROUND_CLOSEST</FONT>(x, divisor)(&nbsp;&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) __x = x;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(divisor) __d = divisor;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(((typeof(x))-1) &gt; 0 ||&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; ((typeof(divisor))-1) &gt; 0 || (__x) &gt; 0) ?&nbsp;\<BR>&nbsp;&nbsp;(((__x) + ((__d) / 2)) / (__d)) :&nbsp;\<BR>&nbsp;&nbsp;(((__x) - ((__d) / 2)) / (__d));&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>)<BR>/*<BR>&nbsp;* Same as above but for u64 dividends. divisor must be a 32-bit<BR>&nbsp;* number.<BR>&nbsp;*/<BR>#define DIV_ROUND_CLOSEST_ULL(x, divisor)(&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(divisor) __d = divisor;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;unsigned long long _tmp = (x) + (__d) / 2;&nbsp;\<BR>&nbsp;do_div(_tmp, __d);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;_tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>)