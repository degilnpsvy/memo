<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: 26px/40px 'PT Sans', Arial, Helvetica, sans-serif; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(116,116,116); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=columns-2>&nbsp;</DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: 26px/40px 'PT Sans', Arial, Helvetica, sans-serif; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(116,116,116); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=columns-2>
<H2 style="PADDING-BOTTOM: 0px; TEXT-TRANSFORM: none; TEXT-INDENT: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 18px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; PADDING-TOP: 0px; -webkit-text-stroke-width: 0px"><A style="LINE-HEIGHT: 27px !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 36px !important; TEXT-DECORATION: none" href="http://resources.infosecinstitute.com/system-address-map-initialization-x86x64-architecture-part-2-pci-express-based-systems/">System Address Map Initialization in x86/x64 Architecture Part 2: PCI Express-Based Systems</A></H2></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: 26px/40px 'PT Sans', Arial, Helvetica, sans-serif; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(116,116,116); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=columns-2>&nbsp;</DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: 26px/40px 'PT Sans', Arial, Helvetica, sans-serif; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(116,116,116); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=columns-2>This article is the second part of a series that clarifies PCI expansion ROM address mapping to the system address map. The mapping was not sufficiently covered in my &#8220;Malicious PCI Expansion ROM&#8221;&#8216; article (<A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://resources.infosecinstitute.com/pci-expansion-rom/">http://resources.infosecinstitute.com/pci-expansion-rom/</A>). You are assumed to have a working knowledge of PCI bus protocol and details of the x86/x64 boot process. If you don&#8217;t, then please read the first part to get up to speed with the background knowledge required to understand this article (at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/">http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/</A>).</DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: 26px/40px 'PT Sans', Arial, Helvetica, sans-serif; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(116,116,116); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=post-content>
<P style="MARGIN: 0px 0px 20px">The first part focuses on system address map initialization in a x86/x64<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>PCI-based</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>system. This article focuses on more recent systems, i.e., x86/x64<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>PCI Express-based</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>systems. From this point on, PCI Express is abbreviated as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>PCIe</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>throughout this article, in accordance with official PCI Express specification.</P>
<P style="MARGIN: 0px 0px 20px">We are going to look at system address map initialization in x86/x64 PCIe-based systems. Similar to the first part, the focus is on understanding the address mapping mechanism of the PCIe bus protocol. Knowledge of the address mapping is important to understand access to contents of the PCI expansion ROM in PCIe-based system.</P>
<P style="MARGIN: 0px 0px 20px">PCIe is very different on the physical level from PCI. However, on the logical level PCIe is an extension of PCI. In fact, you can boot an OS only supporting the PCI bus on platforms using PCIe without a problem, as long as the OS support conforms to the PCI bus protocol specification. The fact that PCIe is an extension to PCI means that you should be familiar with the PCI bus protocol before you can understand PCIe. That&#8217;s why you are strongly advised to read the first part before moving forward with this second part.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">Conventions</H2>
<P style="MARGIN: 0px 0px 20px">This article uses these conventions:</P>
<OL>
<LI>&#8220;Main memory&#8221; refers to RAM modules installed on the motherboard. 
<LI>&#8220;Memory controller&#8221; refers to that part of the chipset or the CPU that controls the RAM modules and controls access to the RAM modules. 
<LI>Flash memory refers to either the chip on the motherboard that stores the BIOS/UEFI or the chip on expansion card that stores the PCI expansion ROM contents. 
<LI>&#8220;Memory range&#8221; or &#8220;memory address range&#8221; means the range from the base/start address to the end address (base address + memory size) occupied by a device in the CPU memory space. 
<LI>&#8220;Memory space&#8221; means the set of memory addresses accessible by the CPU, i.e., the memory that is addressable from the CPU. Memory in this context could mean RAM, ROM, or other forms of memory that can be addressed by the CPU. 
<LI>&#8220;PCI expansion ROM&#8221; refers to the ROM chip on a PCI device or the contents of the chip, except when the context contains other specific explanation. 
<LI>The terms &#8220;hostbridge&#8221; and &#8220;northbridge&#8221; refer to the same logic components in this article. Both terms refer to the digital logic component that glues the CPU cores to the rest of the system, i.e., connecting the CPU cores to RAM modules, PCIe graphics, the &#8220;southbridge&#8221; chipset, etc. 
<LI>Intel 4<SUP>th</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>Generation Core Architecture CPUs are called &#8220;Haswell CPU&#8221; or simply &#8220;Haswell&#8221; in most of this article. Intel uses &#8220;Haswell&#8221; as the codename for this CPU generation. 
<LI>Hexadecimal values end with &#8220;h&#8221; as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0B0Ah</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or starts with &#8220;0x&#8221; as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0xB0A</SPAN>. 
<LI>Binary values end with &#8220;b&#8221; as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">1010b</SPAN>. 
<LI>The term &#8220;memory transactions routing&#8221; means memory transactions routing based on target address of the transaction, unless stated otherwise.</LI></OL>
<P style="MARGIN: 0px 0px 20px">Another recurring word in this article is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>platform firmware</EM>. Platform firmware refers to code to initialize the platform upon reset, i.e., the BIOS or UEFI code residing in the flash ROM chip of the motherboard.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">Preserving Firmware Code Compatibility in Modern-Day x64 Hardware</H2>
<P style="MARGIN: 0px 0px 20px">The x64 architecture is an extension of the x86 architecture. Therefore, x64 inherits most of the x86 architecture characteristics, including its very early boot characteristics and most of its system address map. There are two important aspects that x64 preserves from x86 with respect to firmware code execution:</P>
<OL>
<LI>The CPU reset vector location. Even though x64 architecture is a 64-bit CPU architecture, the reset vector remains the same as in x86 (32-bit) architecture, i.e., at address 4GB-16 bytes (<SPAN style="FONT-FAMILY: 'Courier New'">FFFF_FFF0h</SPAN>). This is meant to preserve compatibility with old add-on hardware migrated to x64 platforms and also compatibility with numerous low-level code depending on the reset vector. 
<LI>The &#8220;compatibility/legacy&#8221; memory ranges in the system address map. The &#8220;compatibility&#8221; memory ranges are used for legacy devices. For example, some ranges in the lowest 1MB memory area are mapped to legacy hardware or their hardware emulation equivalent. More important, part of the memory range is mapped to the bootblock part of the BIOS/UEFI flash ROM chip. The memory ranges for the BIOS/UEFI flash ROM didn&#8217;t change because the CPU reset vector remains the same. Moreover, lots of firmware code depends on that address mapping as well. Breaking the compatibility from x86 would cause a lot of problems for the smooth migration to the x64 64-bit architecture, not counting on the business impact such a thing would cause. That&#8217;s why preserving the compatibility between the two different architectures is important, down to the firmware and chip level.</LI></OL>
<P style="MARGIN: 0px 0px 20px">Let&#8217;s look at what is needed at the chip level to preserve the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>backward</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>compatibility x86 architecture, now that you know the reason for preserving the compatibility. Figure 1 shows the logic components of the Haswell platform with relation to the UEFI/BIOS code fetch/read. As you can see, two blocks of logic, one in the CPU and one in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>Platform Controller Hub</EM>(PCH), are provided to preserve the backward compatibility. They are the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>compatibility memory range logic</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the CPU and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>internal memory target decoder logic</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the PCH. As for the Direct Media Interface (DMI) 2.0 controller logic, it&#8217;s transparent with respect to software, including firmware code&#8212;it just acts as a very fast &#8220;pass-through&#8221; device; it doesn&#8217;t alter any of the transactions initiated by the firmware code that pass through it.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 1. BIOS/UEFI Code Read Transaction in Modern Platform</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre1.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre1.png"></P>
<P style="MARGIN: 0px 0px 20px">Figure 1 shows the CPU core fetching code from the BIOS/UEFI flash ROM connected to the PCH (&#8220;southbridge&#8221;) via the serial peripheral interface (SPI)&#8212;see the dashed red line in Figure 1. This is what happened in the very early boot stage, when the CPU has just finished initializing itself and starts to fetch code located in the reset vector. The presence of &#8220;compatibility&#8221; logic in the platform, as shown in Figure 1, makes it possible to run DOS or 32-bit OS without any problems.</P>
<P style="MARGIN: 0px 0px 20px">Figure 1 shows there are four CPU cores in the CPU. However, not all of them are the same; one of them is marked as boot strap processor (BSP), while the other three are marked as application processors (AP). When the system first boots or during a hardware reset, there is only one core that&#8217;s active, the BSP. The APs are not active at that point. It&#8217;s the job of the firmware (BIOS/UEFI) code that runs in the BSP to initialize and activate the APs during the system initialization phase.</P>
<P style="MARGIN: 0px 0px 20px">Be aware though, that Figure 1 doesn&#8217;t show all of the interconnections and hardware logic on both the CPU and the PCH, only those related to BIOS/UEFI code execution. The point is to highlight components that take part in very early BIOS/UEFI code execution after a system reset takes place.</P>
<P style="MARGIN: 0px 0px 20px">As you can see in Figure 1, the transaction to reach the BIOS/UEFI flash ROM chip doesn&#8217;t involve any PCIe logic or fabric; even if the hostbridge contains the PCIe root complex logic, the transaction doesn&#8217;t go through it. Nonetheless, you still need to learn about PCIe bus protocol because the PCI expansion ROM that resides in a PCIe expansion card will use the PCIe fabric and logic. That&#8217;s the reason PCIe-related sections are coming next in this article.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">A Deeper Look into PCI-to-PCI Bridge</H2>
<P style="MARGIN: 0px 0px 20px">PCIe hardware is logically represented as one PCI device or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" title=collection href="http://resources.infosecinstitute.com/collection/">collection</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of PCI devices. Some contain<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>logical</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>PCI-to-PCI bridge(s). The first part of this series doesn&#8217;t delve much into PCI-to-PCI bridge. Therefore, we&#8217;re going to take a much closer look into it here because it&#8217;s used heavily as a logical PCIe device building block. For example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>root port</EM>(&#8220;outgoing&#8221; port from the root complex) is logically a PCI-to-PCI bridge and a PCIe switch logically looks like several connected PCI-to-PCI bridges.</P>
<P style="MARGIN: 0px 0px 20px">We&#8217;ll start dissecting PCI-to-PCI bridge by looking at its PCI configuration register header. PCI-to-PCI bridge must implement PCI configuration register type 1 header in its PCI configuration space register, unlike the header that must be implemented by<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>non</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>PCI-to-PCI bridge device&#8212;refer to the first part for PCI configuration register type 0 header. Figure 2 shows format of PCI-to-PCI bridge configuration space header, i.e. PCI configuration register type 1 header. This format is dictated by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>PCI-to-PCI Bridge Architecture Specification v1.1</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>published by PCISIG.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 2. PCI Configuration Register Type 1 Header (for PCI-to-PCI Bridge)</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre2.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre2.png"></P>
<P style="MARGIN: 0px 0px 20px">The numbers in the top of Figure 2 mark the bit position in the registers of the PCI configuration space header. The numbers to the right of Figure 2 mark the offset of the registers in the PCI configuration space header. Registers marked with yellow in Figure 2 determine the memory and IO range forwarded by the PCI-to-PCI bridge from its primary interface (the interface closer to the CPU) to its secondary interface (the interface farther away from the CPU). Registers marked with green in Figure 2 determine the PCI bus number of the bus in the PCI-to-PCI bridge primary interface (Primary Bus Number), the PCI bus number of the PCI bus in its secondary interface (Secondary Bus Number) and the highest PCI bus number downstream of the PCI-to-PCI bridge (Subordinate Bus Number).</P>
<P style="MARGIN: 0px 0px 20px"><STRONG>NOTE:</STRONG></P>
<P style="MARGIN: 0px 0px 20px">Every PCIe device must set the Capabilities List bit in the Status register to 1 and every PCIe device must implement the Capabilities Pointer register (marked in purple in Figure 2). The reason is because PCIe is implemented as an extension to PCI protocol and the way to extend the configuration space of a PCIe device (compared to &#8220;ordinary&#8221; PCI device) is via the Capabilities Pointer register.</P>
<P style="MARGIN: 0px 0px 20px">Figure 3 shows an illustration of PCI-to-PCI bridge primary and secondary interface in a hypothetical platform&#8212;the platform components&#8217; inner workings are the same with a real world system despite the platform is hypothetical; it&#8217;s just simplified to make it easier to understand. PCI bus 1 connects to the PCI-to-PCI bridge primary interface and PCI bus 2 connects to the PCI-to-PCI bridge secondary interface in Figure 3.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 3. PCI-to-PCI Bridge Interfaces</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre3.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre3.png"></P>
<P style="MARGIN: 0px 0px 20px">The PCI-to-PCI bridge forwards an IO transaction &#8220;downstream&#8221; (from the primary interface to the secondary interface) if the IO limit register contains a value greater than the IO base register value and the transaction address falls within the range covered by both registers. Likewise, the PCI-to-PCI bridge forwards a memory transaction &#8220;downstream&#8221; if the memory limit register contains a value greater than the memory base register value and the transaction address falls within the range covered by both registers.</P>
<P style="MARGIN: 0px 0px 20px">There is a fundamental difference between the memory base/limit register and the prefetchable memory base/limit register. The memory base/limit registers are used for memory ranges occupied by devices that have a side effect on read transactions. The prefetchable memory base/limit registers are used only for devices that don&#8217;t have side effects on read because, in this case, the PCI-to-PCI bridge can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>prefetch</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the data a on read transaction from the device without problems. Prefetching works because there is no side effect on the read transaction. Another difference is that the prefetchable memory base/limit registers are able to handle devices located above the 4GB limit because they can handle 64-bit address space.</P>
<P style="MARGIN: 0px 0px 20px">There are no memory base/limit registers for devices mapped above 4GB because the PCI specification assumes all devices that require large address ranges behave like memory, i.e., their &#8220;memory&#8221; contents are prefetchable and don&#8217;t have side effects on reads. Therefore, the PCI specification implies that devices with large address range consumption should implement prefetchable memory base/limit registers instead of memory base/limit registers and all devices with memory that have side effects on read should be mapped to address ranges below the 4GB limit by the platform firmware.</P>
<P style="MARGIN: 0px 0px 20px">A fact sometimes overlooked when dealing with PCI-to-PCI bridge is that the bridge forwards memory transactions &#8220;upstream&#8221; (<EM>from the secondary interface to the primary interface&lt;) &#8212;</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>i.e., from PCI device to the direction of the CPU&#8212;if the transaction address range doesn&#8217;t fall within the range covered by the memory base/limit or prefetchable memory base/limit registers. Perhaps, you&#8217;re asking, why is this behavior needed? The answer is because we need direct memory access (DMA) to work for devices connected to the PCI-to-PCI bridge secondary interface. In DMA, the device &#8220;downstream&#8221; of the PCI-to-PCI bridge initiates the transaction (to read-from or write-to RAM) and the PCI-to-PCI bridge must ensure that the transaction is forwarded from the device in &#8220;upstream&#8221; direction toward the RAM.</P>
<P style="MARGIN: 0px 0px 20px">Devices in DMA (in this case PCI devices) need to write data into the system memory&#8212;the so-called DMA write transaction. If you look at Figure 3, the DMA write transaction for devices connected to the PCI-to-PCI bridge secondary interface must go through the PCI-to-PCI bridge to reach the system memory; if the PCI-to-PCI bridge doesn&#8217;t forward the write transaction &#8220;upstream,&#8221; DMA cannot work because the contents from the device cannot be written to the system memory.</P>
<P style="MARGIN: 0px 0px 20px">Now, let&#8217;s have a look at an example of a memory transaction that&#8217;s forwarded &#8220;downstream&#8221; by PCI-to-PCI bridge in Figure 3. Before we proceed to examine the example, we are going to make several assumptions:</P>
<UL>
<LI>The system in Figure 3 has 8GB system memory. The first 3GB of the system memory is mapped to the lowest 3GB of the CPU memory address space; the rest is mapped to address range 4GB-to-9GB in the CPU memory address space&#8212;above the 4GB limit. 
<LI>The platform firmware has initialized all of the base address registers (BARs) of the PCI devices in the system; including the PCI-to-PCI bridge BARs. The platform firmware initialized the CPU memory range from 3GB to 4GB to be used by PCI devices; of course outside of the hardcoded range used by advanced programmable interrupt controller (APIC) logic, the platform firmware flash ROM chip and some other legacy system functions in the memory range close to the 4GB limit. 
<LI>
<DIV>Contents of the initialized PCI devices BARs and related registers are as follows:</DIV>
<UL>
<LI>PCI device 1, only one BAR in use with 16 MB (non-prefetchable) memory space consumption starting at address<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3.5GB). This BAR claims transactions to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8211;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E0FF_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>non-prefetchable memory range. 
<LI>PCI device 2, only one BAR in use with 16 MB (non-prefetchable) memory space consumption starting at address<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E100_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3.5GB + 16 MB). This BAR claims transactions to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E100_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8211;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E1FF_FFFFh</SPAN>non-prefetchable memory range. 
<LI>PCI device 3, only one BAR in use with 32 MB (prefetchable) memory space consumption starting at address<SPAN style="FONT-FAMILY: 'Courier New'">E200_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3.5GB + 32 MB). This BAR claims transactions to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E200_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8211;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">E3FF_FFFFh</SPAN>prefetchable memory range. 
<LI>PCI device 4, only one BAR in use with 128 MB (prefetchable) memory space consumption starting at address<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB). This BAR claims transactions to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8211;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C7FF_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>prefetchable memory range. 
<LI>PCI device 5, only one BAR in use with 128 MB (prefetchable) memory space consumption starting at address<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C800_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB + 128MB). This BAR claims transactions to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C800_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8211;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">CFFF_FFFFh</SPAN>prefetchable memory range. 
<LI>PCI device 6, only one BAR in use with 256 MB (prefetchable) memory space consumption starting at address<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">D000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB + 256MB). This BAR claims transactions to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">D000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8211;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">DFFF_FFFFh</SPAN>prefetchable memory range. 
<LI>
<DIV>PCI-to-PCI bridge address and routing related configuration registers contents:</DIV>
<UL>
<LI>Primary Bus Number Register: 1 
<LI>Secondary Bus Number Register: 2 
<LI>Subordinate Bus Number Register: 2 (Note: This is the same as secondary bus number because there is no other bus with higher number downstream of the PCI-to-PCI bridge) 
<LI>Memory Base: (Disabled) 
<LI>Memory Limit: (Disabled) 
<LI>Prefetchable Memory Base:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB) 
<LI>Prefetchable Memory Limit:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">DFFF_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3.5GB &#8211; 1)</LI></UL></LI></UL></LI></UL>
<P style="MARGIN: 0px 0px 20px">Now let&#8217;s look at a sample read transaction with the PCI devices arrangement as in the assumptions above. Let&#8217;s say the CPU needs to read data from PCI device at address<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">D100_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB + 16MB) to RAM. This is what happens:</P>
<OL>
<LI>The CPU core issues a &#8220;read&#8221; transaction. This read transaction reaches the integrated hostbridge/northbridge. 
<LI>The northbridge forward the &#8220;read&#8221; transaction to the southbridge because it knows that the requested address resides in the southbridge. 
<LI>The southbridge forwards the &#8220;read&#8221; transaction to the PCI bus 1, which is connected directly to it. 
<LI>The PCI-to-PCI bridge claims the &#8220;read&#8221; transaction because it&#8217;s within its assigned range. The PCI-to-PCI bridge claims the &#8220;read&#8221; transaction and responds to it because the requested address is within the range of its prefetchable memory range (between the value of the prefetchable memory base and prefetchable memory limit). 
<LI>The PCI-to-PCI bridge forwards the &#8220;read&#8221; transaction to its secondary bus, PCI bus 2. 
<LI>PCI device 6 claims the &#8220;read&#8221; transaction in PCI bus 2 because it falls within the range of its BAR. 
<LI>PCI device 6 returns the data at the target address (<SPAN style="FONT-FAMILY: 'Courier New'">D100_0000h</SPAN>) via PCI bus 2. 
<LI>The PCI-to-PCI bridge forwards the data to the southbridge via PCI bus 1. 
<LI>The southbridge forwards the data to the CPU. 
<LI>The northbridge in the CPU then places the data in RAM and the read transaction completes.</LI></OL>
<P style="MARGIN: 0px 0px 20px">From the sample above, you can see that the PCI-to-PCI bridge forwards read/write transaction from its primary interface to its secondary interface if the requested address falls within its range. If the read/write transaction doesn&#8217;t fall within its configured range, the PCI-to-PCI bridge would not forward the transaction from its primary interface to its secondary interface.</P>
<P style="MARGIN: 0px 0px 20px">A seldom known fact about PCI-to-PCI bridge is the presence of a subtractive decode PCI-to-PCI bridge. The &#8220;decoding&#8221; method explained in the example above&#8212;to claim the &#8220;read&#8221; transaction&#8212;is known as positive decode, i.e., the device claims the transaction if it&#8217;s within its assigned range (in one of its BAR). The reverse of positive decode is known as subtractive decode. In subtractive decode the device&#8212;with subtractive decode support&#8212;claims the transaction if there is no other device on the bus that claims the transaction, irrespective of whether the transaction is within the device range or not. There could only be one subtractive decode device in one PCI bus tree. There is a certain class of PCI-to-PCI bridge device that supports subtractive decode. It was used to support address decoding of legacy devices&#8212;such as a BIOS chip&#8212;in older chipsets. However, this technique is largely abandoned in modern-day chipsets because there is already legacy-support logic in the chipset and the CPU.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">PCIe Device Types</H2>
<P style="MARGIN: 0px 0px 20px">You have learned all the required prerequisites to understand PCIe protocol in the previous section. Now let&#8217;s start by looking into PCIe device types based on their role in a PCIe device tree topology. This is important to understand because you need a fundamental understanding of PCIe device types to understand PCIe devices initialization. PCIe devices are categorized as follows:</P>
<OL>
<LI>PCIe<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>root complex</STRONG>. The root complex is similar to northbridge in PCI-based system. It acts as the &#8220;glue&#8221; logic to connect the PCIe device tree to main memory (RAM), and the CPU. In many cases, the root complex also provides high speed PCIe connection to the GPU. The root complex can be implemented as part of the northbridge in systems that employ two physical chips for the chipset logic. However, nowadays the root complex is always integrated into the CPU chip, as you can see in Figure 1. Figure 1 shows the PCIe root complex as part of the hostbridge that&#8217;s integrated into the CPU. The root complex connects to the PCIe device tree through a logical port known as<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>root port</STRONG>. It is a logical port because the root port can be implemented physically in a chip outside the chip containing the root complex. For example, the root complex can reside in the CPU, but the root port is located in the chipset. The Haswell CPU and Intel 8-series PCH implements this root port arrangement. Note that the root complex can have more than one root port. 
<LI>PCIe<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>switch</STRONG>. A PCIe switch is a device that connects two or more PCIe links. A switch contains several connected virtual PCI-to-PCI bridges internally. That is the reason why you should have a deep understanding of PCI-to-PCI bridge in order to understand PCIe device tree topology. Anyway, the root complex can contain a switch, in which case the root complex will have several root ports. 
<LI>PCIe<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>endpoint device</STRONG>. This is the PCIe device type that most people know as a PCIe device. A PCIe endpoint device is a PCIe device that terminates a PCIe link; it only has one connection to the PCIe tree topology&#8212;it can have connection to another kind of bus, though. For example, a PCIe network card in most cases is an endpoint device, just as PCIe storage controller, etc. PCIe endpoint device can also act as a bridge to legacy/compatibility bus, such as a PCIe-to-PCI bridge, or a bridge to a low pin count (LPC) bus, etc.</LI></OL>
<P style="MARGIN: 0px 0px 20px">Perhaps the explanation of a PCIe switch and endpoint device is still vague. Figure 4 shows an example of a PCIe switch and endpoint devices in a PCIe device tree topology. Figure 4 shows that the PCIe switch is composed of three connected &#8220;virtual&#8221; (logical) PCI-to-PCI bridges. The switch has one inbound port (called an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>ingress</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>port in PCIe) and two outbound ports (called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>egress</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>ports in PCIe). There are two endpoint devices connected to the switch, an add-in network and an add-in SCSI controller. Each of the endpoint devices connect to the switch via the switch&#8217;s virtual PCI-to-PCI bridges.</P>
<P style="MARGIN: 0px 0px 20px">Figure 4 shows the physical location of the root ports of the PCIe root complex. One is directly connected to the PCIe root complex and the other is not directly connected to the PCIe root complex&#8212;i.e.. connected via the chipset interconnect. In the latter case, the chipset interconnect is said to be transparent with respect to PCIe device tree topology. Figure 4 shows the external PCIe graphics links to the root port that&#8217;s located in the PCIe root complex while the PCIe switch links to the root port via the chipset interconnect. There is no difference between them from a PCIe logic point of view.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 4. PCIe Switch and Endpoint Devices</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://2we26u4fam7n16rz3a44uhbe1bq2.wpengine.netdna-cdn.com/wp-content/plugins/jquery-image-lazy-loading/images/grey.gif" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre4.png"></P>
<P style="MARGIN: 0px 0px 20px">Figure 4 shows the interconnection between PCIe devices. This interconnection is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>link</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>in PCIe bus protocol. The link is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>logical</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>interconnection that connects two PCIe ports on two different PCIe devices. Each link consists of one or more<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>lanes</STRONG>. Each lane consists of a pair of physical interconnects, one in the outgoing direction from the PCIe device and one in the incoming direction to the PCIe device. The physical interconnect uses differential signaling to transmit the PCIe packets in either direction.</P>
<P style="MARGIN: 0px 0px 20px">At this point, PCIe device basics should be clear to you. In the next section I&#8217;ll go through the details of communication between PCIe devices.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">PCIe Packets and Device Layering</H2>
<P style="MARGIN: 0px 0px 20px">One of the major differences between PCIe and PCI bus protocol is the implementation of a higher level of abstraction in PCIe. Each transaction in PCIe is wrapped into a PCIe packet before it&#8217;s transmitted to another PCIe device. Therefore, PCIe is a packet-based protocol for chip-to-chip communication. This fact has the consequence that PCIe has the capability to implement quality of service (QoS) via packet prioritization. However, I&#8217;m not going to explain about the QoS in PCIe, you just need to know QoS exists in PCIe.</P>
<P style="MARGIN: 0px 0px 20px">Now let&#8217;s get to the packet details. PCIe protocol employs the same philosophy as TCP/IP in that it uses several communication layers, with each layer appending &#8220;header&#8221; to the content of the packet to provide routing, error correction and other housekeeping. Figure 5 shows how PCIe implements this philosophy.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 5. PCIe Packet-Based Communication</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre5.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre5.png"></P>
<P style="MARGIN: 0px 0px 20px">There are three types of packets in PCIe protocol (as seen from the highest level of abstraction down to lowest level packet sent over the PCIe link):</P>
<OL>
<LI>Transaction layer packet (TLP)&#8212;The transaction layer in the PCIe device constructs this packet, as seen in Figure 5. the TLP consists of a TLP header and the data content being transmitted. The source of the data content is the PCIe device core and the PCIe core logic interface in the device. The TLP header contains CRC, among other data. TLP can travel through the PCIe device tree, passing through<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>more than one</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>PCIe devices between the source and the destination device. This looks like the packet &#8220;tunnels&#8221; through the PCIe device in between the source and the destination. But in reality the packet is just routed through the PCIe device tree. The PCIe device in between the source and the destination must be a PCIe switch because only a switch can forward/route packets from its ingress port to its egress port. 
<LI>Data link layer packet (DLLP)&#8212;The data link layer in the PCIe device constructs this packet, as seen in Figure 5. DLLP wraps the TLP in yet another header. DLLP provides another CRC for the packet in the DLLP header. DLLP can only travel between PCIe devices directly connected to each other through a PCIe link. Therefore, the purpose of the CRC is different from that provided by the TLP because DLLP CRC is used to make sure that the neighboring PCIe device receives the packet correctly. There are also some specific DLLPs which don&#8217;t contain any TLP packet inside of it, such as DLLP for link power management, flow control, etc. 
<LI>Physical layer packet (PLP)&#8212;The physical layer in the PCIe device constructs this packet, as seen in Figure 5. PLP wraps the DLLP into one or several PLPs, depending on the size of the DLLP; if the size of the DLLP cannot fit into a single PLP, the PLP logic divides the DLLP into several &#8220;frames&#8221; of PLPs. The PLPs are transmitted in the link between two connected PCIe devices. There are also some specific PLPs that don&#8217;t contain any DLLP packet, such as PLP for link training, clock tolerance compensation, etc.</LI></OL>
<P style="MARGIN: 0px 0px 20px">The explanation about PCIe packet types above implies that a PCIe device must have three device layers, one for each type of packet. In practice, that&#8217;s not always the case. As long as the PCIe device can create PCIe packets that conform to the specification, it&#8217;s fine.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">PCIe Address Spaces</H2>
<P style="MARGIN: 0px 0px 20px">You know from the previous section that PCIe is a packet-based chip-to-chip communication protocol. This means that the protocol requires some means to route the DLLP or TLP between chips. DLLP can only reach directly linked PCIe chips. Therefore, we are more interested in TLP routing because in several cases the target of a read/write transaction lies several chips away from the source of the read/write transaction. There are several mechanisms to route the TLP. Here, we are going to look into one of them, namely, the TLP routing based on address, also known as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>address routing</EM>.</P>
<P style="MARGIN: 0px 0px 20px">There are four address spaces in PCIe. In contrast, PCI only have three address spaces. PCIe address spaces are as follows:</P>
<OL>
<LI>PCIe configuration space&#8212;This address space is used to access the PCI-compatible configuration registers in PCIe devices and also the PCIe enhanced configuration registers. Part of this address space that resides in the CPU IO space is provided for backward compatibility reasons&#8212;i.e., compatibility with PCI bus protocol. The rest of the PCIe configuration space resides in the CPU memory space. The access mechanism for the first 256 registers is the same as in PCI for x64 architecture, i.e., using IO port<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0xCF8-0xCFB</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for address and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0xCFC-0xCFF</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for data. As in PCI devices, there are 256 eight-bit configuration space registers that are mapped to this IO address space in PCIe. The first 256 byte configuration registers are immediately available at the very early boot stage via the CPU IO space (because the mapping doesn&#8217;t require firmware initialization), while the rest are available only after the platform firmware finishes initializing CPU memory space used for PCIe configuration space. PCIe supports a larger number of configuration space registers than PCI. Each PCIe device has 4KB configuration space registers. The first 256 bytes of those registers are mapped to both the &#8220;legacy&#8221; PCI configuration space and to PCIe configuration space in the CPU memory space. The entire 4KB PCIe configuration space registers can be accessed via PCIe enhanced configuration mechanism. PCIe enhanced configuration mechanism uses the CPU memory space instead of the CPU IO space (PCI configuration mechanism uses the CPU IO space in x86/x64 architecture). 
<LI>PCIe memory space&#8212;This address space lies in the CPU memory address space, just as in PCI. However, PCIe supports 64-bit addressing by default. Part of the PCIe configuration register is located in the PCIe memory space. However, what is meant by PCIe memory space in this context is the CPU memory space consumed by PCIe devices for non-configuration purposes. For example, the CPU memory space used to store PCIe device data, such as for local RAM in PCIe network controller card or PCIe graphics card local RAM used for graphics buffer. 
<LI>PCIe IO space&#8212;This is the same as the IO space in PCI bus protocol. It exists only for PCI backward compatibility reason. 
<LI>PCIe message space&#8212;This is a new address space not previously implemented in PCI. This address space exists to eliminate the need for physical sideband signals. Therefore, everything that used to be implemented physically in previous bus protocols, such as the interrupt sideband signal, is now implemented as messages in the PCIe device tree. We are not going to look deeper into this address space. It&#8217;s enough to know its purpose.</LI></OL>
<P style="MARGIN: 0px 0px 20px">This article only deals with two address spaces of the four PCIe address spaces explained above, PCIe configuration space and PCIe memory space. We are going to look into the PCIe configuration space in the PCIe configuration mechanism section later. In this section, we&#8217;re going to look into the PCIe memory space in detail.</P>
<P style="MARGIN: 0px 0px 20px">For the sample, we&#8217;re going to proceed to scrutinize a PCIe memory read transaction that goes through the PCIe fabric (device tree), a read transaction routed via address-routing. We&#8217;re going to look at a quite complicated PCIe platform that contains a PCIe switch. This kind of configuration usually doesn&#8217;t exist on a desktop-class PCIe platform, only on a server-class PCIe platform. The complexity of the sample would make it a lot easier for the reader to deal with desktop-class hardware in a real-world scenario because the latter is simpler compared to server-class platform.</P>
<P style="MARGIN: 0px 0px 20px">Figure 6 shows the sample memory read transaction with targets address at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB). The memory read transaction originated in the CPU core 1, and the target is the contents of the PCIe Infiniband &#8220;network&#8221; controller &#8220;local&#8221; memory because that address is mapped to the latter device&#8217;s memory. The transaction is routed through the PCIe fabric. The double arrow in the read transaction path in Figure 6&#8212;marked as a dashed purple line&#8212;indicates that the path taken to get to the PCIe device memory contents is identical to the path taken by the requested data back to CPU core 1.</P>
<P style="MARGIN: 0px 0px 20px">Address-routing in the PCIe fabric can only happen after all the address-related registers in all PCIe devices in the fabric are initialized. We assume that the platform firmware initializes the platform in Figure 6 as follows:</P>
<OL>
<LI>The system has 8GB RAM; 3GB mapped to the 0-to-3GB memory range and the rest mapped to the 4GB-to-8GB memory range. The mapping is controlled by the respective mapping registers in the hostbridge. 
<LI>The PCIe Infiniband network controller has 32MB of local memory, mapped to addresses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN style="FONT-FAMILY: 'Courier New'">C1FF_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB to 3GB+32MB-1). 
<LI>The PCIe SCSI controller card has 32MB of local memory, mapped to addresses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C200_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C3FF_FFFFh</SPAN>(3GB+32MB to 3GB+64MB-1). 
<LI>Virtual PCI-to-PCI bridge 1, 2, and 3 don&#8217;t claim memory or an IO range for themselves, i.e., BAR 0 and BAR 1 of each of these devices are initialized to values that don&#8217;t claim any memory ranges. 
<LI>Virtual PCI-to-PCI bridge 1 claims memory range<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C3FF_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB to 3GB+64MB-1) as prefetchable memory. 
<LI>Virtual PCI-to-PCI bridge 2 claims memory range<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C1FF_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB to 3GB+32MB-1) as prefetchable memory. 
<LI>Virtual PCI-to-PCI bridge 3 claims memory range<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C200_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C3FF_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB+32MB to 3GB+64MB-1) as prefetchable memory.</LI></OL>
<P style="MARGIN: 0px 0px 20px">With all the memory-related stuff initialized, we can proceed to see how the read transaction travels through the PCIe fabric.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 6. PCIe Memory Read Transaction Sample Going through the PCIe Fabric via Address Routing</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre6.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre6.png"></P>
<P style="MARGIN: 0px 0px 20px">Now let&#8217;s look at the steps taken by the read transaction shown in Figure 6:</P>
<OL>
<LI>The memory read transaction with target address at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>originated in the CPU&#8217;s core 1. 
<LI>The memory read transaction reaches the hostbridge. The hostbridge mapping register directs the transaction to the PCIe root complex logic because the address maps to the memory range claimed by PCIe. 
<LI>The PCIe root complex logic in the hostbridge recognizes the memory read transaction as targeting the PCIe fabric&#8212;due to the hostbridge mapping registers setting&#8212;and converts the memory read transaction into a PCIe read TLP. 
<LI>The TLP is placed in &#8220;logical&#8221; PCI bus 0. PCI bus 0 originates in the PCIe root complex logic and ends in virtual PCI-to-PCI bridge 1 in the PCIe switch inside the chipset. Note that the chipset interconnect logic is transparent with respect to PCI and PCIe protocol. 
<LI>Virtual PCI-to-PCI bridge 1 checks the target address of the TLP. In the beginning, virtual PCI-to-PCI bridge 1 checks whether the TLP target address is within virtual PCI-to-PCI bridge 1 itself by comparing the target address with the value of its BAR 0 and BAR 1 registers. However, virtual PCI-to-PCI bridge 1 BAR 0 and BAR 1 don&#8217;t claim any memory read/write transaction as per the platform firmware initialization value. Then it checks whether the target address of the TLP is within the range of one of its memory base/limit or prefetchable memory base/limit registers. Figure 6 shows both of these steps in point (a) and (b). Virtual PCI-to-PCI bridge 1 found that the target address of the TLP is within the range of the range of its prefetchable memory range. Therefore, the Virtual PCI-to-PCI bridge 1 accepts the TLP in PCI bus 0 and routes the TLP to PCI bus 1. 
<LI>Virtual PCI-to-PCI bridge 2 and virtual PCI-to-PCI bridge 3 do a similar thing to the TLP in PCI bus 1 as virtual PCI-to-PCI bridge 1 did on PCI bus 0, i.e., check their own BARs and their memory base/limit and prefetchable memory base/limit. Virtual PCI-to-PCI bridge 2 found that the TLP target address is in its secondary interface. Therefore, virtual PCI-to-PCI bridge 2 accepts the TLP in PCI bus 1 and routes the TLP to PCI bus 2. 
<LI>The PCIe Infiniband network controller in PCI bus 2 checks the target address of the TLP routed by virtual PCI-to-PCI bridge 2 and accepts the TLP because the target address is within the range of one of its BARs. 
<LI>The PCIe Infiniband network controller returns contents of the target address to the CPU via the PCIe fabric. Note: we are not going to scrutinize this process in detail because we have learned the details of the TLP address-based routing from the CPU to the PCIe Infiniband network controller.</LI></OL>
<P style="MARGIN: 0px 0px 20px">At this point, PCIe address spaces and PCIe address routing should be clear. The next section focuses on PCIe configuration space and the mechanism for routing PCIe configuration transactions to their targets.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">PCIe Configuration Mechanisms</H2>
<P style="MARGIN: 0px 0px 20px">You need to know PCIe configuration mechanisms because they are the methods used to initialize all of the PCIe devices in a platform that implements PCIe. There are two types of configuration mechanisms in PCIe. as follows:</P>
<OL>
<LI>The PCI-compatible configuration mechanism&#8212;This configuration mechanism is identical to the PCI configuration mechanism. On an x86/x64 platform, this configuration mechanism uses IO port<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">CF8h-CFBh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the address port, and IO port<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">CFCh-CFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the data port to read/write values from/into the PCI configuration register of the PCIe device. This configuration mechanism can access 256-bytes configuration registers per device&#8212;refer to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>PCI configuration register section</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the first part of this series (at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/">http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/</A>) for details on PCI configuration mechanisms. PCIe supports 4KB of configuration registers per device, in contrast to &#8220;only&#8221; 256 bytes supported by PCI. The rest of the configuration registers can be accessed via the second PCIe configuration mechanism, the PCIe enhanced configuration mechanism. 
<LI>The PCIe enhanced configuration mechanism&#8212;In this configuration mechanism, the entire PCIe configuration registers all of the PCIe devices that are mapped to the CPU memory space, including the first 256-bytes PCI-compatible configuration registers, which are mapped to both the CPU IO space and the CPU memory space&#8212;see point 1 above. The CPU memory range occupied by the PCIe configuration registers must be aligned to the 256MB boundary. The size of the memory range is 256MB. The calculation to arrive in this memory range size is simple: each PCIe device has 4KB configuration registers, PCIe supports the same number of buses as PCI, i.e. 256 buses, 32 devices per bus, and 8 functions per device. Therefore, the total size of the required memory range is: 256 x 32 x 8 x 4KB; which is equal to 256MB.</LI></OL>
<P style="MARGIN: 0px 0px 20px">One of the implications of the PCIe configuration mechanism is that the first 256-bytes of each of the PCIe device configuration registers are mapped into two different spaces, the CPU IO space&#8212;through the PCI-compatible configuration mechanism&#8212;and the CPU memory space&#8212;through the PCIe enhanced configuration mechanism. If you are still confused about this explanation, take a look at Figure 7. Figure 7 shows mapping of the PCIe device configuration space registers of one PCIe device into the CPU IO space and CPU memory space.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 7. PCIe Device Configuration Space Register Mapping as Seen from the CPU</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre7.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre7.png"></P>
<P style="MARGIN: 0px 0px 20px">You might be asking why PCIe systems still need to implement the PCI configuration mechanism. The first reason is to provide backward-compatibility to operating systems that existed prior to the PCIe being adopted and the second reason is to provide a way to initialize the PCIe enhanced configuration mechanism. On an x64 platform, the CPU memory range consumed by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>PCIe enhanced configuration mechanism is not hardcoded to a certain CPU memory range, it&#8217;s relocatable in the 64-bit CPU memory space</EM>. The platform firmware must initialize certain register in the PCIe root complex logic to map the PCIe devices&#8217; configuration registers to certain address in the 64-bit CPU memory space. The start address to map the PCIe configuration registers must be aligned to 256MB boundary. On the other hand, location of the PCI configuration registers in the CPU IO space is hardcoded in x86 and x64; this provides a way to initialize the register that controls the mapping of all of the PCIe configuration registers&#8212;in the PCIe root complex&#8212;via PCI-compatible configuration mechanism because PCI-compatible configuration mechanism is available at all times, including very early at system boot.</P>
<P style="MARGIN: 0px 0px 20px">A PCIe enhanced configuration mechanism has an implication that reading or writing the PCIe configuration registers of a PCIe device requires a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>memory read or write</EM>. This is a contrast to the PCI configuration mechanism, where the code to do the same thing requires an IO read or IO write. This approach was a trend in the hardware world in the late 90&#8242;s&#8212;i.e., moving all hardware-related registers to CPU memory space to simplify hardware and system software design. It was not adopted just by the PCIe bus protocol but also by other bus protocols in CPU architectures other than x64.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 8. PCIe Enhanced Configuration Mechanism Address Bits Mapping to CPU Memory Space</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre8.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre8.png"></P>
<P style="MARGIN: 0px 0px 20px">Figure 8 shows mapping of the PCIe enhanced configuration space into the 64-bit CPU memory space. This is the breakdown of the 64-bit PCIe enhanced configuration space register address:</P>
<OL>
<LI>Address bits 28-63 are upper bits of the 256MB-aligned base address of the 256MB memory-mapped IO address range allocated for the enhanced configuration mechanism. The manner in which the base address is allocated is implementation-specific. Platform firmware supplies the base address to the OS. Mostly, the base address is controlled by a programmable register that resides in the chipset or is integrated into the CPU. 
<LI>Address bits 20-27 select the target bus (1-of-256). 
<LI>Address bits 15-19 select the target device (1-of-32) on the bus. 
<LI>Address bits 12-14 select the target function (1-of-8) within the device. 
<LI>Address bits 2-11 select the target double-word (a.k.a. dword); 1-of-1024 within the selected function&#8217;s configuration space. 
<LI>Address bits 0-1 define the start byte location within the selected dword.</LI></OL>
<P style="MARGIN: 0px 0px 20px">As in PCI configuration register address accesses, reading or writing to PCIe enhanced configuration registers must be aligned into a dword (32-bit) boundary. This is because the CPU and the chipset in the path to the PCIe enhanced configuration register only guarantee the delivery of configuration transactions if they are aligned to a 32-bit boundary.</P>
<P style="MARGIN: 0px 0px 20px">In x64 architecture, a special register in the CPU&#8212;part of the PCIe root complex logic&#8212;controls the 36-bit PCIe enhanced configuration space base address. This base address register must be initialized by the platform firmware on boot. The register initialization is carried out through a PCI-compatible configuration mechanism because, at very early boot, the register contains a default value that is not usable to address the registers in the PCIe enhanced configuration space. We&#8217;ll have a look deeper into the implementation of this base address when we dissect the PCIe-based system address map later.</P>
<P style="MARGIN: 0px 0px 20px">Now, let&#8217;s look at a simple example of PCIe enhanced configuration register mapping into the CPU address space. Let&#8217;s make these assumptions:</P>
<OL>
<LI>The base address of the PCIe enhanced configuration address space is set to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C400_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB+64MB) in the PCIe root complex register. 
<LI>The target PCIe device resides in bus number one (1). 
<LI>The target PCIe device is device number zero (0) in the corresponding bus. 
<LI>The target PCIe function is function number zero (0). 
<LI>The target register resides at offset 256 (100h) in the PCIe device configuration space. 
<LI>Size of the target register is 32 bits (1 dword).</LI></OL>
<P style="MARGIN: 0px 0px 20px">With the assumptions above, we found out that the target PCIe enhanced configuration register resides at address<SPAN style="FONT-FAMILY: 'Courier New'">C410_0100h</SPAN>. The higher 32-bit value of the PCIe enhanced configuration register address is practically 0; the target address only uses the lower 32-bit of the CPU memory address space. If the target address that corresponds to the target PCIe configuration register is still confusing, break it down according to the mapping shown in Figure 8. It should be clear after that.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">PCIe Capabilities Register Set</H2>
<P style="MARGIN: 0px 0px 20px">There are several fundamental differences between PCIe and &#8220;legacy&#8221; PCI devices. We are going to look into one of those differences before we move on to PCIe BAR initialization because they affect PCIe BAR implementation, the PCIe capabilities register set. All PCIe devices must implement the PCIe capabilities register set in the first 256 bytes of its configuration space registers. In contrast, a &#8220;legacy&#8221; PCI device is not required to implement any capabilities register set. In &#8220;legacy&#8221; PCI devices, implementing a capabilities pointer is optional,<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>not</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>mandatory. Figure 9 shows implementation of the PCIe capabilities register set in a PCIe device configuration space register.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 9. PCIe Device Capabilities Register Set</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre9.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre9.png"></P>
<P style="MARGIN: 0px 0px 20px">Figure 9 shows a capabilities pointer register&#8212;highlighted in purple&#8212;in PCIe device configuration space pointing to the PCIe capabilities register set. In practice, the capabilities pointer register points to the start of PCIe capabilities register set by using an 8-bit offset (in bytes) of the start of PCIe capabilities register set. The offset is calculated from start of the PCIe device configuration space. This 8-bit offset is stored in the capabilities pointer register. The position of the PCIe capabilities register set is device-specific. However, the PCIe capabilities register set is guaranteed to be placed in the first 256 bytes of the PCIe device configuration space and located after the mandatory PCI header. Both a type 0 or type 1 header must implement the PCIe capabilities register set in a PCIe device configuration space.</P>
<P style="MARGIN: 0px 0px 20px">Now, let&#8217;s look more closely at part of the PCIe capabilities register set. Figure 9 shows the third register in the capabilities register set is the PCIe capabilities register. Figure 10 shows format of this register&#8217;s contents.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 10. PCIe Capabilities Register Format</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre10.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre10.png"></P>
<P style="MARGIN: 0px 0px 20px">Device/port type bits (bits 4-7) in the PCIe capabilities register are the ones that affect the PCIe device mapping to the system address map. Device/port type bits determine whether the PCIe device is a native PCIe endpoint function or a legacy PCIe endpoint function. Differences between the two types of PCIe device are:</P>
<OL>
<LI>The value of device/port type bits in a native PCIe endpoint function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0000b</SPAN>. Native PCIe endpoint function devices must map all of the device components, such as its registers and local memory, to the CPU memory space at runtime&#8212;from inside a running OS. The only time the device is permitted to use the CPU IO space is during early boot time, before the platform firmware finishes initializing the system. 
<LI>Value of device/port type bits in a legacy PCIe endpoint function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0001b</SPAN>. Legacy PCIe endpoint function devices are permitted to use the CPU IO space even at runtime. The PCIe specification assumes that legacy PCIe endpoint function devices act as front-end to legacy bus, such as PCI or PCI-X.</LI></OL>
<P style="MARGIN: 0px 0px 20px">Now, it&#8217;s clear that the contents of the PCIe capabilities register determine whether the PCIe device will map its BARs to the CPU memory space or to the CPU IO space at runtime. There are special cases though, especially when dealing with legacy IO devices. For example, legacy PC-compatible devices such as VGA and IDE controllers frequently expect to be located within fixed legacy IO ranges. Such functions do not implement base address registers. Instead, the configuration software identifies them as legacy functions via their respective class codes&#8212;offset<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">09h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the PCIe configuration space&#8212;and then enables their IO decoder(s) by setting the IO space bit in its command register to one.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">PCIe Base Address Register Initialization</H2>
<P style="MARGIN: 0px 0px 20px">PCIe devices use BAR just like PCI devices. Therefore, a PCIe device&#8217;s BAR must be initialized before the device can be used. PCI BAR initialization is the job of the platform firmware. The PCI specification provides implementation notes on PCI BAR initialization. PCIe continues to support this BAR initialization method.</P>
<P style="MARGIN: 0px 0px 20px">I&#8217;m not going to repeat the explanation PCI BAR initialization here; I&#8217;m only going to highlight the differences between PCIe BAR initialization and PCI BAR initialization in this section. Please refer to the first part of the series for the basics of PCI BAR formats and PCI BAR initialization (at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/">http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/</A>).</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">PCIe BAR Formats</H3>
<P style="MARGIN: 0px 0px 20px">There are two types of BAR: The first is a BAR that maps to the CPU IO space&#8212;an IO BAR&#8212;and the second one is a BAR that maps to the CPU memory space&#8212;a memory BAR. A PCIe IO BAR is exactly the same as a PCI IO BAR. However, the PCIe specification recommends abandoning using the IO BAR for new PCIe devices. These new devices should use the memory BAR instead.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 11. PCI/PCIe Memory BAR Format</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre11.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre11.png"></P>
<P style="MARGIN: 0px 0px 20px">Figure 11 shows the memory BAR format. Figure 11 shows that the lowest bit is hardcoded to 0 in the BAR that map to CPU memory space. It also shows that bit 1 and bit 2 determine whether the BAR is a 32-bit BAR or 64-bit BAR.</P>
<P style="MARGIN: 0px 0px 20px">Figure 11 shows that bit 3 controls the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>prefetching</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the BAR that map to CPU memory space. Prefetching in this context means that the CPU fetches the contents of memory addressed by the BAR before a request to that specific memory address is made, i.e., the &#8220;fetching&#8221; happens in advance, hence &#8220;pre&#8221;-fetching. This feature is used to improve the overall PCI/PCIe device memory read speed.</P>
<P style="MARGIN: 0px 0px 20px">The main difference between a PCI and PCIe memory BAR is that all memory BAR registers in PCIe endpoint functions with the prefetchable bit set to 1 must be implemented as 64-bit memory BARs. Memory BARs that do not have the prefetchable bit set to 1 may be implemented as 32-bit BARs. The minimum memory range requested by a memory BAR is 128 bytes.</P>
<P style="MARGIN: 0px 0px 20px">Another difference between PCIe and PCI is the notion of a dual address cycle (DAC). PCIe is a serial bus protocol and doesn&#8217;t implement DAC. PCIe was designed with native 64-bit addressing in mind. Therefore, support for memory transactions targeting 64-bit addresses is native in PCIe. There is no performance penalty for carrying out memory transactions targeting 64-bit addresses.</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">PCIe BAR Sizing</H3>
<P style="MARGIN: 0px 0px 20px">The algorithm for PCIe BAR sizing is the same as the algorithm for PCI device BAR sizing explained in the first article. The difference lies only in prefetchable memory BAR, because a prefetchable memory BAR in PCIe must be 64 bits wide, the BAR sizing algorithm must use two consecutive 32-bit BARs instead of one 32-bit BAR during BAR sizing.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">Dissecting PCIe-Based System Address Map</H2>
<P style="MARGIN: 0px 0px 20px">In this section we look at an implementation sample of the system address map in x86/x64 before proceeding to the system address map initialization in more detail. The implementation sample is based on Haswell&#8212;with integrated northbridge/hostbridge&#8212;and the Intel 8-series PCH platform. This platform implements the PCIe bus and it&#8217;s an up-to-date platform. Therefore, it&#8217;s a perfect example to learn real-world PCIe implementation.</P>
<P style="MARGIN: 0px 0px 20px">Intel 8-series PCH can be viewed as southbridge in the classic system layout; however, both are not the same logic because there are some functions in the PCH that absent in the &#8220;classic&#8221; southbridge. You can download the CPU datasheet from<A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://www.intel.com/content/www/us/en/processors/core/CoreTechnicalResources.html">http://www.intel.com/content/www/us/en/processors/core/CoreTechnicalResources.html</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and PCH datasheet from<A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://www.intel.com/content/www/xr/en/chipsets/8-series-chipset-pch-datasheet.html">http://www.intel.com/content/www/xr/en/chipsets/8-series-chipset-pch-datasheet.html</A>.</P>
<P style="MARGIN: 0px 0px 20px">PCIe differs from PCI in that PCIe moves everything to CPU memory space, including its configuration space, as you can see from the PCIe configuration mechanisms section. The presence of part of PCIe configuration registers in the CPU IO space is only for backward compatibility reasons. This fact means the CPU memory space in a PCIe-based system is a bit more fragmented compared to PCI-based systems. However, this approach pays back in terms of less complication in CPU design and quicker access to all of the memory ranges mapped to the CPU memory space, including PCIe configuration registers, because access to CPU memory space is quicker than access to IO space by default.</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">Haswell CPU and Intel 8-series Chipset Platform</H3>
<P style="MARGIN: 0px 0px 20px">Figure 12 shows a block diagram of systems with Haswell CPU and 8-series chipset combination. Figure 12 shows the entire connection from the chipset to other components in the system, including those that might not exist in all chipset stock keeping units (SKUs).</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 12. Intel Haswell CPU with 8-series Chipset Block Diagram</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre12.jpg" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre12.jpg"></P>
<P style="MARGIN: 0px 0px 20px">Not all of the system interconnects in Figure 12 affect the system address map. We are going to focus only on interconnects and control registers that affect the system address map in this article. The interconnects of interest in Figure 12 are the DMI 2.0 interconnect, the interconnect from CPU to PCIe graphics, the SPI interconnect from the Intel H87 chipset to the platform firmware, the interconnect from the Intel H87 chipset to PCIe devices, and the interconnect from the CPU to DDR3 DRAM modules. We will get into the details of memory transactions routing to these interconnects in the next section (Haswell Memory Transactions Routing).</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">Haswell Memory Transactions Routing</H3>
<P style="MARGIN: 0px 0px 20px">Address-based memory transactions routing in Haswell CPU determines the system memory map. There are several control registers in the hostbridge part of the CPU that control memory transaction routing in this platform. Before we get into the registers details, we&#8217;ll have a look at the high-level view of the memory transaction routing in the northbridge. Figure 13 shows the logic components in the northbridge that takes care of memory transaction routing. You won&#8217;t see these logic blocks depicted in any of the publicly available datasheet from Intel. I draw them in Figure 13 based on details provided in the datasheet. The logic blocks are &#8220;abstractions&#8221; to make the memory transaction routing understandable.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 13. Memory Transactions Routing in Haswell Northbridge/Hostbridge</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre13.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre13.png"></P>
<P style="MARGIN: 0px 0px 20px">Memory transactions in Figure 13 originate in the CPU and target DRAM, DMI, or the external PCIe graphics. We are not going to delve into direct memory access (DMA) in this article because DMA can originate in the PCIe graphics or the DMI. This means that the DMA adds unnecessary complications to understanding memory transaction routing in the hostbridge.</P>
<P style="MARGIN: 0px 0px 20px">Figure 13 shows five different memory transaction routing logic blocks that connect directly to Haswell CPU cores. The memory transaction routing logic blocks are as follows:</P>
<OL>
<LI>&#8220;Normal&#8221; DRAM range logic&#8212;This logic block routes memory transactions (read/write) targeting the range covered by DRAM, which requires<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>no</EM><BR><EM>remapping</EM>, i.e., the target address of the transaction doesn&#8217;t need any translation before entering the memory/DRAM controller. The control registers that control this memory range are<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>top of low usable DRAM</STRONG>(TOLUD) register and<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>remap base</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>register. Both registers are in the hostbridge. TOLUD controls CPU memory range occupied by the DRAM below 4GB. Remap base is only in use if the system DRAM size is equal to or larger than 4GB; in this case remap base marks the end of the &#8220;normal&#8221; CPU DRAM range above 4GB. 
<LI>Remapped DRAM range logic&#8212;This logic block routes memory transactions (read/write) targeting range covered by DRAM that requires<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>remapping</EM>, i.e., the target address of the transaction need to be translated before entering the memory/DRAM controller. There are two control registers that control the remapped memory range, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>remap base</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>remap limit</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>registers. The registers are in the hostbridge. 
<LI>
<DIV>Compatibility memory range logic&#8212;This logic block routes memory transactions (read/write) targeting range covered by the compatibility memory range. This memory range comprises the range between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">A_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN style="FONT-FAMILY: 'Courier New'">F_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the ISA hole from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">F0_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">F_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(15MB to 16MB). This memory range is further divided into three sub-ranges:</DIV>
<OL>
<LI>Legacy VGA memory range lies between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">A_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">B_FFFFh</SPAN>&#8212;<STRONG>VGA memory map mode</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>control register controls mapping of compatibility memory range from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">A_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">B_FFFFh</SPAN>. This range may be mapped to PCIe, DMI or Internal Graphics Device (IGD), depending on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>VGA memory map mode</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>control register value. Therefore, a memory transaction targeting memory ranges between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">A_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN style="FONT-FAMILY: 'Courier New'">B_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be routed to either PCIe or DMI or IGD. 
<LI>Non-VGA compatibility and non-&#8221;ISA Hole&#8221; memory range, which consists of memory range from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C_0000h</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">F_FFFFh</SPAN>&#8212;All memory transactions targeting this compatibility memory range are routed either to the memory/DRAM controller or the 8-series PCH chipset (Intel H87 chipset in Figure 12) via the DMI interface, depending on values in the control registers of the corresponding compatibility memory range logic. The control registers for compatibility memory range from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">F_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are named<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>programmable attribute map</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>(PAM) registers. There are seven PAM registers, from PAM0 to PAM6; all of them are located in the hostbridge part of the CPU. 
<LI>&#8220;ISA hole&#8221; memory range from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">F0_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">F_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(15MB-16MB)&#8212;A<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>legacy access control</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>(LAC) register in the hostbridge controls routing of memory transactions targeting the ISA hole at memory range<SPAN style="FONT-FAMILY: 'Courier New'">F0_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">F_FFFFh</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(15MB-16MB). All memory transactions targeting this compatibility memory range are routed either to the memory/DRAM controller or to the 8-series PCH chipset (Intel H87 chipset in Figure 12) via the DMI interface, depending on values in the LAC control register. The ISA hole is an optional range; it&#8217;s by default disabled on the hostbridge. 
<LI>Platform firmware flash, message-signaled interrupt (MSI) and advanced programmable interrupt controller (APIC) memory range&#8212;This range is between 4GB-minus-20MB to 4GB (<SPAN style="FONT-FAMILY: 'Courier New'">FEC0_0000h</SPAN>-<SPAN style="FONT-FAMILY: 'Courier New'">FFFF_FFFFh</SPAN>). All memory transactions targeting this compatibility memory range are always routed to the DMI interface, except those targeting the MSI address range and the APIC memory ranges that correspond to the local APIC in the CPU cores. Memory transactions targeting the range occupied by the platform firmware flash will be forwarded by the southbridge to the platform firmware flash chip once the transactions reached the southbridge via the DMI. This memory range is hardcoded; no control register in the hostbridge is needed for memory transaction routing in this memory range.</LI></OL>
<LI>PCIe 3.0 graphics memory range logic&#8212;This logic block routes memory transactions (read/write) targeting range covered by the BARs of the external PCIe graphics card. If the range is below 4GB, there are no specific control register in the hostbridge that alter access to this memory range, only the external PCIe graphics BARs that determine the routing. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>PMBASEU</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>PMLIMITU</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>registers control access to the PCIe graphics memory range if the external PCIe graphics uses memory range above 4GB. Both registers are part of the PCIe controllers integrated into the Haswell CPU. 
<LI>PCIe 2.0/PCI memory range logic. This logic block routes memory transactions (read/write) targeting range from the value of TOLUD register to 4GB to the 8-series PCH chipset via the DMI interface. This logic block also routes memory transactions (read/write) targeting range between<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>PMBASEU</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>PMLIMITU</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>registers&#8212;but don&#8217;t fall within the range covered by the PCIe 3.0 graphics memory range&#8212;if the system has 4GB RAM or more . The range from TOLUD value to 4GB is set aside for PCI/PCIe memory. The PCI/PCIe memory range that&#8217;s not claimed by the PCIe 3.0 graphics resides in the 8-series PCH chipset. The control register for this range is the TOLUD, PMABASEU and PMLIMITU registers, located in the hostbridge.</LI></OL>
<P style="MARGIN: 0px 0px 20px">All five memory transaction routing logic blocks are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>mutually exclusive</EM>, i.e., every memory transaction must be claimed only by either<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>one</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of them. There should be only one memory transaction routing logic block that claims one memory transaction. &#8220;Anarchy&#8221; in memory transaction routing could happen though. Anarchy in this context means more than one logic block claims a memory transaction. Anarchy happens if the platform firmware initializes one or more control registers of these logic blocks incorrectly.</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">Haswell System Address Map</H3>
<P style="MARGIN: 0px 0px 20px">In the preceding section, you have learned how memory transactions are routed in Haswell by the northbridge based on the target address of the transactions. This section delve into the result of the routing, the system address map. The presence of address remapping in the northbridge makes the system address map quite complicated, i.e., the address map depends on the point of view, whether the address map is seen from the CPU core(s) perspective or not. Figure 14 shows a Haswell system address map with 4GB RAM or more. I choose not to talk about Haswell systems with less than 4GB of RAM because address remapping is not in use in such configuration.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 14. Haswell System Address Map (System Memory &gt;= 4GB)</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre14.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre14.png"></P>
<P style="MARGIN: 0px 0px 20px">Figure 14 shows the Haswell system address map from the CPU core perspective and from the DRAM controller perspective. System address maps from both perspectives are different because the DRAM controller doesn&#8217;t see memory ranges consumed by PCI/PCIe devices and it doesn&#8217;t need such visibility either. The CPU views the memory ranges from TOLUD-to-4GB as allocated to PCI/PCIe devices, while the DRAM controller views the same memory range to be allocated to DRAM. Such different &#8220;views&#8221; are possible because the northbridge remaps the respective memory range in the DRAM from TOLUD-to-4GB (as seen from DRAM controller) to a new memory range above 4GB called &#8220;reclaim&#8221; memory range in the CPU memory space. The &#8220;reclaim&#8221; memory range is determined by two registers: REMAP BASE and REMAP LIMIT registers in the northbridge. The memory remapping logic in the northbridge carries out the remapping task, as you can see in Figure 13.</P>
<P style="MARGIN: 0px 0px 20px">Boxes with light blue color in Figure 14 represent memory ranges occupied by RAM. This means that the DRAM controller sees the available RAM as a contiguous memory range while the CPU core doesn&#8217;t. The CPU core view contains &#8220;holes&#8221; in the memory range below 4GB that don&#8217;t belong to RAM&#8212;the &#8220;holes&#8221; are marked as boxes with non-light-blue colors in Figure 14.</P>
<P style="MARGIN: 0px 0px 20px">Detail of the memory ranges in Figure 14 as follows:</P>
<OL>
<LI>Legacy address range (as seen from CPU core perspective)&#8212;This range is the DOS compatibility range between 0-to-1MB. Memory transactions targeting the range between 0-640KB are always routed to DRAM, while memory transactions targeting the range between 640KB-1MB are routed based on the value of the PAM register which controls the respective ranges. Recall that there are seven PAM registers controlling the memory range between 640KB-1MB. 
<LI>Main memory ranges are memory ranges occupied by DRAM that don&#8217;t require address remapping. OS has visibility to these ranges. The &#8220;normal&#8221; memory range logic in Figure 13 handles these memory ranges. These memory ranges have identical mappings from both the CPU perspective and the DRAM controller perspective. 
<LI>TSEG range&#8212;This memory range has an identical mapping from both the CPU perspective and the DRAM controller perspective. TSEG is an abbreviation for &#8220;top of main memory segment.&#8221; However, in today&#8217;s context this means the segment that lies in the top of main memory range below the 4GB limit. The start of this memory range is determined by the value of the TSEG memory base (<STRONG>TSEGMB)</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>register in the hostbridge. Contents of this segment can only be seen when the CPU is running in system management mode (SMM). Therefore, code running outside of SMM doesn&#8217;t have visibility of this range in RAM, even the operating system code. This segment stores the runtime data and code of the platform firmware. 
<LI>&#8220;GFX GTT Stolen&#8221; memory range&#8212;This memory range is seen as part of the PCI/PCIe memory range from the CPU perspective, while it&#8217;s seen as part of the DRAM from DRAM controller perspective. This memory range only exists if the integrated graphics device (IGD) in the CPU is enabled in the hostbridge GMCH graphics control (GGC) register (via its VAMEN bit)&#8212;the platform firmware must initialize the bit based on the firmware configuration setting. This memory range stores the graphics translation table (GTT) entries&#8212;GTT entries are akin to page table entries (PTEs) in the CPU, but GTT entries are used for graphics memory. This memory range occupies the PCI/PCIe memory range from the CPU perspective despite the fact that it physically resides in the system memory (DRAM), not in the local RAM of a PCIe graphics card. Bits 8-9 (GGMS bits) in the GGC register in the hostbridge determine the size of this memory range, while the base of the GTT stolen memory (<STRONG>BGSM</STRONG>) register in the hostbridge determines the start/base address of this memory range. 
<LI>&#8220;GFX stolen&#8221; memory range&#8212;This memory range is seen as part of the PCI/PCIe memory range from the CPU perspective, while it&#8217;s seen as part of the DRAM from the DRAM controller perspective. This memory range only exists if the IGD in the CPU is enabled&#8212;see &#8220;GFX GTT stolen&#8221; above for details on enabling the IGD. This memory range stores the graphics data, i.e., it acts as graphics memory for the IGD. This memory range occupies the PCI/PCIe memory range from the CPU perspective despite the fact that it physically resides in the system memory (DRAM), not in the local RAM of a PCIe graphics card. Bits 3-7 (GMS bits) in the GGC register in the hostbridge determine the size of this memory range, while the base data of stolen memory (<STRONG>BDSM</STRONG>) register in the hostbridge determines the start/base address of this memory range. 
<LI>PCI/PCIe memory range below 4GB&#8212;This memory range is only seen from the CPU perspective. This range is determined by whether the IGD is activated or not. If the IGD is active, this memory range starts at the value of the BGSM register; otherwise this memory range starts at the value of TOLUD register. The upper limit of this memory range is 4GB-20MB (<SPAN style="FONT-FAMILY: 'Courier New'">FEC0_0000h</SPAN>). Access to this range is forwarded to either the external PCIe graphics via the PCIe 3.0 connection or to the southbridge via the DMI. 
<LI>PCI/PCIe memory range above 4GB&#8212;This memory range is only seen from the CPU perspective. The value of top of upper usable DRAM (<STRONG>TOUUD</STRONG>) register in the hostbridge determines the start of this memory range. The value of TOUUD is equal to the value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>REMAPLIMIT</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>register plus one. The PMLIMITU register (in the hostbridge) value determines the end of this memory range. Access to this range is forwarded to either the external PCIe graphics via the PCIe 3.0 connection or to the southbridge via the DMI. 
<LI>Graphics aperture range&#8212;This memory range is seen as part of PCI/PCIe memory range below 4GB in Figure 14. However, in practice, this memory range may as well reside in the PCI/PCIe memory range above 4GB, depending on the platform firmware and the system configuration. This memory range is always mapped to the PCI/PCIe memory range. It&#8217;s used as contiguous address space or as additional graphics memory space if the graphics memory in the IGD or external PCIe graphics card is running out. The graphics aperture range in the platform firmware configuration must be enabled for this range to exist. Otherwise, it doesn&#8217;t exist. Memory management for the system memory allocated to serve the graphics aperture uses a graphics translation table just like the legacy AGP aperture. The difference lies in the possibility that the aperture lies above the 4GB limit and the handling of the graphics aperture memory management. It&#8217;s the responsibility of the OS&#8212;specifically the graphics device driver&#8212;to carry out memory management for the graphics aperture. Refer to the first part of this series for graphics aperture basics (at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/">http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/</A>). The graphics memory aperture base address register (<STRONG>GMADR</STRONG>) in the IGD determines the start address of the graphics aperture when the IGD acts as the graphics chip in the Haswell platform. 
<LI>Flash BIOS, APIC, MSI interrupt memory range (<SPAN style="FONT-FAMILY: 'Courier New'">FEC0_0000h &#8211; FFFF_FFFFh</SPAN>)&#8212;As explained in the previous section, all memory transactions targeting this compatibility memory range are always routed to the DMI interface, except those targeting the MSI address range and the APIC memory ranges that correspond to the local APIC in the CPU cores. Memory transactions targeting the last two ranges are always directed to the CPU. 
<LI>Main memory reclaim address range&#8212;This memory range occupies a different address when viewed from the CPU perspective and from the DRAM controller perspective. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>REMAPBASE</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>REMAPLIMIT</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>register in the hostbridge determine the start and the end of this memory range as seen from the CPU perspective. The TOLUD register and the 4GB limit defines the start and end of the same memory range when viewed from the DRAM controller perspective. The &#8220;remapped memory range logic&#8221; in the hostbridge&#8212;shown in Figure 13&#8212;remaps memory transactions from the CPU targeting this memory range before the transactions reach the DRAM controller. 
<LI>Manageability engine UMA memory range&#8212;This range is<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>not</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>controlled by the CPU. The manageability engine (ME) is integrated into the 8-series PCH (southbridge). The platform firmware reads the<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>Intel management engine UMA Register</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the 8-series PCH to determine the size of this range. The platform firmware must allocate this range from the top of memory (TOM) up-to the size requested by UMA register. The platform firmware initializes the<STRONG>MESEG_BASE</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>MESEG_MASK</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>registers in the hostbridge to allocate the requested range from DRAM. ME is basically a microcontroller running in its own execution environment, out of the CPU&#8217;s control. ME uses the manageability engine UMA memory range in RAM to cache its firmware while the system is not in low power state. ME uses its own&#8212;integrated&#8212;static RAM if the system is on low-power state. ME doesn&#8217;t run when the system is completely out of power.</LI></OL>
<P style="MARGIN: 0px 0px 20px">At this point, the Haswell system memory map should be clear. Nonetheless, we are going to look into a hypothetical memory read transaction to improve our Haswell system memory map understanding. Let&#8217;s make the following assumptions on the system configuration:</P>
<UL>
<LI>Physical memory (DRAM) size: 6GB 
<LI>Memory space allocated to memory mapped IO (including Flash, APIC, MSI, Intel TXT): 1GB 
<LI>Size of remapped physical memory: 1GB 
<LI>Top of memory (TOM):<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">1_8000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(6GB) 
<LI>ME UMA size:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8212; ME is disabled 
<LI>TOUUD:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">1_C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(7GB) &#8212; This address is 1MB-aligned 
<LI>TOLUD:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB) 
<LI>REMAPBASE:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">1_8000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(6GB) 
<LI>REMAPLIMIT:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">1_BFF0_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(7GB &#8211; 1) 
<LI>Note: The remap range is inclusive of the base and limit addresses. In the address decoder, bits 0-19 of the remap base address are assumed to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0h</SPAN>. Similarly, bits 0-19 of the remap limit are assumed to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">0Fh</SPAN>. This configuration ensures the remap range to stay in 1MB boundaries.</LI></UL>
<P style="MARGIN: 0px 0px 20px">Now, let&#8217;s trace a memory read transaction that targets<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">1_8000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(6GB) physical address in this system configuration. Figure 15 shows how the memory read transaction travels in the system.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 15. Haswell Memory Read Transaction Sample</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre15.png" width=581 height=492 data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre15.png"></P>
<P style="MARGIN: 0px 0px 20px">The red lines in Figure 15 denote the memory read transaction. Figure 15 intentionally doesn&#8217;t show logic blocks not related to the memory read transaction to ease understanding of the transaction flow. Figure 15 shows the memory read transaction originated from CPU core 1. Then, the &#8220;remapped memory range logic&#8221; claims the memory read transaction once it enters the hostbridge because it&#8217;s within the range covered by REMAPBASE and REMAPLIMIT registers. The &#8220;remapped memory range logic&#8221; then remaps the transaction target address into the address as seen from the DRAM controller perspective and forwards the transaction to the DRAM controller afterwards. The DRAM controller then handles the memory read transaction&#8212;i.e., it fetches the correct contents from the DRAM module.</P>
<P style="MARGIN: 0px 0px 20px">The sample memory read transaction illustrates how the logic block in the hostbridge claims a memory read transaction and processes it accordingly. The Haswell system address map should be clear to you once you fully understand this memory read transaction sample.</P>
<P style="MARGIN: 0px 0px 20px">Last but not least, you might be asking how the PCIe expansion ROM is addressed in Haswell. Well, it&#8217;s very similar to a PCI-based system. The XROMBAR register in the particular PCIe expansion card must be enabled and programmed to consume memory range in the PCI/PCIe memory range. The rest is just the same as in a PCI-based system. There is no particular enhancement carried out by the PCIe bus protocol in this respect.</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">PCIe Enhanced Configuration Space in Haswell Platform</H3>
<P style="MARGIN: 0px 0px 20px">In this section we will look at PCIe enhanced configuration space location in the Haswell system address map. The first 256-byte PCIe configuration space registers are mapped to the CPU IO space at port<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">CF8h-CFFh</SPAN>, just as in the legacy PCI bus&#8212;in addition, these registers are also mapped to the PCIe enhanced configuration space.</P>
<P style="MARGIN: 0px 0px 20px">Contrary to legacy PCI configuration space, the entire PCIe configuration space (4KB per-device) is located in the CPU memory space. On the x86/x64 platform, the memory range consumed by the PCIe configuration space is relocatable in the CPU memory space. The platform firmware must initialize the location of this configuration space in the CPU memory space. We should look more closely into Haswell-specific implementation in this section.</P>
<P style="MARGIN: 0px 0px 20px">Now, let&#8217;s calculate the memory space requirement of the PCIe configuration space registers:</P>
<OL>
<LI>The maximum number or PCIe buses in the system is 256 
<LI>The maximum number of PCIe devices per bus is 32 
<LI>The maximum number of function per device is 8 
<LI>Each function can implement up-to 4KB configuration registers</LI></OL>
<P style="MARGIN: 0px 0px 20px">Using the statistics above, the entire PCIe configuration space registers requires: 256 x 32 x 8 x 4KB of memory space. This amounts to 256MB of memory space. Therefore, the platform firmware must initialize the system address map to accommodate this PCIe configuration space requirement. However, in practice, the memory space requirement of the PCIe enhanced configuration space in a particular system can be less than 256MB because the system cannot support that many PCIe devices physically.</P>
<P style="MARGIN: 0px 0px 20px">In most cases, the PCIe enhanced configuration space is carved out of the PCI/PCIe memory range. The PCIe configuration space can be mapped to the PCI/PCIe memory range below 4GB (from TOLUD to the 4GB limit) or mapped to PCI/PCIe memory above the 4GB limit (above TOUUD) in the Haswell memory map, as shown in Figure 16.</P>
<P style="MARGIN: 0px 0px 20px">On the Haswell platform, the PCI express register range base address (<STRONG>PCIEXBAR</STRONG>)&#8212;a register&#8212;in the hostbridge determines the location of the PCIe enhanced configuration space. PCIEXBAR contents determine the start address and the size of the PCIe enhanced configuration space. Figure 16 shows the two possible alternatives to map the PCIe enhanced configuration space. They are marked as &#8220;Mapping Alternative 1&#8243; (within the PCI/PCIe memory range below 4GB) and &#8220;Mapping Alternative 2&#8243; (within the PCI/PCIe memory range above TOUUD). PCIEXBAR can set the size of the PCIe enhanced configuration space to 64 MB, 128 MB or 256 MB. The platform firmware should initialize the bits that control the size of the PCIe enhanced configuration space in PCIEXBAR at boot.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 16. PCIe Enhanced Configuration Space Register Mapping on Haswell Platform</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://2we26u4fam7n16rz3a44uhbe1bq2.wpengine.netdna-cdn.com/wp-content/plugins/jquery-image-lazy-loading/images/grey.gif" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre16.png"></P>
<P style="MARGIN: 0px 0px 20px">Mapping of the PCIe enhanced configuration space to the Haswell system address map should be clear at this point. Now, let&#8217;s proceed to learn how to access the PCIe enhanced configuration space register. The memory address used to access the PCIe configuration space of a specific device function on the Haswell platform follows:</P>
<P style="MARGIN: 0px 0px 20px"><SPAN style="FONT-FAMILY: 'Courier New'">PCIe_reg_addr_in_CPU_memory_space = PCIEXBAR + Bus_Number * 1MB +<BR>Device_Number * 32KB + Function_Number * 4KB +<BR>Register_Offset</SPAN></P>
<P style="MARGIN: 0px 0px 20px">Perhaps you&#8217;re asking where the 1MB, 32KB, and 4KB multipliers come from. It&#8217;s simple actually: For each bus, we need 32 (device) * 8 (function) * 4KB of memory space, this is equal to 1MB; for each device, we need 8 (function) * 4KB of memory space, this is equal to 32KB.</P>
<P style="MARGIN: 0px 0px 20px">Now, let&#8217;s look into a simple sample. Let&#8217;s assume that PCIEXBAR is initialized to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C000_0000h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3GB) and we want to access the PCIe configuration register in Bus 0, device 2, function 1, at offset<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">40h</SPAN>. What is the address of this particular register? Let&#8217;s calculate it:</P>
<P style="MARGIN: 0px 0px 20px"><SPAN style="FONT-FAMILY: 'Courier New'">Register_address_in_memory = C000_0000h + 0 * 1MB + 2 * 32KB + 1 * 4KB + 40h<BR>Register_address_in_memory = C000_0000h + 0 + 1_0000h + 1000h + 40h<BR>Register_address_in_memory = C001_1040h</SPAN></P>
<P style="MARGIN: 0px 0px 20px">We found that the target PCIe configuration register is located at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">C001_1040h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the CPU memory space. With this sample, you should now have no problem dealing with PCIe enhanced configuration space.</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">System Management Mode (SMM) Memory on the Haswell Platform</H3>
<P style="MARGIN: 0px 0px 20px">In the first article of this series, you learned that there are two memory ranges used to store SMM code and data, the high segment (HSEG) and TSEG. However, on the Haswell platform, HSEG has been deprecated and unsupported. Therefore, there is only one memory range used to store SMM code and data in Haswell, the TSEG memory range.</P>
<P style="MARGIN: 0px 0px 20px">Figure 14 shows the location of the SMM memory in the system address map. The TSEGMB register in the hostbridge controls the TSEG start address. The TSEG memory range always ends at the value of BGSM register. Contents of the TSEG memory range are only accessible in two occasions. The first is when the system has just started and the platform firmware has not initialized the TSEG configuration. The second is when the CPU is running in system management mode. Access to TSEG is controlled by the system management RAM control (<STRONG>SMRAMC</STRONG>) register in the hostbridge.</P>
<P style="MARGIN: 0px 0px 20px">The Haswell hostbridge prevents access not originating in the CPU core to TSEG. This prevents &#8220;rogue&#8221; hardware or firmware code running on add-on device to mess with contents of TSEG. The main reason to do this is because the security of the system is compromised if a device other than the CPU is given access to TSEG. At this point, everything regarding SMM memory in a typical Haswell-based system should be clear.</P>
<H3 style="LINE-HEIGHT: 24px !important; FONT-FAMILY: 'Antic Slab', Arial, Helvetica, sans-serif !important; COLOR: rgb(51,51,51) !important; FONT-SIZE: 16px !important; FONT-WEIGHT: normal">Graphics Address Remapping/Relocation Table (GART) on Haswell Platform</H3>
<P style="MARGIN: 0px 0px 20px">In this section we are going to delve into GART. In the first article, I talked about GART in a legacy system, i.e. AGP GART. This section talks about present-day GART, i.e., GART in a PCIe-based system. Microsoft outlines requirements for GART implementation in a PCIe-based system&#8212;PCIe GART for short. You can read the requirements at<A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://msdn.microsoft.com/en-us/library/windows/hardware/gg463285.aspx">http://msdn.microsoft.com/en-us/library/windows/hardware/gg463285.aspx</A>. This is the relevant excerpt:</P>
<P style="MARGIN: 0px 0px 20px 21pt">By definition, AGP requires a chipset with a graphics address relocation table (GART), which provides a linear view of nonlinear system memory to the graphics device.<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>PCIe, however, requires that the memory linearization hardware exist on the graphics device itself instead of on the chipset</STRONG>. Consequently, driver support for memory linearization in PCIe must exist in the video driver, instead of as an AGP-style separate GART miniport driver. Graphics hardware vendors who want to use nonlocal video memory in their Windows XP driver model (XPDM) drivers must implement both memory linearization hardware and the corresponding software. All PCIe graphics adapters that are compatible with the WDDM must support memory linearization in hardware and software.&#8221;</P>
<P style="MARGIN: 0px 0px 20px">It&#8217;s clear from the excerpt above that GART logic must be implemented in the PCIe graphics chip itself, not in the chipset logic. However, in the case of Haswell, there is an integrated PCIe graphics chip&#8212;the IGD&#8212;which is part of the northbridge. This is not a problem, though, as long as the integrated PCIe graphics implements its GART logic, i.e., the GART logic is part of the IGD, not part of other logic in the northbridge. This way the system is compliant with the Microsoft requirement above. Indeed, Haswell implement the GART logic as part of the IGD. We&#8217;ll look closer into it in this section.</P>
<P style="MARGIN: 0px 0px 20px"><SPAN><STRONG>Figure 17. Haswell GART Implementation</STRONG></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><IMG style="BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; DISPLAY: inline; MAX-WIDTH: 100%; BORDER-TOP-STYLE: none; HEIGHT: auto; VERTICAL-ALIGN: top; BORDER-LEFT-STYLE: none" class="lazy " alt="" src="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre17.png" data-original="http://resources.infosecinstitute.com/wp-content/uploads/010814_1515_SystemAddre17.png"></P>
<P style="MARGIN: 0px 0px 20px">Figure 17 shows the inner working of the GART logic in the IGD, which is located inside the northbridge/hostbridge. Figure 17 shows that the GART logic maps three memory blocks in the graphics aperture&#8212;located in the PCI/PCIe memory range&#8212;to three different memory blocks in the main memory (system DRAM).</P>
<P style="MARGIN: 0px 0px 20px">I&#8217;d like to point out the meaning of the abbreviations and component naming related to GART shown in Figure 17, before we get into details of the GART logic. These are the details:</P>
<OL>
<LI>IGD or internal graphics device is the integrated graphics chip of the Haswell platform. This chip is integrated in to the CPU silicon die. This chip contains the GART logic. 
<LI>GTTADR is the graphics translation table base register. This register contains the start address of the graphics translation table, i.e., the start of the GART entries in the CPU memory space. Figure 17 shows the GART entries reside in the GTTADR range (marked in light green). The GTTADR range is a memory-mapped IO range because the contents of the range reside in a PCIe device, the IGD device. This memory range is not located in system memory but in the IGD. You can think of it as a buffer (memory) containing GART entries but residing in the IGD. This is different from GART entries in a legacy AGP system, where the GART entries reside in system memory. 
<LI>GMADR is the graphics memory aperture base register. This register is part of the GART logic. Contents of this register contain the start address of the graphics aperture in the CPU memory space. Figure 17 shows that GMADR points to start of Block #1, which is the first block of the graphics aperture range. 
<LI>TLBs are the translation look-aside buffers used to handle graphics memory transactions. They are part of the GART logic in the IGD. These TLBs are similar to TLBs you would find in the CPU&#8217;s memory management unit (MMU). 
<LI>PTEs means page table entries. I use this term to highlight the fact that the GART entries are basically similar to PTEs in the CPU but these are used specifically for graphics. 
<LI>DSM is the graphics data stolen memory. This is the memory range used by the IGD as graphics memory. If you look at Figure 14, this range is part of the PCI/PCIe memory range despite it resides in the system DRAM. It resides in system DRAM because it&#8217;s below TOLUD. This memory range is only accessible to the IGD at runtime. Therefore, it behaves just like external PCIe graphics card local memory. 
<LI>GSM is the graphics translation table (GTT) stolen memory.<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>This memory range is completely different from the range covered by GTTADR</EM>. This memory range contains GTT entries for IGD internal use only. GTT entries in this memory range are not the same as GTT entries for GART. You have to pay attention to this difference. 
<LI>TOLUD is the top of low usable DRAM register. This register contains the highest address below 4GB that&#8217;s used by the system DRAM. 
<LI>TSEGMB is the TSEG memory base register. This register contains the start address of TSEG. 
<LI>Graphics aperture is a memory range in the CPU memory address space which is part of the PCI/PCIe memory space and is used to provide linear address space to additional graphics memory. This is actually very similar to the AGP aperture in legacy AGP-based systems, as explained in the first article. The only difference is the possible location of the graphics aperture. In legacy AGP-based system, the graphics aperture could only be located below 4GB, whereas the graphics aperture in PCIe-based system can lie either below 4GB or above 4GB, as long as it&#8217;s within the PCI/PCIe memory range. 
<LI>Block #1, Block #2, Block #3. These blocks illustrate mapping of adjacent memory blocks from the graphics aperture range to the system DRAM memory range. They illustrate the presence of linear memory space in the graphics aperture range, which is translated by the GART logic into memory blocks allocated by the OS in the system DRAM. If you are still confused about how this mapping works out, read the GART section in the first article.</LI></OL>
<P style="MARGIN: 0px 0px 20px">Figure 17 simplifies a couple of things; among them is the location of the graphics aperture memory range. The graphics aperture pointed to by GMADR can start anywhere in the CPU memory space, either below 4G or above 4GB. However, Figure 17 shows the graphics aperture memory range resides below 4GB. You have to be aware of this.</P>
<P style="MARGIN: 0px 0px 20px">Let&#8217;s summarize the difference between legacy AGP GART and modern-day PCIe GART. The first one is that AGP GART logic was implemented as part of the hostbridge while modern-day GART logic is implemented as part of the PCIe graphics chip. In case the PCIe graphics chip is located in the hostbridge (like in the Haswell case), the GART logic will be part of the hostbridge. The operating system treats AGP GART and PCIe GART differently. AGP GART has its own miniport driver, while the PCIe GART driver is part of the PCIe graphics device driver. The second major difference is in the location of the graphics aperture: In a legacy AGP system, the graphics aperture always resides below 4GB while the modern-day PCIe graphics aperture can lie either below 4GB or above 4GB.</P>
<P style="MARGIN: 0px 0px 20px">At this point you should have a clear understanding of GART on the Haswell platform. Even if this section talks about GART in the IGD PCIe graphics chip, you should be able to understand GART implemented by add-on PCIe graphics card easily because its principle is just the same. The difference is only in the location of the graphics memory/buffer, which is basically very similar from the system address map standpoint.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">Haswell System Address Map Initialization</H2>
<P style="MARGIN: 0px 0px 20px">In this section we&#8217;ll have a look at the Haswell system address map initialization. We&#8217;re not going to dive into the minute detail of the initialization but just sufficiently deep to understand the whole process. There are several steps in the Haswell boot process that are parts of system address map initialization. They are as follows:</P>
<OL>
<LI>Manageability engine (ME) initialization&#8212;ME initialization happens prior to platform firmware code execution. ME initializes the<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>Intel management engine UMA register</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the 8-series PCH to signal to the platform firmware how much space it requires in the system DRAM for use as the ME UMA memory region. 
<LI>Chipset initialization&#8212;In this step, the chipset registers is initialized, including the chipset base address registers (BARs). We are particularly interested in chipset BAR initialization because this initialization affects the system address map. There are two chipsets in the Haswell platform, the northbridge and the southbridge. The northbridge is part of the CPU&#8212;sometimes called the uncore part&#8212;and the southbridge is the 8-series PCH. There are many registers involved in the system address map that are part of the chipset, as you can see from the previous sections. TOLUD, TSEGMB, and TOUUD are just a few of them. However, most of these registers are not initialized before the size of the system DRAM is known. Therefore, most of them are initialized as part of or after main memory initialization. 
<LI>Main memory (RAM) initialization&#8212;In this step, the memory controller initialization happens. The memory controller initialization and RAM initialization happen together as complementary code, because the platform firmware code must figure out the correct parameters supported by both the memory controller and the RAM modules installed on the system and then initialize both of the components into the &#8220;correct&#8221; setup. The memory sizing process is carried out in this step. The memory sizing determines the size of system DRAM. This is mostly carried out by reading contents of the serial presence detect (SPD) chip in the DRAM module. However, most platform firmware also executes random read/write operations to the DRAM to determine whether the claimed size in the SPD is indeed usable. As for the algorithm of the random read/write, it depends on the particular platform firmware. Initialization of the BARs in the chipset such as MESEG_BASE, TOLUD, TOUUD, TSEGMB, etc. is also carried in this step after the actual size of the system DRAM is known. 
<LI>
<DIV>PCI/PCIe device discovery and initialization&#8212;In this step, PCI devices&#8212;by extension the PCIe devices and other devices connected to PCI-compatible bus&#8212;are detected and initialized. The devices detected in this step could be part of the chipset and/or other PCI devices in the system, either soldered to the motherboard or on the PCI/PCIe expansion slots. There are several resources assignments to the device happening in this step: IO space assignment, memory-mapped IO (MMIO) space assignment, IRQ assignment (for devices that requires IRQ), and expansion ROM detection and execution. The assignment of memory or IO address space happens via the use of BAR in the PCI/PCIe devices. Initialization of USB devices happens in this step as well because USB is a PCI bus-compatible protocol. Other non-legacy devices are also initialized in this step, such as SATA, SPI, etc. The PCIe GART logic registers initialization also happens in this step because all of them point to memory ranges in the PCI/PCIe memory range. This step above actually consists of two sub-steps:</DIV>
<OL>
<LI>Initialization of the critical PCI configuration space registers in all of the PCI and PCIe devices via the legacy PCI configuration mechanism that uses CPU IO port. This step is required because only the CPU IO port used for the initialization is hardcoded; thus, it can be used right away. This step also includes the step to initialize the<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>PCIEXBAR</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the hostbridge. The PCIe enhanced configuration space registers cannot be accessed before this register is initialized via legacy PCI configuration mechanism. 
<LI>Initialization of the PCIe enhanced configuration space registers&#8212;Once PCIEXBAR is initialized and the PCIe devices identified, the platform firmware can initialize all of the PCIe configuration registers, including the PCIe enhanced configuration space registers.</LI></OL></LI></OL>
<P style="MARGIN: 0px 0px 20px">Once all of the registers in the hostbridge, the 8-series PCH, and all PCI and PCIe devices are initialized, the system address map is formed. The code in the Haswell platform firmware that carries out this initialization must be complicated because, as you have seen in the &#8220;Haswell System Address Map&#8221; section, the system address map is complicated. However, at this point you should have a clear understanding of a modern-day PCIe-based system from system address map point of view, including initialization of the system address map&#8212;carried out by the platform firmware.</P>
<DIV style="BORDER-BOTTOM: 1px solid; BORDER-LEFT: 1px solid; BACKGROUND-COLOR: rgb(206,236,245); MARGIN: 20px 0px 25px; PADDING-LEFT: 25px; PADDING-RIGHT: 25px; FONT-SIZE: medium; BORDER-TOP: 1px solid; BORDER-RIGHT: 1px solid"><STRONG>Want to learn more??<SPAN class=Apple-converted-space>&nbsp;</SPAN></STRONG>The InfoSec Institute<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://www.infosecinstitute.com/find_out_pricing_re.html">Reverse Engineering course<SPAN class=Apple-converted-space>&nbsp;</SPAN></A>teaches you everything from reverse engineering malware to discovering vulnerabilities in binaries. These skills are required in order to properly secure an organization from today's ever evolving threats.<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>In this 5 day hands-on course, you will gain the necessary binary analysis skills to discover the true nature of any Windows binary.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>You will learn how to recognize the high level language constructs (such as branching statements, looping functions and network socket code) critical to performing a thorough and professional reverse engineering analysis of a binary. Some features of this course include:<BR><BR>
<UL style="FONT-SIZE: medium">
<LI style="FONT-SIZE: medium"><B><A style="COLOR: rgb(51,51,51) !important; TEXT-DECORATION: none" href="http://www.iacertification.org/crea_certified_reverse_engineering_analyst.html">CREA</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Certification</B> 
<LI style="FONT-SIZE: medium">5 days of Intensive<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>Hands-On Labs</B> 
<LI style="FONT-SIZE: medium">Hostile Code &amp; Malware analysis, including: Worms, Viruses, Trojans, Rootkits and Bots 
<LI style="FONT-SIZE: medium">Binary obfuscation schemes, used by: Hackers, Trojan writers and copy protection algorithms 
<LI style="FONT-SIZE: medium">Learn the methodologies, tools, and manual reversing techniques used real world situations in our reversing lab.</LI></UL>
<CENTER>
<DIV style="PADDING-BOTTOM: 14px; PADDING-LEFT: 10px; PADDING-RIGHT: 0px; PADDING-TOP: 0px" class=btn><A style="TEXT-ALIGN: center; PADDING-BOTTOM: 0px; PADDING-LEFT: 0px; WIDTH: 240px; PADDING-RIGHT: 0px; DISPLAY: block; BACKGROUND: url(http://www.infosecinstitute.com/images/btn_green.png) no-repeat; HEIGHT: 33px; COLOR: rgb(255,255,255); FONT-SIZE: 17px; FONT-WEIGHT: bold; TEXT-DECORATION: none; PADDING-TOP: 10px; text-shadow: rgb(33, 77, 30) 1px 1px 1px" href="http://www.infosecinstitute.com/find_out_pricing_re.html">VIEW RCE COURSE</A></DIV></CENTER></DIV>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">Deeper Look into UEFI GetMemoryMap() Interface</H2>
<P style="MARGIN: 0px 0px 20px">In the first part of this series, you learned about the BIOS E820h interface. In this article I would only reiterate the UEFI equivalent of that function, the UEFI<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">GetMemoryMap()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. This function is available as part of the UEFI boot services. Therefore, you need to traverse into the UEFI boot services table to &#8220;call&#8221; the function. The &#8220;simplified&#8221; algorithm to call this function as follows:</P>
<OL style="MARGIN-LEFT: 38pt">
<LI>Locate the EFI system table. 
<LI>Traverse to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">EFI_BOOTSERVICES_TABLE</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the EFI system table. 
<LI>Traverse the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">EFI_BOOTSERVICES_TABLE</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to locate the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">GetMemoryMap()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. 
<LI>Call the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">GetMemoryMap()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function.</LI></OL>
<P style="MARGIN: 0px 0px 20px">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">GetMemoryMap()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function returns a similar data structure to the one returned by the legacy E820h interface. The data structure is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">EFI_MEMORY_DESCRIPTOR</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">EFI_MEMORY_DESCRIPTOR</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as follows:</P>
<P style="MARGIN: 0px 0px 20px; BACKGROUND: rgb(238,236,225)"><SPAN style="FONT-FAMILY: Consolas; FONT-SIZE: 8pt">//*******************************************************<BR>//EFI_MEMORY_DESCRIPTOR<BR>//*******************************************************<BR>typedef struct {<BR>UINT32 Type;<BR>EFI_PHYSICAL_ADDRESS PhysicalStart;<BR>EFI_VIRTUAL_ADDRESS VirtualStart;<BR>UINT64 NumberOfPages;<BR>UINT64 Attribute;<BR>} EFI_MEMORY_DESCRIPTOR;<BR></SPAN></P>
<P style="MARGIN: 0px 0px 20px"><SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 'Courier New'">GetMemoryMap()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN>function returns a copy of the current memory map. The map is an array of memory descriptors, each of which describes a contiguous block of memory. The map describes all of memory, no matter how it is being used. The memory map is only used to describe memory that is present in the system. Memory descriptors are never used to describe holes in the system memory map.</SPAN></P>
<P style="MARGIN: 0px 0px 20px">Well, this article doesn&#8217;t try to delve deeper into UEFI<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">GetMemoryMap()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>interface. You can read details of the interface and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-FAMILY: 'Courier New'">EFI_MEMORY_DESCRIPTOR</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the UEFI specification. Should you be interested in digging deeper, the<SPAN style="FONT-FAMILY: 'Courier New'">GetMemoryMap()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function is located in the &#8220;Boot Services&#8221; chapter of the UEFI specification, under the &#8220;Memory Allocation Services&#8221; section.</P>
<H2 style="PADDING-BOTTOM: 0px; MARGIN: 0px 0px 25px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 36px 'Antic Slab', Arial, Helvetica, sans-serif; COLOR: rgb(51,51,51); PADDING-TOP: 0px">Closing Thoughts</H2>
<P style="MARGIN: 0px 0px 20px">This article delves quite deeply into the Haswell system address map and its initialization. It should give strong background knowledge for those looking to understand present-day systems, which could be even more complex than the one explained here. If there is anything really intriguing regarding the Haswell platform, it&#8217;s the manageability engine (ME). This part of the system deserves its own scrutiny and further research. I&#8217;m aware of at least one proof-of-concept work in this particular field, but it was not on Haswell.</P></DIV>