<H1 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; TEXT-TRANSFORM: none; TEXT-INDENT: 0px; MARGIN: 0px 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 1.8em/1.3 'Linux Libertine', Georgia, Times, serif; WHITE-SPACE: normal; BACKGROUND: none transparent scroll repeat 0% 0%; LETTER-SPACING: normal; COLOR: black; OVERFLOW: hidden; WORD-SPACING: 0px; PADDING-TOP: 0px; -webkit-text-stroke-width: 0px" id=firstHeading lang=en class=firstHeading><SPAN dir=auto>X86 Assembly/Bootloaders</SPAN></H1>
<DIV style="POSITION: relative; TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: 0.87em/1.6 sans-serif; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(37,37,37); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" id=bodyContent class=mw-body-content>
<DIV style="LINE-HEIGHT: 1.2em; MARGIN: 0px 0px 1.4em 1em; WIDTH: auto; COLOR: rgb(84,84,84); FONT-SIZE: 12px" id=contentSub><SPAN style="DISPLAY: block" class=subpages>&lt;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="X86 Assembly" href="http://en.wikibooks.org/wiki/X86_Assembly">X86 Assembly</A></SPAN></DIV>
<DIV style="MARGIN-TOP: -1.4em; ZOOM: 1; MARGIN-BOTTOM: 1.4em; HEIGHT: 0px; OVERFLOW: hidden; -webkit-user-select: none" id=jump-to-nav class=mw-jump><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#mw-navigation"></A><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#p-search"></A></DIV>
<DIV style="DIRECTION: ltr" dir=ltr id=mw-content-text lang=en class=mw-content-ltr>
<CENTER>
<DIV style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; BORDER-LEFT: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 5px; BACKGROUND-COLOR: rgb(249,249,249); MARGIN: 5px; PADDING-LEFT: 5px; WIDTH: 739px; PADDING-RIGHT: 5px; COLOR: rgb(0,0,0); BORDER-TOP: rgb(170,170,170) 1px solid; BORDER-RIGHT: rgb(170,170,170) 1px solid; PADDING-TOP: 5px" class="PrettyTextBox noprint"><BIG><B><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="X86 Assembly" href="http://en.wikibooks.org/wiki/X86_Assembly"><FONT size=4>x86 Assembly</FONT></A></B></BIG></DIV></CENTER>
<TABLE style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; BORDER-LEFT: rgb(30,144,255) 10px solid; PADDING-BOTTOM: 0em; MARGIN: 0px 0px 0px 10px; PADDING-LEFT: 0em; WIDTH: 250px; PADDING-RIGHT: 0em; BACKGROUND: rgb(251,251,251); FLOAT: right; CLEAR: right; FONT-SIZE: 14px; BORDER-TOP: rgb(170,170,170) 1px solid; BORDER-RIGHT: rgb(170,170,170) 1px solid; PADDING-TOP: 0em" class="plainlinks noprint messagebox notice">
<TBODY>
<TR style="VERTICAL-ALIGN: middle">
<TD style="BORDER-BOTTOM: medium none; TEXT-ALIGN: center; BORDER-LEFT: medium none; PADDING-BOTTOM: 0.1em; PADDING-LEFT: 0.1em; WIDTH: 45px; PADDING-RIGHT: 0.1em; VERTICAL-ALIGN: middle; BORDER-TOP: medium none; BORDER-RIGHT: medium none; PADDING-TOP: 0.1em"><FONT size=4><IMG style="BORDER-BOTTOM: 0em; TEXT-ALIGN: center; BORDER-LEFT: 0em; PADDING-BOTTOM: 0em; PADDING-LEFT: 0.5em; PADDING-RIGHT: 0.5em; VERTICAL-ALIGN: middle; BORDER-TOP: 0em; BORDER-RIGHT: 0em; PADDING-TOP: 0em" alt=Wikipedia-logo.png src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/40px-Wikipedia-logo.png" width=40 height=40 srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/60px-Wikipedia-logo.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/80px-Wikipedia-logo.png 2x" data-file-width="200" data-file-height="200"></FONT></TD>
<TD style="BORDER-BOTTOM: medium none; TEXT-ALIGN: left; BORDER-LEFT: medium none; PADDING-BOTTOM: 0.5em; PADDING-LEFT: 0em; PADDING-RIGHT: 0.5em; COLOR: black; VERTICAL-ALIGN: middle; BORDER-TOP: medium none; BORDER-RIGHT: medium none; PADDING-TOP: 0.5em">
<P style="MARGIN: 0.5em 0px"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class=extiw title=w: href="http://en.wikipedia.org/wiki/" target=_blank>Wikipedia</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>has related information at<A style="PADDING-BOTTOM: 0px !important; PADDING-LEFT: 0px !important; PADDING-RIGHT: 0px !important; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none; PADDING-TOP: 0px !important" class="external text" href="http://en.wikipedia.org/wiki/Bootloader" target=_blank><I><B>Bootloader</B></I></A></P></TD></TR></TBODY></TABLE>
<P style="MARGIN: 0.5em 0px">When a computer is turned on, there is some beeping, and some flashing lights, and then a loading screen appears. And then magically, the operating system loads into memory. The question is then raised, how does the operating system load up? What gets the ball rolling? The answer is<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>bootloaders</B>.</P>
<P style="MARGIN: 0.5em 0px"></P>
<DIV style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; BORDER-LEFT: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 7px; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 7px; PADDING-RIGHT: 7px; ZOOM: 1; DISPLAY: table; FONT-SIZE: 13px; BORDER-TOP: rgb(170,170,170) 1px solid; BORDER-RIGHT: rgb(170,170,170) 1px solid; PADDING-TOP: 7px" id=toc class=toc>
<DIV style="TEXT-ALIGN: center; DIRECTION: ltr" id=toctitle>
<H2 style="BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; DISPLAY: inline; FONT-FAMILY: sans-serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 13px; OVERFLOW: hidden; BORDER-TOP: medium none; FONT-WEIGHT: bold; BORDER-RIGHT: medium none; PADDING-TOP: 0px">Contents</H2><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 13px; -webkit-user-select: none" class=toctoggle>&nbsp;[<A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" id=togglelink href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#">hide</A>]&nbsp;</SPAN></DIV>
<UL style="TEXT-ALIGN: left; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.5em; LIST-STYLE-TYPE: none; MARGIN: 0.3em 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; LIST-STYLE-IMAGE: none; PADDING-TOP: 0px">
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-1"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#What_is_a_Bootloader.3F"><SPAN class=tocnumber>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>What is a Bootloader?</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-2"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#The_Bootsector"><SPAN class=tocnumber>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>The Bootsector</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-3"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#The_Boot_Process"><SPAN class=tocnumber>3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>The Boot Process</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-4"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#Technical_Details"><SPAN class=tocnumber>4</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>Technical Details</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-5"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#Hard_disks"><SPAN class=tocnumber>5</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>Hard disks</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-6"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#GNU_GRUB"><SPAN class=tocnumber>6</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>GNU GRUB</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-7"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#Example_of_a_Boot_Loader_.E2.80.92_Linux_Kernel_v0.01"><SPAN class=tocnumber>7</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>Example of a Boot Loader &#8210; Linux Kernel v0.01</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-8"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#Testing_the_Bootloader"><SPAN class=tocnumber>8</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>Testing the Bootloader</SPAN></A> 
<LI style="MARGIN-BOTTOM: 0.1em" class="toclevel-1 tocsection-9"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#Further_Reading"><SPAN class=tocnumber>9</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=toctext>Further Reading</SPAN></A></LI></UL></DIV>
<P style="MARGIN: 0.5em 0px"></P>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=What_is_a_Bootloader.3F class=mw-headline>What is a Bootloader?</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: What is a Bootloader?" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=1">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<P style="MARGIN: 0.5em 0px">Bootloaders are small pieces of software that play a role in getting an operating system loaded and ready for execution when a computer is turned on. The way this happens varies between different computer designs (early computers required a person to manually set the computer up whenever it was turned on), and often there are several stages in the process of boot loading.</P>
<P style="MARGIN: 0.5em 0px">It's crucial to understand that the term "bootloader" is simply a classification of software (and sometimes a blurry one). To the processor, a bootloader is just another piece of code that it blindly executes. There are many different kinds of boot loaders. Some are small, others are large; some follow very simple rules while others show fancy screens and give the user a selection to choose from.</P>
<P style="MARGIN: 0.5em 0px">On IBM PC compatibles, the first program to load is the Basic Input/Output System (BIOS). The BIOS performs many tests and initialisations, and if everything is OK, the BIOS's boot loader begins. Its purpose is to load another boot loader! It selects a disk (or some other storage media) from which it loads a secondary boot loader.</P>
<P style="MARGIN: 0.5em 0px">In some cases,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>this</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>boot loader loads enough of an operating system to start running it. In other cases, it loads yet another boot loader from somewhere else. This often happens when multiple operating systems are installed on a single computer; each OS may have its own specific bootloader, with a "central" bootloader that loads one of the specific ones according to the user's selection.</P>
<P style="MARGIN: 0.5em 0px">Most bootloaders are written exclusively in assembly language (or even machine code), because they need to be compact, they don't have access to OS routines (such as memory allocation) that other languages might require, they need to follow some unusual requirements, and they make frequent use of low-level features. However some bootloaders, particularly those that have many features and allow user input, are quite heavyweight. These are often written in a combination of assembly and C. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="PADDING-RIGHT: 13px; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class="external text" href="http://www.gnu.org/software/grub/" rel=nofollow target=_blank>GRand Unified Bootloader</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(GRUB) is an example of such.</P>
<P style="MARGIN: 0.5em 0px">Some boot loaders are highly OS-specific, while others are less so - certainly the BIOS boot loader is not OS-specific. The MS-DOS boot loader (which was placed on<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>all</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>MS-DOS formatted floppy disks) simply checks if the files<B>IO.SYS</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>MSDOS.SYS</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>exist; if they are not present it displays the error "Non-System disk or disk error" otherwise it loads and begins execution of<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>IO.SYS</B>.</P>
<P style="MARGIN: 0.5em 0px">The final stage boot loader may be expected (by the OS) to prepare the computer in some way, for instance by placing the processor in protected mode and programming the interrupt controller. While it would be possible to do these things inside the OS's initialisation procedure, moving them into the bootloader can simplify the OS design. Some operating systems require their bootloader to set up a small, basic GDT (<A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="X86 Assembly/Global Descriptor Table" href="http://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table">Global Descriptor Table</A>) and enter protected mode, in order to remove the need for the OS to have any 16-bit code. However, the OS might replace this with its own sophisticated GDT soon after.</P>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=The_Bootsector class=mw-headline>The Bootsector</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: The Bootsector" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=2">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<P style="MARGIN: 0.5em 0px">The first 512 bytes of a disk are known as the<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>bootsector</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>Master Boot Record</B>. The boot sector is an area of the disk reserved for booting purposes. If the bootsector of a disk contains a valid boot sector (the last word of the sector must contain the signature 0xAA55), then the disk is treated by the BIOS as bootable.</P>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=The_Boot_Process class=mw-headline>The Boot Process</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: The Boot Process" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=3">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<P style="MARGIN: 0.5em 0px">When switched on or reset, an x86 processor begins executing the instructions it finds at address FFFF:0000 (at this stage it is operating in<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>Real Mode</B>). In IBM PC compatible processors, this address is mapped to a ROM chip that contains the computer's Basic Input/Output System (BIOS) code. The BIOS is responsible for many tests and initialisations; for instance the BIOS may perform a memory test, initialise the interrupt controller and system timer, and test that these devices are working.</P>
<P style="MARGIN: 0.5em 0px">Eventually the actual boot loading begins. First the BIOS searches for and initialises available storage media (such as floppy drives, hard disks, CD drives), then it decides which of these it will attempt to boot from. It checks each device for availability (e.g. ensuring a floppy drive contains a disk), then the 0xAA55 signature, in some predefined order (often the order is configurable using the BIOS setup tool). It loads the first sector of the first bootable device it comes across into RAM, and initiates execution.</P>
<P style="MARGIN: 0.5em 0px">Ideally, this will be another boot loader, and it will continue the job, making a few preparations, then passing control to something else.</P>
<P style="MARGIN: 0.5em 0px">While BIOSes remain compatible with 20-year-old software, they have also become more sophisticated over time. Early BIOSes could not boot from CD drives, but now CD and even DVD booting are standard BIOS features. Booting from USB storage devices is also possible, and some systems can boot from over the network. To achieve such advanced functioning, BIOSes sometimes enter protected mode and the like, but then return to real mode in order to be compatible with legacy boot loaders. This creates a chicken-and-egg problem: bootloaders are written to work with the ubiquitous BIOS, and BIOSes are written to support all those bootloaders, preventing much in the way of new boot loading features.</P>
<P style="MARGIN: 0.5em 0px">However, a new bootstrap technology, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class=extiw title="w:Extensible Firmware Interface" href="http://en.wikipedia.org/wiki/Extensible_Firmware_Interface" target=_blank>EFI</A>, is beginning to gain momentum. It is much more sophisticated and will not be discussed in this article.</P>
<P style="MARGIN: 0.5em 0px">Note also that other computer systems - even some that use x86 processors - may boot in different ways. Indeed, some embedded systems whose software is compact enough to be stored on ROM chips may not need bootloaders at all.</P>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=Technical_Details class=mw-headline>Technical Details</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: Technical Details" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=4">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<P style="MARGIN: 0.5em 0px">A bootloader runs under certain conditions that the programmer must appreciate in order to make a successful bootloader. The following pertains to bootloaders initiated by the PC BIOS:</P>
<OL style="PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.5em; MARGIN: 0.3em 0px 0px 3.2em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; LIST-STYLE-IMAGE: none; PADDING-TOP: 0px">
<LI style="MARGIN-BOTTOM: 0.1em">The first sector of a drive contains its boot loader. 
<LI style="MARGIN-BOTTOM: 0.1em">One sector is 512 bytes &#8212; the last two bytes of which<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>must</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>be 0xAA55 (i.e. 0x55 followed by 0xAA), or else the BIOS will treat the drive as unbootable. 
<LI style="MARGIN-BOTTOM: 0.1em">If everything is in order, said first sector will be placed at RAM address 0000:7C00, and the BIOS's role is over as it transfers control to 0000:7C00 (that is, it JMPs to that address). 
<LI style="MARGIN-BOTTOM: 0.1em">The DL register will contain the drive number that is being booted from, useful if you want to read more data from elsewhere on the drive. 
<LI style="MARGIN-BOTTOM: 0.1em">The BIOS leaves behind a lot of code, both to handle hardware interrupts (such as a keypress) and to provide services to the bootloader and OS (such as keyboard input, disk read, and writing to the screen). You must understand the purpose of the Interrupt Vector Table (IVT), and be careful not to interfere with the parts of the BIOS that you depend on. Most operating systems replace the BIOS code with their own code, but the boot loader can't use anything but its own code and what the BIOS provides. Useful BIOS serve include<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE style="BORDER-BOTTOM: rgb(221,221,221) 1px solid; BORDER-LEFT: rgb(221,221,221) 1px solid; PADDING-BOTTOM: 1px; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 4px; PADDING-RIGHT: 4px; FONT-FAMILY: monospace, Courier; COLOR: black; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: rgb(221,221,221) 1px solid; PADDING-TOP: 1px; border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px">int 10h</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(for displaying text/graphics),<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE style="BORDER-BOTTOM: rgb(221,221,221) 1px solid; BORDER-LEFT: rgb(221,221,221) 1px solid; PADDING-BOTTOM: 1px; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 4px; PADDING-RIGHT: 4px; FONT-FAMILY: monospace, Courier; COLOR: black; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: rgb(221,221,221) 1px solid; PADDING-TOP: 1px; border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px">int 13h</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(disk functions) and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE style="BORDER-BOTTOM: rgb(221,221,221) 1px solid; BORDER-LEFT: rgb(221,221,221) 1px solid; PADDING-BOTTOM: 1px; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 4px; PADDING-RIGHT: 4px; FONT-FAMILY: monospace, Courier; COLOR: black; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: rgb(221,221,221) 1px solid; PADDING-TOP: 1px; border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px">int 16h</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(keyboard input). 
<LI style="MARGIN-BOTTOM: 0.1em">This means that any code or data that the boot loader needs must either be included in the first sector (be careful not to accidentally execute data) or manually loaded from another sector of the disk to somewhere in RAM. Because the OS is not running yet, most of the RAM will be unused. However, you must take care not to interfere with the RAM that is required by the BIOS interrupt handlers and services mentioned above. 
<LI style="MARGIN-BOTTOM: 0.1em">The OS code itself (or the next bootloader) will need to be loaded into RAM as well. 
<LI style="MARGIN-BOTTOM: 0.1em">The BIOS places the stack pointer 512 bytes beyond the end of the boot sector, meaning that the stack cannot exceed 512 bytes. It may be necessary to move the stack to a larger area. 
<LI style="MARGIN-BOTTOM: 0.1em">There are some conventions that need to be respected if the disk is to be readable under mainstream operating systems. For instance you may wish to include a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class=extiw title="w:BIOS Parameter Block" href="http://en.wikipedia.org/wiki/BIOS_Parameter_Block" target=_blank>BIOS Parameter Block</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a floppy disk to render the disk readable under most PC operating systems.</LI></OL>
<P style="MARGIN: 0.5em 0px">Most assemblers will have a command or directive similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE style="BORDER-BOTTOM: rgb(221,221,221) 1px solid; BORDER-LEFT: rgb(221,221,221) 1px solid; PADDING-BOTTOM: 1px; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 4px; PADDING-RIGHT: 4px; FONT-FAMILY: monospace, Courier; COLOR: black; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: rgb(221,221,221) 1px solid; PADDING-TOP: 1px; border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px">ORG 7C00h</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that informs the assembler that the code will be loaded starting at offset 7C00h. The assembler will take this into account when calculating instruction and data addresses. If you leave this out, the assembler assumes the code is loaded at address 0 and this must be compensated for manually in the code.</P>
<P style="MARGIN: 0.5em 0px">Usually, the bootloader will load the kernel into memory, and then jump to the kernel. The kernel will then be able to reclaim the memory used by the bootloader (because it has already performed its job). However it is possible to include OS code within the boot sector and keep it resident after the OS begins.</P>
<P style="MARGIN: 0.5em 0px">Here is a simple bootloader demo designed for NASM:</P>
<DIV style="BORDER-BOTTOM: rgb(47,111,171) 1px dashed; BORDER-LEFT: rgb(47,111,171) 1px dashed; PADDING-BOTTOM: 1em; LINE-HEIGHT: 1.1em; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 1em; PADDING-RIGHT: 1em; FONT-FAMILY: monospace, Courier; DIRECTION: ltr; COLOR: black; BORDER-TOP: rgb(47,111,171) 1px dashed; BORDER-RIGHT: rgb(47,111,171) 1px dashed; PADDING-TOP: 1em" dir=ltr class="mw-geshi mw-code mw-content-ltr">
<DIV style="LINE-HEIGHT: normal; FONT-FAMILY: monospace, monospace" class="asm source-asm"><PRE style="BORDER-BOTTOM: white 0px; BORDER-LEFT: white 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 1em/1.2em monospace, monospace; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; VERTICAL-ALIGN: top; BORDER-TOP: white 0px; BORDER-RIGHT: white 0px; PADDING-TOP: 0px" class=de1>         org <SPAN style="COLOR: rgb(255,0,0)" class=nu0>7C00h</SPAN>
 
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jmp</SPAN> short <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>Start</SPAN> <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Jump over the data (the 'short' keyword makes the jmp instruction smaller)</SPAN>
 
 Msg<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>    <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>db</SPAN> <SPAN style="COLOR: rgb(127,0,127)" class=st0>"Hello World! "</SPAN>
 EndMsg<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
 
 <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>Start</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>  <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>bx</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>000Fh</SPAN>   <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Page 0, colour attribute 15 (white) for the int 10 calls below</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>cx</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>1</SPAN>       <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;We will want to write 1 character</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>xor</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dx</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dx</SPAN>      <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Start at top left corner</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ds</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dx</SPAN>      <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Ensure ds = 0 (to let us load the message)</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>cld</SPAN>             <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Ensure direction flag is cleared (for LODSB)</SPAN>
 
 Print<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>  <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>si</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> Msg     <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Loads the address of the first byte of the message, 7C02h in this case</SPAN>
 
                         <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;PC BIOS Interrupt 10 Subfunction 2 - Set cursor position</SPAN>
                         <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;AH = 2</SPAN>
 Char<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>   <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ah</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>2</SPAN>       <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;BH = page, DH = row, DL = column</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>int</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>10h</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>lodsb</SPAN>           <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Load a byte of the message into AL.</SPAN>
                         <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Remember that DS is 0 and SI holds the</SPAN>
                         <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;offset of one of the bytes of the message.</SPAN>
 
                         <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;PC BIOS Interrupt 10 Subfunction 9 - Write character and colour</SPAN>
                         <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;AH = 9</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ah</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>9</SPAN>       <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;BH = page, AL = character, BL = attribute, CX = character count</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>int</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>10h</SPAN>
 
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>inc</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dl</SPAN>          <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Advance cursor</SPAN>
 
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>cmp</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dl</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>80</SPAN>      <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Wrap around edge of screen if necessary</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jne</SPAN> Skip
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>xor</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dl</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dl</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>inc</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dh</SPAN>
 
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>cmp</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dh</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>25</SPAN>      <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Wrap around bottom of screen if necessary</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jne</SPAN> Skip
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>xor</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dh</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dh</SPAN>
 
 Skip<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>   <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>cmp</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>si</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> EndMsg  <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;If we're not at end of message,</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jne</SPAN> Char        <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;continue loading characters</SPAN>
         <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jmp</SPAN> Print       <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;otherwise restart from the beginning of the message</SPAN>
 
 
 <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>times</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0200h</SPAN> <SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>2</SPAN> <SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN> <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=sy2>$</SPAN> <SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN> <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=sy2>$$</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN>  <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>db</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>    <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Zerofill up to 510 bytes</SPAN>
 
         <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>dw</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0AA55h</SPAN>       <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;Boot Sector signature</SPAN>
 
 <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;OPTIONAL:</SPAN>
 <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;To zerofill up to the size of a standard 1.44MB, 3.5" floppy disk</SPAN>
 <SPAN style="FONT-STYLE: italic; COLOR: rgb(102,102,102)" class=co1>;times 1474560 - ($ - $$) db 0</SPAN>
</PRE></DIV></DIV>
<P style="MARGIN: 0.5em 0px"><BR>To compile the above file, suppose it is called 'floppy.asm', you can use following command:</P><PRE style="BORDER-BOTTOM: rgb(221,221,221) 1px solid; BORDER-LEFT: rgb(221,221,221) 1px solid; PADDING-BOTTOM: 1em; LINE-HEIGHT: 1.3em; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 1em; PADDING-RIGHT: 1em; FONT-FAMILY: monospace, Courier; COLOR: black; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: rgb(221,221,221) 1px solid; PADDING-TOP: 1em">nasm -f bin -o floppy.img floppy.asm
</PRE>
<P style="MARGIN: 0.5em 0px">While strictly speaking this is not a bootloader, it is bootable, and demonstrates several things:</P>
<UL style="PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.5em; LIST-STYLE-TYPE: disc; MARGIN: 0.3em 0px 0px 1.6em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; LIST-STYLE-IMAGE: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAANAQMAAABb8jbLAAAABlBMVEX///8AUow5QSOjAAAAAXRSTlMAQObYZgAAABNJREFUCB1jYEABBQw/wLCAgQEAGpIDyT0IVcsAAAAASUVORK5CYII=); PADDING-TOP: 0px">
<LI style="MARGIN-BOTTOM: 0.1em">How to include and access data in the boot sector 
<LI style="MARGIN-BOTTOM: 0.1em">How to skip over included data (this is required for a BIOS Parameter Block) 
<LI style="MARGIN-BOTTOM: 0.1em">How to place the 0xAA55 signature at the end of the sector (NASM will issue an error if there is too much code to fit in a sector) 
<LI style="MARGIN-BOTTOM: 0.1em">The use of BIOS interrupts</LI></UL>
<P style="MARGIN: 0.5em 0px">On Linux, you can issue a command like</P><PRE style="BORDER-BOTTOM: rgb(221,221,221) 1px solid; BORDER-LEFT: rgb(221,221,221) 1px solid; PADDING-BOTTOM: 1em; LINE-HEIGHT: 1.3em; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 1em; PADDING-RIGHT: 1em; FONT-FAMILY: monospace, Courier; COLOR: black; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: rgb(221,221,221) 1px solid; PADDING-TOP: 1em">cat floppy.img &gt; /dev/fd0
</PRE>
<P style="MARGIN: 0.5em 0px">to write the image to the floppy disk (the image may be smaller than the size of the disk in which case only as much information as is in the image will be written to the disk). Under Windows you can use software such as RAWRITE.</P>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=Hard_disks class=mw-headline>Hard disks</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: Hard disks" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=5">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<TABLE style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; BORDER-LEFT: rgb(30,144,255) 10px solid; PADDING-BOTTOM: 0em; MARGIN: 0px 0px 0px 10px; PADDING-LEFT: 0em; WIDTH: 250px; PADDING-RIGHT: 0em; BACKGROUND: rgb(251,251,251); FLOAT: right; CLEAR: right; FONT-SIZE: 14px; BORDER-TOP: rgb(170,170,170) 1px solid; BORDER-RIGHT: rgb(170,170,170) 1px solid; PADDING-TOP: 0em" class="plainlinks noprint messagebox notice">
<TBODY>
<TR style="VERTICAL-ALIGN: middle">
<TD style="BORDER-BOTTOM: medium none; TEXT-ALIGN: center; BORDER-LEFT: medium none; PADDING-BOTTOM: 0.1em; PADDING-LEFT: 0.1em; WIDTH: 45px; PADDING-RIGHT: 0.1em; VERTICAL-ALIGN: middle; BORDER-TOP: medium none; BORDER-RIGHT: medium none; PADDING-TOP: 0.1em"><IMG style="BORDER-BOTTOM: 0em; TEXT-ALIGN: center; BORDER-LEFT: 0em; PADDING-BOTTOM: 0em; PADDING-LEFT: 0.5em; PADDING-RIGHT: 0.5em; VERTICAL-ALIGN: middle; BORDER-TOP: 0em; BORDER-RIGHT: 0em; PADDING-TOP: 0em" alt=Wikipedia-logo.png src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/40px-Wikipedia-logo.png" width=40 height=40 srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/60px-Wikipedia-logo.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/80px-Wikipedia-logo.png 2x" data-file-width="200" data-file-height="200"></TD>
<TD style="BORDER-BOTTOM: medium none; TEXT-ALIGN: left; BORDER-LEFT: medium none; PADDING-BOTTOM: 0.5em; PADDING-LEFT: 0em; PADDING-RIGHT: 0.5em; COLOR: black; VERTICAL-ALIGN: middle; BORDER-TOP: medium none; BORDER-RIGHT: medium none; PADDING-TOP: 0.5em">
<P style="MARGIN: 0.5em 0px"><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class=extiw title=w: href="http://en.wikipedia.org/wiki/" target=_blank>Wikipedia</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>has related information at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="PADDING-BOTTOM: 0px !important; PADDING-LEFT: 0px !important; PADDING-RIGHT: 0px !important; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none; PADDING-TOP: 0px !important" class="external text" href="http://en.wikipedia.org/wiki/Master_boot_record" target=_blank><I><B>Master boot record</B></I></A></P></TD></TR></TBODY></TABLE>
<P style="MARGIN: 0.5em 0px">Hard disks usually add an extra layer to this process, since they may be partitioned. The first sector of a hard disk is known as the Master Boot Record (MBR). Conventionally, the partition information for a hard disk is included at the end of the MBR, just before the 0xAA55 signature.</P>
<P style="MARGIN: 0.5em 0px">The role of the BIOS is no different to before: to read the first sector of the disk (that is, the MBR) into RAM, and transfer execution to the first byte of this sector. The BIOS is oblivious to partitioning schemes - all it checks for is the presence of the 0xAA55 signature.</P>
<P style="MARGIN: 0.5em 0px">While this means that one can use the MBR in any way one would like (for instance, omit or extend the partition table) this is seldom done. Despite the fact that the partition table design is very old and limited - it is limited to four partitions - virtually all operating systems for IBM PC compatibles assume that the MBR will be formatted like this. Therefore to break with convention is to render your disk inoperable except to operating systems specifically designed to use it.</P>
<P style="MARGIN: 0.5em 0px">In practice, the MBR usually contains a boot loader whose purpose is to load another boot loader - to be found at the start of one of the partitions. This is often a very simple program which finds the first partition marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>Active</I>, loads its first sector into RAM, and commences its execution. Since by convention the new boot loader is also loaded to address 7C00h, the old loader may need to relocate all or part of itself to a different location before doing this. Also, ES:SI is expected to contain the address in RAM of the partition table, and DL the boot drive number. Breaking such conventions may render a bootloader incompatible with other bootloaders.</P>
<P style="MARGIN: 0.5em 0px">However, many boot managers (software that enables the user to select a partition, and sometimes even kernel, to boot from) use custom MBR code which loads the remainder of the boot manager code from somewhere on disk, then provides the user with options on how to continue the bootstrap process. It is also possible for the boot manager to reside within a partition, in which case it must first be loaded by another boot loader.</P>
<P style="MARGIN: 0.5em 0px">Most boot managers support chain loading (that is, starting another boot loader via the usual first-sector-of-partition-to-address-7C00 process) and this is often used for systems such as DOS and Windows. However, some boot managers (notably GRUB) support the loading of a user-selected kernel image. This can be used with systems such as GNU/Linux and Solaris, allowing more flexibility in starting the system. The mechanism may differ somewhat from that of chain loading.</P>
<P style="MARGIN: 0.5em 0px">Clearly, the partition table presents a chicken-and-egg problem that is placing unreasonable limitations on partitioning schemes. One solution gaining momentum is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class=extiw title="w:GUID Partition Table" href="http://en.wikipedia.org/wiki/GUID_Partition_Table" target=_blank>GUID Partition Table</A>; it uses a dummy MBR partition table so that legacy operating systems will not interfere with the GPT, while newer operating systems can take advantage of the many improvements offered by the system.</P>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=GNU_GRUB class=mw-headline>GNU GRUB</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: GNU GRUB" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=6">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<P style="MARGIN: 0.5em 0px">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="PADDING-RIGHT: 13px; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class="external text" href="http://www.gnu.org/software/grub/" rel=nofollow target=_blank>GRand Unified Bootloader</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>supports the flexible<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="PADDING-RIGHT: 13px; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(102,51,102); TEXT-DECORATION: none" class="external text" href="http://www.gnu.org/software/grub/manual/multiboot/html_node/index.html" rel=nofollow target=_blank><I>multiboot</I></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>boot protocol. This protocol aims to simplify the boot process by providing a single, flexible protocol for booting a variety of operating systems. Many free operating systems can be booted using multiboot.</P>
<P style="MARGIN: 0.5em 0px">GRUB is extremely powerful and is practically a small operating system. It can read various file systems and thus lets you specify a kernel image<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>by filename</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well as separate module files that the kernel may make use of. Command-line arguments can be passed to the kernel as well - this is a nice way of starting an OS in maintenance mode, or "safe mode", or with VGA graphics, and so on. GRUB can provide a menu for the user to select from as well as allowing custom loading parameters to be entered.</P>
<P style="MARGIN: 0.5em 0px">Obviously this functionality cannot possibly be provided in 512 bytes of code. This is why GRUB is split into two or three "stages":</P>
<UL style="PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.5em; LIST-STYLE-TYPE: disc; MARGIN: 0.3em 0px 0px 1.6em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; LIST-STYLE-IMAGE: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAANAQMAAABb8jbLAAAABlBMVEX///8AUow5QSOjAAAAAXRSTlMAQObYZgAAABNJREFUCB1jYEABBQw/wLCAgQEAGpIDyT0IVcsAAAAASUVORK5CYII=); PADDING-TOP: 0px">
<LI style="MARGIN-BOTTOM: 0.1em">Stage 1 - this is a 512-byte block that has the location of stage 1.5 or stage 2 hardcoded into it. It loads the next stage. 
<LI style="MARGIN-BOTTOM: 0.1em">Stage 1.5 - an optional stage which understands the filesystem (e.g. FAT32 or ext3) where stage 2 resides. It will find out where stage 2 is located and load it. This stage is quite small and is located in a fixed area, often just after Stage 1. 
<LI style="MARGIN-BOTTOM: 0.1em">Stage 2 - this is a much larger image that has all the GRUB functionality.</LI></UL>
<P style="MARGIN: 0.5em 0px">Note that Stage 1 may be installed to the Master Boot Record of a hard disk, or may be installed in one of the partitions and chainloaded by another boot loader.</P>
<P style="MARGIN: 0.5em 0px">Windows can not be loaded using multiboot, but the Windows bootloader (like those of other non-multiboot operating systems) can be chainloaded from GRUB, which isn't quite as good, but does let you boot such systems.</P>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=Example_of_a_Boot_Loader_.E2.80.92_Linux_Kernel_v0.01 class=mw-headline>Example of a Boot Loader &#8210; Linux Kernel v0.01</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: Example of a Boot Loader &#8210; Linux Kernel v0.01" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=7">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<DIV style="BORDER-BOTTOM: rgb(47,111,171) 1px dashed; BORDER-LEFT: rgb(47,111,171) 1px dashed; PADDING-BOTTOM: 1em; LINE-HEIGHT: 1.1em; BACKGROUND-COLOR: rgb(249,249,249); PADDING-LEFT: 1em; PADDING-RIGHT: 1em; FONT-FAMILY: monospace, Courier; DIRECTION: ltr; COLOR: black; BORDER-TOP: rgb(47,111,171) 1px dashed; BORDER-RIGHT: rgb(47,111,171) 1px dashed; PADDING-TOP: 1em" dir=ltr class="mw-geshi mw-code mw-content-ltr">
<DIV style="LINE-HEIGHT: normal; FONT-FAMILY: monospace, monospace" class="asm source-asm"><PRE style="BORDER-BOTTOM: white 0px; BORDER-LEFT: white 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 1em/1.2em monospace, monospace; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; VERTICAL-ALIGN: top; BORDER-TOP: white 0px; BORDER-RIGHT: white 0px; PADDING-TOP: 0px" class=de1>SYSSIZE=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x8000</SPAN>
|
|	boot<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>s
|
| boot<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>s is loaded <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>at</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x7c00</SPAN> by the bios<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>startup routines<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>and</SPAN> moves itself
| <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN> of the way to address <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x90000</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>and</SPAN> jumps there<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
|
| It then loads the system <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>at</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x10000</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> using BIOS interrupts<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> Thereafter
| it disables all interrupts<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> moves the system down to <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x0000</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> changes
| to protected mode<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>and</SPAN> calls the <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>start</SPAN> of system<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> System then must
| RE<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>initialize the protected mode <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>in</SPAN> it<SPAN style="COLOR: rgb(127,0,127)" class=st0>'s own tables, and enable
| interrupts as needed.
|
| NOTE! currently system is at most 8*65536 bytes long. This should be no
| problem, even in the future. I want to keep it simple. This 512 kB
| kernel size should be enough - in fact more would mean we'</SPAN>d have to move
| <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>not</SPAN> just these <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>start</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>up routines<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> but also <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>do</SPAN> something about the cache<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>
| memory <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN>block IO devices<SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> The area left over <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>in</SPAN> the lower <SPAN style="COLOR: rgb(255,0,0)" class=nu0>640</SPAN> kB is meant
| for these<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> No other memory is assumed to be <SPAN style="COLOR: rgb(127,0,127)" class=st0>"physical"</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> i<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>e<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> all memory
| over 1Mb is demand<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>paging<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> All addresses under 1Mb are guaranteed to match
| their physical addresses<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
|
| NOTE1 above is no longer valid <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>in</SPAN> it<SPAN style="COLOR: rgb(127,0,127)" class=st0>'s entirety. cache-memory is allocated
| above the 1Mb mark as well as below. Otherwise it is mainly correct.
|
| NOTE 2! The boot disk type must be set at compile-time, by setting
| the following equ. Having the boot-up procedure hunt for the right
| disk type is severe brain-damage.
| The loader has been made as simple as possible (had to, to get it
| in 512 bytes with the code to move to protected mode), and continuous
| read errors will result in a unbreakable loop. Reboot by hand. It
| loads pretty fast by getting whole sectors at a time whenever possible.
 
| 1.44Mb disks:
sectors = 18
| 1.2Mb disks:
| sectors = 15
| 720kB disks:
| sectors = 9
 
.globl begtext, begdata, begbss, endtext, enddata, endbss
.text
begtext:
.data
begdata:
.bss
begbss:
.text
 
BOOTSEG = 0x07c0
INITSEG = 0x9000
SYSSEG  = 0x1000			| system loaded at 0x10000 (65536).
ENDSEG	= SYSSEG + SYSSIZE
 
entry start
start:
	mov	ax,#BOOTSEG
	mov	ds,ax
	mov	ax,#INITSEG
	mov	es,ax
	mov	cx,#256
	sub	si,si
	sub	di,di
	rep
	movw
	jmpi	go,INITSEG
go:	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	mov	ss,ax
	mov	sp,#0x400		| arbitrary value &gt;&gt;512
 
	mov	ah,#0x03	| read cursor pos
	xor	bh,bh
	int	0x10
 
	mov	cx,#24
	mov	bx,#0x0007	| page 0, attribute 7 (normal)
	mov	bp,#msg1
	mov	ax,#0x1301	| write string, move cursor
	int	0x10
 
| ok, we'</SPAN>ve written the message<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> now
| we want to load the system <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>at</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x10000</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN>
 
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ax</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#SYSSEG
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>es</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ax</SPAN>		| <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>segment</SPAN> of <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x010000</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>call</SPAN>	read_it
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>call</SPAN>	kill_motor
 
| if the read went well we get current cursor position ans save it for
| posterity<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
 
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ah</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x03</SPAN>	| read cursor pos
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>xor</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>bh</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>bh</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>int</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x10</SPAN>		| save it <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>in</SPAN> known place<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> con_init fetches
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>[</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>510</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>]</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dx</SPAN>	| it from <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x90510</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
 
| now we want to move to protected mode <SPAN style="COLOR: rgb(51,153,51)" class=sy1>...</SPAN>
 
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>cli</SPAN>			| no interrupts allowed !
 
| first we move the system to it<SPAN style="COLOR: rgb(127,0,127)" class=st0>'s rightful place
 
	mov	ax,#0x0000
	cld			| '</SPAN>direction<SPAN style="COLOR: rgb(127,0,127)" class=st0>'=0, movs moves forward
do_move:
	mov	es,ax		| destination segment
	add	ax,#0x1000
	cmp	ax,#0x9000
	jz	end_move
	mov	ds,ax		| source segment
	sub	di,di
	sub	si,si
	mov 	cx,#0x8000
	rep
	movsw
	j	do_move
 
| then we load the segment descriptors
 
end_move:
 
	mov	ax,cs		| right, forgot this at first. didn'</SPAN>t work <SPAN style="COLOR: rgb(51,153,51)" class=sy1>:-</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ds</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ax</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>lidt</SPAN>	idt_48		| load idt with <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>lgdt</SPAN>	gdt_48		| load gdt with whatever appropriate
 
| that was painless<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> now we enable A20
 
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>call</SPAN>	empty_8042
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xD1</SPAN>		| command <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>write</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x64</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>call</SPAN>	empty_8042
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xDF</SPAN>		| A20 on
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x60</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>call</SPAN>	empty_8042
 
| well<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> that went ok<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> I hope<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> Now we have to reprogram the interrupts <SPAN style="COLOR: rgb(51,153,51)" class=sy1>:-</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN>
| we put them right after the intel<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>reserved hardware interrupts<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>at</SPAN>
| <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>int</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x20</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x2F</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> There they won<SPAN style="COLOR: rgb(127,0,127)" class=st0>'t mess up anything. Sadly IBM really
| messed this up with the original PC, and they haven'</SPAN>t been able to
| rectify it afterwards<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> Thus the BIOS puts interrupts <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>at</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x08</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x0f</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>
| which is used for the internal hardware interrupts as well<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> We just
| have to reprogram the <SPAN style="COLOR: rgb(255,0,0)" class=nu0>8259</SPAN><SPAN style="COLOR: rgb(127,0,127)" class=st0>'s, and it isn'</SPAN>t fun<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
 
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x11</SPAN>		| initialization sequence
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x20</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>		| send it to 8259A<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>1</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>		| <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jmp</SPAN> <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=sy2>$</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>+</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>2</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jmp</SPAN> <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=sy2>$</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>+</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>2</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xA0</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>		| <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>and</SPAN> to 8259A<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>2</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x20</SPAN>		| <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>start</SPAN> of hardware <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>int</SPAN><SPAN style="COLOR: rgb(127,0,127)" class=st0>'s (0x20)
	out	#0x21,al
	.word	0x00eb,0x00eb
	mov	al,#0x28		| start of hardware int'</SPAN>s <SPAN style="COLOR: rgb(255,0,0)" class=nu0>2</SPAN> <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x28</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xA1</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x04</SPAN>		| <SPAN style="COLOR: rgb(255,0,0)" class=nu0>8259</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>1</SPAN> is master
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x21</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x02</SPAN>		| <SPAN style="COLOR: rgb(255,0,0)" class=nu0>8259</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>2</SPAN> is slave
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xA1</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x01</SPAN>		| <SPAN style="COLOR: rgb(255,0,0)" class=nu0>8086</SPAN> mode for both
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x21</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xA1</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xFF</SPAN>		| mask off all interrupts for now
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x21</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00eb</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>out</SPAN>	#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0xA1</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN>
 
| well<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> that certainly wasn<SPAN style="COLOR: rgb(127,0,127)" class=st0>'t fun :-(. Hopefully it works, and we don'</SPAN>t
| need no steenking BIOS anyway <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN>except for the initial loading <SPAN style="COLOR: rgb(51,153,51)" class=sy1>:-</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
| The BIOS<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>routine wants lots of unnecessary <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>data</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>and</SPAN> it<SPAN style="COLOR: rgb(127,0,127)" class=st0>'s less
| "interesting" anyway. This is how REAL programmers do it.
|
| Well, now'</SPAN>s the time to actually move <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>into</SPAN> protected mode<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> To make
| things as simple as possible<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> we <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>do</SPAN> no register set<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>up <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>or</SPAN> anything<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>
| we let the gnu<SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>compiled <SPAN style="COLOR: rgb(255,0,0)" class=nu0>32</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>bit programs <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>do</SPAN> that<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN> We just jump to
| <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>absolute</SPAN> address <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00000</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>in</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>32</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN>bit protected mode<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
 
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ax</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x0001</SPAN>	| protected mode <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN>PE<SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN> bit
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>lmsw</SPAN>	<SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>ax</SPAN>		| This is it!
	jmpi	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>8</SPAN>		| <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>jmp</SPAN> offset <SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN> of <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>segment</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>8</SPAN> <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN><SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>cs</SPAN><SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN>
 
| This routine checks that the keyboard command queue is empty
| No timeout is used <SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN> if this hangs there is something wrong with
| the machine<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>and</SPAN> we probably couldn<SPAN style="COLOR: rgb(127,0,127)" class=st0>'t proceed anyway.
empty_8042:
	.word	0x00eb,0x00eb
	in	al,#0x64	| 8042 status port
	test	al,#2		| is input buffer full?
	jnz	empty_8042	| yes - loop
	ret
 
| This routine loads the system at address 0x10000, making sure
| no 64kB boundaries are crossed. We try to load it as fast as
| possible, loading whole tracks whenever we can.
|
| in:	es - starting address segment (normally 0x1000)
|
| This routine has to be recompiled to fit another drive type,
| just change the "sectors" variable at the start of the file
| (originally 18, for a 1.44Mb drive)
|
sread:	.word 1			| sectors read of current track
head:	.word 0			| current head
track:	.word 0			| current track
read_it:
	mov ax,es
	test ax,#0x0fff
die:	jne die			| es must be at 64kB boundary
	xor bx,bx		| bx is starting address within segment
rp_read:
	mov ax,es
	cmp ax,#ENDSEG		| have we loaded all yet?
	jb ok1_read
	ret
ok1_read:
	mov ax,#sectors
	sub ax,sread
	mov cx,ax
	shl cx,#9
	add cx,bx
	jnc ok2_read
	je ok2_read
	xor ax,ax
	sub ax,bx
	shr ax,#9
ok2_read:
	call read_track
	mov cx,ax
	add ax,sread
	cmp ax,#sectors
	jne ok3_read
	mov ax,#1
	sub ax,head
	jne ok4_read
	inc track
ok4_read:
	mov head,ax
	xor ax,ax
ok3_read:
	mov sread,ax
	shl cx,#9
	add bx,cx
	jnc rp_read
	mov ax,es
	add ax,#0x1000
	mov es,ax
	xor bx,bx
	jmp rp_read
 
read_track:
	push ax
	push bx
	push cx
	push dx
	mov dx,track
	mov cx,sread
	inc cx
	mov ch,dl
	mov dx,head
	mov dh,dl
	mov dl,#0
	and dx,#0x0100
	mov ah,#2
	int 0x13
	jc bad_rt
	pop dx
	pop cx
	pop bx
	pop ax
	ret
bad_rt:	mov ax,#0
	mov dx,#0
	int 0x13
	pop dx
	pop cx
	pop bx
	pop ax
	jmp read_track
 
/*
 * This procedure turns off the floppy drive motor, so
 * that we enter the kernel in a known state, and
 * don'</SPAN>t have to worry about it later<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>
 <SPAN style="COLOR: rgb(51,153,51)" class=sy1>*/</SPAN>
kill_motor<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>push</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dx</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dx</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x3f2</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>mov</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>al</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN>#<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>
	outb
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>pop</SPAN> <SPAN style="COLOR: rgb(70,170,3); FONT-WEIGHT: bold" class=kw4>dx</SPAN>
	<SPAN style="COLOR: rgb(0,0,127); FONT-WEIGHT: bold" class=kw1>ret</SPAN>
 
gdt<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>		| dummy
 
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x07FF</SPAN>		| 8Mb <SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN> limit=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>2047</SPAN> <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>2048</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>*</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>4096</SPAN>=8Mb<SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x0000</SPAN>		| base address=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x9A00</SPAN>		| <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>code</SPAN> read<SPAN style="COLOR: rgb(51,153,51)" class=sy1>/</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>exec</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00C0</SPAN>		| granularity=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>4096</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>386</SPAN>
 
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x07FF</SPAN>		| 8Mb <SPAN style="COLOR: rgb(51,153,51)" class=sy1>-</SPAN> limit=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>2047</SPAN> <SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>(</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>2048</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>*</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>4096</SPAN>=8Mb<SPAN style="COLOR: rgb(0,153,0); FONT-WEIGHT: bold" class=br0>)</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x0000</SPAN>		| base address=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x9200</SPAN>		| <SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>data</SPAN> read<SPAN style="COLOR: rgb(51,153,51)" class=sy1>/</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>write</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x00C0</SPAN>		| granularity=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>4096</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>386</SPAN>
 
idt_48<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>			| idt limit=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0</SPAN>			| idt base=0L
 
gdt_48<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	<SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x800</SPAN>		| gdt limit=<SPAN style="COLOR: rgb(255,0,0)" class=nu0>2048</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>256</SPAN> GDT entries
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>word</SPAN>	gdt<SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>0x9</SPAN>		| gdt base = 0X9xxxx
 
msg1<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>byte</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>13</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>10</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN>ascii <SPAN style="COLOR: rgb(127,0,127)" class=st0>"Loading system ..."</SPAN>
	<SPAN style="COLOR: rgb(51,153,51)" class=sy1>.</SPAN><SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw6>byte</SPAN> <SPAN style="COLOR: rgb(255,0,0)" class=nu0>13</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>10</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>13</SPAN><SPAN style="COLOR: rgb(51,153,51)" class=sy1>,</SPAN><SPAN style="COLOR: rgb(255,0,0)" class=nu0>10</SPAN>
 
<SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>.text</SPAN>
endtext<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
<SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>.data</SPAN>
enddata<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
<SPAN style="COLOR: rgb(0,0,255); FONT-WEIGHT: bold" class=kw5>.bss</SPAN>
endbss<SPAN style="COLOR: rgb(51,153,51)" class=sy1>:</SPAN>
</PRE></DIV></DIV>
<H2 style="BORDER-BOTTOM: rgb(170,170,170) 1px solid; PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.3; MARGIN: 1em 0px 0.25em; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: 'Linux Libertine', Georgia, Times, serif; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: black; FONT-SIZE: 1.5em; OVERFLOW: hidden; FONT-WEIGHT: normal; PADDING-TOP: 0px"><SPAN id=Testing_the_Bootloader class=mw-headline>Testing the Bootloader</SPAN><SPAN style="LINE-HEIGHT: 1em; DISPLAY: inline-block; FONT-FAMILY: sans-serif; MARGIN-LEFT: 1em; FONT-SIZE: small; VERTICAL-ALIGN: baseline; FONT-WEIGHT: normal; -webkit-user-select: none" class=mw-editsection><SPAN class=mw-editsection-bracket>[</SPAN><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" title="Edit section: Testing the Bootloader" href="http://en.wikibooks.org/w/index.php?title=X86_Assembly/Bootloaders&amp;action=edit&amp;section=8">edit</A><SPAN class=mw-editsection-bracket>]</SPAN></SPAN></H2>
<P style="MARGIN: 0.5em 0px">Perhaps the easiest way to test a bootloader is inside a virtual machine, like VirtualBox or VMware.<SUP style="LINE-HEIGHT: 1; FONT-STYLE: normal; FONT-WEIGHT: normal" id=cite_ref-1 class=reference><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#cite_note-1">[1]</A></SUP></P>
<P style="MARGIN: 0.5em 0px">Sometimes it is useful if the bootloader supports the GDB remote debug protocol.<SUP style="LINE-HEIGHT: 1; FONT-STYLE: normal; FONT-WEIGHT: normal" id=cite_ref-2 class=reference><A style="BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(11,0,128); TEXT-DECORATION: none" href="http://en.wikibooks.org/wiki/X86_Assembly/Bootloaders#cite_note-2">[2]</A></SUP></P></DIV></DIV>