<FONT class=extract>/*<BR>&nbsp;* Simple, straightforward mutexes with strict semantics:<BR>&nbsp;*<BR>&nbsp;* - only one task can hold the mutex at a time<BR>&nbsp;* - only the owner can unlock the mutex<BR>&nbsp;* - multiple unlocks are not permitted<BR>&nbsp;* - recursive locking is not permitted<BR>&nbsp;* - a mutex object must be initialized via the API<BR>&nbsp;* - a mutex object must not be initialized via memset or copying<BR>&nbsp;* - task may not exit with mutex held<BR>&nbsp;* - memory areas where held locks reside must not be freed<BR>&nbsp;* - held mutexes must not be reinitialized<BR>&nbsp;* - mutexes may not be used in hardware or software interrupt<BR>&nbsp;*&nbsp;&nbsp; contexts such as tasklets and timers<BR>&nbsp;*<BR>&nbsp;* These semantics are fully enforced when DEBUG_MUTEXES is<BR>&nbsp;* enabled. Furthermore, besides enforcing the above rules, the mutex<BR>&nbsp;* debugging code also implements a number of additional features<BR>&nbsp;* that make lock debugging easier and faster:<BR>&nbsp;*<BR>&nbsp;* - uses symbolic names of mutexes, whenever they are printed in debug output<BR>&nbsp;* - point-of-acquire tracking, symbolic lookup of function names<BR>&nbsp;* - list of all locks held in the system, printout of them<BR>&nbsp;* - owner tracking<BR>&nbsp;* - detects self-recursing locks and prints out all relevant info<BR>&nbsp;* - detects multi-task circular deadlocks and prints out all affected<BR>&nbsp;*&nbsp;&nbsp; locks and tasks (and only those tasks)<BR>&nbsp;*/</FONT><BR>struct mutex {<BR><SPAN class=cloze>[...]</SPAN> 
<P></P>
<P><SPAN class=cloze></SPAN>#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)<BR>&nbsp;struct task_struct&nbsp;*owner;<BR>#endif<BR>#ifdef CONFIG_MUTEX_SPIN_ON_OWNER<BR>&nbsp;struct optimistic_spin_queue osq; /* Spinner MCS lock */<BR>#endif<BR>#ifdef CONFIG_DEBUG_MUTEXES<BR>&nbsp;void&nbsp;&nbsp;&nbsp;*magic;<BR>#endif<BR>#ifdef CONFIG_DEBUG_LOCK_ALLOC<BR>&nbsp;struct lockdep_map&nbsp;dep_map;<BR>#endif<BR>};