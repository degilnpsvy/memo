/**<BR>&nbsp;* device_create - creates a device and registers it with sysfs<BR>&nbsp;* @class: pointer to the struct class that this device should be registered to<BR>&nbsp;* @parent: pointer to the parent struct device of this new device, if any<BR>&nbsp;* @devt: the dev_t for the char device to be added<BR>&nbsp;* @drvdata: the data to be added to the device for callbacks<BR>&nbsp;* @fmt: string for the device's name<BR>&nbsp;*<BR>&nbsp;* This function can be used by char device classes.&nbsp; A struct device<BR>&nbsp;* will be created in sysfs, registered to the specified class.<BR>&nbsp;*<BR>&nbsp;* A "dev" file will be created, showing the dev_t for the device, if<BR>&nbsp;* the dev_t is not 0,0.<BR>&nbsp;* If a pointer to a parent struct device is passed in, the newly created<BR>&nbsp;* struct device will be a child of that device in sysfs.<BR>&nbsp;* The pointer to the struct device will be returned from the call.<BR>&nbsp;* Any further sysfs files that might be required can be created using this<BR>&nbsp;* pointer.<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*<BR>&nbsp;* Note: the struct class passed to this function must have previously<BR>&nbsp;* been created with a call to class_create().<BR>&nbsp;*/<BR>struct device *device_create(struct class *class, struct device *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_t devt, void *drvdata, const char *fmt, ...)<BR>{<BR>&nbsp;va_list vargs;<BR>&nbsp;struct device *dev; 
<P></P>
<P>&nbsp;va_start(vargs, fmt);<BR>&nbsp;dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);<BR>&nbsp;va_end(vargs);<BR>&nbsp;return dev;<BR>}<BR>EXPORT_SYMBOL_GPL(device_create);