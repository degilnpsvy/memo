drivers/base/core.c 
<P></P>
<P>/*<BR>&nbsp;* drivers/base/core.c - core driver model code (device registration, etc)<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2002-3 Patrick Mochel<BR>&nbsp;* Copyright (c) 2002-3 Open Source Development Labs<BR>&nbsp;* Copyright (c) 2006 Greg Kroah-Hartman &lt;<A href="mailto:gregkh@suse.de">gregkh@suse.de</A>&gt;<BR>&nbsp;* Copyright (c) 2006 Novell, Inc.<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2<BR>&nbsp;*<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/device.h&gt;<BR>#include &lt;linux/err.h&gt;<BR>#include &lt;linux/fwnode.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/module.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/kdev_t.h&gt;<BR>#include &lt;linux/notifier.h&gt;<BR>#include &lt;linux/of.h&gt;<BR>#include &lt;linux/of_device.h&gt;<BR>#include &lt;linux/genhd.h&gt;<BR>#include &lt;linux/kallsyms.h&gt;<BR>#include &lt;linux/mutex.h&gt;<BR>#include &lt;linux/pm_runtime.h&gt;<BR>#include &lt;linux/netdevice.h&gt;<BR>#include &lt;linux/sysfs.h&gt;</P>
<P>#include "base.h"<BR>#include "power/power.h"</P>
<P>#ifdef CONFIG_SYSFS_DEPRECATED<BR>#ifdef CONFIG_SYSFS_DEPRECATED_V2<BR>long sysfs_deprecated = 1;<BR>#else<BR>long sysfs_deprecated = 0;<BR>#endif<BR>static int __init sysfs_deprecated_setup(char *arg)<BR>{<BR>&nbsp;return kstrtol(arg, 10, &amp;sysfs_deprecated);<BR>}<BR>early_param("sysfs.deprecated", sysfs_deprecated_setup);<BR>#endif</P>
<P>int (*platform_notify)(struct device *dev) = NULL;<BR>int (*platform_notify_remove)(struct device *dev) = NULL;<BR>static struct kobject *dev_kobj;<BR>struct kobject *sysfs_dev_char_kobj;<BR>struct kobject *sysfs_dev_block_kobj;</P>
<P>static DEFINE_MUTEX(device_hotplug_lock);</P>
<P>void lock_device_hotplug(void)<BR>{<BR>&nbsp;mutex_lock(&amp;device_hotplug_lock);<BR>}</P>
<P>void unlock_device_hotplug(void)<BR>{<BR>&nbsp;mutex_unlock(&amp;device_hotplug_lock);<BR>}</P>
<P>int lock_device_hotplug_sysfs(void)<BR>{<BR>&nbsp;if (mutex_trylock(&amp;device_hotplug_lock))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;/* Avoid busy looping (5 ms of sleep should do). */<BR>&nbsp;msleep(5);<BR>&nbsp;return restart_syscall();<BR>}</P>
<P>#ifdef CONFIG_BLOCK<BR>static inline int device_is_not_partition(struct device *dev)<BR>{<BR>&nbsp;return !(dev-&gt;type == &amp;part_type);<BR>}<BR>#else<BR>static inline int device_is_not_partition(struct device *dev)<BR>{<BR>&nbsp;return 1;<BR>}<BR>#endif</P>
<P>/**<BR>&nbsp;* dev_driver_string - Return a device's driver name, if at all possible<BR>&nbsp;* @dev: struct device to get the name of<BR>&nbsp;*<BR>&nbsp;* Will return the device's driver's name if it is bound to a device.&nbsp; If<BR>&nbsp;* the device is not bound to a driver, it will return the name of the bus<BR>&nbsp;* it is attached to.&nbsp; If it is not attached to a bus either, an empty<BR>&nbsp;* string will be returned.<BR>&nbsp;*/<BR>const char *dev_driver_string(const struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv;</P>
<P>&nbsp;/* dev-&gt;driver can change to NULL underneath us because of unbinding,<BR>&nbsp; * so be careful about accessing it.&nbsp; dev-&gt;bus and dev-&gt;class should<BR>&nbsp; * never change once they are set, so they don't need special care.<BR>&nbsp; */<BR>&nbsp;drv = ACCESS_ONCE(dev-&gt;driver);<BR>&nbsp;return drv ? drv-&gt;name :<BR>&nbsp;&nbsp;&nbsp;(dev-&gt;bus ? dev-&gt;bus-&gt;name :<BR>&nbsp;&nbsp;&nbsp;(dev-&gt;class ? dev-&gt;class-&gt;name : ""));<BR>}<BR>EXPORT_SYMBOL(dev_driver_string);</P>
<P>#define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)</P>
<P>static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct device_attribute *dev_attr = to_dev_attr(attr);<BR>&nbsp;struct device *dev = kobj_to_dev(kobj);<BR>&nbsp;ssize_t ret = -EIO;</P>
<P>&nbsp;if (dev_attr-&gt;show)<BR>&nbsp;&nbsp;ret = dev_attr-&gt;show(dev, dev_attr, buf);<BR>&nbsp;if (ret &gt;= (ssize_t)PAGE_SIZE) {<BR>&nbsp;&nbsp;print_symbol("dev_attr_show: %s returned bad count\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;(unsigned long)dev_attr-&gt;show);<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}</P>
<P>static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct device_attribute *dev_attr = to_dev_attr(attr);<BR>&nbsp;struct device *dev = kobj_to_dev(kobj);<BR>&nbsp;ssize_t ret = -EIO;</P>
<P>&nbsp;if (dev_attr-&gt;store)<BR>&nbsp;&nbsp;ret = dev_attr-&gt;store(dev, dev_attr, buf, count);<BR>&nbsp;return ret;<BR>}</P>
<P>static const struct sysfs_ops dev_sysfs_ops = {<BR>&nbsp;.show&nbsp;= dev_attr_show,<BR>&nbsp;.store&nbsp;= dev_attr_store,<BR>};</P>
<P>#define to_ext_attr(x) container_of(x, struct dev_ext_attribute, attr)</P>
<P>ssize_t device_store_ulong(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t size)<BR>{<BR>&nbsp;struct dev_ext_attribute *ea = to_ext_attr(attr);<BR>&nbsp;char *end;<BR>&nbsp;unsigned long new = simple_strtoul(buf, &amp;end, 0);<BR>&nbsp;if (end == buf)<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;*(unsigned long *)(ea-&gt;var) = new;<BR>&nbsp;/* Always return full write size even if we didn't consume all */<BR>&nbsp;return size;<BR>}<BR>EXPORT_SYMBOL_GPL(device_store_ulong);</P>
<P>ssize_t device_show_ulong(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct dev_ext_attribute *ea = to_ext_attr(attr);<BR>&nbsp;return snprintf(buf, PAGE_SIZE, "%lx\n", *(unsigned long *)(ea-&gt;var));<BR>}<BR>EXPORT_SYMBOL_GPL(device_show_ulong);</P>
<P>ssize_t device_store_int(struct device *dev,<BR>&nbsp;&nbsp;&nbsp; struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp; const char *buf, size_t size)<BR>{<BR>&nbsp;struct dev_ext_attribute *ea = to_ext_attr(attr);<BR>&nbsp;char *end;<BR>&nbsp;long new = simple_strtol(buf, &amp;end, 0);<BR>&nbsp;if (end == buf || new &gt; INT_MAX || new &lt; INT_MIN)<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;*(int *)(ea-&gt;var) = new;<BR>&nbsp;/* Always return full write size even if we didn't consume all */<BR>&nbsp;return size;<BR>}<BR>EXPORT_SYMBOL_GPL(device_store_int);</P>
<P>ssize_t device_show_int(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;char *buf)<BR>{<BR>&nbsp;struct dev_ext_attribute *ea = to_ext_attr(attr);</P>
<P>&nbsp;return snprintf(buf, PAGE_SIZE, "%d\n", *(int *)(ea-&gt;var));<BR>}<BR>EXPORT_SYMBOL_GPL(device_show_int);</P>
<P>ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t size)<BR>{<BR>&nbsp;struct dev_ext_attribute *ea = to_ext_attr(attr);</P>
<P>&nbsp;if (strtobool(buf, ea-&gt;var) &lt; 0)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;return size;<BR>}<BR>EXPORT_SYMBOL_GPL(device_store_bool);</P>
<P>ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct dev_ext_attribute *ea = to_ext_attr(attr);</P>
<P>&nbsp;return snprintf(buf, PAGE_SIZE, "%d\n", *(bool *)(ea-&gt;var));<BR>}<BR>EXPORT_SYMBOL_GPL(device_show_bool);</P>
<P>/**<BR>&nbsp;* device_release - free device structure.<BR>&nbsp;* @kobj: device's kobject.<BR>&nbsp;*<BR>&nbsp;* This is called once the reference count for the object<BR>&nbsp;* reaches 0. We forward the call to the device's release<BR>&nbsp;* method, which should handle actually freeing the structure.<BR>&nbsp;*/<BR>static void device_release(struct kobject *kobj)<BR>{<BR>&nbsp;struct device *dev = kobj_to_dev(kobj);<BR>&nbsp;struct device_private *p = dev-&gt;p;</P>
<P>&nbsp;/*<BR>&nbsp; * Some platform devices are driven without driver attached<BR>&nbsp; * and managed resources may have been acquired.&nbsp; Make sure<BR>&nbsp; * all resources are released.<BR>&nbsp; *<BR>&nbsp; * Drivers still can add resources into device after device<BR>&nbsp; * is deleted but alive, so release devres here to avoid<BR>&nbsp; * possible memory leak.<BR>&nbsp; */<BR>&nbsp;devres_release_all(dev);</P>
<P>&nbsp;if (dev-&gt;release)<BR>&nbsp;&nbsp;dev-&gt;release(dev);<BR>&nbsp;else if (dev-&gt;type &amp;&amp; dev-&gt;type-&gt;release)<BR>&nbsp;&nbsp;dev-&gt;type-&gt;release(dev);<BR>&nbsp;else if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;dev_release)<BR>&nbsp;&nbsp;dev-&gt;class-&gt;dev_release(dev);<BR>&nbsp;else<BR>&nbsp;&nbsp;WARN(1, KERN_ERR "Device '%s' does not have a release() "<BR>&nbsp;&nbsp;&nbsp;"function, it is broken and must be fixed.\n",<BR>&nbsp;&nbsp;&nbsp;dev_name(dev));<BR>&nbsp;kfree(p);<BR>}</P>
<P>static const void *device_namespace(struct kobject *kobj)<BR>{<BR>&nbsp;struct device *dev = kobj_to_dev(kobj);<BR>&nbsp;const void *ns = NULL;</P>
<P>&nbsp;if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;ns_type)<BR>&nbsp;&nbsp;ns = dev-&gt;class-&gt;namespace(dev);</P>
<P>&nbsp;return ns;<BR>}</P>
<P>static struct kobj_type device_ktype = {<BR>&nbsp;.release&nbsp;= device_release,<BR>&nbsp;.sysfs_ops&nbsp;= &amp;dev_sysfs_ops,<BR>&nbsp;.namespace&nbsp;= device_namespace,<BR>};</P>
<P><BR>static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)<BR>{<BR>&nbsp;struct kobj_type *ktype = get_ktype(kobj);</P>
<P>&nbsp;if (ktype == &amp;device_ktype) {<BR>&nbsp;&nbsp;struct device *dev = kobj_to_dev(kobj);<BR>&nbsp;&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;&nbsp;return 1;<BR>&nbsp;&nbsp;if (dev-&gt;class)<BR>&nbsp;&nbsp;&nbsp;return 1;<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}</P>
<P>static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)<BR>{<BR>&nbsp;struct device *dev = kobj_to_dev(kobj);</P>
<P>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;return dev-&gt;bus-&gt;name;<BR>&nbsp;if (dev-&gt;class)<BR>&nbsp;&nbsp;return dev-&gt;class-&gt;name;<BR>&nbsp;return NULL;<BR>}</P>
<P>static int dev_uevent(struct kset *kset, struct kobject *kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kobj_uevent_env *env)<BR>{<BR>&nbsp;struct device *dev = kobj_to_dev(kobj);<BR>&nbsp;int retval = 0;</P>
<P>&nbsp;/* add device node properties if present */<BR>&nbsp;if (MAJOR(dev-&gt;devt)) {<BR>&nbsp;&nbsp;const char *tmp;<BR>&nbsp;&nbsp;const char *name;<BR>&nbsp;&nbsp;umode_t mode = 0;<BR>&nbsp;&nbsp;kuid_t uid = GLOBAL_ROOT_UID;<BR>&nbsp;&nbsp;kgid_t gid = GLOBAL_ROOT_GID;</P>
<P>&nbsp;&nbsp;add_uevent_var(env, "MAJOR=%u", MAJOR(dev-&gt;devt));<BR>&nbsp;&nbsp;add_uevent_var(env, "MINOR=%u", MINOR(dev-&gt;devt));<BR>&nbsp;&nbsp;name = device_get_devnode(dev, &amp;mode, &amp;uid, &amp;gid, &amp;tmp);<BR>&nbsp;&nbsp;if (name) {<BR>&nbsp;&nbsp;&nbsp;add_uevent_var(env, "DEVNAME=%s", name);<BR>&nbsp;&nbsp;&nbsp;if (mode)<BR>&nbsp;&nbsp;&nbsp;&nbsp;add_uevent_var(env, "DEVMODE=%#o", mode &amp; 0777);<BR>&nbsp;&nbsp;&nbsp;if (!uid_eq(uid, GLOBAL_ROOT_UID))<BR>&nbsp;&nbsp;&nbsp;&nbsp;add_uevent_var(env, "DEVUID=%u", from_kuid(&amp;init_user_ns, uid));<BR>&nbsp;&nbsp;&nbsp;if (!gid_eq(gid, GLOBAL_ROOT_GID))<BR>&nbsp;&nbsp;&nbsp;&nbsp;add_uevent_var(env, "DEVGID=%u", from_kgid(&amp;init_user_ns, gid));<BR>&nbsp;&nbsp;&nbsp;kfree(tmp);<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;if (dev-&gt;type &amp;&amp; dev-&gt;type-&gt;name)<BR>&nbsp;&nbsp;add_uevent_var(env, "DEVTYPE=%s", dev-&gt;type-&gt;name);</P>
<P>&nbsp;if (dev-&gt;driver)<BR>&nbsp;&nbsp;add_uevent_var(env, "DRIVER=%s", dev-&gt;driver-&gt;name);</P>
<P>&nbsp;/* Add common DT information about the device */<BR>&nbsp;of_device_uevent(dev, env);</P>
<P>&nbsp;/* have the bus specific function add its stuff */<BR>&nbsp;if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;uevent) {<BR>&nbsp;&nbsp;retval = dev-&gt;bus-&gt;uevent(dev, env);<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;pr_debug("device: '%s': %s: bus uevent() returned %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp; dev_name(dev), __func__, retval);<BR>&nbsp;}</P>
<P>&nbsp;/* have the class specific function add its stuff */<BR>&nbsp;if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;dev_uevent) {<BR>&nbsp;&nbsp;retval = dev-&gt;class-&gt;dev_uevent(dev, env);<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;pr_debug("device: '%s': %s: class uevent() "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "returned %d\n", dev_name(dev),<BR>&nbsp;&nbsp;&nbsp;&nbsp; __func__, retval);<BR>&nbsp;}</P>
<P>&nbsp;/* have the device type specific function add its stuff */<BR>&nbsp;if (dev-&gt;type &amp;&amp; dev-&gt;type-&gt;uevent) {<BR>&nbsp;&nbsp;retval = dev-&gt;type-&gt;uevent(dev, env);<BR>&nbsp;&nbsp;if (retval)<BR>&nbsp;&nbsp;&nbsp;pr_debug("device: '%s': %s: dev_type uevent() "<BR>&nbsp;&nbsp;&nbsp;&nbsp; "returned %d\n", dev_name(dev),<BR>&nbsp;&nbsp;&nbsp;&nbsp; __func__, retval);<BR>&nbsp;}</P>
<P>&nbsp;return retval;<BR>}</P>
<P>static const struct kset_uevent_ops device_uevent_ops = {<BR>&nbsp;.filter =&nbsp;dev_uevent_filter,<BR>&nbsp;.name =&nbsp;&nbsp;dev_uevent_name,<BR>&nbsp;.uevent =&nbsp;dev_uevent,<BR>};</P>
<P>static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct kobject *top_kobj;<BR>&nbsp;struct kset *kset;<BR>&nbsp;struct kobj_uevent_env *env = NULL;<BR>&nbsp;int i;<BR>&nbsp;size_t count = 0;<BR>&nbsp;int retval;</P>
<P>&nbsp;/* search the kset, the device belongs to */<BR>&nbsp;top_kobj = &amp;dev-&gt;kobj;<BR>&nbsp;while (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)<BR>&nbsp;&nbsp;top_kobj = top_kobj-&gt;parent;<BR>&nbsp;if (!top_kobj-&gt;kset)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;kset = top_kobj-&gt;kset;<BR>&nbsp;if (!kset-&gt;uevent_ops || !kset-&gt;uevent_ops-&gt;uevent)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;/* respect filter */<BR>&nbsp;if (kset-&gt;uevent_ops &amp;&amp; kset-&gt;uevent_ops-&gt;filter)<BR>&nbsp;&nbsp;if (!kset-&gt;uevent_ops-&gt;filter(kset, &amp;dev-&gt;kobj))<BR>&nbsp;&nbsp;&nbsp;goto out;</P>
<P>&nbsp;env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);<BR>&nbsp;if (!env)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;/* let the kset specific function add its keys */<BR>&nbsp;retval = kset-&gt;uevent_ops-&gt;uevent(kset, &amp;dev-&gt;kobj, env);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;/* copy keys to file */<BR>&nbsp;for (i = 0; i &lt; env-&gt;envp_idx; i++)<BR>&nbsp;&nbsp;count += sprintf(&amp;buf[count], "%s\n", env-&gt;envp[i]);<BR>out:<BR>&nbsp;kfree(env);<BR>&nbsp;return count;<BR>}</P>
<P>static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;enum kobject_action action;</P>
<P>&nbsp;if (kobject_action_type(buf, count, &amp;action) == 0)<BR>&nbsp;&nbsp;kobject_uevent(&amp;dev-&gt;kobj, action);<BR>&nbsp;else<BR>&nbsp;&nbsp;dev_err(dev, "uevent: unknown action-string\n");<BR>&nbsp;return count;<BR>}<BR>static DEVICE_ATTR_RW(uevent);</P>
<P>static ssize_t online_show(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;bool val;</P>
<P>&nbsp;device_lock(dev);<BR>&nbsp;val = !dev-&gt;offline;<BR>&nbsp;device_unlock(dev);<BR>&nbsp;return sprintf(buf, "%u\n", val);<BR>}</P>
<P>static ssize_t online_store(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;bool val;<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = strtobool(buf, &amp;val);<BR>&nbsp;if (ret &lt; 0)<BR>&nbsp;&nbsp;return ret;</P>
<P>&nbsp;ret = lock_device_hotplug_sysfs();<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;return ret;</P>
<P>&nbsp;ret = val ? device_online(dev) : device_offline(dev);<BR>&nbsp;unlock_device_hotplug();<BR>&nbsp;return ret &lt; 0 ? ret : count;<BR>}<BR>static DEVICE_ATTR_RW(online);</P>
<P>int device_add_groups(struct device *dev, const struct attribute_group **groups)<BR>{<BR>&nbsp;return sysfs_create_groups(&amp;dev-&gt;kobj, groups);<BR>}</P>
<P>void device_remove_groups(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups)<BR>{<BR>&nbsp;sysfs_remove_groups(&amp;dev-&gt;kobj, groups);<BR>}</P>
<P>static int device_add_attrs(struct device *dev)<BR>{<BR>&nbsp;struct class *class = dev-&gt;class;<BR>&nbsp;const struct device_type *type = dev-&gt;type;<BR>&nbsp;int error;</P>
<P>&nbsp;if (class) {<BR>&nbsp;&nbsp;error = device_add_groups(dev, class-&gt;dev_groups);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;return error;<BR>&nbsp;}</P>
<P>&nbsp;if (type) {<BR>&nbsp;&nbsp;error = device_add_groups(dev, type-&gt;groups);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto err_remove_class_groups;<BR>&nbsp;}</P>
<P>&nbsp;error = device_add_groups(dev, dev-&gt;groups);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto err_remove_type_groups;</P>
<P>&nbsp;if (device_supports_offline(dev) &amp;&amp; !dev-&gt;offline_disabled) {<BR>&nbsp;&nbsp;error = device_create_file(dev, &amp;dev_attr_online);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto err_remove_dev_groups;<BR>&nbsp;}</P>
<P>&nbsp;return 0;</P>
<P>&nbsp;err_remove_dev_groups:<BR>&nbsp;device_remove_groups(dev, dev-&gt;groups);<BR>&nbsp;err_remove_type_groups:<BR>&nbsp;if (type)<BR>&nbsp;&nbsp;device_remove_groups(dev, type-&gt;groups);<BR>&nbsp;err_remove_class_groups:<BR>&nbsp;if (class)<BR>&nbsp;&nbsp;device_remove_groups(dev, class-&gt;dev_groups);</P>
<P>&nbsp;return error;<BR>}</P>
<P>static void device_remove_attrs(struct device *dev)<BR>{<BR>&nbsp;struct class *class = dev-&gt;class;<BR>&nbsp;const struct device_type *type = dev-&gt;type;</P>
<P>&nbsp;device_remove_file(dev, &amp;dev_attr_online);<BR>&nbsp;device_remove_groups(dev, dev-&gt;groups);</P>
<P>&nbsp;if (type)<BR>&nbsp;&nbsp;device_remove_groups(dev, type-&gt;groups);</P>
<P>&nbsp;if (class)<BR>&nbsp;&nbsp;device_remove_groups(dev, class-&gt;dev_groups);<BR>}</P>
<P>static ssize_t dev_show(struct device *dev, struct device_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;char *buf)<BR>{<BR>&nbsp;return print_dev_t(buf, dev-&gt;devt);<BR>}<BR>static DEVICE_ATTR_RO(dev);</P>
<P>/* /sys/devices/ */<BR>struct kset *devices_kset;</P>
<P>/**<BR>&nbsp;* device_create_file - create sysfs attribute file for device.<BR>&nbsp;* @dev: device.<BR>&nbsp;* @attr: device attribute descriptor.<BR>&nbsp;*/<BR>int device_create_file(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct device_attribute *attr)<BR>{<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (dev) {<BR>&nbsp;&nbsp;WARN(((attr-&gt;attr.mode &amp; S_IWUGO) &amp;&amp; !attr-&gt;store),<BR>&nbsp;&nbsp;&nbsp;"Attribute %s: write permission without 'store'\n",<BR>&nbsp;&nbsp;&nbsp;attr-&gt;attr.name);<BR>&nbsp;&nbsp;WARN(((attr-&gt;attr.mode &amp; S_IRUGO) &amp;&amp; !attr-&gt;show),<BR>&nbsp;&nbsp;&nbsp;"Attribute %s: read permission without 'show'\n",<BR>&nbsp;&nbsp;&nbsp;attr-&gt;attr.name);<BR>&nbsp;&nbsp;error = sysfs_create_file(&amp;dev-&gt;kobj, &amp;attr-&gt;attr);<BR>&nbsp;}</P>
<P>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(device_create_file);</P>
<P>/**<BR>&nbsp;* device_remove_file - remove sysfs attribute file.<BR>&nbsp;* @dev: device.<BR>&nbsp;* @attr: device attribute descriptor.<BR>&nbsp;*/<BR>void device_remove_file(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;const struct device_attribute *attr)<BR>{<BR>&nbsp;if (dev)<BR>&nbsp;&nbsp;sysfs_remove_file(&amp;dev-&gt;kobj, &amp;attr-&gt;attr);<BR>}<BR>EXPORT_SYMBOL_GPL(device_remove_file);</P>
<P>/**<BR>&nbsp;* device_remove_file_self - remove sysfs attribute file from its own method.<BR>&nbsp;* @dev: device.<BR>&nbsp;* @attr: device attribute descriptor.<BR>&nbsp;*<BR>&nbsp;* See kernfs_remove_self() for details.<BR>&nbsp;*/<BR>bool device_remove_file_self(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct device_attribute *attr)<BR>{<BR>&nbsp;if (dev)<BR>&nbsp;&nbsp;return sysfs_remove_file_self(&amp;dev-&gt;kobj, &amp;attr-&gt;attr);<BR>&nbsp;else<BR>&nbsp;&nbsp;return false;<BR>}<BR>EXPORT_SYMBOL_GPL(device_remove_file_self);</P>
<P>/**<BR>&nbsp;* device_create_bin_file - create sysfs binary attribute file for device.<BR>&nbsp;* @dev: device.<BR>&nbsp;* @attr: device binary attribute descriptor.<BR>&nbsp;*/<BR>int device_create_bin_file(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct bin_attribute *attr)<BR>{<BR>&nbsp;int error = -EINVAL;<BR>&nbsp;if (dev)<BR>&nbsp;&nbsp;error = sysfs_create_bin_file(&amp;dev-&gt;kobj, attr);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(device_create_bin_file);</P>
<P>/**<BR>&nbsp;* device_remove_bin_file - remove sysfs binary attribute file<BR>&nbsp;* @dev: device.<BR>&nbsp;* @attr: device binary attribute descriptor.<BR>&nbsp;*/<BR>void device_remove_bin_file(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct bin_attribute *attr)<BR>{<BR>&nbsp;if (dev)<BR>&nbsp;&nbsp;sysfs_remove_bin_file(&amp;dev-&gt;kobj, attr);<BR>}<BR>EXPORT_SYMBOL_GPL(device_remove_bin_file);</P>
<P>static void klist_children_get(struct klist_node *n)<BR>{<BR>&nbsp;struct device_private *p = to_device_private_parent(n);<BR>&nbsp;struct device *dev = p-&gt;device;</P>
<P>&nbsp;get_device(dev);<BR>}</P>
<P>static void klist_children_put(struct klist_node *n)<BR>{<BR>&nbsp;struct device_private *p = to_device_private_parent(n);<BR>&nbsp;struct device *dev = p-&gt;device;</P>
<P>&nbsp;put_device(dev);<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* device_initialize - init device structure.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* This prepares the device for use by other layers by initializing<BR>&nbsp;* its fields.<BR>&nbsp;* It is the first half of device_register(), if called by<BR>&nbsp;* that function, though it can also be called separately, so one<BR>&nbsp;* may use @dev's fields. In particular, get_device()/put_device()<BR>&nbsp;* may be used for reference counting of @dev after calling this<BR>&nbsp;* function.<BR>&nbsp;*<BR>&nbsp;* All fields in @dev must be initialized by the caller to 0, except<BR>&nbsp;* for those explicitly set to some other value.&nbsp; The simplest<BR>&nbsp;* approach is to use kzalloc() to allocate the structure containing<BR>&nbsp;* @dev.<BR>&nbsp;*<BR>&nbsp;* NOTE: Use put_device() to give up your reference instead of freeing<BR>&nbsp;* @dev directly once you have called this function.<BR>&nbsp;*/<BR>void device_initialize(struct device *dev)<BR>{<BR>&nbsp;dev-&gt;kobj.kset = devices_kset;<BR>&nbsp;kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);<BR>&nbsp;INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);<BR>&nbsp;mutex_init(&amp;dev-&gt;mutex);<BR>&nbsp;lockdep_set_novalidate_class(&amp;dev-&gt;mutex);<BR>&nbsp;spin_lock_init(&amp;dev-&gt;devres_lock);<BR>&nbsp;INIT_LIST_HEAD(&amp;dev-&gt;devres_head);<BR>&nbsp;device_pm_init(dev);<BR>&nbsp;set_dev_node(dev, -1);<BR>}<BR>EXPORT_SYMBOL_GPL(device_initialize);</FONT></P>
<P>struct kobject *virtual_device_parent(struct device *dev)<BR>{<BR>&nbsp;static struct kobject *virtual_dir = NULL;</P>
<P>&nbsp;if (!virtual_dir)<BR>&nbsp;&nbsp;virtual_dir = kobject_create_and_add("virtual",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;devices_kset-&gt;kobj);</P>
<P>&nbsp;return virtual_dir;<BR>}</P>
<P>struct class_dir {<BR>&nbsp;struct kobject kobj;<BR>&nbsp;struct class *class;<BR>};</P>
<P>#define to_class_dir(obj) container_of(obj, struct class_dir, kobj)</P>
<P>static void class_dir_release(struct kobject *kobj)<BR>{<BR>&nbsp;struct class_dir *dir = to_class_dir(kobj);<BR>&nbsp;kfree(dir);<BR>}</P>
<P>static const<BR>struct kobj_ns_type_operations *class_dir_child_ns_type(struct kobject *kobj)<BR>{<BR>&nbsp;struct class_dir *dir = to_class_dir(kobj);<BR>&nbsp;return dir-&gt;class-&gt;ns_type;<BR>}</P>
<P>static struct kobj_type class_dir_ktype = {<BR>&nbsp;.release&nbsp;= class_dir_release,<BR>&nbsp;.sysfs_ops&nbsp;= &amp;kobj_sysfs_ops,<BR>&nbsp;.child_ns_type&nbsp;= class_dir_child_ns_type<BR>};</P>
<P>static struct kobject *<BR>class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)<BR>{<BR>&nbsp;struct class_dir *dir;<BR>&nbsp;int retval;</P>
<P>&nbsp;dir = kzalloc(sizeof(*dir), GFP_KERNEL);<BR>&nbsp;if (!dir)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;dir-&gt;class = class;<BR>&nbsp;kobject_init(&amp;dir-&gt;kobj, &amp;class_dir_ktype);</P>
<P>&nbsp;dir-&gt;kobj.kset = &amp;class-&gt;p-&gt;glue_dirs;</P>
<P>&nbsp;retval = kobject_add(&amp;dir-&gt;kobj, parent_kobj, "%s", class-&gt;name);<BR>&nbsp;if (retval &lt; 0) {<BR>&nbsp;&nbsp;kobject_put(&amp;dir-&gt;kobj);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}<BR>&nbsp;return &amp;dir-&gt;kobj;<BR>}</P>
<P>static DEFINE_MUTEX(gdp_mutex);</P>
<P>static struct kobject *get_device_parent(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *parent)<BR>{<BR>&nbsp;if (dev-&gt;class) {<BR>&nbsp;&nbsp;struct kobject *kobj = NULL;<BR>&nbsp;&nbsp;struct kobject *parent_kobj;<BR>&nbsp;&nbsp;struct kobject *k;</P>
<P>#ifdef CONFIG_BLOCK<BR>&nbsp;&nbsp;/* block disks show up in /sys/block */<BR>&nbsp;&nbsp;if (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class) {<BR>&nbsp;&nbsp;&nbsp;if (parent &amp;&amp; parent-&gt;class == &amp;block_class)<BR>&nbsp;&nbsp;&nbsp;&nbsp;return &amp;parent-&gt;kobj;<BR>&nbsp;&nbsp;&nbsp;return &amp;block_class.p-&gt;subsys.kobj;<BR>&nbsp;&nbsp;}<BR>#endif</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * If we have no parent, we live in "virtual".<BR>&nbsp;&nbsp; * Class-devices with a non class-device as parent, live<BR>&nbsp;&nbsp; * in a "glue" directory to prevent namespace collisions.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (parent == NULL)<BR>&nbsp;&nbsp;&nbsp;parent_kobj = virtual_device_parent(dev);<BR>&nbsp;&nbsp;else if (parent-&gt;class &amp;&amp; !dev-&gt;class-&gt;ns_type)<BR>&nbsp;&nbsp;&nbsp;return &amp;parent-&gt;kobj;<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;parent_kobj = &amp;parent-&gt;kobj;</P>
<P>&nbsp;&nbsp;mutex_lock(&amp;gdp_mutex);</P>
<P>&nbsp;&nbsp;/* find our class-directory at the parent and reference it */<BR>&nbsp;&nbsp;spin_lock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);<BR>&nbsp;&nbsp;list_for_each_entry(k, &amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list, entry)<BR>&nbsp;&nbsp;&nbsp;if (k-&gt;parent == parent_kobj) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;kobj = kobject_get(k);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;spin_unlock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);<BR>&nbsp;&nbsp;if (kobj) {<BR>&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;gdp_mutex);<BR>&nbsp;&nbsp;&nbsp;return kobj;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* or create a new class-directory at the parent device */<BR>&nbsp;&nbsp;k = class_dir_create_and_add(dev-&gt;class, parent_kobj);<BR>&nbsp;&nbsp;/* do not emit an uevent for this simple "glue" directory */<BR>&nbsp;&nbsp;mutex_unlock(&amp;gdp_mutex);<BR>&nbsp;&nbsp;return k;<BR>&nbsp;}</P>
<P>&nbsp;/* subsystems can specify a default root directory for their devices */<BR>&nbsp;if (!parent &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_root)<BR>&nbsp;&nbsp;return &amp;dev-&gt;bus-&gt;dev_root-&gt;kobj;</P>
<P>&nbsp;if (parent)<BR>&nbsp;&nbsp;return &amp;parent-&gt;kobj;<BR>&nbsp;return NULL;<BR>}</P>
<P>static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)<BR>{<BR>&nbsp;/* see if we live in a "glue" directory */<BR>&nbsp;if (!glue_dir || !dev-&gt;class ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; glue_dir-&gt;kset != &amp;dev-&gt;class-&gt;p-&gt;glue_dirs)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;mutex_lock(&amp;gdp_mutex);<BR>&nbsp;kobject_put(glue_dir);<BR>&nbsp;mutex_unlock(&amp;gdp_mutex);<BR>}</P>
<P>static void cleanup_device_parent(struct device *dev)<BR>{<BR>&nbsp;cleanup_glue_dir(dev, dev-&gt;kobj.parent);<BR>}</P>
<P>static int device_add_class_symlinks(struct device *dev)<BR>{<BR>&nbsp;struct device_node *of_node = dev_of_node(dev);<BR>&nbsp;int error;</P>
<P>&nbsp;if (of_node) {<BR>&nbsp;&nbsp;error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;of_node-&gt;kobj,"of_node");<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;dev_warn(dev, "Error %d creating of_node link\n",error);<BR>&nbsp;&nbsp;/* An error here doesn't warrant bringing down the device */<BR>&nbsp;}</P>
<P>&nbsp;if (!dev-&gt;class)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;error = sysfs_create_link(&amp;dev-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "subsystem");<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto out_devnode;</P>
<P>&nbsp;if (dev-&gt;parent &amp;&amp; device_is_not_partition(dev)) {<BR>&nbsp;&nbsp;error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;parent-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "device");<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto out_subsys;<BR>&nbsp;}</P>
<P>#ifdef CONFIG_BLOCK<BR>&nbsp;/* /sys/block has directories and does not need symlinks */<BR>&nbsp;if (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class)<BR>&nbsp;&nbsp;return 0;<BR>#endif</P>
<P>&nbsp;/* link in the class directory pointing to the device */<BR>&nbsp;error = sysfs_create_link(&amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;kobj, dev_name(dev));<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto out_device;</P>
<P>&nbsp;return 0;</P>
<P>out_device:<BR>&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "device");</P>
<P>out_subsys:<BR>&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "subsystem");<BR>out_devnode:<BR>&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "of_node");<BR>&nbsp;return error;<BR>}</P>
<P>static void device_remove_class_symlinks(struct device *dev)<BR>{<BR>&nbsp;if (dev_of_node(dev))<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "of_node");</P>
<P>&nbsp;if (!dev-&gt;class)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;if (dev-&gt;parent &amp;&amp; device_is_not_partition(dev))<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "device");<BR>&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "subsystem");<BR>#ifdef CONFIG_BLOCK<BR>&nbsp;if (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class)<BR>&nbsp;&nbsp;return;<BR>#endif<BR>&nbsp;sysfs_delete_link(&amp;dev-&gt;class-&gt;p-&gt;subsys.kobj, &amp;dev-&gt;kobj, dev_name(dev));<BR>}</P>
<P>/**<BR>&nbsp;* dev_set_name - set a device name<BR>&nbsp;* @dev: device<BR>&nbsp;* @fmt: format string for the device's name<BR>&nbsp;*/<BR>int dev_set_name(struct device *dev, const char *fmt, ...)<BR>{<BR>&nbsp;va_list vargs;<BR>&nbsp;int err;</P>
<P>&nbsp;va_start(vargs, fmt);<BR>&nbsp;err = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, vargs);<BR>&nbsp;va_end(vargs);<BR>&nbsp;return err;<BR>}<BR>EXPORT_SYMBOL_GPL(dev_set_name);</P>
<P>/**<BR>&nbsp;* device_to_dev_kobj - select a /sys/dev/ directory for the device<BR>&nbsp;* @dev: device<BR>&nbsp;*<BR>&nbsp;* By default we select char/ for new entries.&nbsp; Setting class-&gt;dev_obj<BR>&nbsp;* to NULL prevents an entry from being created.&nbsp; class-&gt;dev_kobj must<BR>&nbsp;* be set (or cleared) before any devices are registered to the class<BR>&nbsp;* otherwise device_create_sys_dev_entry() and<BR>&nbsp;* device_remove_sys_dev_entry() will disagree about the presence of<BR>&nbsp;* the link.<BR>&nbsp;*/<BR>static struct kobject *device_to_dev_kobj(struct device *dev)<BR>{<BR>&nbsp;struct kobject *kobj;</P>
<P>&nbsp;if (dev-&gt;class)<BR>&nbsp;&nbsp;kobj = dev-&gt;class-&gt;dev_kobj;<BR>&nbsp;else<BR>&nbsp;&nbsp;kobj = sysfs_dev_char_kobj;</P>
<P>&nbsp;return kobj;<BR>}</P>
<P>static int device_create_sys_dev_entry(struct device *dev)<BR>{<BR>&nbsp;struct kobject *kobj = device_to_dev_kobj(dev);<BR>&nbsp;int error = 0;<BR>&nbsp;char devt_str[15];</P>
<P>&nbsp;if (kobj) {<BR>&nbsp;&nbsp;format_dev_t(devt_str, dev-&gt;devt);<BR>&nbsp;&nbsp;error = sysfs_create_link(kobj, &amp;dev-&gt;kobj, devt_str);<BR>&nbsp;}</P>
<P>&nbsp;return error;<BR>}</P>
<P>static void device_remove_sys_dev_entry(struct device *dev)<BR>{<BR>&nbsp;struct kobject *kobj = device_to_dev_kobj(dev);<BR>&nbsp;char devt_str[15];</P>
<P>&nbsp;if (kobj) {<BR>&nbsp;&nbsp;format_dev_t(devt_str, dev-&gt;devt);<BR>&nbsp;&nbsp;sysfs_remove_link(kobj, devt_str);<BR>&nbsp;}<BR>}</P>
<P>int device_private_init(struct device *dev)<BR>{<BR>&nbsp;dev-&gt;p = kzalloc(sizeof(*dev-&gt;p), GFP_KERNEL);<BR>&nbsp;if (!dev-&gt;p)<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;dev-&gt;p-&gt;device = dev;<BR>&nbsp;klist_init(&amp;dev-&gt;p-&gt;klist_children, klist_children_get,<BR>&nbsp;&nbsp;&nbsp;&nbsp; klist_children_put);<BR>&nbsp;INIT_LIST_HEAD(&amp;dev-&gt;p-&gt;deferred_probe);<BR>&nbsp;return 0;<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* device_add - add device to device hierarchy.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* This is part 2 of device_register(), though may be called<BR>&nbsp;* separately _iff_ device_initialize() has been called separately.<BR>&nbsp;*<BR>&nbsp;* This adds @dev to the kobject hierarchy via kobject_add(), adds it<BR>&nbsp;* to the global and sibling lists for the device, then<BR>&nbsp;* adds it to the other relevant subsystems of the driver model.<BR>&nbsp;*<BR>&nbsp;* Do not call this routine or device_register() more than once for<BR>&nbsp;* any device structure.&nbsp; The driver model core is not designed to work<BR>&nbsp;* with devices that get unregistered and then spring back to life.<BR>&nbsp;* (Among other things, it's very hard to guarantee that all references<BR>&nbsp;* to the previous incarnation of @dev have been dropped.)&nbsp; Allocate<BR>&nbsp;* and register a fresh new struct device instead.<BR>&nbsp;*<BR>&nbsp;* NOTE: _Never_ directly free @dev after calling this function, even<BR>&nbsp;* if it returned an error! Always use put_device() to give up your<BR>&nbsp;* reference instead.<BR>&nbsp;*/<BR>int device_add(struct device *dev)<BR>{<BR>&nbsp;struct device *parent = NULL;<BR>&nbsp;struct kobject *kobj;<BR>&nbsp;struct class_interface *class_intf;<BR>&nbsp;int error = -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;dev = get_device(dev);<BR>&nbsp;if (!dev)<BR>&nbsp;&nbsp;goto done;</FONT></P>
<P><FONT class=extract>&nbsp;if (!dev-&gt;p) {<BR>&nbsp;&nbsp;error = device_private_init(dev);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto done;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * for statically allocated devices, which should all be converted<BR>&nbsp; * some day, we need to initialize the name. We prevent reading back<BR>&nbsp; * the name, and force the use of dev_name()<BR>&nbsp; */<BR>&nbsp;if (dev-&gt;init_name) {<BR>&nbsp;&nbsp;dev_set_name(dev, "%s", dev-&gt;init_name);<BR>&nbsp;&nbsp;dev-&gt;init_name = NULL;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* subsystems can specify simple device enumeration */<BR>&nbsp;if (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)<BR>&nbsp;&nbsp;dev_set_name(dev, "%s%u", dev-&gt;bus-&gt;dev_name, dev-&gt;id);</FONT></P>
<P><FONT class=extract>&nbsp;if (!dev_name(dev)) {<BR>&nbsp;&nbsp;error = -EINVAL;<BR>&nbsp;&nbsp;goto name_error;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("device: '%s': %s\n", dev_name(dev), __func__);</FONT></P>
<P><FONT class=extract>&nbsp;parent = get_device(dev-&gt;parent);<BR>&nbsp;kobj = get_device_parent(dev, parent);<BR>&nbsp;if (kobj)<BR>&nbsp;&nbsp;dev-&gt;kobj.parent = kobj;</FONT></P>
<P><FONT class=extract>&nbsp;/* use parent numa_node */<BR>&nbsp;if (parent)<BR>&nbsp;&nbsp;set_dev_node(dev, dev_to_node(parent));</FONT></P>
<P><FONT class=extract>&nbsp;/* first, register with generic layer. */<BR>&nbsp;/* we require the name to be set before, and pass NULL */<BR>&nbsp;error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto Error;</FONT></P>
<P><FONT class=extract>&nbsp;/* notify platform of device entry */<BR>&nbsp;if (platform_notify)<BR>&nbsp;&nbsp;platform_notify(dev);</FONT></P>
<P><FONT class=extract>&nbsp;error = device_create_file(dev, &amp;dev_attr_uevent);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto attrError;</FONT></P>
<P><FONT class=extract>&nbsp;error = device_add_class_symlinks(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto SymlinkError;<BR>&nbsp;error = device_add_attrs(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto AttrsError;<BR>&nbsp;error = bus_add_device(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto BusError;<BR>&nbsp;error = dpm_sysfs_add(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto DPMError;<BR>&nbsp;device_pm_add(dev);</FONT></P>
<P><FONT class=extract>&nbsp;if (MAJOR(dev-&gt;devt)) {<BR>&nbsp;&nbsp;error = device_create_file(dev, &amp;dev_attr_dev);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto DevAttrError;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;error = device_create_sys_dev_entry(dev);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto SysEntryError;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;devtmpfs_create_node(dev);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* Notify clients of device addition.&nbsp; This call must come<BR>&nbsp; * after dpm_sysfs_add() and before kobject_uevent().<BR>&nbsp; */<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_ADD_DEVICE, dev);</FONT></P>
<P><FONT class=extract>&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);<BR>&nbsp;bus_probe_device(dev);<BR>&nbsp;if (parent)<BR>&nbsp;&nbsp;klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;parent-&gt;p-&gt;klist_children);</FONT></P>
<P><FONT class=extract>&nbsp;if (dev-&gt;class) {<BR>&nbsp;&nbsp;mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;&nbsp;/* tie the class to the device */<BR>&nbsp;&nbsp;klist_add_tail(&amp;dev-&gt;knode_class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;/* notify any interfaces that the device is here */<BR>&nbsp;&nbsp;list_for_each_entry(class_intf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)<BR>&nbsp;&nbsp;&nbsp;if (class_intf-&gt;add_dev)<BR>&nbsp;&nbsp;&nbsp;&nbsp;class_intf-&gt;add_dev(dev, class_intf);<BR>&nbsp;&nbsp;mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;}<BR>done:<BR>&nbsp;put_device(dev);<BR>&nbsp;return error;<BR>&nbsp;SysEntryError:<BR>&nbsp;if (MAJOR(dev-&gt;devt))<BR>&nbsp;&nbsp;device_remove_file(dev, &amp;dev_attr_dev);<BR>&nbsp;DevAttrError:<BR>&nbsp;device_pm_remove(dev);<BR>&nbsp;dpm_sysfs_remove(dev);<BR>&nbsp;DPMError:<BR>&nbsp;bus_remove_device(dev);<BR>&nbsp;BusError:<BR>&nbsp;device_remove_attrs(dev);<BR>&nbsp;AttrsError:<BR>&nbsp;device_remove_class_symlinks(dev);<BR>&nbsp;SymlinkError:<BR>&nbsp;device_remove_file(dev, &amp;dev_attr_uevent);<BR>&nbsp;attrError:<BR>&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);<BR>&nbsp;kobject_del(&amp;dev-&gt;kobj);<BR>&nbsp;Error:<BR>&nbsp;cleanup_device_parent(dev);<BR>&nbsp;put_device(parent);<BR>name_error:<BR>&nbsp;kfree(dev-&gt;p);<BR>&nbsp;dev-&gt;p = NULL;<BR>&nbsp;goto done;<BR>}<BR>EXPORT_SYMBOL_GPL(device_add);</FONT></P>
<P>/**<BR>&nbsp;* device_register - register a device with the system.<BR>&nbsp;* @dev: pointer to the device structure<BR>&nbsp;*<BR>&nbsp;* This happens in two clean steps - initialize the device<BR>&nbsp;* and add it to the system. The two steps can be called<BR>&nbsp;* separately, but this is the easiest and most common.<BR>&nbsp;* I.e. you should only call the two helpers separately if<BR>&nbsp;* have a clearly defined need to use and refcount the device<BR>&nbsp;* before it is added to the hierarchy.<BR>&nbsp;*<BR>&nbsp;* For more information, see the kerneldoc for device_initialize()<BR>&nbsp;* and device_add().<BR>&nbsp;*<BR>&nbsp;* NOTE: _Never_ directly free @dev after calling this function, even<BR>&nbsp;* if it returned an error! Always use put_device() to give up the<BR>&nbsp;* reference initialized in this function instead.<BR>&nbsp;*/<BR>int device_register(struct device *dev)<BR>{<BR>&nbsp;device_initialize(dev);<BR>&nbsp;return device_add(dev);<BR>}<BR>EXPORT_SYMBOL_GPL(device_register);</P>
<P>/**<BR>&nbsp;* get_device - increment reference count for device.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* This simply forwards the call to kobject_get(), though<BR>&nbsp;* we do take care to provide for the case that we get a NULL<BR>&nbsp;* pointer passed in.<BR>&nbsp;*/<BR>struct device *get_device(struct device *dev)<BR>{<BR>&nbsp;return dev ? kobj_to_dev(kobject_get(&amp;dev-&gt;kobj)) : NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(get_device);</P>
<P>/**<BR>&nbsp;* put_device - decrement reference count.<BR>&nbsp;* @dev: device in question.<BR>&nbsp;*/<BR>void put_device(struct device *dev)<BR>{<BR>&nbsp;/* might_sleep(); */<BR>&nbsp;if (dev)<BR>&nbsp;&nbsp;kobject_put(&amp;dev-&gt;kobj);<BR>}<BR>EXPORT_SYMBOL_GPL(put_device);</P>
<P><FONT class=extract>/**<BR>&nbsp;* device_del - delete device from system.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* This is the first part of the device unregistration<BR>&nbsp;* sequence. This removes the device from the lists we control<BR>&nbsp;* from here, has it removed from the other driver model<BR>&nbsp;* subsystems it was added to in device_add(), and removes it<BR>&nbsp;* from the kobject hierarchy.<BR>&nbsp;*<BR>&nbsp;* NOTE: this should be called manually _iff_ device_add() was<BR>&nbsp;* also called manually.<BR>&nbsp;*/<BR>void device_del(struct device *dev)<BR>{<BR>&nbsp;struct device *parent = dev-&gt;parent;<BR>&nbsp;struct class_interface *class_intf;</FONT></P>
<P><FONT class=extract>&nbsp;/* Notify clients of device removal.&nbsp; This call must come<BR>&nbsp; * before dpm_sysfs_remove().<BR>&nbsp; */<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_DEL_DEVICE, dev);<BR>&nbsp;dpm_sysfs_remove(dev);<BR>&nbsp;if (parent)<BR>&nbsp;&nbsp;klist_del(&amp;dev-&gt;p-&gt;knode_parent);<BR>&nbsp;if (MAJOR(dev-&gt;devt)) {<BR>&nbsp;&nbsp;devtmpfs_delete_node(dev);<BR>&nbsp;&nbsp;device_remove_sys_dev_entry(dev);<BR>&nbsp;&nbsp;device_remove_file(dev, &amp;dev_attr_dev);<BR>&nbsp;}<BR>&nbsp;if (dev-&gt;class) {<BR>&nbsp;&nbsp;device_remove_class_symlinks(dev);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;&nbsp;/* notify any interfaces that the device is now gone */<BR>&nbsp;&nbsp;list_for_each_entry(class_intf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)<BR>&nbsp;&nbsp;&nbsp;if (class_intf-&gt;remove_dev)<BR>&nbsp;&nbsp;&nbsp;&nbsp;class_intf-&gt;remove_dev(dev, class_intf);<BR>&nbsp;&nbsp;/* remove the device from the class list */<BR>&nbsp;&nbsp;klist_del(&amp;dev-&gt;knode_class);<BR>&nbsp;&nbsp;mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;}<BR>&nbsp;device_remove_file(dev, &amp;dev_attr_uevent);<BR>&nbsp;device_remove_attrs(dev);<BR>&nbsp;bus_remove_device(dev);<BR>&nbsp;device_pm_remove(dev);<BR>&nbsp;driver_deferred_probe_del(dev);</FONT></P>
<P><FONT class=extract>&nbsp;/* Notify the platform of the removal, in case they<BR>&nbsp; * need to do anything...<BR>&nbsp; */<BR>&nbsp;if (platform_notify_remove)<BR>&nbsp;&nbsp;platform_notify_remove(dev);<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_REMOVED_DEVICE, dev);<BR>&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);<BR>&nbsp;cleanup_device_parent(dev);<BR>&nbsp;kobject_del(&amp;dev-&gt;kobj);<BR>&nbsp;put_device(parent);<BR>}<BR>EXPORT_SYMBOL_GPL(device_del);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* device_unregister - unregister device from system.<BR>&nbsp;* @dev: device going away.<BR>&nbsp;*<BR>&nbsp;* We do this in two parts, like we do device_register(). First,<BR>&nbsp;* we remove it from all the subsystems with device_del(), then<BR>&nbsp;* we decrement the reference count via put_device(). If that<BR>&nbsp;* is the final reference count, the device will be cleaned up<BR>&nbsp;* via device_release() above. Otherwise, the structure will<BR>&nbsp;* stick around until the final reference to the device is dropped.<BR>&nbsp;*/<BR>void device_unregister(struct device *dev)<BR>{<BR>&nbsp;pr_debug("device: '%s': %s\n", dev_name(dev), __func__);<BR>&nbsp;device_del(dev);<BR>&nbsp;put_device(dev);<BR>}<BR>EXPORT_SYMBOL_GPL(device_unregister);</FONT></P>
<P>static struct device *next_device(struct klist_iter *i)<BR>{<BR>&nbsp;struct klist_node *n = klist_next(i);<BR>&nbsp;struct device *dev = NULL;<BR>&nbsp;struct device_private *p;</P>
<P>&nbsp;if (n) {<BR>&nbsp;&nbsp;p = to_device_private_parent(n);<BR>&nbsp;&nbsp;dev = p-&gt;device;<BR>&nbsp;}<BR>&nbsp;return dev;<BR>}</P>
<P>/**<BR>&nbsp;* device_get_devnode - path of device node file<BR>&nbsp;* @dev: device<BR>&nbsp;* @mode: returned file access mode<BR>&nbsp;* @uid: returned file owner<BR>&nbsp;* @gid: returned file group<BR>&nbsp;* @tmp: possibly allocated string<BR>&nbsp;*<BR>&nbsp;* Return the relative path of a possible device node.<BR>&nbsp;* Non-default names may need to allocate a memory to compose<BR>&nbsp;* a name. This memory is returned in tmp and needs to be<BR>&nbsp;* freed by the caller.<BR>&nbsp;*/<BR>const char *device_get_devnode(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umode_t *mode, kuid_t *uid, kgid_t *gid,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char **tmp)<BR>{<BR>&nbsp;char *s;</P>
<P>&nbsp;*tmp = NULL;</P>
<P>&nbsp;/* the device type may provide a specific name */<BR>&nbsp;if (dev-&gt;type &amp;&amp; dev-&gt;type-&gt;devnode)<BR>&nbsp;&nbsp;*tmp = dev-&gt;type-&gt;devnode(dev, mode, uid, gid);<BR>&nbsp;if (*tmp)<BR>&nbsp;&nbsp;return *tmp;</P>
<P>&nbsp;/* the class may provide a specific name */<BR>&nbsp;if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;devnode)<BR>&nbsp;&nbsp;*tmp = dev-&gt;class-&gt;devnode(dev, mode);<BR>&nbsp;if (*tmp)<BR>&nbsp;&nbsp;return *tmp;</P>
<P>&nbsp;/* return name without allocation, tmp == NULL */<BR>&nbsp;if (strchr(dev_name(dev), '!') == NULL)<BR>&nbsp;&nbsp;return dev_name(dev);</P>
<P>&nbsp;/* replace '!' in the name with '/' */<BR>&nbsp;s = kstrdup(dev_name(dev), GFP_KERNEL);<BR>&nbsp;if (!s)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;strreplace(s, '!', '/');<BR>&nbsp;return *tmp = s;<BR>}</P>
<P>/**<BR>&nbsp;* device_for_each_child - device child iterator.<BR>&nbsp;* @parent: parent struct device.<BR>&nbsp;* @fn: function to be called for each device.<BR>&nbsp;* @data: data for the callback.<BR>&nbsp;*<BR>&nbsp;* Iterate over @parent's child devices, and call @fn for each,<BR>&nbsp;* passing it @data.<BR>&nbsp;*<BR>&nbsp;* We check the return of @fn each time. If it returns anything<BR>&nbsp;* other than 0, we break out and return that value.<BR>&nbsp;*/<BR>int device_for_each_child(struct device *parent, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int (*fn)(struct device *dev, void *data))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device *child;<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (!parent-&gt;p)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;klist_iter_init(&amp;parent-&gt;p-&gt;klist_children, &amp;i);<BR>&nbsp;while ((child = next_device(&amp;i)) &amp;&amp; !error)<BR>&nbsp;&nbsp;error = fn(child, data);<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(device_for_each_child);</P>
<P>/**<BR>&nbsp;* device_find_child - device iterator for locating a particular device.<BR>&nbsp;* @parent: parent struct device<BR>&nbsp;* @match: Callback function to check device<BR>&nbsp;* @data: Data to pass to match function<BR>&nbsp;*<BR>&nbsp;* This is similar to the device_for_each_child() function above, but it<BR>&nbsp;* returns a reference to a device that is 'found' for later use, as<BR>&nbsp;* determined by the @match callback.<BR>&nbsp;*<BR>&nbsp;* The callback should return 0 if the device doesn't match and non-zero<BR>&nbsp;* if it does.&nbsp; If the callback returns non-zero and a reference to the<BR>&nbsp;* current device can be obtained, this function will return to the caller<BR>&nbsp;* and not iterate over any more devices.<BR>&nbsp;*<BR>&nbsp;* NOTE: you will need to drop the reference with put_device() after use.<BR>&nbsp;*/<BR>struct device *device_find_child(struct device *parent, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int (*match)(struct device *dev, void *data))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device *child;</P>
<P>&nbsp;if (!parent)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;klist_iter_init(&amp;parent-&gt;p-&gt;klist_children, &amp;i);<BR>&nbsp;while ((child = next_device(&amp;i)))<BR>&nbsp;&nbsp;if (match(child, data) &amp;&amp; get_device(child))<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return child;<BR>}<BR>EXPORT_SYMBOL_GPL(device_find_child);</P>
<P>int __init devices_init(void)<BR>{<BR>&nbsp;devices_kset = kset_create_and_add("devices", &amp;device_uevent_ops, NULL);<BR>&nbsp;if (!devices_kset)<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;dev_kobj = kobject_create_and_add("dev", NULL);<BR>&nbsp;if (!dev_kobj)<BR>&nbsp;&nbsp;goto dev_kobj_err;<BR>&nbsp;sysfs_dev_block_kobj = kobject_create_and_add("block", dev_kobj);<BR>&nbsp;if (!sysfs_dev_block_kobj)<BR>&nbsp;&nbsp;goto block_kobj_err;<BR>&nbsp;sysfs_dev_char_kobj = kobject_create_and_add("char", dev_kobj);<BR>&nbsp;if (!sysfs_dev_char_kobj)<BR>&nbsp;&nbsp;goto char_kobj_err;</P>
<P>&nbsp;return 0;</P>
<P>&nbsp;char_kobj_err:<BR>&nbsp;kobject_put(sysfs_dev_block_kobj);<BR>&nbsp;block_kobj_err:<BR>&nbsp;kobject_put(dev_kobj);<BR>&nbsp;dev_kobj_err:<BR>&nbsp;kset_unregister(devices_kset);<BR>&nbsp;return -ENOMEM;<BR>}</P>
<P>static int device_check_offline(struct device *dev, void *not_used)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = device_for_each_child(dev, NULL, device_check_offline);<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;return ret;</P>
<P>&nbsp;return device_supports_offline(dev) &amp;&amp; !dev-&gt;offline ? -EBUSY : 0;<BR>}</P>
<P>/**<BR>&nbsp;* device_offline - Prepare the device for hot-removal.<BR>&nbsp;* @dev: Device to be put offline.<BR>&nbsp;*<BR>&nbsp;* Execute the device bus type's .offline() callback, if present, to prepare<BR>&nbsp;* the device for a subsequent hot-removal.&nbsp; If that succeeds, the device must<BR>&nbsp;* not be used until either it is removed or its bus type's .online() callback<BR>&nbsp;* is executed.<BR>&nbsp;*<BR>&nbsp;* Call under device_hotplug_lock.<BR>&nbsp;*/<BR>int device_offline(struct device *dev)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;if (dev-&gt;offline_disabled)<BR>&nbsp;&nbsp;return -EPERM;</P>
<P>&nbsp;ret = device_for_each_child(dev, NULL, device_check_offline);<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;return ret;</P>
<P>&nbsp;device_lock(dev);<BR>&nbsp;if (device_supports_offline(dev)) {<BR>&nbsp;&nbsp;if (dev-&gt;offline) {<BR>&nbsp;&nbsp;&nbsp;ret = 1;<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;ret = dev-&gt;bus-&gt;offline(dev);<BR>&nbsp;&nbsp;&nbsp;if (!ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_OFFLINE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;dev-&gt;offline = true;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;device_unlock(dev);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;* device_online - Put the device back online after successful device_offline().<BR>&nbsp;* @dev: Device to be put back online.<BR>&nbsp;*<BR>&nbsp;* If device_offline() has been successfully executed for @dev, but the device<BR>&nbsp;* has not been removed subsequently, execute its bus type's .online() callback<BR>&nbsp;* to indicate that the device can be used again.<BR>&nbsp;*<BR>&nbsp;* Call under device_hotplug_lock.<BR>&nbsp;*/<BR>int device_online(struct device *dev)<BR>{<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;device_lock(dev);<BR>&nbsp;if (device_supports_offline(dev)) {<BR>&nbsp;&nbsp;if (dev-&gt;offline) {<BR>&nbsp;&nbsp;&nbsp;ret = dev-&gt;bus-&gt;online(dev);<BR>&nbsp;&nbsp;&nbsp;if (!ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ONLINE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;dev-&gt;offline = false;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;ret = 1;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;device_unlock(dev);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>struct root_device {<BR>&nbsp;struct device dev;<BR>&nbsp;struct module *owner;<BR>};</P>
<P>static inline struct root_device *to_root_device(struct device *d)<BR>{<BR>&nbsp;return container_of(d, struct root_device, dev);<BR>}</P>
<P>static void root_device_release(struct device *dev)<BR>{<BR>&nbsp;kfree(to_root_device(dev));<BR>}</P>
<P>/**<BR>&nbsp;* __root_device_register - allocate and register a root device<BR>&nbsp;* @name: root device name<BR>&nbsp;* @owner: owner module of the root device, usually THIS_MODULE<BR>&nbsp;*<BR>&nbsp;* This function allocates a root device and registers it<BR>&nbsp;* using device_register(). In order to free the returned<BR>&nbsp;* device, use root_device_unregister().<BR>&nbsp;*<BR>&nbsp;* Root devices are dummy devices which allow other devices<BR>&nbsp;* to be grouped under /sys/devices. Use this function to<BR>&nbsp;* allocate a root device and then use it as the parent of<BR>&nbsp;* any device which should appear under /sys/devices/{name}<BR>&nbsp;*<BR>&nbsp;* The /sys/devices/{name} directory will also contain a<BR>&nbsp;* 'module' symlink which points to the @owner directory<BR>&nbsp;* in sysfs.<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*<BR>&nbsp;* Note: You probably want to use root_device_register().<BR>&nbsp;*/<BR>struct device *__root_device_register(const char *name, struct module *owner)<BR>{<BR>&nbsp;struct root_device *root;<BR>&nbsp;int err = -ENOMEM;</P>
<P>&nbsp;root = kzalloc(sizeof(struct root_device), GFP_KERNEL);<BR>&nbsp;if (!root)<BR>&nbsp;&nbsp;return ERR_PTR(err);</P>
<P>&nbsp;err = dev_set_name(&amp;root-&gt;dev, "%s", name);<BR>&nbsp;if (err) {<BR>&nbsp;&nbsp;kfree(root);<BR>&nbsp;&nbsp;return ERR_PTR(err);<BR>&nbsp;}</P>
<P>&nbsp;root-&gt;dev.release = root_device_release;</P>
<P>&nbsp;err = device_register(&amp;root-&gt;dev);<BR>&nbsp;if (err) {<BR>&nbsp;&nbsp;put_device(&amp;root-&gt;dev);<BR>&nbsp;&nbsp;return ERR_PTR(err);<BR>&nbsp;}</P>
<P>#ifdef CONFIG_MODULES&nbsp;/* gotta find a "cleaner" way to do this */<BR>&nbsp;if (owner) {<BR>&nbsp;&nbsp;struct module_kobject *mk = &amp;owner-&gt;mkobj;</P>
<P>&nbsp;&nbsp;err = sysfs_create_link(&amp;root-&gt;dev.kobj, &amp;mk-&gt;kobj, "module");<BR>&nbsp;&nbsp;if (err) {<BR>&nbsp;&nbsp;&nbsp;device_unregister(&amp;root-&gt;dev);<BR>&nbsp;&nbsp;&nbsp;return ERR_PTR(err);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;root-&gt;owner = owner;<BR>&nbsp;}<BR>#endif</P>
<P>&nbsp;return &amp;root-&gt;dev;<BR>}<BR>EXPORT_SYMBOL_GPL(__root_device_register);</P>
<P>/**<BR>&nbsp;* root_device_unregister - unregister and free a root device<BR>&nbsp;* @dev: device going away<BR>&nbsp;*<BR>&nbsp;* This function unregisters and cleans up a device that was created by<BR>&nbsp;* root_device_register().<BR>&nbsp;*/<BR>void root_device_unregister(struct device *dev)<BR>{<BR>&nbsp;struct root_device *root = to_root_device(dev);</P>
<P>&nbsp;if (root-&gt;owner)<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;root-&gt;dev.kobj, "module");</P>
<P>&nbsp;device_unregister(dev);<BR>}<BR>EXPORT_SYMBOL_GPL(root_device_unregister);</P>
<P><BR>static void device_create_release(struct device *dev)<BR>{<BR>&nbsp;pr_debug("device: '%s': %s\n", dev_name(dev), __func__);<BR>&nbsp;kfree(dev);<BR>}</P>
<P>static struct device *<BR>device_create_groups_vargs(struct class *class, struct device *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_t devt, void *drvdata,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, va_list args)<BR>{<BR>&nbsp;struct device *dev = NULL;<BR>&nbsp;int retval = -ENODEV;</P>
<P>&nbsp;if (class == NULL || IS_ERR(class))<BR>&nbsp;&nbsp;goto error;</P>
<P>&nbsp;dev = kzalloc(sizeof(*dev), GFP_KERNEL);<BR>&nbsp;if (!dev) {<BR>&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;&nbsp;goto error;<BR>&nbsp;}</P>
<P>&nbsp;device_initialize(dev);<BR>&nbsp;dev-&gt;devt = devt;<BR>&nbsp;dev-&gt;class = class;<BR>&nbsp;dev-&gt;parent = parent;<BR>&nbsp;dev-&gt;groups = groups;<BR>&nbsp;dev-&gt;release = device_create_release;<BR>&nbsp;dev_set_drvdata(dev, drvdata);</P>
<P>&nbsp;retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto error;</P>
<P>&nbsp;retval = device_add(dev);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto error;</P>
<P>&nbsp;return dev;</P>
<P>error:<BR>&nbsp;put_device(dev);<BR>&nbsp;return ERR_PTR(retval);<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* device_create_vargs - creates a device and registers it with sysfs<BR>&nbsp;* @class: pointer to the struct class that this device should be registered to<BR>&nbsp;* @parent: pointer to the parent struct device of this new device, if any<BR>&nbsp;* @devt: the dev_t for the char device to be added<BR>&nbsp;* @drvdata: the data to be added to the device for callbacks<BR>&nbsp;* @fmt: string for the device's name<BR>&nbsp;* @args: va_list for the device's name<BR>&nbsp;*<BR>&nbsp;* This function can be used by char device classes.&nbsp; A struct device<BR>&nbsp;* will be created in sysfs, registered to the specified class.<BR>&nbsp;*<BR>&nbsp;* A "dev" file will be created, showing the dev_t for the device, if<BR>&nbsp;* the dev_t is not 0,0.<BR>&nbsp;* If a pointer to a parent struct device is passed in, the newly created<BR>&nbsp;* struct device will be a child of that device in sysfs.<BR>&nbsp;* The pointer to the struct device will be returned from the call.<BR>&nbsp;* Any further sysfs files that might be required can be created using this<BR>&nbsp;* pointer.<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*<BR>&nbsp;* Note: the struct class passed to this function must have previously<BR>&nbsp;* been created with a call to class_create().<BR>&nbsp;*/<BR>struct device *device_create_vargs(struct class *class, struct device *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_t devt, void *drvdata, const char *fmt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args)<BR>{<BR>&nbsp;return device_create_groups_vargs(class, parent, devt, drvdata, NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt, args);<BR>}<BR>EXPORT_SYMBOL_GPL(device_create_vargs);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* device_create - creates a device and registers it with sysfs<BR>&nbsp;* @class: pointer to the struct class that this device should be registered to<BR>&nbsp;* @parent: pointer to the parent struct device of this new device, if any<BR>&nbsp;* @devt: the dev_t for the char device to be added<BR>&nbsp;* @drvdata: the data to be added to the device for callbacks<BR>&nbsp;* @fmt: string for the device's name<BR>&nbsp;*<BR>&nbsp;* This function can be used by char device classes.&nbsp; A struct device<BR>&nbsp;* will be created in sysfs, registered to the specified class.<BR>&nbsp;*<BR>&nbsp;* A "dev" file will be created, showing the dev_t for the device, if<BR>&nbsp;* the dev_t is not 0,0.<BR>&nbsp;* If a pointer to a parent struct device is passed in, the newly created<BR>&nbsp;* struct device will be a child of that device in sysfs.<BR>&nbsp;* The pointer to the struct device will be returned from the call.<BR>&nbsp;* Any further sysfs files that might be required can be created using this<BR>&nbsp;* pointer.<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*<BR>&nbsp;* Note: the struct class passed to this function must have previously<BR>&nbsp;* been created with a call to class_create().<BR>&nbsp;*/<BR>struct device *device_create(struct class *class, struct device *parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_t devt, void *drvdata, const char *fmt, ...)<BR>{<BR>&nbsp;va_list vargs;<BR>&nbsp;struct device *dev;</FONT></P>
<P><FONT class=extract>&nbsp;va_start(vargs, fmt);<BR>&nbsp;dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);<BR>&nbsp;va_end(vargs);<BR>&nbsp;return dev;<BR>}<BR>EXPORT_SYMBOL_GPL(device_create);</FONT></P>
<P>/**<BR>&nbsp;* device_create_with_groups - creates a device and registers it with sysfs<BR>&nbsp;* @class: pointer to the struct class that this device should be registered to<BR>&nbsp;* @parent: pointer to the parent struct device of this new device, if any<BR>&nbsp;* @devt: the dev_t for the char device to be added<BR>&nbsp;* @drvdata: the data to be added to the device for callbacks<BR>&nbsp;* @groups: NULL-terminated list of attribute groups to be created<BR>&nbsp;* @fmt: string for the device's name<BR>&nbsp;*<BR>&nbsp;* This function can be used by char device classes.&nbsp; A struct device<BR>&nbsp;* will be created in sysfs, registered to the specified class.<BR>&nbsp;* Additional attributes specified in the groups parameter will also<BR>&nbsp;* be created automatically.<BR>&nbsp;*<BR>&nbsp;* A "dev" file will be created, showing the dev_t for the device, if<BR>&nbsp;* the dev_t is not 0,0.<BR>&nbsp;* If a pointer to a parent struct device is passed in, the newly created<BR>&nbsp;* struct device will be a child of that device in sysfs.<BR>&nbsp;* The pointer to the struct device will be returned from the call.<BR>&nbsp;* Any further sysfs files that might be required can be created using this<BR>&nbsp;* pointer.<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*<BR>&nbsp;* Note: the struct class passed to this function must have previously<BR>&nbsp;* been created with a call to class_create().<BR>&nbsp;*/<BR>struct device *device_create_with_groups(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *parent, dev_t devt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *drvdata,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, ...)<BR>{<BR>&nbsp;va_list vargs;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;va_start(vargs, fmt);<BR>&nbsp;dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt, vargs);<BR>&nbsp;va_end(vargs);<BR>&nbsp;return dev;<BR>}<BR>EXPORT_SYMBOL_GPL(device_create_with_groups);</P>
<P>static int __match_devt(struct device *dev, const void *data)<BR>{<BR>&nbsp;const dev_t *devt = data;</P>
<P>&nbsp;return dev-&gt;devt == *devt;<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* device_destroy - removes a device that was created with device_create()<BR>&nbsp;* @class: pointer to the struct class that this device was registered with<BR>&nbsp;* @devt: the dev_t of the device that was previously registered<BR>&nbsp;*<BR>&nbsp;* This call unregisters and cleans up a device that was created with a<BR>&nbsp;* call to device_create().<BR>&nbsp;*/<BR>void device_destroy(struct class *class, dev_t devt)<BR>{<BR>&nbsp;struct device *dev;</FONT></P>
<P><FONT class=extract>&nbsp;dev = class_find_device(class, NULL, &amp;devt, __match_devt);<BR>&nbsp;if (dev) {<BR>&nbsp;&nbsp;put_device(dev);<BR>&nbsp;&nbsp;device_unregister(dev);<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(device_destroy);</FONT></P>
<P>/**<BR>&nbsp;* device_rename - renames a device<BR>&nbsp;* @dev: the pointer to the struct device to be renamed<BR>&nbsp;* @new_name: the new name of the device<BR>&nbsp;*<BR>&nbsp;* It is the responsibility of the caller to provide mutual<BR>&nbsp;* exclusion between two different calls of device_rename<BR>&nbsp;* on the same device to ensure that new_name is valid and<BR>&nbsp;* won't conflict with other devices.<BR>&nbsp;*<BR>&nbsp;* Note: Don't call this function.&nbsp; Currently, the networking layer calls this<BR>&nbsp;* function, but that will change.&nbsp; The following text from Kay Sievers offers<BR>&nbsp;* some insight:<BR>&nbsp;*<BR>&nbsp;* Renaming devices is racy at many levels, symlinks and other stuff are not<BR>&nbsp;* replaced atomically, and you get a "move" uevent, but it's not easy to<BR>&nbsp;* connect the event to the old and new device. Device nodes are not renamed at<BR>&nbsp;* all, there isn't even support for that in the kernel now.<BR>&nbsp;*<BR>&nbsp;* In the meantime, during renaming, your target name might be taken by another<BR>&nbsp;* driver, creating conflicts. Or the old name is taken directly after you<BR>&nbsp;* renamed it -- then you get events for the same DEVPATH, before you even see<BR>&nbsp;* the "move" event. It's just a mess, and nothing new should ever rely on<BR>&nbsp;* kernel device renaming. Besides that, it's not even implemented now for<BR>&nbsp;* other things than (driver-core wise very simple) network devices.<BR>&nbsp;*<BR>&nbsp;* We are currently about to change network renaming in udev to completely<BR>&nbsp;* disallow renaming of devices in the same namespace as the kernel uses,<BR>&nbsp;* because we can't solve the problems properly, that arise with swapping names<BR>&nbsp;* of multiple interfaces without races. Means, renaming of eth[0-9]* will only<BR>&nbsp;* be allowed to some other name than eth[0-9]*, for the aforementioned<BR>&nbsp;* reasons.<BR>&nbsp;*<BR>&nbsp;* Make up a "real" name in the driver before you register anything, or add<BR>&nbsp;* some other attributes for userspace to find the device, or use udev to add<BR>&nbsp;* symlinks -- but never rename kernel devices later, it's a complete mess. We<BR>&nbsp;* don't even want to get into that and try to implement the missing pieces in<BR>&nbsp;* the core. We really have other pieces to fix in the driver core mess. :)<BR>&nbsp;*/<BR>int device_rename(struct device *dev, const char *new_name)<BR>{<BR>&nbsp;struct kobject *kobj = &amp;dev-&gt;kobj;<BR>&nbsp;char *old_device_name = NULL;<BR>&nbsp;int error;</P>
<P>&nbsp;dev = get_device(dev);<BR>&nbsp;if (!dev)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;dev_dbg(dev, "renaming to %s\n", new_name);</P>
<P>&nbsp;old_device_name = kstrdup(dev_name(dev), GFP_KERNEL);<BR>&nbsp;if (!old_device_name) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;if (dev-&gt;class) {<BR>&nbsp;&nbsp;error = sysfs_rename_link_ns(&amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kobj, old_device_name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_name, kobject_namespace(kobj));<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;error = kobject_rename(kobj, new_name);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto out;</P>
<P>out:<BR>&nbsp;put_device(dev);</P>
<P>&nbsp;kfree(old_device_name);</P>
<P>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(device_rename);</P>
<P>static int device_move_class_links(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *old_parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *new_parent)<BR>{<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (old_parent)<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "device");<BR>&nbsp;if (new_parent)<BR>&nbsp;&nbsp;error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;new_parent-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "device");<BR>&nbsp;return error;<BR>}</P>
<P>/**<BR>&nbsp;* device_move - moves a device to a new parent<BR>&nbsp;* @dev: the pointer to the struct device to be moved<BR>&nbsp;* @new_parent: the new parent of the device (can by NULL)<BR>&nbsp;* @dpm_order: how to reorder the dpm_list<BR>&nbsp;*/<BR>int device_move(struct device *dev, struct device *new_parent,<BR>&nbsp;&nbsp;enum dpm_order dpm_order)<BR>{<BR>&nbsp;int error;<BR>&nbsp;struct device *old_parent;<BR>&nbsp;struct kobject *new_parent_kobj;</P>
<P>&nbsp;dev = get_device(dev);<BR>&nbsp;if (!dev)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;device_pm_lock();<BR>&nbsp;new_parent = get_device(new_parent);<BR>&nbsp;new_parent_kobj = get_device_parent(dev, new_parent);</P>
<P>&nbsp;pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),<BR>&nbsp;&nbsp; __func__, new_parent ? dev_name(new_parent) : "&lt;NULL&gt;");<BR>&nbsp;error = kobject_move(&amp;dev-&gt;kobj, new_parent_kobj);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;cleanup_glue_dir(dev, new_parent_kobj);<BR>&nbsp;&nbsp;put_device(new_parent);<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}<BR>&nbsp;old_parent = dev-&gt;parent;<BR>&nbsp;dev-&gt;parent = new_parent;<BR>&nbsp;if (old_parent)<BR>&nbsp;&nbsp;klist_remove(&amp;dev-&gt;p-&gt;knode_parent);<BR>&nbsp;if (new_parent) {<BR>&nbsp;&nbsp;klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;new_parent-&gt;p-&gt;klist_children);<BR>&nbsp;&nbsp;set_dev_node(dev, dev_to_node(new_parent));<BR>&nbsp;}</P>
<P>&nbsp;if (dev-&gt;class) {<BR>&nbsp;&nbsp;error = device_move_class_links(dev, old_parent, new_parent);<BR>&nbsp;&nbsp;if (error) {<BR>&nbsp;&nbsp;&nbsp;/* We ignore errors on cleanup since we're hosed anyway... */<BR>&nbsp;&nbsp;&nbsp;device_move_class_links(dev, new_parent, old_parent);<BR>&nbsp;&nbsp;&nbsp;if (!kobject_move(&amp;dev-&gt;kobj, &amp;old_parent-&gt;kobj)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (new_parent)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;klist_remove(&amp;dev-&gt;p-&gt;knode_parent);<BR>&nbsp;&nbsp;&nbsp;&nbsp;dev-&gt;parent = old_parent;<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (old_parent) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;old_parent-&gt;p-&gt;klist_children);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_dev_node(dev, dev_to_node(old_parent));<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;cleanup_glue_dir(dev, new_parent_kobj);<BR>&nbsp;&nbsp;&nbsp;put_device(new_parent);<BR>&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;switch (dpm_order) {<BR>&nbsp;case DPM_ORDER_NONE:<BR>&nbsp;&nbsp;break;<BR>&nbsp;case DPM_ORDER_DEV_AFTER_PARENT:<BR>&nbsp;&nbsp;device_pm_move_after(dev, new_parent);<BR>&nbsp;&nbsp;break;<BR>&nbsp;case DPM_ORDER_PARENT_BEFORE_DEV:<BR>&nbsp;&nbsp;device_pm_move_before(new_parent, dev);<BR>&nbsp;&nbsp;break;<BR>&nbsp;case DPM_ORDER_DEV_LAST:<BR>&nbsp;&nbsp;device_pm_move_last(dev);<BR>&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;put_device(old_parent);<BR>out:<BR>&nbsp;device_pm_unlock();<BR>&nbsp;put_device(dev);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(device_move);</P>
<P>/**<BR>&nbsp;* device_shutdown - call -&gt;shutdown() on each device to shutdown.<BR>&nbsp;*/<BR>void device_shutdown(void)<BR>{<BR>&nbsp;struct device *dev, *parent;</P>
<P>&nbsp;spin_lock(&amp;devices_kset-&gt;list_lock);<BR>&nbsp;/*<BR>&nbsp; * Walk the devices list backward, shutting down each in turn.<BR>&nbsp; * Beware that device unplug events may also start pulling<BR>&nbsp; * devices offline, even as the system is shutting down.<BR>&nbsp; */<BR>&nbsp;while (!list_empty(&amp;devices_kset-&gt;list)) {<BR>&nbsp;&nbsp;dev = list_entry(devices_kset-&gt;list.prev, struct device,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kobj.entry);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * hold reference count of device's parent to<BR>&nbsp;&nbsp; * prevent it from being freed because parent's<BR>&nbsp;&nbsp; * lock is to be held<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;parent = get_device(dev-&gt;parent);<BR>&nbsp;&nbsp;get_device(dev);<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Make sure the device is off the kset list, in the<BR>&nbsp;&nbsp; * event that dev-&gt;*-&gt;shutdown() doesn't remove it.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;list_del_init(&amp;dev-&gt;kobj.entry);<BR>&nbsp;&nbsp;spin_unlock(&amp;devices_kset-&gt;list_lock);</P>
<P>&nbsp;&nbsp;/* hold lock to avoid race with probe/release */<BR>&nbsp;&nbsp;if (parent)<BR>&nbsp;&nbsp;&nbsp;device_lock(parent);<BR>&nbsp;&nbsp;device_lock(dev);</P>
<P>&nbsp;&nbsp;/* Don't allow any more runtime suspends */<BR>&nbsp;&nbsp;pm_runtime_get_noresume(dev);<BR>&nbsp;&nbsp;pm_runtime_barrier(dev);</P>
<P>&nbsp;&nbsp;if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;shutdown) {<BR>&nbsp;&nbsp;&nbsp;if (initcall_debug)<BR>&nbsp;&nbsp;&nbsp;&nbsp;dev_info(dev, "shutdown\n");<BR>&nbsp;&nbsp;&nbsp;dev-&gt;bus-&gt;shutdown(dev);<BR>&nbsp;&nbsp;} else if (dev-&gt;driver &amp;&amp; dev-&gt;driver-&gt;shutdown) {<BR>&nbsp;&nbsp;&nbsp;if (initcall_debug)<BR>&nbsp;&nbsp;&nbsp;&nbsp;dev_info(dev, "shutdown\n");<BR>&nbsp;&nbsp;&nbsp;dev-&gt;driver-&gt;shutdown(dev);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;device_unlock(dev);<BR>&nbsp;&nbsp;if (parent)<BR>&nbsp;&nbsp;&nbsp;device_unlock(parent);</P>
<P>&nbsp;&nbsp;put_device(dev);<BR>&nbsp;&nbsp;put_device(parent);</P>
<P>&nbsp;&nbsp;spin_lock(&amp;devices_kset-&gt;list_lock);<BR>&nbsp;}<BR>&nbsp;spin_unlock(&amp;devices_kset-&gt;list_lock);<BR>}</P>
<P>/*<BR>&nbsp;* Device logging functions<BR>&nbsp;*/</P>
<P>#ifdef CONFIG_PRINTK<BR>static int<BR>create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)<BR>{<BR>&nbsp;const char *subsys;<BR>&nbsp;size_t pos = 0;</P>
<P>&nbsp;if (dev-&gt;class)<BR>&nbsp;&nbsp;subsys = dev-&gt;class-&gt;name;<BR>&nbsp;else if (dev-&gt;bus)<BR>&nbsp;&nbsp;subsys = dev-&gt;bus-&gt;name;<BR>&nbsp;else<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;pos += snprintf(hdr + pos, hdrlen - pos, "SUBSYSTEM=%s", subsys);<BR>&nbsp;if (pos &gt;= hdrlen)<BR>&nbsp;&nbsp;goto overflow;</P>
<P>&nbsp;/*<BR>&nbsp; * Add device identifier DEVICE=:<BR>&nbsp; *&nbsp;&nbsp; b12:8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block dev_t<BR>&nbsp; *&nbsp;&nbsp; c127:3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char dev_t<BR>&nbsp; *&nbsp;&nbsp; n8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netdev ifindex<BR>&nbsp; *&nbsp;&nbsp; +sound:card0&nbsp; subsystem:devname<BR>&nbsp; */<BR>&nbsp;if (MAJOR(dev-&gt;devt)) {<BR>&nbsp;&nbsp;char c;</P>
<P>&nbsp;&nbsp;if (strcmp(subsys, "block") == 0)<BR>&nbsp;&nbsp;&nbsp;c = 'b';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;c = 'c';<BR>&nbsp;&nbsp;pos++;<BR>&nbsp;&nbsp;pos += snprintf(hdr + pos, hdrlen - pos,<BR>&nbsp;&nbsp;&nbsp;&nbsp;"DEVICE=%c%u:%u",<BR>&nbsp;&nbsp;&nbsp;&nbsp;c, MAJOR(dev-&gt;devt), MINOR(dev-&gt;devt));<BR>&nbsp;} else if (strcmp(subsys, "net") == 0) {<BR>&nbsp;&nbsp;struct net_device *net = to_net_dev(dev);</P>
<P>&nbsp;&nbsp;pos++;<BR>&nbsp;&nbsp;pos += snprintf(hdr + pos, hdrlen - pos,<BR>&nbsp;&nbsp;&nbsp;&nbsp;"DEVICE=n%u", net-&gt;ifindex);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;pos++;<BR>&nbsp;&nbsp;pos += snprintf(hdr + pos, hdrlen - pos,<BR>&nbsp;&nbsp;&nbsp;&nbsp;"DEVICE=+%s:%s", subsys, dev_name(dev));<BR>&nbsp;}</P>
<P>&nbsp;if (pos &gt;= hdrlen)<BR>&nbsp;&nbsp;goto overflow;</P>
<P>&nbsp;return pos;</P>
<P>overflow:<BR>&nbsp;dev_WARN(dev, "device/subsystem name too long");<BR>&nbsp;return 0;<BR>}</P>
<P>int dev_vprintk_emit(int level, const struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fmt, va_list args)<BR>{<BR>&nbsp;char hdr[128];<BR>&nbsp;size_t hdrlen;</P>
<P>&nbsp;hdrlen = create_syslog_header(dev, hdr, sizeof(hdr));</P>
<P>&nbsp;return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);<BR>}<BR>EXPORT_SYMBOL(dev_vprintk_emit);</P>
<P>int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int r;</P>
<P>&nbsp;va_start(args, fmt);</P>
<P>&nbsp;r = dev_vprintk_emit(level, dev, fmt, args);</P>
<P>&nbsp;va_end(args);</P>
<P>&nbsp;return r;<BR>}<BR>EXPORT_SYMBOL(dev_printk_emit);</P>
<P>static void __dev_printk(const char *level, const struct device *dev,<BR>&nbsp;&nbsp;&nbsp;struct va_format *vaf)<BR>{<BR>&nbsp;if (dev)<BR>&nbsp;&nbsp;dev_printk_emit(level[1] - '0', dev, "%s %s: %pV",<BR>&nbsp;&nbsp;&nbsp;&nbsp;dev_driver_string(dev), dev_name(dev), vaf);<BR>&nbsp;else<BR>&nbsp;&nbsp;printk("%s(NULL device *): %pV", level, vaf);<BR>}</P>
<P>void dev_printk(const char *level, const struct device *dev,<BR>&nbsp;&nbsp;const char *fmt, ...)<BR>{<BR>&nbsp;struct va_format vaf;<BR>&nbsp;va_list args;</P>
<P>&nbsp;va_start(args, fmt);</P>
<P>&nbsp;vaf.fmt = fmt;<BR>&nbsp;vaf.va = &amp;args;</P>
<P>&nbsp;__dev_printk(level, dev, &amp;vaf);</P>
<P>&nbsp;va_end(args);<BR>}<BR>EXPORT_SYMBOL(dev_printk);</P>
<P>#define define_dev_printk_level(func, kern_level)&nbsp;&nbsp;\<BR>void func(const struct device *dev, const char *fmt, ...)&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct va_format vaf;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;va_list args;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;va_start(args, fmt);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;vaf.fmt = fmt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;vaf.va = &amp;args;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__dev_printk(kern_level, dev, &amp;vaf);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;va_end(args);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>EXPORT_SYMBOL(func);</P>
<P>define_dev_printk_level(dev_emerg, KERN_EMERG);<BR>define_dev_printk_level(dev_alert, KERN_ALERT);<BR>define_dev_printk_level(dev_crit, KERN_CRIT);<BR>define_dev_printk_level(dev_err, KERN_ERR);<BR>define_dev_printk_level(dev_warn, KERN_WARNING);<BR>define_dev_printk_level(dev_notice, KERN_NOTICE);<BR>define_dev_printk_level(_dev_info, KERN_INFO);</P>
<P>#endif</P>
<P>static inline bool fwnode_is_primary(struct fwnode_handle *fwnode)<BR>{<BR>&nbsp;return fwnode &amp;&amp; !IS_ERR(fwnode-&gt;secondary);<BR>}</P>
<P>/**<BR>&nbsp;* set_primary_fwnode - Change the primary firmware node of a given device.<BR>&nbsp;* @dev: Device to handle.<BR>&nbsp;* @fwnode: New primary firmware node of the device.<BR>&nbsp;*<BR>&nbsp;* Set the device's firmware node pointer to @fwnode, but if a secondary<BR>&nbsp;* firmware node of the device is present, preserve it.<BR>&nbsp;*/<BR>void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode)<BR>{<BR>&nbsp;if (fwnode) {<BR>&nbsp;&nbsp;struct fwnode_handle *fn = dev-&gt;fwnode;</P>
<P>&nbsp;&nbsp;if (fwnode_is_primary(fn))<BR>&nbsp;&nbsp;&nbsp;fn = fn-&gt;secondary;</P>
<P>&nbsp;&nbsp;fwnode-&gt;secondary = fn;<BR>&nbsp;&nbsp;dev-&gt;fwnode = fwnode;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;dev-&gt;fwnode = fwnode_is_primary(dev-&gt;fwnode) ?<BR>&nbsp;&nbsp;&nbsp;dev-&gt;fwnode-&gt;secondary : NULL;<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(set_primary_fwnode);</P>
<P>/**<BR>&nbsp;* set_secondary_fwnode - Change the secondary firmware node of a given device.<BR>&nbsp;* @dev: Device to handle.<BR>&nbsp;* @fwnode: New secondary firmware node of the device.<BR>&nbsp;*<BR>&nbsp;* If a primary firmware node of the device is present, set its secondary<BR>&nbsp;* pointer to @fwnode.&nbsp; Otherwise, set the device's firmware node pointer to<BR>&nbsp;* @fwnode.<BR>&nbsp;*/<BR>void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode)<BR>{<BR>&nbsp;if (fwnode)<BR>&nbsp;&nbsp;fwnode-&gt;secondary = ERR_PTR(-ENODEV);</P>
<P>&nbsp;if (fwnode_is_primary(dev-&gt;fwnode))<BR>&nbsp;&nbsp;dev-&gt;fwnode-&gt;secondary = fwnode;<BR>&nbsp;else<BR>&nbsp;&nbsp;dev-&gt;fwnode = fwnode;<BR>}