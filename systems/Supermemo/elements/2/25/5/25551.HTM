include/linux/completion.h 
<P></P>
<P>#ifndef __LINUX_COMPLETION_H<BR>#define __LINUX_COMPLETION_H</P>
<P></P>
<P>/*<BR>&nbsp;* (C) Copyright 2001 Linus Torvalds<BR>&nbsp;*<BR>&nbsp;* Atomic wait-for-completion handler data structures.<BR>&nbsp;* See kernel/sched/completion.c for details.<BR>&nbsp;*/</P>
<P>#include &lt;linux/wait.h&gt;</P>
<P><FONT class=extract>/*<BR>&nbsp;* struct completion - structure used to maintain state for a "completion"<BR>&nbsp;*<BR>&nbsp;* This is the opaque structure used to maintain the state for a "completion".<BR>&nbsp;* Completions currently use a FIFO to queue threads that have to wait for<BR>&nbsp;* the "completion" event.<BR>&nbsp;*<BR>&nbsp;* See also:&nbsp; complete(), wait_for_completion() (and friends _timeout,<BR>&nbsp;* _interruptible, _interruptible_timeout, and _killable), init_completion(),<BR>&nbsp;* reinit_completion(), and macros DECLARE_COMPLETION(),<BR>&nbsp;* DECLARE_COMPLETION_ONSTACK().<BR>&nbsp;*/<BR>struct completion {<BR>&nbsp;unsigned int done;<BR>&nbsp;wait_queue_head_t wait;<BR>};</FONT></P>
<P>#define COMPLETION_INITIALIZER(work) \<BR>&nbsp;{ 0, __WAIT_QUEUE_HEAD_INITIALIZER((work).wait) }</P>
<P>#define COMPLETION_INITIALIZER_ONSTACK(work) \<BR>&nbsp;({ init_completion(&amp;work); work; })</P>
<P>/**<BR>&nbsp;* DECLARE_COMPLETION - declare and initialize a completion structure<BR>&nbsp;* @work:&nbsp; identifier for the completion structure<BR>&nbsp;*<BR>&nbsp;* This macro declares and initializes a completion structure. Generally used<BR>&nbsp;* for static declarations. You should use the _ONSTACK variant for automatic<BR>&nbsp;* variables.<BR>&nbsp;*/<BR>#define DECLARE_COMPLETION(work) \<BR>&nbsp;struct completion work = COMPLETION_INITIALIZER(work)</P>
<P>/*<BR>&nbsp;* Lockdep needs to run a non-constant initializer for on-stack<BR>&nbsp;* completions - so we use the _ONSTACK() variant for those that<BR>&nbsp;* are on the kernel stack:<BR>&nbsp;*/<BR>/**<BR>&nbsp;* DECLARE_COMPLETION_ONSTACK - declare and initialize a completion structure<BR>&nbsp;* @work:&nbsp; identifier for the completion structure<BR>&nbsp;*<BR>&nbsp;* This macro declares and initializes a completion structure on the kernel<BR>&nbsp;* stack.<BR>&nbsp;*/<BR>#ifdef CONFIG_LOCKDEP<BR># define DECLARE_COMPLETION_ONSTACK(work) \<BR>&nbsp;struct completion work = COMPLETION_INITIALIZER_ONSTACK(work)<BR>#else<BR># define DECLARE_COMPLETION_ONSTACK(work) DECLARE_COMPLETION(work)<BR>#endif</P>
<P>/**<BR>&nbsp;* init_completion - Initialize a dynamically allocated completion<BR>&nbsp;* @x:&nbsp; pointer to completion structure that is to be initialized<BR>&nbsp;*<BR>&nbsp;* This inline function will initialize a dynamically created completion<BR>&nbsp;* structure.<BR>&nbsp;*/<BR>static inline void init_completion(struct completion *x)<BR>{<BR>&nbsp;x-&gt;done = 0;<BR>&nbsp;init_waitqueue_head(&amp;x-&gt;wait);<BR>}</P>
<P>/**<BR>&nbsp;* reinit_completion - reinitialize a completion structure<BR>&nbsp;* @x:&nbsp; pointer to completion structure that is to be reinitialized<BR>&nbsp;*<BR>&nbsp;* This inline function should be used to reinitialize a completion structure so it can<BR>&nbsp;* be reused. This is especially important after complete_all() is used.<BR>&nbsp;*/<BR>static inline void reinit_completion(struct completion *x)<BR>{<BR>&nbsp;x-&gt;done = 0;<BR>}</P>
<P>extern void wait_for_completion(struct completion *);<BR>extern void wait_for_completion_io(struct completion *);<BR>extern int wait_for_completion_interruptible(struct completion *x);<BR>extern int wait_for_completion_killable(struct completion *x);<BR>extern unsigned long wait_for_completion_timeout(struct completion *x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long timeout);<BR>extern unsigned long wait_for_completion_io_timeout(struct completion *x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long timeout);<BR>extern long wait_for_completion_interruptible_timeout(<BR>&nbsp;struct completion *x, unsigned long timeout);<BR>extern long wait_for_completion_killable_timeout(<BR>&nbsp;struct completion *x, unsigned long timeout);<BR>extern bool try_wait_for_completion(struct completion *x);<BR>extern bool completion_done(struct completion *x);</P>
<P>extern void complete(struct completion *);<BR>extern void complete_all(struct completion *);</P>
<P>#endif