include/linux/types.h 
<P></P>
<P>#ifndef _LINUX_TYPES_H<BR>#define _LINUX_TYPES_H</P>
<P></P>
<P>#define __EXPORTED_HEADERS__<BR>#include &lt;uapi/linux/types.h&gt;</P>
<P>#ifndef __ASSEMBLY__</P>
<P>#define DECLARE_BITMAP(name,bits) \<BR>&nbsp;unsigned long name[BITS_TO_LONGS(bits)]</P>
<P>typedef __u32 __kernel_dev_t;</P>
<P>typedef __kernel_fd_set&nbsp;&nbsp;fd_set;<BR>typedef __kernel_dev_t&nbsp;&nbsp;dev_t;<BR>typedef __kernel_ino_t&nbsp;&nbsp;ino_t;<BR>typedef __kernel_mode_t&nbsp;&nbsp;mode_t;<BR>typedef unsigned short&nbsp;&nbsp;umode_t;<BR>typedef __u32&nbsp;&nbsp;&nbsp;nlink_t;<BR>typedef __kernel_off_t&nbsp;&nbsp;off_t;<BR>typedef __kernel_pid_t&nbsp;&nbsp;pid_t;<BR>typedef __kernel_daddr_t&nbsp;daddr_t;<BR>typedef __kernel_key_t&nbsp;&nbsp;key_t;<BR>typedef __kernel_suseconds_t&nbsp;suseconds_t;<BR>typedef __kernel_timer_t&nbsp;timer_t;<BR>typedef __kernel_clockid_t&nbsp;clockid_t;<BR>typedef __kernel_mqd_t&nbsp;&nbsp;mqd_t;</P>
<P>typedef _Bool&nbsp;&nbsp;&nbsp;bool;</P>
<P>typedef __kernel_uid32_t&nbsp;uid_t;<BR>typedef __kernel_gid32_t&nbsp;gid_t;<BR>typedef __kernel_uid16_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid16_t;<BR>typedef __kernel_gid16_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid16_t;</P>
<P>typedef unsigned long&nbsp;&nbsp;uintptr_t;</P>
<P>#ifdef CONFIG_UID16<BR>/* This is defined by include/asm-{arch}/posix_types.h */<BR>typedef __kernel_old_uid_t&nbsp;old_uid_t;<BR>typedef __kernel_old_gid_t&nbsp;old_gid_t;<BR>#endif /* CONFIG_UID16 */</P>
<P>#if defined(__GNUC__)<BR>typedef __kernel_loff_t&nbsp;&nbsp;loff_t;<BR>#endif</P>
<P>/*<BR>&nbsp;* The following typedefs are also protected by individual ifdefs for<BR>&nbsp;* historical reasons:<BR>&nbsp;*/<BR>#ifndef _SIZE_T<BR>#define _SIZE_T<BR>typedef __kernel_size_t&nbsp;&nbsp;size_t;<BR>#endif</P>
<P>#ifndef _SSIZE_T<BR>#define _SSIZE_T<BR>typedef __kernel_ssize_t&nbsp;ssize_t;<BR>#endif</P>
<P>#ifndef _PTRDIFF_T<BR>#define _PTRDIFF_T<BR>typedef __kernel_ptrdiff_t&nbsp;ptrdiff_t;<BR>#endif</P>
<P>#ifndef _TIME_T<BR>#define _TIME_T<BR>typedef __kernel_time_t&nbsp;&nbsp;time_t;<BR>#endif</P>
<P>#ifndef _CLOCK_T<BR>#define _CLOCK_T<BR>typedef __kernel_clock_t&nbsp;clock_t;<BR>#endif</P>
<P>#ifndef _CADDR_T<BR>#define _CADDR_T<BR>typedef __kernel_caddr_t&nbsp;caddr_t;<BR>#endif</P>
<P><FONT class=extract>/* bsd */<BR>typedef unsigned char&nbsp;&nbsp;u_char;<BR>typedef unsigned short&nbsp;&nbsp;u_short;<BR>typedef unsigned int&nbsp;&nbsp;u_int;<BR>typedef unsigned long&nbsp;&nbsp;u_long;</FONT></P>
<P><FONT class=extract>/* sysv */<BR>typedef unsigned char&nbsp;&nbsp;unchar;<BR>typedef unsigned short&nbsp;&nbsp;ushort;<BR>typedef unsigned int&nbsp;&nbsp;uint;<BR>typedef unsigned long&nbsp;&nbsp;ulong;</FONT></P>
<P><FONT class=extract>#ifndef __BIT_TYPES_DEFINED__<BR>#define __BIT_TYPES_DEFINED__</FONT></P>
<P><FONT class=extract>typedef&nbsp;&nbsp;__u8&nbsp;&nbsp;u_int8_t;<BR>typedef&nbsp;&nbsp;__s8&nbsp;&nbsp;int8_t;<BR>typedef&nbsp;&nbsp;__u16&nbsp;&nbsp;u_int16_t;<BR>typedef&nbsp;&nbsp;__s16&nbsp;&nbsp;int16_t;<BR>typedef&nbsp;&nbsp;__u32&nbsp;&nbsp;u_int32_t;<BR>typedef&nbsp;&nbsp;__s32&nbsp;&nbsp;int32_t;</FONT></P>
<P><FONT class=extract>#endif /* !(__BIT_TYPES_DEFINED__) */</FONT></P>
<P><FONT class=extract>typedef&nbsp;&nbsp;__u8&nbsp;&nbsp;uint8_t;<BR>typedef&nbsp;&nbsp;__u16&nbsp;&nbsp;uint16_t;<BR>typedef&nbsp;&nbsp;__u32&nbsp;&nbsp;uint32_t;</FONT></P>
<P><FONT class=extract>#if defined(__GNUC__)<BR>typedef&nbsp;&nbsp;__u64&nbsp;&nbsp;uint64_t;<BR>typedef&nbsp;&nbsp;__u64&nbsp;&nbsp;u_int64_t;<BR>typedef&nbsp;&nbsp;__s64&nbsp;&nbsp;int64_t;<BR>#endif</FONT></P>
<P>/* this is a special 64bit data type that is 8-byte aligned */<BR>#define aligned_u64 __u64 __attribute__((aligned(8)))<BR>#define aligned_be64 __be64 __attribute__((aligned(8)))<BR>#define aligned_le64 __le64 __attribute__((aligned(8)))</P>
<P>/**<BR>&nbsp;* The type used for indexing onto a disc or disc partition.<BR>&nbsp;*<BR>&nbsp;* Linux always considers sectors to be 512 bytes long independently<BR>&nbsp;* of the devices real block size.<BR>&nbsp;*<BR>&nbsp;* blkcnt_t is the type of the inode's block count.<BR>&nbsp;*/<BR>#ifdef CONFIG_LBDAF<BR>typedef u64 sector_t;<BR>typedef u64 blkcnt_t;<BR>#else<BR>typedef unsigned long sector_t;<BR>typedef unsigned long blkcnt_t;<BR>#endif</P>
<P>/*<BR>&nbsp;* The type of an index into the pagecache.<BR>&nbsp;*/<BR>#define pgoff_t unsigned long</P>
<P>/*<BR>&nbsp;* A dma_addr_t can hold any valid DMA address, i.e., any address returned<BR>&nbsp;* by the DMA API.<BR>&nbsp;*<BR>&nbsp;* If the DMA API only uses 32-bit addresses, dma_addr_t need only be 32<BR>&nbsp;* bits wide.&nbsp; Bus addresses, e.g., PCI BARs, may be wider than 32 bits,<BR>&nbsp;* but drivers do memory-mapped I/O to ioremapped kernel virtual addresses,<BR>&nbsp;* so they don't care about the size of the actual bus addresses.<BR>&nbsp;*/<BR>#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT<BR>typedef u64 dma_addr_t;<BR>#else<BR>typedef u32 dma_addr_t;<BR>#endif</P>
<P><FONT class=extract>typedef unsigned __bitwise__ gfp_t;<BR>typedef unsigned __bitwise__ fmode_t;<BR>typedef unsigned __bitwise__ oom_flags_t;</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_PHYS_ADDR_T_64BIT<BR>typedef u64 phys_addr_t;<BR>#else<BR>typedef u32 phys_addr_t;<BR>#endif</FONT></P>
<P><FONT class=extract>typedef phys_addr_t resource_size_t;</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* This type is the placeholder for a hardware interrupt number. It has to be<BR>&nbsp;* big enough to enclose whatever representation is used by a given platform.<BR>&nbsp;*/<BR>typedef unsigned long irq_hw_number_t;</FONT></P>
<P><FONT class=extract>typedef struct {<BR>&nbsp;int counter;<BR>} atomic_t;</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_64BIT<BR>typedef struct {<BR>&nbsp;long counter;<BR>} atomic64_t;<BR>#endif</FONT></P>
<P><FONT class=extract>struct list_head {<BR>&nbsp;struct list_head *next, *prev;<BR>};</FONT></P>
<P><FONT class=extract>struct hlist_head {<BR>&nbsp;struct hlist_node *first;<BR>};</FONT></P>
<P><FONT class=extract>struct hlist_node {<BR>&nbsp;struct hlist_node *next, **pprev;<BR>};</FONT></P>
<P>struct ustat {<BR>&nbsp;__kernel_daddr_t&nbsp;f_tfree;<BR>&nbsp;__kernel_ino_t&nbsp;&nbsp;f_tinode;<BR>&nbsp;char&nbsp;&nbsp;&nbsp;f_fname[6];<BR>&nbsp;char&nbsp;&nbsp;&nbsp;f_fpack[6];<BR>};</P>
<P>/**<BR>&nbsp;* struct callback_head - callback structure for use with RCU and task_work<BR>&nbsp;* @next: next update requests in a list<BR>&nbsp;* @func: actual update function to call after the grace period.<BR>&nbsp;*/<BR>struct callback_head {<BR>&nbsp;struct callback_head *next;<BR>&nbsp;void (*func)(struct callback_head *head);<BR>};<BR>#define rcu_head callback_head</P>
<P>/* clocksource cycle base type */<BR>typedef u64 cycle_t;</P>
<P>#endif /*&nbsp; __ASSEMBLY__ */<BR>#endif /* _LINUX_TYPES_H */