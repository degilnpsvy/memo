kernel/sched/completion.c 
<P></P>
<P><FONT class=extract>/*<BR>&nbsp;* Generic wait-for-completion handler;<BR>&nbsp;*<BR>&nbsp;* It differs from semaphores in that their default case is the opposite,<BR>&nbsp;* wait_for_completion default blocks whereas semaphore default non-block. The<BR>&nbsp;* interface also makes it easy to 'complete' multiple waiting threads,<BR>&nbsp;* something which isn't entirely natural for semaphores.<BR>&nbsp;*<BR>&nbsp;* But more importantly, the primitive documents the usage. Semaphores would<BR>&nbsp;* typically be used for exclusion which gives rise to priority inversion.<BR>&nbsp;* Waiting for completion is a typically sync point, but not an exclusion point.<BR>&nbsp;*/</FONT></P>
<P></P>
<P>#include &lt;linux/sched.h&gt;<BR>#include &lt;linux/completion.h&gt;</P>
<P><FONT class=extract>/**<BR>&nbsp;* complete: - signals a single thread waiting on this completion<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;*<BR>&nbsp;* This will wake up a single thread waiting on this completion. Threads will be<BR>&nbsp;* awakened in the same order in which they were queued.<BR>&nbsp;*<BR>&nbsp;* See also complete_all(), wait_for_completion() and related routines.<BR>&nbsp;*<BR>&nbsp;* It may be assumed that this function implies a write memory barrier before<BR>&nbsp;* changing the task state if and only if any tasks are woken up.<BR>&nbsp;*/<BR>void complete(struct completion *x)<BR>{<BR>&nbsp;unsigned long flags;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock_irqsave(&amp;x-&gt;wait.lock, flags);<BR>&nbsp;x-&gt;done++;<BR>&nbsp;__wake_up_locked(&amp;x-&gt;wait, TASK_NORMAL, 1);<BR>&nbsp;spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags);<BR>}<BR>EXPORT_SYMBOL(complete);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* complete_all: - signals all threads waiting on this completion<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;*<BR>&nbsp;* This will wake up all threads waiting on this particular completion event.<BR>&nbsp;*<BR>&nbsp;* It may be assumed that this function implies a write memory barrier before<BR>&nbsp;* changing the task state if and only if any tasks are woken up.<BR>&nbsp;*/<BR>void complete_all(struct completion *x)<BR>{<BR>&nbsp;unsigned long flags;</FONT></P>
<P><FONT class=extract>&nbsp;spin_lock_irqsave(&amp;x-&gt;wait.lock, flags);<BR>&nbsp;x-&gt;done += UINT_MAX/2;<BR>&nbsp;__wake_up_locked(&amp;x-&gt;wait, TASK_NORMAL, 0);<BR>&nbsp;spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags);<BR>}<BR>EXPORT_SYMBOL(complete_all);</FONT></P>
<P>static inline long __sched<BR>do_wait_for_common(struct completion *x,<BR>&nbsp;&nbsp;&nbsp;&nbsp; long (*action)(long), long timeout, int state)<BR>{<BR>&nbsp;if (!x-&gt;done) {<BR>&nbsp;&nbsp;DECLARE_WAITQUEUE(wait, current);</P>
<P>&nbsp;&nbsp;__add_wait_queue_tail_exclusive(&amp;x-&gt;wait, &amp;wait);<BR>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;if (signal_pending_state(state, current)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;timeout = -ERESTARTSYS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;__set_current_state(state);<BR>&nbsp;&nbsp;&nbsp;spin_unlock_irq(&amp;x-&gt;wait.lock);<BR>&nbsp;&nbsp;&nbsp;timeout = action(timeout);<BR>&nbsp;&nbsp;&nbsp;spin_lock_irq(&amp;x-&gt;wait.lock);<BR>&nbsp;&nbsp;} while (!x-&gt;done &amp;&amp; timeout);<BR>&nbsp;&nbsp;__remove_wait_queue(&amp;x-&gt;wait, &amp;wait);<BR>&nbsp;&nbsp;if (!x-&gt;done)<BR>&nbsp;&nbsp;&nbsp;return timeout;<BR>&nbsp;}<BR>&nbsp;x-&gt;done--;<BR>&nbsp;return timeout ?: 1;<BR>}</P>
<P>static inline long __sched<BR>__wait_for_common(struct completion *x,<BR>&nbsp;&nbsp;&nbsp; long (*action)(long), long timeout, int state)<BR>{<BR>&nbsp;might_sleep();</P>
<P>&nbsp;spin_lock_irq(&amp;x-&gt;wait.lock);<BR>&nbsp;timeout = do_wait_for_common(x, action, timeout, state);<BR>&nbsp;spin_unlock_irq(&amp;x-&gt;wait.lock);<BR>&nbsp;return timeout;<BR>}</P>
<P>static long __sched<BR>wait_for_common(struct completion *x, long timeout, int state)<BR>{<BR>&nbsp;return __wait_for_common(x, schedule_timeout, timeout, state);<BR>}</P>
<P>static long __sched<BR>wait_for_common_io(struct completion *x, long timeout, int state)<BR>{<BR>&nbsp;return __wait_for_common(x, io_schedule_timeout, timeout, state);<BR>}</P>
<P>/**<BR>&nbsp;* wait_for_completion: - waits for completion of a task<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;*<BR>&nbsp;* This waits to be signaled for completion of a specific task. It is NOT<BR>&nbsp;* interruptible and there is no timeout.<BR>&nbsp;*<BR>&nbsp;* See also similar routines (i.e. wait_for_completion_timeout()) with timeout<BR>&nbsp;* and interrupt capability. Also see complete().<BR>&nbsp;*/<BR>void __sched wait_for_completion(struct completion *x)<BR>{<BR>&nbsp;wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_UNINTERRUPTIBLE);<BR>}<BR>EXPORT_SYMBOL(wait_for_completion);</P>
<P>/**<BR>&nbsp;* wait_for_completion_timeout: - waits for completion of a task (w/timeout)<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;* @timeout:&nbsp; timeout value in jiffies<BR>&nbsp;*<BR>&nbsp;* This waits for either a completion of a specific task to be signaled or for a<BR>&nbsp;* specified timeout to expire. The timeout is in jiffies. It is not<BR>&nbsp;* interruptible.<BR>&nbsp;*<BR>&nbsp;* Return: 0 if timed out, and positive (at least 1, or number of jiffies left<BR>&nbsp;* till timeout) if completed.<BR>&nbsp;*/<BR>unsigned long __sched<BR>wait_for_completion_timeout(struct completion *x, unsigned long timeout)<BR>{<BR>&nbsp;return wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);<BR>}<BR>EXPORT_SYMBOL(wait_for_completion_timeout);</P>
<P>/**<BR>&nbsp;* wait_for_completion_io: - waits for completion of a task<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;*<BR>&nbsp;* This waits to be signaled for completion of a specific task. It is NOT<BR>&nbsp;* interruptible and there is no timeout. The caller is accounted as waiting<BR>&nbsp;* for IO (which traditionally means blkio only).<BR>&nbsp;*/<BR>void __sched wait_for_completion_io(struct completion *x)<BR>{<BR>&nbsp;wait_for_common_io(x, MAX_SCHEDULE_TIMEOUT, TASK_UNINTERRUPTIBLE);<BR>}<BR>EXPORT_SYMBOL(wait_for_completion_io);</P>
<P>/**<BR>&nbsp;* wait_for_completion_io_timeout: - waits for completion of a task (w/timeout)<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;* @timeout:&nbsp; timeout value in jiffies<BR>&nbsp;*<BR>&nbsp;* This waits for either a completion of a specific task to be signaled or for a<BR>&nbsp;* specified timeout to expire. The timeout is in jiffies. It is not<BR>&nbsp;* interruptible. The caller is accounted as waiting for IO (which traditionally<BR>&nbsp;* means blkio only).<BR>&nbsp;*<BR>&nbsp;* Return: 0 if timed out, and positive (at least 1, or number of jiffies left<BR>&nbsp;* till timeout) if completed.<BR>&nbsp;*/<BR>unsigned long __sched<BR>wait_for_completion_io_timeout(struct completion *x, unsigned long timeout)<BR>{<BR>&nbsp;return wait_for_common_io(x, timeout, TASK_UNINTERRUPTIBLE);<BR>}<BR>EXPORT_SYMBOL(wait_for_completion_io_timeout);</P>
<P>/**<BR>&nbsp;* wait_for_completion_interruptible: - waits for completion of a task (w/intr)<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;*<BR>&nbsp;* This waits for completion of a specific task to be signaled. It is<BR>&nbsp;* interruptible.<BR>&nbsp;*<BR>&nbsp;* Return: -ERESTARTSYS if interrupted, 0 if completed.<BR>&nbsp;*/<BR>int __sched wait_for_completion_interruptible(struct completion *x)<BR>{<BR>&nbsp;long t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_INTERRUPTIBLE);<BR>&nbsp;if (t == -ERESTARTSYS)<BR>&nbsp;&nbsp;return t;<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL(wait_for_completion_interruptible);</P>
<P>/**<BR>&nbsp;* wait_for_completion_interruptible_timeout: - waits for completion (w/(to,intr))<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;* @timeout:&nbsp; timeout value in jiffies<BR>&nbsp;*<BR>&nbsp;* This waits for either a completion of a specific task to be signaled or for a<BR>&nbsp;* specified timeout to expire. It is interruptible. The timeout is in jiffies.<BR>&nbsp;*<BR>&nbsp;* Return: -ERESTARTSYS if interrupted, 0 if timed out, positive (at least 1,<BR>&nbsp;* or number of jiffies left till timeout) if completed.<BR>&nbsp;*/<BR>long __sched<BR>wait_for_completion_interruptible_timeout(struct completion *x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long timeout)<BR>{<BR>&nbsp;return wait_for_common(x, timeout, TASK_INTERRUPTIBLE);<BR>}<BR>EXPORT_SYMBOL(wait_for_completion_interruptible_timeout);</P>
<P>/**<BR>&nbsp;* wait_for_completion_killable: - waits for completion of a task (killable)<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;*<BR>&nbsp;* This waits to be signaled for completion of a specific task. It can be<BR>&nbsp;* interrupted by a kill signal.<BR>&nbsp;*<BR>&nbsp;* Return: -ERESTARTSYS if interrupted, 0 if completed.<BR>&nbsp;*/<BR>int __sched wait_for_completion_killable(struct completion *x)<BR>{<BR>&nbsp;long t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_KILLABLE);<BR>&nbsp;if (t == -ERESTARTSYS)<BR>&nbsp;&nbsp;return t;<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL(wait_for_completion_killable);</P>
<P>/**<BR>&nbsp;* wait_for_completion_killable_timeout: - waits for completion of a task (w/(to,killable))<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;* @timeout:&nbsp; timeout value in jiffies<BR>&nbsp;*<BR>&nbsp;* This waits for either a completion of a specific task to be<BR>&nbsp;* signaled or for a specified timeout to expire. It can be<BR>&nbsp;* interrupted by a kill signal. The timeout is in jiffies.<BR>&nbsp;*<BR>&nbsp;* Return: -ERESTARTSYS if interrupted, 0 if timed out, positive (at least 1,<BR>&nbsp;* or number of jiffies left till timeout) if completed.<BR>&nbsp;*/<BR>long __sched<BR>wait_for_completion_killable_timeout(struct completion *x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long timeout)<BR>{<BR>&nbsp;return wait_for_common(x, timeout, TASK_KILLABLE);<BR>}<BR>EXPORT_SYMBOL(wait_for_completion_killable_timeout);</P>
<P>/**<BR>&nbsp;*&nbsp;try_wait_for_completion - try to decrement a completion without blocking<BR>&nbsp;*&nbsp;@x:&nbsp;completion structure<BR>&nbsp;*<BR>&nbsp;*&nbsp;Return: 0 if a decrement cannot be done without blocking<BR>&nbsp;*&nbsp;&nbsp; 1 if a decrement succeeded.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If a completion is being used as a counting completion,<BR>&nbsp;*&nbsp;attempt to decrement the counter without blocking. This<BR>&nbsp;*&nbsp;enables us to avoid waiting if the resource the completion<BR>&nbsp;*&nbsp;is protecting is not available.<BR>&nbsp;*/<BR>bool try_wait_for_completion(struct completion *x)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret = 1;</P>
<P>&nbsp;/*<BR>&nbsp; * Since x-&gt;done will need to be locked only<BR>&nbsp; * in the non-blocking case, we check x-&gt;done<BR>&nbsp; * first without taking the lock so we can<BR>&nbsp; * return early in the blocking case.<BR>&nbsp; */<BR>&nbsp;if (!READ_ONCE(x-&gt;done))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;spin_lock_irqsave(&amp;x-&gt;wait.lock, flags);<BR>&nbsp;if (!x-&gt;done)<BR>&nbsp;&nbsp;ret = 0;<BR>&nbsp;else<BR>&nbsp;&nbsp;x-&gt;done--;<BR>&nbsp;spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(try_wait_for_completion);</P>
<P>/**<BR>&nbsp;*&nbsp;completion_done - Test to see if a completion has any waiters<BR>&nbsp;*&nbsp;@x:&nbsp;completion structure<BR>&nbsp;*<BR>&nbsp;*&nbsp;Return: 0 if there are waiters (wait_for_completion() in progress)<BR>&nbsp;*&nbsp;&nbsp; 1 if there are no waiters.<BR>&nbsp;*<BR>&nbsp;*/<BR>bool completion_done(struct completion *x)<BR>{<BR>&nbsp;if (!READ_ONCE(x-&gt;done))<BR>&nbsp;&nbsp;return false;</P>
<P>&nbsp;/*<BR>&nbsp; * If -&gt;done, we need to wait for complete() to release -&gt;wait.lock<BR>&nbsp; * otherwise we can end up freeing the completion before complete()<BR>&nbsp; * is done referencing it.<BR>&nbsp; *<BR>&nbsp; * The RMB pairs with complete()'s RELEASE of -&gt;wait.lock and orders<BR>&nbsp; * the loads of -&gt;done and -&gt;wait.lock such that we cannot observe<BR>&nbsp; * the lock before complete() acquires it while observing the -&gt;done<BR>&nbsp; * after it's acquired the lock.<BR>&nbsp; */<BR>&nbsp;smp_rmb();<BR>&nbsp;spin_unlock_wait(&amp;x-&gt;wait.lock);<BR>&nbsp;return true;<BR>}<BR>EXPORT_SYMBOL(completion_done);