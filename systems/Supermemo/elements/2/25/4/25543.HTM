include/linux/rwlock.h
<P></P>
<P>#ifndef __LINUX_RWLOCK_H<BR>#define __LINUX_RWLOCK_H</P>
<P></P>
<P>#ifndef __LINUX_SPINLOCK_H<BR># error "please don't include this file directly"<BR>#endif</P>
<P>/*<BR>&nbsp;* rwlock related methods<BR>&nbsp;*<BR>&nbsp;* split out from spinlock.h<BR>&nbsp;*<BR>&nbsp;* portions Copyright 2005, Red Hat, Inc., Ingo Molnar<BR>&nbsp;* Released under the General Public License (GPL).<BR>&nbsp;*/</P>
<P>#ifdef CONFIG_DEBUG_SPINLOCK<BR>&nbsp; extern void __rwlock_init(rwlock_t *lock, const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct lock_class_key *key);<BR># define rwlock_init(lock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static struct lock_class_key __key;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__rwlock_init((lock), #lock, &amp;__key);&nbsp;&nbsp;&nbsp;\<BR>} while (0)<BR>#else<BR># define rwlock_init(lock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do { *(lock) = __RW_LOCK_UNLOCKED(lock); } while (0)<BR>#endif</P>
<P>#ifdef CONFIG_DEBUG_SPINLOCK<BR>&nbsp;extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);<BR>#define do_raw_read_lock_flags(lock, flags) do_raw_read_lock(lock)<BR>&nbsp;extern int do_raw_read_trylock(rwlock_t *lock);<BR>&nbsp;extern void do_raw_read_unlock(rwlock_t *lock) __releases(lock);<BR>&nbsp;extern void do_raw_write_lock(rwlock_t *lock) __acquires(lock);<BR>#define do_raw_write_lock_flags(lock, flags) do_raw_write_lock(lock)<BR>&nbsp;extern int do_raw_write_trylock(rwlock_t *lock);<BR>&nbsp;extern void do_raw_write_unlock(rwlock_t *lock) __releases(lock);<BR>#else<BR># define do_raw_read_lock(rwlock)&nbsp;do {__acquire(lock); arch_read_lock(&amp;(rwlock)-&gt;raw_lock); } while (0)<BR># define do_raw_read_lock_flags(lock, flags) \<BR>&nbsp;&nbsp;do {__acquire(lock); arch_read_lock_flags(&amp;(lock)-&gt;raw_lock, *(flags)); } while (0)<BR># define do_raw_read_trylock(rwlock)&nbsp;arch_read_trylock(&amp;(rwlock)-&gt;raw_lock)<BR># define do_raw_read_unlock(rwlock)&nbsp;do {arch_read_unlock(&amp;(rwlock)-&gt;raw_lock); __release(lock); } while (0)<BR># define do_raw_write_lock(rwlock)&nbsp;do {__acquire(lock); arch_write_lock(&amp;(rwlock)-&gt;raw_lock); } while (0)<BR># define do_raw_write_lock_flags(lock, flags) \<BR>&nbsp;&nbsp;do {__acquire(lock); arch_write_lock_flags(&amp;(lock)-&gt;raw_lock, *(flags)); } while (0)<BR># define do_raw_write_trylock(rwlock)&nbsp;arch_write_trylock(&amp;(rwlock)-&gt;raw_lock)<BR># define do_raw_write_unlock(rwlock)&nbsp;do {arch_write_unlock(&amp;(rwlock)-&gt;raw_lock); __release(lock); } while (0)<BR>#endif</P>
<P>#define read_can_lock(rwlock)&nbsp;&nbsp;arch_read_can_lock(&amp;(rwlock)-&gt;raw_lock)<BR>#define write_can_lock(rwlock)&nbsp;&nbsp;arch_write_can_lock(&amp;(rwlock)-&gt;raw_lock)</P>
<P>/*<BR>&nbsp;* Define the various rw_lock methods.&nbsp; Note we define these<BR>&nbsp;* regardless of whether CONFIG_SMP or CONFIG_PREEMPT are set. The various<BR>&nbsp;* methods are defined as nops in the case they are not required.<BR>&nbsp;*/<BR>#define read_trylock(lock)&nbsp;__cond_lock(lock, _raw_read_trylock(lock))<BR>#define write_trylock(lock)&nbsp;__cond_lock(lock, _raw_write_trylock(lock))</P>
<P>#define write_lock(lock)&nbsp;_raw_write_lock(lock)<BR>#define read_lock(lock)&nbsp;&nbsp;_raw_read_lock(lock)</P>
<P>#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</P>
<P>#define read_lock_irqsave(lock, flags)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;typecheck(unsigned long, flags);&nbsp;\<BR>&nbsp;&nbsp;flags = _raw_read_lock_irqsave(lock);&nbsp;\<BR>&nbsp;} while (0)<BR>#define write_lock_irqsave(lock, flags)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;typecheck(unsigned long, flags);&nbsp;\<BR>&nbsp;&nbsp;flags = _raw_write_lock_irqsave(lock);&nbsp;\<BR>&nbsp;} while (0)</P>
<P>#else</P>
<P>#define read_lock_irqsave(lock, flags)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;typecheck(unsigned long, flags);&nbsp;\<BR>&nbsp;&nbsp;_raw_read_lock_irqsave(lock, flags);&nbsp;\<BR>&nbsp;} while (0)<BR>#define write_lock_irqsave(lock, flags)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;typecheck(unsigned long, flags);&nbsp;\<BR>&nbsp;&nbsp;_raw_write_lock_irqsave(lock, flags);&nbsp;\<BR>&nbsp;} while (0)</P>
<P>#endif</P>
<P>#define read_lock_irq(lock)&nbsp;&nbsp;_raw_read_lock_irq(lock)<BR>#define read_lock_bh(lock)&nbsp;&nbsp;_raw_read_lock_bh(lock)<BR>#define write_lock_irq(lock)&nbsp;&nbsp;_raw_write_lock_irq(lock)<BR>#define write_lock_bh(lock)&nbsp;&nbsp;_raw_write_lock_bh(lock)<BR>#define read_unlock(lock)&nbsp;&nbsp;_raw_read_unlock(lock)<BR>#define write_unlock(lock)&nbsp;&nbsp;_raw_write_unlock(lock)<BR>#define read_unlock_irq(lock)&nbsp;&nbsp;_raw_read_unlock_irq(lock)<BR>#define write_unlock_irq(lock)&nbsp;&nbsp;_raw_write_unlock_irq(lock)</P>
<P>#define read_unlock_irqrestore(lock, flags)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;typecheck(unsigned long, flags);&nbsp;&nbsp;\<BR>&nbsp;&nbsp;_raw_read_unlock_irqrestore(lock, flags);&nbsp;\<BR>&nbsp;} while (0)<BR>#define read_unlock_bh(lock)&nbsp;&nbsp;_raw_read_unlock_bh(lock)</P>
<P>#define write_unlock_irqrestore(lock, flags)&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;typecheck(unsigned long, flags);&nbsp;\<BR>&nbsp;&nbsp;_raw_write_unlock_irqrestore(lock, flags);&nbsp;\<BR>&nbsp;} while (0)<BR>#define write_unlock_bh(lock)&nbsp;&nbsp;_raw_write_unlock_bh(lock)</P>
<P>#define write_trylock_irqsave(lock, flags) \<BR>({ \<BR>&nbsp;local_irq_save(flags); \<BR>&nbsp;write_trylock(lock) ? \<BR>&nbsp;1 : ({ local_irq_restore(flags); 0; }); \<BR>})</P>
<P>#endif /* __LINUX_RWLOCK_H */