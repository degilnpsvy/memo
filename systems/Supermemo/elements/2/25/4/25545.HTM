include/linux/jiffies.h 
<P></P>
<P>#ifndef _LINUX_JIFFIES_H<BR>#define _LINUX_JIFFIES_H</P>
<P></P>
<P>#include &lt;linux/math64.h&gt;<BR>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/types.h&gt;<BR>#include &lt;linux/time.h&gt;<BR>#include &lt;linux/timex.h&gt;<BR>#include &lt;asm/param.h&gt;&nbsp;&nbsp;&nbsp;/* for HZ */<BR>#include &lt;generated/timeconst.h&gt;</P>
<P>/*<BR>&nbsp;* The following defines establish the engineering parameters of the PLL<BR>&nbsp;* model. The HZ variable establishes the timer interrupt frequency, 100 Hz<BR>&nbsp;* for the SunOS kernel, 256 Hz for the Ultrix kernel and 1024 Hz for the<BR>&nbsp;* OSF/1 kernel. The SHIFT_HZ define expresses the same value as the<BR>&nbsp;* nearest power of two in order to avoid hardware multiply operations.<BR>&nbsp;*/<BR>#if HZ &gt;= 12 &amp;&amp; HZ &lt; 24<BR># define SHIFT_HZ&nbsp;4<BR>#elif HZ &gt;= 24 &amp;&amp; HZ &lt; 48<BR># define SHIFT_HZ&nbsp;5<BR>#elif HZ &gt;= 48 &amp;&amp; HZ &lt; 96<BR># define SHIFT_HZ&nbsp;6<BR>#elif HZ &gt;= 96 &amp;&amp; HZ &lt; 192<BR># define SHIFT_HZ&nbsp;7<BR>#elif HZ &gt;= 192 &amp;&amp; HZ &lt; 384<BR># define SHIFT_HZ&nbsp;8<BR>#elif HZ &gt;= 384 &amp;&amp; HZ &lt; 768<BR># define SHIFT_HZ&nbsp;9<BR>#elif HZ &gt;= 768 &amp;&amp; HZ &lt; 1536<BR># define SHIFT_HZ&nbsp;10<BR>#elif HZ &gt;= 1536 &amp;&amp; HZ &lt; 3072<BR># define SHIFT_HZ&nbsp;11<BR>#elif HZ &gt;= 3072 &amp;&amp; HZ &lt; 6144<BR># define SHIFT_HZ&nbsp;12<BR>#elif HZ &gt;= 6144 &amp;&amp; HZ &lt; 12288<BR># define SHIFT_HZ&nbsp;13<BR>#else<BR># error Invalid value of HZ.<BR>#endif</P>
<P>/* Suppose we want to divide two numbers NOM and DEN: NOM/DEN, then we can<BR>&nbsp;* improve accuracy by shifting LSH bits, hence calculating:<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; (NOM &lt;&lt; LSH) / DEN<BR>&nbsp;* This however means trouble for large NOM, because (NOM &lt;&lt; LSH) may no<BR>&nbsp;* longer fit in 32 bits. The following way of calculating this gives us<BR>&nbsp;* some slack, under the following conditions:<BR>&nbsp;*&nbsp;&nbsp; - (NOM / DEN) fits in (32 - LSH) bits.<BR>&nbsp;*&nbsp;&nbsp; - (NOM % DEN) fits in (32 - LSH) bits.<BR>&nbsp;*/<BR>#define SH_DIV(NOM,DEN,LSH) (&nbsp;&nbsp; (((NOM) / (DEN)) &lt;&lt; (LSH))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + ((((NOM) % (DEN)) &lt;&lt; (LSH)) + (DEN) / 2) / (DEN))</P>
<P>/* LATCH is used in the interval timer and ftape setup. */<BR>#define LATCH ((CLOCK_TICK_RATE + HZ/2) / HZ)&nbsp;/* For divider */</P>
<P>extern int register_refined_jiffies(long clock_tick_rate);</P>
<P>/* TICK_NSEC is the time between ticks in nsec assuming SHIFTED_HZ */<BR>#define TICK_NSEC ((NSEC_PER_SEC+HZ/2)/HZ)</P>
<P>/* TICK_USEC is the time between ticks in usec assuming fake USER_HZ */<BR>#define TICK_USEC ((1000000UL + USER_HZ/2) / USER_HZ)</P>
<P>/* some arch's have a small-data section that can be accessed register-relative<BR>&nbsp;* but that can only take up to, say, 4-byte variables. jiffies being part of<BR>&nbsp;* an 8-byte variable may not be correctly accessed unless we force the issue<BR>&nbsp;*/<BR>#define __jiffy_data&nbsp; __attribute__((section(".data")))</P>
<P>/*<BR>&nbsp;* The 64-bit value is not atomic - you MUST NOT read it<BR>&nbsp;* without sampling the sequence number in jiffies_lock.<BR>&nbsp;* get_jiffies_64() will do this for you as appropriate.<BR>&nbsp;*/<BR>extern u64 __jiffy_data jiffies_64;<BR>extern unsigned long volatile __jiffy_data jiffies;</P>
<P>#if (BITS_PER_LONG &lt; 64)<BR>u64 get_jiffies_64(void);<BR>#else<BR>static inline u64 get_jiffies_64(void)<BR>{<BR>&nbsp;return (u64)jiffies;<BR>}<BR>#endif</P>
<P><FONT class=extract>/*<BR>&nbsp;*&nbsp;These inlines deal with timer wrapping correctly. You are <BR>&nbsp;*&nbsp;strongly encouraged to use them<BR>&nbsp;*&nbsp;1. Because people otherwise forget<BR>&nbsp;*&nbsp;2. Because if the timer wrap changes in future you won't have to<BR>&nbsp;*&nbsp;&nbsp;&nbsp; alter your driver code.<BR>&nbsp;*<BR>&nbsp;* time_after(a,b) returns true if the time a is after time b.<BR>&nbsp;*<BR>&nbsp;* Do this with "&lt;0" and "&gt;=0" to only test the sign of the result. A<BR>&nbsp;* good compiler would generate better code (and a really good compiler<BR>&nbsp;* wouldn't care). Gcc is currently neither.<BR>&nbsp;*/<BR>#define time_after(a,b)&nbsp;&nbsp;\<BR>&nbsp;(typecheck(unsigned long, a) &amp;&amp; \<BR>&nbsp; typecheck(unsigned long, b) &amp;&amp; \<BR>&nbsp; ((long)((b) - (a)) &lt; 0))<BR>#define time_before(a,b)&nbsp;time_after(b,a)</FONT></P>
<P><FONT class=extract>#define time_after_eq(a,b)&nbsp;\<BR>&nbsp;(typecheck(unsigned long, a) &amp;&amp; \<BR>&nbsp; typecheck(unsigned long, b) &amp;&amp; \<BR>&nbsp; ((long)((a) - (b)) &gt;= 0))<BR>#define time_before_eq(a,b)&nbsp;time_after_eq(b,a)</FONT></P>
<P>/*<BR>&nbsp;* Calculate whether a is in the range of [b, c].<BR>&nbsp;*/<BR>#define time_in_range(a,b,c) \<BR>&nbsp;(time_after_eq(a,b) &amp;&amp; \<BR>&nbsp; time_before_eq(a,c))</P>
<P>/*<BR>&nbsp;* Calculate whether a is in the range of [b, c).<BR>&nbsp;*/<BR>#define time_in_range_open(a,b,c) \<BR>&nbsp;(time_after_eq(a,b) &amp;&amp; \<BR>&nbsp; time_before(a,c))</P>
<P>/* Same as above, but does so with platform independent 64bit types.<BR>&nbsp;* These must be used when utilizing jiffies_64 (i.e. return value of<BR>&nbsp;* get_jiffies_64() */<BR>#define time_after64(a,b)&nbsp;\<BR>&nbsp;(typecheck(__u64, a) &amp;&amp;&nbsp;\<BR>&nbsp; typecheck(__u64, b) &amp;&amp; \<BR>&nbsp; ((__s64)((b) - (a)) &lt; 0))<BR>#define time_before64(a,b)&nbsp;time_after64(b,a)</P>
<P>#define time_after_eq64(a,b)&nbsp;\<BR>&nbsp;(typecheck(__u64, a) &amp;&amp; \<BR>&nbsp; typecheck(__u64, b) &amp;&amp; \<BR>&nbsp; ((__s64)((a) - (b)) &gt;= 0))<BR>#define time_before_eq64(a,b)&nbsp;time_after_eq64(b,a)</P>
<P>#define time_in_range64(a, b, c) \<BR>&nbsp;(time_after_eq64(a, b) &amp;&amp; \<BR>&nbsp; time_before_eq64(a, c))</P>
<P><FONT class=extract>/*<BR>&nbsp;* These four macros compare jiffies and 'a' for convenience.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>/* time_is_before_jiffies(a) return true if a is before jiffies */<BR>#define time_is_before_jiffies(a) time_after(jiffies, a)</FONT></P>
<P><FONT class=extract>/* time_is_after_jiffies(a) return true if a is after jiffies */<BR>#define time_is_after_jiffies(a) time_before(jiffies, a)</FONT></P>
<P><FONT class=extract>/* time_is_before_eq_jiffies(a) return true if a is before or equal to jiffies*/<BR>#define time_is_before_eq_jiffies(a) time_after_eq(jiffies, a)</FONT></P>
<P><FONT class=extract>/* time_is_after_eq_jiffies(a) return true if a is after or equal to jiffies*/<BR>#define time_is_after_eq_jiffies(a) time_before_eq(jiffies, a)</FONT></P>
<P>/*<BR>&nbsp;* Have the 32 bit jiffies value wrap 5 minutes after boot<BR>&nbsp;* so jiffies wrap bugs show up earlier.<BR>&nbsp;*/<BR>#define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))</P>
<P>/*<BR>&nbsp;* Change timeval to jiffies, trying to avoid the<BR>&nbsp;* most obvious overflows..<BR>&nbsp;*<BR>&nbsp;* And some not so obvious.<BR>&nbsp;*<BR>&nbsp;* Note that we don't want to return LONG_MAX, because<BR>&nbsp;* for various timeout reasons we often end up having<BR>&nbsp;* to wait "jiffies+1" in order to guarantee that we wait<BR>&nbsp;* at _least_ "jiffies" - so "jiffies+1" had better still<BR>&nbsp;* be positive.<BR>&nbsp;*/<BR>#define MAX_JIFFY_OFFSET ((LONG_MAX &gt;&gt; 1)-1)</P>
<P>extern unsigned long preset_lpj;</P>
<P>/*<BR>&nbsp;* We want to do realistic conversions of time so we need to use the same<BR>&nbsp;* values the update wall clock code uses as the jiffies size.&nbsp; This value<BR>&nbsp;* is: TICK_NSEC (which is defined in timex.h).&nbsp; This<BR>&nbsp;* is a constant and is in nanoseconds.&nbsp; We will use scaled math<BR>&nbsp;* with a set of scales defined here as SEC_JIFFIE_SC,&nbsp; USEC_JIFFIE_SC and<BR>&nbsp;* NSEC_JIFFIE_SC.&nbsp; Note that these defines contain nothing but<BR>&nbsp;* constants and so are computed at compile time.&nbsp; SHIFT_HZ (computed in<BR>&nbsp;* timex.h) adjusts the scaling for different HZ values.</P>
<P>&nbsp;* Scaled math???&nbsp; What is that?<BR>&nbsp;*<BR>&nbsp;* Scaled math is a way to do integer math on values that would,<BR>&nbsp;* otherwise, either overflow, underflow, or cause undesired div<BR>&nbsp;* instructions to appear in the execution path.&nbsp; In short, we "scale"<BR>&nbsp;* up the operands so they take more bits (more precision, less<BR>&nbsp;* underflow), do the desired operation and then "scale" the result back<BR>&nbsp;* by the same amount.&nbsp; If we do the scaling by shifting we avoid the<BR>&nbsp;* costly mpy and the dastardly div instructions.</P>
<P>&nbsp;* Suppose, for example, we want to convert from seconds to jiffies<BR>&nbsp;* where jiffies is defined in nanoseconds as NSEC_PER_JIFFIE.&nbsp; The<BR>&nbsp;* simple math is: jiff = (sec * NSEC_PER_SEC) / NSEC_PER_JIFFIE; We<BR>&nbsp;* observe that (NSEC_PER_SEC / NSEC_PER_JIFFIE) is a constant which we<BR>&nbsp;* might calculate at compile time, however, the result will only have<BR>&nbsp;* about 3-4 bits of precision (less for smaller values of HZ).<BR>&nbsp;*<BR>&nbsp;* So, we scale as follows:<BR>&nbsp;* jiff = (sec) * (NSEC_PER_SEC / NSEC_PER_JIFFIE);<BR>&nbsp;* jiff = ((sec) * ((NSEC_PER_SEC * SCALE)/ NSEC_PER_JIFFIE)) / SCALE;<BR>&nbsp;* Then we make SCALE a power of two so:<BR>&nbsp;* jiff = ((sec) * ((NSEC_PER_SEC &lt;&lt; SCALE)/ NSEC_PER_JIFFIE)) &gt;&gt; SCALE;<BR>&nbsp;* Now we define:<BR>&nbsp;* #define SEC_CONV = ((NSEC_PER_SEC &lt;&lt; SCALE)/ NSEC_PER_JIFFIE))<BR>&nbsp;* jiff = (sec * SEC_CONV) &gt;&gt; SCALE;<BR>&nbsp;*<BR>&nbsp;* Often the math we use will expand beyond 32-bits so we tell C how to<BR>&nbsp;* do this and pass the 64-bit result of the mpy through the "&gt;&gt; SCALE"<BR>&nbsp;* which should take the result back to 32-bits.&nbsp; We want this expansion<BR>&nbsp;* to capture as much precision as possible.&nbsp; At the same time we don't<BR>&nbsp;* want to overflow so we pick the SCALE to avoid this.&nbsp; In this file,<BR>&nbsp;* that means using a different scale for each range of HZ values (as<BR>&nbsp;* defined in timex.h).<BR>&nbsp;*<BR>&nbsp;* For those who want to know, gcc will give a 64-bit result from a "*"<BR>&nbsp;* operator if the result is a long long AND at least one of the<BR>&nbsp;* operands is cast to long long (usually just prior to the "*" so as<BR>&nbsp;* not to confuse it into thinking it really has a 64-bit operand,<BR>&nbsp;* which, buy the way, it can do, but it takes more code and at least 2<BR>&nbsp;* mpys).</P>
<P>&nbsp;* We also need to be aware that one second in nanoseconds is only a<BR>&nbsp;* couple of bits away from overflowing a 32-bit word, so we MUST use<BR>&nbsp;* 64-bits to get the full range time in nanoseconds.</P>
<P>&nbsp;*/</P>
<P>/*<BR>&nbsp;* Here are the scales we will use.&nbsp; One for seconds, nanoseconds and<BR>&nbsp;* microseconds.<BR>&nbsp;*<BR>&nbsp;* Within the limits of cpp we do a rough cut at the SEC_JIFFIE_SC and<BR>&nbsp;* check if the sign bit is set.&nbsp; If not, we bump the shift count by 1.<BR>&nbsp;* (Gets an extra bit of precision where we can use it.)<BR>&nbsp;* We know it is set for HZ = 1024 and HZ = 100 not for 1000.<BR>&nbsp;* Haven't tested others.</P>
<P>&nbsp;* Limits of cpp (for #if expressions) only long (no long long), but<BR>&nbsp;* then we only need the most signicant bit.<BR>&nbsp;*/</P>
<P>#define SEC_JIFFIE_SC (31 - SHIFT_HZ)<BR>#if !((((NSEC_PER_SEC &lt;&lt; 2) / TICK_NSEC) &lt;&lt; (SEC_JIFFIE_SC - 2)) &amp; 0x80000000)<BR>#undef SEC_JIFFIE_SC<BR>#define SEC_JIFFIE_SC (32 - SHIFT_HZ)<BR>#endif<BR>#define NSEC_JIFFIE_SC (SEC_JIFFIE_SC + 29)<BR>#define SEC_CONVERSION ((unsigned long)((((u64)NSEC_PER_SEC &lt;&lt; SEC_JIFFIE_SC) +\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TICK_NSEC -1) / (u64)TICK_NSEC))</P>
<P>#define NSEC_CONVERSION ((unsigned long)((((u64)1 &lt;&lt; NSEC_JIFFIE_SC) +\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TICK_NSEC -1) / (u64)TICK_NSEC))<BR>/*<BR>&nbsp;* The maximum jiffie value is (MAX_INT &gt;&gt; 1).&nbsp; Here we translate that<BR>&nbsp;* into seconds.&nbsp; The 64-bit case will overflow if we are not careful,<BR>&nbsp;* so use the messy SH_DIV macro to do it.&nbsp; Still all constants.<BR>&nbsp;*/<BR>#if BITS_PER_LONG &lt; 64<BR># define MAX_SEC_IN_JIFFIES \<BR>&nbsp;(long)((u64)((u64)MAX_JIFFY_OFFSET * TICK_NSEC) / NSEC_PER_SEC)<BR>#else&nbsp;/* take care of overflow on 64 bits machines */<BR># define MAX_SEC_IN_JIFFIES \<BR>&nbsp;(SH_DIV((MAX_JIFFY_OFFSET &gt;&gt; SEC_JIFFIE_SC) * TICK_NSEC, NSEC_PER_SEC, 1) - 1)</P>
<P>#endif</P>
<P>/*<BR>&nbsp;* Convert various time units to each other:<BR>&nbsp;*/<BR>extern unsigned int jiffies_to_msecs(const unsigned long j);<BR>extern unsigned int jiffies_to_usecs(const unsigned long j);</P>
<P>static inline u64 jiffies_to_nsecs(const unsigned long j)<BR>{<BR>&nbsp;return (u64)jiffies_to_usecs(j) * NSEC_PER_USEC;<BR>}</P>
<P>extern unsigned long __msecs_to_jiffies(const unsigned int m);<BR>#if HZ &lt;= MSEC_PER_SEC &amp;&amp; !(MSEC_PER_SEC % HZ)<BR>/*<BR>&nbsp;* HZ is equal to or smaller than 1000, and 1000 is a nice round<BR>&nbsp;* multiple of HZ, divide with the factor between them, but round<BR>&nbsp;* upwards:<BR>&nbsp;*/<BR>static inline unsigned long _msecs_to_jiffies(const unsigned int m)<BR>{<BR>&nbsp;return (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);<BR>}<BR>#elif HZ &gt; MSEC_PER_SEC &amp;&amp; !(HZ % MSEC_PER_SEC)<BR>/*<BR>&nbsp;* HZ is larger than 1000, and HZ is a nice round multiple of 1000 -<BR>&nbsp;* simply multiply with the factor between them.<BR>&nbsp;*<BR>&nbsp;* But first make sure the multiplication result cannot overflow:<BR>&nbsp;*/<BR>static inline unsigned long _msecs_to_jiffies(const unsigned int m)<BR>{<BR>&nbsp;if (m &gt; jiffies_to_msecs(MAX_JIFFY_OFFSET))<BR>&nbsp;&nbsp;return MAX_JIFFY_OFFSET;<BR>&nbsp;return m * (HZ / MSEC_PER_SEC);<BR>}<BR>#else<BR>/*<BR>&nbsp;* Generic case - multiply, round and divide. But first check that if<BR>&nbsp;* we are doing a net multiplication, that we wouldn't overflow:<BR>&nbsp;*/<BR>static inline unsigned long _msecs_to_jiffies(const unsigned int m)<BR>{<BR>&nbsp;if (HZ &gt; MSEC_PER_SEC &amp;&amp; m &gt; jiffies_to_msecs(MAX_JIFFY_OFFSET))<BR>&nbsp;&nbsp;return MAX_JIFFY_OFFSET;</P>
<P>&nbsp;return (MSEC_TO_HZ_MUL32 * m + MSEC_TO_HZ_ADJ32) &gt;&gt; MSEC_TO_HZ_SHR32;<BR>}<BR>#endif<BR>/**<BR>&nbsp;* msecs_to_jiffies: - convert milliseconds to jiffies<BR>&nbsp;* @m:&nbsp;time in milliseconds<BR>&nbsp;*<BR>&nbsp;* conversion is done as follows:<BR>&nbsp;*<BR>&nbsp;* - negative values mean 'infinite timeout' (MAX_JIFFY_OFFSET)<BR>&nbsp;*<BR>&nbsp;* - 'too large' values [that would result in larger than<BR>&nbsp;*&nbsp;&nbsp; MAX_JIFFY_OFFSET values] mean 'infinite timeout' too.<BR>&nbsp;*<BR>&nbsp;* - all other values are converted to jiffies by either multiplying<BR>&nbsp;*&nbsp;&nbsp; the input value by a factor or dividing it with a factor and<BR>&nbsp;*&nbsp;&nbsp; handling any 32-bit overflows.<BR>&nbsp;*&nbsp;&nbsp; for the details see __msecs_to_jiffies()<BR>&nbsp;*<BR>&nbsp;* msecs_to_jiffies() checks for the passed in value being a constant<BR>&nbsp;* via __builtin_constant_p() allowing gcc to eliminate most of the<BR>&nbsp;* code, __msecs_to_jiffies() is called if the value passed does not<BR>&nbsp;* allow constant folding and the actual conversion must be done at<BR>&nbsp;* runtime.<BR>&nbsp;* the HZ range specific helpers _msecs_to_jiffies() are called both<BR>&nbsp;* directly here and from __msecs_to_jiffies() in the case where<BR>&nbsp;* constant folding is not possible.<BR>&nbsp;*/<BR>static inline unsigned long msecs_to_jiffies(const unsigned int m)<BR>{<BR>&nbsp;if (__builtin_constant_p(m)) {<BR>&nbsp;&nbsp;if ((int)m &lt; 0)<BR>&nbsp;&nbsp;&nbsp;return MAX_JIFFY_OFFSET;<BR>&nbsp;&nbsp;return _msecs_to_jiffies(m);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;return __msecs_to_jiffies(m);<BR>&nbsp;}<BR>}</P>
<P>extern unsigned long __usecs_to_jiffies(const unsigned int u);<BR>#if HZ &lt;= USEC_PER_SEC &amp;&amp; !(USEC_PER_SEC % HZ)<BR>static inline unsigned long _usecs_to_jiffies(const unsigned int u)<BR>{<BR>&nbsp;return (u + (USEC_PER_SEC / HZ) - 1) / (USEC_PER_SEC / HZ);<BR>}<BR>#elif HZ &gt; USEC_PER_SEC &amp;&amp; !(HZ % USEC_PER_SEC)<BR>static inline unsigned long _usecs_to_jiffies(const unsigned int u)<BR>{<BR>&nbsp;return u * (HZ / USEC_PER_SEC);<BR>}<BR>static inline unsigned long _usecs_to_jiffies(const unsigned int u)<BR>{<BR>#else<BR>static inline unsigned long _usecs_to_jiffies(const unsigned int u)<BR>{<BR>&nbsp;return (USEC_TO_HZ_MUL32 * u + USEC_TO_HZ_ADJ32)<BR>&nbsp;&nbsp;&gt;&gt; USEC_TO_HZ_SHR32;<BR>}<BR>#endif</P>
<P>/**<BR>&nbsp;* usecs_to_jiffies: - convert microseconds to jiffies<BR>&nbsp;* @u:&nbsp;time in microseconds<BR>&nbsp;*<BR>&nbsp;* conversion is done as follows:<BR>&nbsp;*<BR>&nbsp;* - 'too large' values [that would result in larger than<BR>&nbsp;*&nbsp;&nbsp; MAX_JIFFY_OFFSET values] mean 'infinite timeout' too.<BR>&nbsp;*<BR>&nbsp;* - all other values are converted to jiffies by either multiplying<BR>&nbsp;*&nbsp;&nbsp; the input value by a factor or dividing it with a factor and<BR>&nbsp;*&nbsp;&nbsp; handling any 32-bit overflows as for msecs_to_jiffies.<BR>&nbsp;*<BR>&nbsp;* usecs_to_jiffies() checks for the passed in value being a constant<BR>&nbsp;* via __builtin_constant_p() allowing gcc to eliminate most of the<BR>&nbsp;* code, __usecs_to_jiffies() is called if the value passed does not<BR>&nbsp;* allow constant folding and the actual conversion must be done at<BR>&nbsp;* runtime.<BR>&nbsp;* the HZ range specific helpers _usecs_to_jiffies() are called both<BR>&nbsp;* directly here and from __msecs_to_jiffies() in the case where<BR>&nbsp;* constant folding is not possible.<BR>&nbsp;*/<BR>static inline unsigned long usecs_to_jiffies(const unsigned int u)<BR>{<BR>&nbsp;if (__builtin_constant_p(u)) {<BR>&nbsp;&nbsp;if (u &gt; jiffies_to_usecs(MAX_JIFFY_OFFSET))<BR>&nbsp;&nbsp;&nbsp;return MAX_JIFFY_OFFSET;<BR>&nbsp;&nbsp;return _usecs_to_jiffies(u);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;return __usecs_to_jiffies(u);<BR>&nbsp;}<BR>}</P>
<P>extern unsigned long timespec_to_jiffies(const struct timespec *value);<BR>extern void jiffies_to_timespec(const unsigned long jiffies,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct timespec *value);<BR>extern unsigned long timeval_to_jiffies(const struct timeval *value);<BR>extern void jiffies_to_timeval(const unsigned long jiffies,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct timeval *value);</P>
<P>extern clock_t jiffies_to_clock_t(unsigned long x);<BR>static inline clock_t jiffies_delta_to_clock_t(long delta)<BR>{<BR>&nbsp;return jiffies_to_clock_t(max(0L, delta));<BR>}</P>
<P>extern unsigned long clock_t_to_jiffies(unsigned long x);<BR>extern u64 jiffies_64_to_clock_t(u64 x);<BR>extern u64 nsec_to_clock_t(u64 x);<BR>extern u64 nsecs_to_jiffies64(u64 n);<BR>extern unsigned long nsecs_to_jiffies(u64 n);</P>
<P>#define TIMESTAMP_SIZE&nbsp;30</P>
<P>#endif