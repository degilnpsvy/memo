# Documentation/filesystems/ramfs-rootfs-initramfs.txt
<P></P>
<P>ramfs, rootfs and initramfs<BR>October 17, 2005<BR>Rob Landley &lt;<A href="mailto:rob@landley.net">rob@landley.net</A>&gt;<BR>=============================</P>
<P></P>
<P>What is ramfs?<BR>--------------</P>
<P>Ramfs is a very simple filesystem that exports Linux's disk caching<BR>mechanisms (the page cache and dentry cache) as a dynamically resizable<BR>RAM-based filesystem.</P>
<P>Normally all files are cached in memory by Linux.&nbsp; Pages of data read from<BR>backing store (usually the block device the filesystem is mounted on) are kept<BR>around in case it's needed again, but marked as clean (freeable) in case the<BR>Virtual Memory system needs the memory for something else.&nbsp; Similarly, data<BR>written to files is marked clean as soon as it has been written to backing<BR>store, but kept around for caching purposes until the VM reallocates the<BR>memory.&nbsp; A similar mechanism (the dentry cache) greatly speeds up access to<BR>directories.</P>
<P>With ramfs, there is no backing store.&nbsp; Files written into ramfs allocate<BR>dentries and page cache as usual, but there's nowhere to write them to.<BR>This means the pages are never marked clean, so they can't be freed by the<BR>VM when it's looking to recycle memory.</P>
<P>The amount of code required to implement ramfs is tiny, because all the<BR>work is done by the existing Linux caching infrastructure.&nbsp; Basically,<BR>you're mounting the disk cache as a filesystem.&nbsp; Because of this, ramfs is not<BR>an optional component removable via menuconfig, since there would be negligible<BR>space savings.</P>
<P>ramfs and ramdisk:<BR>------------------</P>
<P>The older "ram disk" mechanism created a synthetic block device out of<BR>an area of RAM and used it as backing store for a filesystem.&nbsp; This block<BR>device was of fixed size, so the filesystem mounted on it was of fixed<BR>size.&nbsp; Using a ram disk also required unnecessarily copying memory from the<BR>fake block device into the page cache (and copying changes back out), as well<BR>as creating and destroying dentries.&nbsp; Plus it needed a filesystem driver<BR>(such as ext2) to format and interpret this data.</P>
<P>Compared to ramfs, this wastes memory (and memory bus bandwidth), creates<BR>unnecessary work for the CPU, and pollutes the CPU caches.&nbsp; (There are tricks<BR>to avoid this copying by playing with the page tables, but they're unpleasantly<BR>complicated and turn out to be about as expensive as the copying anyway.)<BR>More to the point, all the work ramfs is doing has to happen _anyway_,<BR>since all file access goes through the page and dentry caches.&nbsp; The RAM<BR>disk is simply unnecessary; ramfs is internally much simpler.</P>
<P>Another reason ramdisks are semi-obsolete is that the introduction of<BR>loopback devices offered a more flexible and convenient way to create<BR>synthetic block devices, now from files instead of from chunks of memory.<BR>See losetup (8) for details.</P>
<P>ramfs and tmpfs:<BR>----------------</P>
<P>One downside of ramfs is you can keep writing data into it until you fill<BR>up all memory, and the VM can't free it because the VM thinks that files<BR>should get written to backing store (rather than swap space), but ramfs hasn't<BR>got any backing store.&nbsp; Because of this, only root (or a trusted user) should<BR>be allowed write access to a ramfs mount.</P>
<P>A ramfs derivative called tmpfs was created to add size limits, and the ability<BR>to write the data to swap space.&nbsp; Normal users can be allowed write access to<BR>tmpfs mounts.&nbsp; See Documentation/filesystems/tmpfs.txt for more information.</P>
<P>What is rootfs?<BR>---------------</P>
<P>Rootfs is a special instance of ramfs (or tmpfs, if that's enabled), which is<BR>always present in 2.6 systems.&nbsp; You can't unmount rootfs for approximately the<BR>same reason you can't kill the init process; rather than having special code<BR>to check for and handle an empty list, it's smaller and simpler for the kernel<BR>to just make sure certain lists can't become empty.</P>
<P>Most systems just mount another filesystem over rootfs and ignore it.&nbsp; The<BR>amount of space an empty instance of ramfs takes up is tiny.</P>
<P>If CONFIG_TMPFS is enabled, rootfs will use tmpfs instead of ramfs by<BR>default.&nbsp; To force ramfs, add "rootfstype=ramfs" to the kernel command<BR>line.</P>
<P>What is initramfs?<BR>------------------</P>
<P>All 2.6 Linux kernels contain a gzipped "cpio" format archive, which is<BR>extracted into rootfs when the kernel boots up.&nbsp; After extracting, the kernel<BR>checks to see if rootfs contains a file "init", and if so it executes it as PID<BR>1.&nbsp; If found, this init process is responsible for bringing the system the<BR>rest of the way up, including locating and mounting the real root device (if<BR>any).&nbsp; If rootfs does not contain an init program after the embedded cpio<BR>archive is extracted into it, the kernel will fall through to the older code<BR>to locate and mount a root partition, then exec some variant of /sbin/init<BR>out of that.</P>
<P>All this differs from the old initrd in several ways:</P>
<P>&nbsp; - The old initrd was always a separate file, while the initramfs archive is<BR>&nbsp;&nbsp;&nbsp; linked into the linux kernel image.&nbsp; (The directory linux-*/usr is devoted<BR>&nbsp;&nbsp;&nbsp; to generating this archive during the build.)</P>
<P>&nbsp; - The old initrd file was a gzipped filesystem image (in some file format,<BR>&nbsp;&nbsp;&nbsp; such as ext2, that needed a driver built into the kernel), while the new<BR>&nbsp;&nbsp;&nbsp; initramfs archive is a gzipped cpio archive (like tar only simpler,<BR>&nbsp;&nbsp;&nbsp; see cpio(1) and Documentation/early-userspace/buffer-format.txt).&nbsp; The<BR>&nbsp;&nbsp;&nbsp; kernel's cpio extraction code is not only extremely small, it's also<BR>&nbsp;&nbsp;&nbsp; __init text and data that can be discarded during the boot process.</P>
<P>&nbsp; - The program run by the old initrd (which was called /initrd, not /init) did<BR>&nbsp;&nbsp;&nbsp; some setup and then returned to the kernel, while the init program from<BR>&nbsp;&nbsp;&nbsp; initramfs is not expected to return to the kernel.&nbsp; (If /init needs to hand<BR>&nbsp;&nbsp;&nbsp; off control it can overmount / with a new root device and exec another init<BR>&nbsp;&nbsp;&nbsp; program.&nbsp; See the switch_root utility, below.)</P>
<P>&nbsp; - When switching another root device, initrd would pivot_root and then<BR>&nbsp;&nbsp;&nbsp; umount the ramdisk.&nbsp; But initramfs is rootfs: you can neither pivot_root<BR>&nbsp;&nbsp;&nbsp; rootfs, nor unmount it.&nbsp; Instead delete everything out of rootfs to<BR>&nbsp;&nbsp;&nbsp; free up the space (find -xdev / -exec rm '{}' ';'), overmount rootfs<BR>&nbsp;&nbsp;&nbsp; with the new root (cd /newmount; mount --move . /; chroot .), attach<BR>&nbsp;&nbsp;&nbsp; stdin/stdout/stderr to the new /dev/console, and exec the new init.</P>
<P>&nbsp;&nbsp;&nbsp; Since this is a remarkably persnickety process (and involves deleting<BR>&nbsp;&nbsp;&nbsp; commands before you can run them), the klibc package introduced a helper<BR>&nbsp;&nbsp;&nbsp; program (utils/run_init.c) to do all this for you.&nbsp; Most other packages<BR>&nbsp;&nbsp;&nbsp; (such as busybox) have named this command "switch_root".</P>
<P>Populating initramfs:<BR>---------------------</P>
<P>The 2.6 kernel build process always creates a gzipped cpio format initramfs<BR>archive and links it into the resulting kernel binary.&nbsp; By default, this<BR>archive is empty (consuming 134 bytes on x86).</P>
<P>The config option CONFIG_INITRAMFS_SOURCE (in General Setup in menuconfig,<BR>and living in usr/Kconfig) can be used to specify a source for the<BR>initramfs archive, which will automatically be incorporated into the<BR>resulting binary.&nbsp; This option can point to an existing gzipped cpio<BR>archive, a directory containing files to be archived, or a text file<BR>specification such as the following example:</P>
<P>&nbsp; dir /dev 755 0 0<BR>&nbsp; nod /dev/console 644 0 0 c 5 1<BR>&nbsp; nod /dev/loop0 644 0 0 b 7 0<BR>&nbsp; dir /bin 755 1000 1000<BR>&nbsp; slink /bin/sh busybox 777 0 0<BR>&nbsp; file /bin/busybox initramfs/busybox 755 0 0<BR>&nbsp; dir /proc 755 0 0<BR>&nbsp; dir /sys 755 0 0<BR>&nbsp; dir /mnt 755 0 0<BR>&nbsp; file /init initramfs/init.sh 755 0 0</P>
<P>Run "usr/gen_init_cpio" (after the kernel build) to get a usage message<BR>documenting the above file format.</P>
<P>One advantage of the configuration file is that root access is not required to<BR>set permissions or create device nodes in the new archive.&nbsp; (Note that those<BR>two example "file" entries expect to find files named "init.sh" and "busybox" in<BR>a directory called "initramfs", under the linux-2.6.* directory.&nbsp; See<BR>Documentation/early-userspace/README for more details.)</P>
<P>The kernel does not depend on external cpio tools.&nbsp; If you specify a<BR>directory instead of a configuration file, the kernel's build infrastructure<BR>creates a configuration file from that directory (usr/Makefile calls<BR>scripts/gen_initramfs_list.sh), and proceeds to package up that directory<BR>using the config file (by feeding it to usr/gen_init_cpio, which is created<BR>from usr/gen_init_cpio.c).&nbsp; The kernel's build-time cpio creation code is<BR>entirely self-contained, and the kernel's boot-time extractor is also<BR>(obviously) self-contained.</P>
<P>The one thing you might need external cpio utilities installed for is creating<BR>or extracting your own preprepared cpio files to feed to the kernel build<BR>(instead of a config file or directory).</P>
<P>The following command line can extract a cpio image (either by the above script<BR>or by the kernel build) back into its component files:</P>
<P>&nbsp; cpio -i -d -H newc -F initramfs_data.cpio --no-absolute-filenames</P>
<P>The following shell script can create a prebuilt cpio archive you can<BR>use in place of the above config file:</P>
<P>&nbsp; #!/bin/sh</P>
<P>&nbsp; # Copyright 2006 Rob Landley &lt;<A href="mailto:rob@landley.net">rob@landley.net</A>&gt; and TimeSys Corporation.<BR>&nbsp; # Licensed under GPL version 2</P>
<P>&nbsp; if [ $# -ne 2 ]<BR>&nbsp; then<BR>&nbsp;&nbsp;&nbsp; echo "usage: mkinitramfs directory imagename.cpio.gz"<BR>&nbsp;&nbsp;&nbsp; exit 1<BR>&nbsp; fi</P>
<P>&nbsp; if [ -d "$1" ]<BR>&nbsp; then<BR>&nbsp;&nbsp;&nbsp; echo "creating $2 from $1"<BR>&nbsp;&nbsp;&nbsp; (cd "$1"; find . | cpio -o -H newc | gzip) &gt; "$2"<BR>&nbsp; else<BR>&nbsp;&nbsp;&nbsp; echo "First argument must be a directory"<BR>&nbsp;&nbsp;&nbsp; exit 1<BR>&nbsp; fi</P>
<P>Note: The cpio man page contains some bad advice that will break your initramfs<BR>archive if you follow it.&nbsp; It says "A typical way to generate the list<BR>of filenames is with the find command; you should give find the -depth option<BR>to minimize problems with permissions on directories that are unwritable or not<BR>searchable."&nbsp; Don't do this when creating initramfs.cpio.gz images, it won't<BR>work.&nbsp; The Linux kernel cpio extractor won't create files in a directory that<BR>doesn't exist, so the directory entries must go before the files that go in<BR>those directories.&nbsp; The above script gets them in the right order.</P>
<P>External initramfs images:<BR>--------------------------</P>
<P>If the kernel has initrd support enabled, an external cpio.gz archive can also<BR>be passed into a 2.6 kernel in place of an initrd.&nbsp; In this case, the kernel<BR>will autodetect the type (initramfs, not initrd) and extract the external cpio<BR>archive into rootfs before trying to run /init.</P>
<P>This has the memory efficiency advantages of initramfs (no ramdisk block<BR>device) but the separate packaging of initrd (which is nice if you have<BR>non-GPL code you'd like to run from initramfs, without conflating it with<BR>the GPL licensed Linux kernel binary).</P>
<P>It can also be used to supplement the kernel's built-in initramfs image.&nbsp; The<BR>files in the external archive will overwrite any conflicting files in<BR>the built-in initramfs archive.&nbsp; Some distributors also prefer to customize<BR>a single kernel image with task-specific initramfs images, without recompiling.</P>
<P>Contents of initramfs:<BR>----------------------</P>
<P>An initramfs archive is a complete self-contained root filesystem for Linux.<BR>If you don't already understand what shared libraries, devices, and paths<BR>you need to get a minimal root filesystem up and running, here are some<BR>references:<BR><A href="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/">http://www.tldp.org/HOWTO/Bootdisk-HOWTO/</A><BR><A href="http://www.tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html">http://www.tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html</A><BR><A href="http://www.linuxfromscratch.org/lfs/view/stable/">http://www.linuxfromscratch.org/lfs/view/stable/</A></P>
<P>The "klibc" package (<A href="http://www.kernel.org/pub/linux/libs/klibc">http://www.kernel.org/pub/linux/libs/klibc</A>) is<BR>designed to be a tiny C library to statically link early userspace<BR>code against, along with some related utilities.&nbsp; It is BSD licensed.</P>
<P>I use uClibc (<A href="http://www.uclibc.org">http://www.uclibc.org</A>) and busybox (<A href="http://www.busybox.net">http://www.busybox.net</A>)<BR>myself.&nbsp; These are LGPL and GPL, respectively.&nbsp; (A self-contained initramfs<BR>package is planned for the busybox 1.3 release.)</P>
<P>In theory you could use glibc, but that's not well suited for small embedded<BR>uses like this.&nbsp; (A "hello world" program statically linked against glibc is<BR>over 400k.&nbsp; With uClibc it's 7k.&nbsp; Also note that glibc dlopens libnss to do<BR>name lookups, even when otherwise statically linked.)</P>
<P>A good first step is to get initramfs to run a statically linked "hello world"<BR>program as init, and test it under an emulator like qemu (<A href="http://www.qemu.org">www.qemu.org</A>) or<BR>User Mode Linux, like so:</P>
<P>&nbsp; cat &gt; hello.c &lt;&lt; EOF<BR>&nbsp; #include &lt;stdio.h&gt;<BR>&nbsp; #include &lt;unistd.h&gt;</P>
<P>&nbsp; int main(int argc, char *argv[])<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; printf("Hello world!\n");<BR>&nbsp;&nbsp;&nbsp; sleep(999999999);<BR>&nbsp; }<BR>&nbsp; EOF<BR>&nbsp; gcc -static hello.c -o init<BR>&nbsp; echo init | cpio -o -H newc | gzip &gt; test.cpio.gz<BR>&nbsp; # Testing external initramfs using the initrd loading mechanism.<BR>&nbsp; qemu -kernel /boot/vmlinuz -initrd test.cpio.gz /dev/zero</P>
<P>When debugging a normal root filesystem, it's nice to be able to boot with<BR>"init=/bin/sh".&nbsp; The initramfs equivalent is "rdinit=/bin/sh", and it's<BR>just as useful.</P>
<P>Why cpio rather than tar?<BR>-------------------------</P>
<P>This decision was made back in December, 2001.&nbsp; The discussion started here:</P>
<P>&nbsp; <A href="http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1538.html">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1538.html</A></P>
<P>And spawned a second thread (specifically on tar vs cpio), starting here:</P>
<P>&nbsp; <A href="http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1587.html">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1587.html</A></P>
<P>The quick and dirty summary version (which is no substitute for reading<BR>the above threads) is:</P>
<P>1) cpio is a standard.&nbsp; It's decades old (from the AT&amp;T days), and already<BR>&nbsp;&nbsp; widely used on Linux (inside RPM, Red Hat's device driver disks).&nbsp; Here's<BR>&nbsp;&nbsp; a Linux Journal article about it from 1996:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A href="http://www.linuxjournal.com/article/1213">http://www.linuxjournal.com/article/1213</A></P>
<P>&nbsp;&nbsp; It's not as popular as tar because the traditional cpio command line tools<BR>&nbsp;&nbsp; require _truly_hideous_ command line arguments.&nbsp; But that says nothing<BR>&nbsp;&nbsp; either way about the archive format, and there are alternative tools,<BR>&nbsp;&nbsp; such as:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; <A href="http://freecode.com/projects/afio">http://freecode.com/projects/afio</A></P>
<P>2) The cpio archive format chosen by the kernel is simpler and cleaner (and<BR>&nbsp;&nbsp; thus easier to create and parse) than any of the (literally dozens of)<BR>&nbsp;&nbsp; various tar archive formats.&nbsp; The complete initramfs archive format is<BR>&nbsp;&nbsp; explained in buffer-format.txt, created in usr/gen_init_cpio.c, and<BR>&nbsp;&nbsp; extracted in init/initramfs.c.&nbsp; All three together come to less than 26k<BR>&nbsp;&nbsp; total of human-readable text.</P>
<P>3) The GNU project standardizing on tar is approximately as relevant as<BR>&nbsp;&nbsp; Windows standardizing on zip.&nbsp; Linux is not part of either, and is free<BR>&nbsp;&nbsp; to make its own technical decisions.</P>
<P>4) Since this is a kernel internal format, it could easily have been<BR>&nbsp;&nbsp; something brand new.&nbsp; The kernel provides its own tools to create and<BR>&nbsp;&nbsp; extract this format anyway.&nbsp; Using an existing standard was preferable,<BR>&nbsp;&nbsp; but not essential.</P>
<P>5) Al Viro made the decision (quote: "tar is ugly as hell and not going to be<BR>&nbsp;&nbsp; supported on the kernel side"):</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A href="http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1540.html">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1540.html</A></P>
<P>&nbsp;&nbsp; explained his reasoning:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A href="http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1550.html">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1550.html</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A href="http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1638.html">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1638.html</A></P>
<P>&nbsp;&nbsp; and, most importantly, designed and implemented the initramfs code.</P>
<P>Future directions:<BR>------------------</P>
<P>Today (2.6.16), initramfs is always compiled in, but not always used.&nbsp; The<BR>kernel falls back to legacy boot code that is reached only if initramfs does<BR>not contain an /init program.&nbsp; The fallback is legacy code, there to ensure a<BR>smooth transition and allowing early boot functionality to gradually move to<BR>"early userspace" (I.E. initramfs).</P>
<P>The move to early userspace is necessary because finding and mounting the real<BR>root device is complex.&nbsp; Root partitions can span multiple devices (raid or<BR>separate journal).&nbsp; They can be out on the network (requiring dhcp, setting a<BR>specific MAC address, logging into a server, etc).&nbsp; They can live on removable<BR>media, with dynamically allocated major/minor numbers and persistent naming<BR>issues requiring a full udev implementation to sort out.&nbsp; They can be<BR>compressed, encrypted, copy-on-write, loopback mounted, strangely partitioned,<BR>and so on.</P>
<P>This kind of complexity (which inevitably includes policy) is rightly handled<BR>in userspace.&nbsp; Both klibc and busybox/uClibc are working on simple initramfs<BR>packages to drop into a kernel build.</P>
<P>The klibc package has now been accepted into Andrew Morton's 2.6.17-mm tree.<BR>The kernel's current early boot code (partition detection, etc) will probably<BR>be migrated into a default initramfs, automatically created and used by the<BR>kernel build.