<FONT class=extract>static __initdata LIST_HEAD(early_platform_driver_list);<BR>static __initdata LIST_HEAD(early_platform_device_list);</FONT> 
<P></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_driver_register - register early platform driver<BR>&nbsp;* @epdrv: early_platform driver structure<BR>&nbsp;* @buf: string passed from early_param()<BR>&nbsp;*<BR>&nbsp;* Helper function for early_platform_init() / early_platform_init_buffer()<BR>&nbsp;*/<BR>int __init early_platform_driver_register(struct early_platform_driver *epdrv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;char *tmp;<BR>&nbsp;int n;</FONT></P>
<P><FONT class=extract>&nbsp;/* Simply add the driver to the end of the global list.<BR>&nbsp; * Drivers will by default be put on the list in compiled-in order.<BR>&nbsp; */<BR>&nbsp;if (!epdrv-&gt;list.next) {<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;epdrv-&gt;list);<BR>&nbsp;&nbsp;list_add_tail(&amp;epdrv-&gt;list, &amp;early_platform_driver_list);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* If the user has specified device then make sure the driver<BR>&nbsp; * gets prioritized. The driver of the last device specified on<BR>&nbsp; * command line will be put first on the list.<BR>&nbsp; */<BR>&nbsp;n = strlen(epdrv-&gt;pdrv-&gt;driver.name);<BR>&nbsp;if (buf &amp;&amp; !strncmp(buf, epdrv-&gt;pdrv-&gt;driver.name, n)) {<BR>&nbsp;&nbsp;list_move(&amp;epdrv-&gt;list, &amp;early_platform_driver_list);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;/* Allow passing parameters after device name */<BR>&nbsp;&nbsp;if (buf[n] == '\0' || buf[n] == ',')<BR>&nbsp;&nbsp;&nbsp;epdrv-&gt;requested_id = -1;<BR>&nbsp;&nbsp;else {<BR>&nbsp;&nbsp;&nbsp;epdrv-&gt;requested_id = simple_strtoul(&amp;buf[n + 1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tmp, 10);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;if (buf[n] != '.' || (tmp == &amp;buf[n + 1])) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;epdrv-&gt;requested_id = EARLY_PLATFORM_ID_ERROR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;n = 0;<BR>&nbsp;&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;&nbsp;n += strcspn(&amp;buf[n + 1], ",") + 1;<BR>&nbsp;&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (buf[n] == ',')<BR>&nbsp;&nbsp;&nbsp;n++;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (epdrv-&gt;bufsize) {<BR>&nbsp;&nbsp;&nbsp;memcpy(epdrv-&gt;buffer, &amp;buf[n],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_t(int, epdrv-&gt;bufsize, strlen(&amp;buf[n]) + 1));<BR>&nbsp;&nbsp;&nbsp;epdrv-&gt;buffer[epdrv-&gt;bufsize - 1] = '\0';<BR>&nbsp;&nbsp;}<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* early_platform_add_devices - adds a number of early platform devices<BR>&nbsp;* @devs: array of early platform devices to add<BR>&nbsp;* @num: number of early platform devices in array<BR>&nbsp;*<BR>&nbsp;* Used by early architecture code to register early platform devices and<BR>&nbsp;* their platform data.<BR>&nbsp;*/<BR>void __init early_platform_add_devices(struct platform_device **devs, int num)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;/* simply add the devices to list */<BR>&nbsp;for (i = 0; i &lt; num; i++) {<BR>&nbsp;&nbsp;dev = &amp;devs[i]-&gt;dev;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (!dev-&gt;devres_head.next) {<BR>&nbsp;&nbsp;&nbsp;pm_runtime_early_init(dev);<BR>&nbsp;&nbsp;&nbsp;INIT_LIST_HEAD(&amp;dev-&gt;devres_head);<BR>&nbsp;&nbsp;&nbsp;list_add_tail(&amp;dev-&gt;devres_head,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;early_platform_device_list);<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>}</FONT></P>
<P>/**<BR>&nbsp;* early_platform_driver_register_all - register early platform drivers<BR>&nbsp;* @class_str: string to identify early platform driver class<BR>&nbsp;*<BR>&nbsp;* Used by architecture code to register all early platform drivers<BR>&nbsp;* for a certain class. If omitted then only early platform drivers<BR>&nbsp;* with matching kernel command line class parameters will be registered.<BR>&nbsp;*/<BR>void __init early_platform_driver_register_all(char *class_str)<BR>{<BR>&nbsp;/* The "class_str" parameter may or may not be present on the kernel<BR>&nbsp; * command line. If it is present then there may be more than one<BR>&nbsp; * matching parameter.<BR>&nbsp; *<BR>&nbsp; * Since we register our early platform drivers using early_param()<BR>&nbsp; * we need to make sure that they also get registered in the case<BR>&nbsp; * when the parameter is missing from the kernel command line.<BR>&nbsp; *<BR>&nbsp; * We use parse_early_options() to make sure the early_param() gets<BR>&nbsp; * called at least once. The early_param() may be called more than<BR>&nbsp; * once since the name of the preferred device may be specified on<BR>&nbsp; * the kernel command line. early_platform_driver_register() handles<BR>&nbsp; * this case for us.<BR>&nbsp; */<BR>&nbsp;parse_early_options(class_str);<BR>}</P>
<P>/**<BR>&nbsp;* early_platform_match - find early platform device matching driver<BR>&nbsp;* @epdrv: early platform driver structure<BR>&nbsp;* @id: id to match against<BR>&nbsp;*/<BR>static struct platform_device * __init<BR>early_platform_match(struct early_platform_driver *epdrv, int id)<BR>{<BR>&nbsp;struct platform_device *pd;</P>
<P>&nbsp;list_for_each_entry(pd, &amp;early_platform_device_list, dev.devres_head)<BR>&nbsp;&nbsp;if (platform_match(&amp;pd-&gt;dev, &amp;epdrv-&gt;pdrv-&gt;driver))<BR>&nbsp;&nbsp;&nbsp;if (pd-&gt;id == id)<BR>&nbsp;&nbsp;&nbsp;&nbsp;return pd;</P>
<P>&nbsp;return NULL;<BR>}</P>
<P>/**<BR>&nbsp;* early_platform_left - check if early platform driver has matching devices<BR>&nbsp;* @epdrv: early platform driver structure<BR>&nbsp;* @id: return true if id or above exists<BR>&nbsp;*/<BR>static int __init early_platform_left(struct early_platform_driver *epdrv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id)<BR>{<BR>&nbsp;struct platform_device *pd;</P>
<P>&nbsp;list_for_each_entry(pd, &amp;early_platform_device_list, dev.devres_head)<BR>&nbsp;&nbsp;if (platform_match(&amp;pd-&gt;dev, &amp;epdrv-&gt;pdrv-&gt;driver))<BR>&nbsp;&nbsp;&nbsp;if (pd-&gt;id &gt;= id)<BR>&nbsp;&nbsp;&nbsp;&nbsp;return 1;</P>
<P>&nbsp;return 0;<BR>}</P>
<P>/**<BR>&nbsp;* early_platform_driver_probe_id - probe drivers matching class_str and id<BR>&nbsp;* @class_str: string to identify early platform driver class<BR>&nbsp;* @id: id to match against<BR>&nbsp;* @nr_probe: number of platform devices to successfully probe before exiting<BR>&nbsp;*/<BR>static int __init early_platform_driver_probe_id(char *class_str,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_probe)<BR>{<BR>&nbsp;struct early_platform_driver *epdrv;<BR>&nbsp;struct platform_device *match;<BR>&nbsp;int match_id;<BR>&nbsp;int n = 0;<BR>&nbsp;int left = 0;</P>
<P>&nbsp;list_for_each_entry(epdrv, &amp;early_platform_driver_list, list) {<BR>&nbsp;&nbsp;/* only use drivers matching our class_str */<BR>&nbsp;&nbsp;if (strcmp(class_str, epdrv-&gt;class_str))<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;if (id == -2) {<BR>&nbsp;&nbsp;&nbsp;match_id = epdrv-&gt;requested_id;<BR>&nbsp;&nbsp;&nbsp;left = 1;</P>
<P>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;match_id = id;<BR>&nbsp;&nbsp;&nbsp;left += early_platform_left(epdrv, id);</P>
<P>&nbsp;&nbsp;&nbsp;/* skip requested id */<BR>&nbsp;&nbsp;&nbsp;switch (epdrv-&gt;requested_id) {<BR>&nbsp;&nbsp;&nbsp;case EARLY_PLATFORM_ID_ERROR:<BR>&nbsp;&nbsp;&nbsp;case EARLY_PLATFORM_ID_UNSET:<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (epdrv-&gt;requested_id == id)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match_id = EARLY_PLATFORM_ID_UNSET;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;switch (match_id) {<BR>&nbsp;&nbsp;case EARLY_PLATFORM_ID_ERROR:<BR>&nbsp;&nbsp;&nbsp;pr_warn("%s: unable to parse %s parameter\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;class_str, epdrv-&gt;pdrv-&gt;driver.name);<BR>&nbsp;&nbsp;&nbsp;/* fall-through */<BR>&nbsp;&nbsp;case EARLY_PLATFORM_ID_UNSET:<BR>&nbsp;&nbsp;&nbsp;match = NULL;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;match = early_platform_match(epdrv, match_id);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (match) {<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Set up a sensible init_name to enable<BR>&nbsp;&nbsp;&nbsp; * dev_name() and others to be used before the<BR>&nbsp;&nbsp;&nbsp; * rest of the driver core is initialized.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (!match-&gt;dev.init_name &amp;&amp; slab_is_available()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (match-&gt;id != -1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match-&gt;dev.init_name =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kasprintf(GFP_KERNEL, "%s.%d",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;id);<BR>&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match-&gt;dev.init_name =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kasprintf(GFP_KERNEL, "%s",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;name);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;if (!match-&gt;dev.init_name)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;&nbsp;if (epdrv-&gt;pdrv-&gt;probe(match))<BR>&nbsp;&nbsp;&nbsp;&nbsp;pr_warn("%s: unable to probe %s early.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_str, match-&gt;name);<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;n++;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (n &gt;= nr_probe)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;if (left)<BR>&nbsp;&nbsp;return n;<BR>&nbsp;else<BR>&nbsp;&nbsp;return -ENODEV;<BR>}</P>
<P>/**<BR>&nbsp;* early_platform_driver_probe - probe a class of registered drivers<BR>&nbsp;* @class_str: string to identify early platform driver class<BR>&nbsp;* @nr_probe: number of platform devices to successfully probe before exiting<BR>&nbsp;* @user_only: only probe user specified early platform devices<BR>&nbsp;*<BR>&nbsp;* Used by architecture code to probe registered early platform drivers<BR>&nbsp;* within a certain class. For probe to happen a registered early platform<BR>&nbsp;* device matching a registered early platform driver is needed.<BR>&nbsp;*/<BR>int __init early_platform_driver_probe(char *class_str,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_probe,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int user_only)<BR>{<BR>&nbsp;int k, n, i;</P>
<P>&nbsp;n = 0;<BR>&nbsp;for (i = -2; n &lt; nr_probe; i++) {<BR>&nbsp;&nbsp;k = early_platform_driver_probe_id(class_str, i, nr_probe - n);</P>
<P>&nbsp;&nbsp;if (k &lt; 0)<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;n += k;</P>
<P>&nbsp;&nbsp;if (user_only)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}</P>
<P>&nbsp;return n;<BR>}</P>
<P>/**<BR>&nbsp;* early_platform_cleanup - clean up early platform code<BR>&nbsp;*/<BR>void __init early_platform_cleanup(void)<BR>{<BR>&nbsp;struct platform_device *pd, *pd2;</P>
<P>&nbsp;/* clean up the devres list used to chain devices */<BR>&nbsp;list_for_each_entry_safe(pd, pd2, &amp;early_platform_device_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp; dev.devres_head) {<BR>&nbsp;&nbsp;list_del(&amp;pd-&gt;dev.devres_head);<BR>&nbsp;&nbsp;memset(&amp;pd-&gt;dev.devres_head, 0, sizeof(pd-&gt;dev.devres_head));<BR>&nbsp;}<BR>}