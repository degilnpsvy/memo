drivers/base/class.c 
<P></P>
<P>/*<BR>&nbsp;* class.c - basic device class management<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2002-3 Patrick Mochel<BR>&nbsp;* Copyright (c) 2002-3 Open Source Development Labs<BR>&nbsp;* Copyright (c) 2003-2004 Greg Kroah-Hartman<BR>&nbsp;* Copyright (c) 2003-2004 IBM Corp.<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2<BR>&nbsp;*<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/device.h&gt;<BR>#include &lt;linux/module.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/kdev_t.h&gt;<BR>#include &lt;linux/err.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/genhd.h&gt;<BR>#include &lt;linux/mutex.h&gt;<BR>#include "base.h"</P>
<P>#define to_class_attr(_attr) container_of(_attr, struct class_attribute, attr)</P>
<P>static ssize_t class_attr_show(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct class_attribute *class_attr = to_class_attr(attr);<BR>&nbsp;struct subsys_private *cp = to_subsys_private(kobj);<BR>&nbsp;ssize_t ret = -EIO;</P>
<P>&nbsp;if (class_attr-&gt;show)<BR>&nbsp;&nbsp;ret = class_attr-&gt;show(cp-&gt;class, class_attr, buf);<BR>&nbsp;return ret;<BR>}</P>
<P>static ssize_t class_attr_store(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const char *buf, size_t count)<BR>{<BR>&nbsp;struct class_attribute *class_attr = to_class_attr(attr);<BR>&nbsp;struct subsys_private *cp = to_subsys_private(kobj);<BR>&nbsp;ssize_t ret = -EIO;</P>
<P>&nbsp;if (class_attr-&gt;store)<BR>&nbsp;&nbsp;ret = class_attr-&gt;store(cp-&gt;class, class_attr, buf, count);<BR>&nbsp;return ret;<BR>}</P>
<P>static void class_release(struct kobject *kobj)<BR>{<BR>&nbsp;struct subsys_private *cp = to_subsys_private(kobj);<BR>&nbsp;struct class *class = cp-&gt;class;</P>
<P>&nbsp;pr_debug("class '%s': release.\n", class-&gt;name);</P>
<P>&nbsp;if (class-&gt;class_release)<BR>&nbsp;&nbsp;class-&gt;class_release(class);<BR>&nbsp;else<BR>&nbsp;&nbsp;pr_debug("class '%s' does not have a release() function, "<BR>&nbsp;&nbsp;&nbsp; "be careful\n", class-&gt;name);</P>
<P>&nbsp;kfree(cp);<BR>}</P>
<P>static const struct kobj_ns_type_operations *class_child_ns_type(struct kobject *kobj)<BR>{<BR>&nbsp;struct subsys_private *cp = to_subsys_private(kobj);<BR>&nbsp;struct class *class = cp-&gt;class;</P>
<P>&nbsp;return class-&gt;ns_type;<BR>}</P>
<P>static const struct sysfs_ops class_sysfs_ops = {<BR>&nbsp;.show&nbsp;&nbsp;&nbsp; = class_attr_show,<BR>&nbsp;.store&nbsp;&nbsp;&nbsp; = class_attr_store,<BR>};</P>
<P>static struct kobj_type class_ktype = {<BR>&nbsp;.sysfs_ops&nbsp;= &amp;class_sysfs_ops,<BR>&nbsp;.release&nbsp;= class_release,<BR>&nbsp;.child_ns_type&nbsp;= class_child_ns_type,<BR>};</P>
<P>/* Hotplug events for classes go to the class subsys */<BR>static struct kset *class_kset;</P>
<P><BR>int class_create_file_ns(struct class *cls, const struct class_attribute *attr,<BR>&nbsp;&nbsp;&nbsp; const void *ns)<BR>{<BR>&nbsp;int error;</P>
<P>&nbsp;if (cls)<BR>&nbsp;&nbsp;error = sysfs_create_file_ns(&amp;cls-&gt;p-&gt;subsys.kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;attr-&gt;attr, ns);<BR>&nbsp;else<BR>&nbsp;&nbsp;error = -EINVAL;<BR>&nbsp;return error;<BR>}</P>
<P>void class_remove_file_ns(struct class *cls, const struct class_attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const void *ns)<BR>{<BR>&nbsp;if (cls)<BR>&nbsp;&nbsp;sysfs_remove_file_ns(&amp;cls-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr, ns);<BR>}</P>
<P>static struct class *class_get(struct class *cls)<BR>{<BR>&nbsp;if (cls)<BR>&nbsp;&nbsp;kset_get(&amp;cls-&gt;p-&gt;subsys);<BR>&nbsp;return cls;<BR>}</P>
<P>static void class_put(struct class *cls)<BR>{<BR>&nbsp;if (cls)<BR>&nbsp;&nbsp;kset_put(&amp;cls-&gt;p-&gt;subsys);<BR>}</P>
<P>static int add_class_attrs(struct class *cls)<BR>{<BR>&nbsp;int i;<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (cls-&gt;class_attrs) {<BR>&nbsp;&nbsp;for (i = 0; cls-&gt;class_attrs[i].attr.name; i++) {<BR>&nbsp;&nbsp;&nbsp;error = class_create_file(cls, &amp;cls-&gt;class_attrs[i]);<BR>&nbsp;&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto error;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>done:<BR>&nbsp;return error;<BR>error:<BR>&nbsp;while (--i &gt;= 0)<BR>&nbsp;&nbsp;class_remove_file(cls, &amp;cls-&gt;class_attrs[i]);<BR>&nbsp;goto done;<BR>}</P>
<P>static void remove_class_attrs(struct class *cls)<BR>{<BR>&nbsp;int i;</P>
<P>&nbsp;if (cls-&gt;class_attrs) {<BR>&nbsp;&nbsp;for (i = 0; cls-&gt;class_attrs[i].attr.name; i++)<BR>&nbsp;&nbsp;&nbsp;class_remove_file(cls, &amp;cls-&gt;class_attrs[i]);<BR>&nbsp;}<BR>}</P>
<P>static void klist_class_dev_get(struct klist_node *n)<BR>{<BR>&nbsp;struct device *dev = container_of(n, struct device, knode_class);</P>
<P>&nbsp;get_device(dev);<BR>}</P>
<P>static void klist_class_dev_put(struct klist_node *n)<BR>{<BR>&nbsp;struct device *dev = container_of(n, struct device, knode_class);</P>
<P>&nbsp;put_device(dev);<BR>}</P>
<P><FONT class=extract>int __class_register(struct class *cls, struct lock_class_key *key)<BR>{<BR>&nbsp;struct subsys_private *cp;<BR>&nbsp;int error;</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("device class '%s': registering\n", cls-&gt;name);</FONT></P>
<P><FONT class=extract>&nbsp;cp = kzalloc(sizeof(*cp), GFP_KERNEL);<BR>&nbsp;if (!cp)<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;klist_init(&amp;cp-&gt;klist_devices, klist_class_dev_get, klist_class_dev_put);<BR>&nbsp;INIT_LIST_HEAD(&amp;cp-&gt;interfaces);<BR>&nbsp;kset_init(&amp;cp-&gt;glue_dirs);<BR>&nbsp;__mutex_init(&amp;cp-&gt;mutex, "subsys mutex", key);<BR>&nbsp;error = kobject_set_name(&amp;cp-&gt;subsys.kobj, "%s", cls-&gt;name);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;kfree(cp);<BR>&nbsp;&nbsp;return error;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* set the default /sys/dev directory for devices of this class */<BR>&nbsp;if (!cls-&gt;dev_kobj)<BR>&nbsp;&nbsp;cls-&gt;dev_kobj = sysfs_dev_char_kobj;</FONT></P>
<P><FONT class=extract>#if defined(CONFIG_BLOCK)<BR>&nbsp;/* let the block class directory show up in the root of sysfs */<BR>&nbsp;if (!sysfs_deprecated || cls != &amp;block_class)<BR>&nbsp;&nbsp;cp-&gt;subsys.kobj.kset = class_kset;<BR>#else<BR>&nbsp;cp-&gt;subsys.kobj.kset = class_kset;<BR>#endif<BR>&nbsp;cp-&gt;subsys.kobj.ktype = &amp;class_ktype;<BR>&nbsp;cp-&gt;class = cls;<BR>&nbsp;cls-&gt;p = cp;</FONT></P>
<P><FONT class=extract>&nbsp;error = kset_register(&amp;cp-&gt;subsys);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;kfree(cp);<BR>&nbsp;&nbsp;return error;<BR>&nbsp;}<BR>&nbsp;error = add_class_attrs(class_get(cls));<BR>&nbsp;class_put(cls);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(__class_register);</FONT></P>
<P>void class_unregister(struct class *cls)<BR>{<BR>&nbsp;pr_debug("device class '%s': unregistering\n", cls-&gt;name);<BR>&nbsp;remove_class_attrs(cls);<BR>&nbsp;kset_unregister(&amp;cls-&gt;p-&gt;subsys);<BR>}</P>
<P>static void class_create_release(struct class *cls)<BR>{<BR>&nbsp;pr_debug("%s called for %s\n", __func__, cls-&gt;name);<BR>&nbsp;kfree(cls);<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* class_create - create a struct class structure<BR>&nbsp;* @owner: pointer to the module that is to "own" this struct class<BR>&nbsp;* @name: pointer to a string for the name of this class.<BR>&nbsp;* @key: the lock_class_key for this class; used by mutex lock debugging<BR>&nbsp;*<BR>&nbsp;* This is used to create a struct class pointer that can then be used<BR>&nbsp;* in calls to device_create().<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct class pointer on success, or ERR_PTR() on error.<BR>&nbsp;*<BR>&nbsp;* Note, the pointer created here is to be destroyed when finished by<BR>&nbsp;* making a call to class_destroy().<BR>&nbsp;*/<BR>struct class *__class_create(struct module *owner, const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct lock_class_key *key)<BR>{<BR>&nbsp;struct class *cls;<BR>&nbsp;int retval;</FONT></P>
<P><FONT class=extract>&nbsp;cls = kzalloc(sizeof(*cls), GFP_KERNEL);<BR>&nbsp;if (!cls) {<BR>&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;&nbsp;goto error;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;cls-&gt;name = name;<BR>&nbsp;cls-&gt;owner = owner;<BR>&nbsp;cls-&gt;class_release = class_create_release;</FONT></P>
<P><FONT class=extract>&nbsp;retval = __class_register(cls, key);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto error;</FONT></P>
<P><FONT class=extract>&nbsp;return cls;</FONT></P>
<P><FONT class=extract>error:<BR>&nbsp;kfree(cls);<BR>&nbsp;return ERR_PTR(retval);<BR>}<BR>EXPORT_SYMBOL_GPL(__class_create);</FONT></P>
<P>/**<BR>&nbsp;* class_destroy - destroys a struct class structure<BR>&nbsp;* @cls: pointer to the struct class that is to be destroyed<BR>&nbsp;*<BR>&nbsp;* Note, the pointer to be destroyed must have been created with a call<BR>&nbsp;* to class_create().<BR>&nbsp;*/<BR>void class_destroy(struct class *cls)<BR>{<BR>&nbsp;if ((cls == NULL) || (IS_ERR(cls)))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;class_unregister(cls);<BR>}</P>
<P>/**<BR>&nbsp;* class_dev_iter_init - initialize class device iterator<BR>&nbsp;* @iter: class iterator to initialize<BR>&nbsp;* @class: the class we wanna iterate over<BR>&nbsp;* @start: the device to start iterating from, if any<BR>&nbsp;* @type: device_type of the devices to iterate over, NULL for all<BR>&nbsp;*<BR>&nbsp;* Initialize class iterator @iter such that it iterates over devices<BR>&nbsp;* of @class.&nbsp; If @start is set, the list iteration will start there,<BR>&nbsp;* otherwise if it is NULL, the iteration starts at the beginning of<BR>&nbsp;* the list.<BR>&nbsp;*/<BR>void class_dev_iter_init(struct class_dev_iter *iter, struct class *class,<BR>&nbsp;&nbsp;&nbsp; struct device *start, const struct device_type *type)<BR>{<BR>&nbsp;struct klist_node *start_knode = NULL;</P>
<P>&nbsp;if (start)<BR>&nbsp;&nbsp;start_knode = &amp;start-&gt;knode_class;<BR>&nbsp;klist_iter_init_node(&amp;class-&gt;p-&gt;klist_devices, &amp;iter-&gt;ki, start_knode);<BR>&nbsp;iter-&gt;type = type;<BR>}<BR>EXPORT_SYMBOL_GPL(class_dev_iter_init);</P>
<P>/**<BR>&nbsp;* class_dev_iter_next - iterate to the next device<BR>&nbsp;* @iter: class iterator to proceed<BR>&nbsp;*<BR>&nbsp;* Proceed @iter to the next device and return it.&nbsp; Returns NULL if<BR>&nbsp;* iteration is complete.<BR>&nbsp;*<BR>&nbsp;* The returned device is referenced and won't be released till<BR>&nbsp;* iterator is proceed to the next device or exited.&nbsp; The caller is<BR>&nbsp;* free to do whatever it wants to do with the device including<BR>&nbsp;* calling back into class code.<BR>&nbsp;*/<BR>struct device *class_dev_iter_next(struct class_dev_iter *iter)<BR>{<BR>&nbsp;struct klist_node *knode;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;while (1) {<BR>&nbsp;&nbsp;knode = klist_next(&amp;iter-&gt;ki);<BR>&nbsp;&nbsp;if (!knode)<BR>&nbsp;&nbsp;&nbsp;return NULL;<BR>&nbsp;&nbsp;dev = container_of(knode, struct device, knode_class);<BR>&nbsp;&nbsp;if (!iter-&gt;type || iter-&gt;type == dev-&gt;type)<BR>&nbsp;&nbsp;&nbsp;return dev;<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(class_dev_iter_next);</P>
<P>/**<BR>&nbsp;* class_dev_iter_exit - finish iteration<BR>&nbsp;* @iter: class iterator to finish<BR>&nbsp;*<BR>&nbsp;* Finish an iteration.&nbsp; Always call this function after iteration is<BR>&nbsp;* complete whether the iteration ran till the end or not.<BR>&nbsp;*/<BR>void class_dev_iter_exit(struct class_dev_iter *iter)<BR>{<BR>&nbsp;klist_iter_exit(&amp;iter-&gt;ki);<BR>}<BR>EXPORT_SYMBOL_GPL(class_dev_iter_exit);</P>
<P>/**<BR>&nbsp;* class_for_each_device - device iterator<BR>&nbsp;* @class: the class we're iterating<BR>&nbsp;* @start: the device to start with in the list, if any.<BR>&nbsp;* @data: data for the callback<BR>&nbsp;* @fn: function to be called for each device<BR>&nbsp;*<BR>&nbsp;* Iterate over @class's list of devices, and call @fn for each,<BR>&nbsp;* passing it @data.&nbsp; If @start is set, the list iteration will start<BR>&nbsp;* there, otherwise if it is NULL, the iteration starts at the<BR>&nbsp;* beginning of the list.<BR>&nbsp;*<BR>&nbsp;* We check the return of @fn each time. If it returns anything<BR>&nbsp;* other than 0, we break out and return that value.<BR>&nbsp;*<BR>&nbsp;* @fn is allowed to do anything including calling back into class<BR>&nbsp;* code.&nbsp; There's no locking restriction.<BR>&nbsp;*/<BR>int class_for_each_device(struct class *class, struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp; void *data, int (*fn)(struct device *, void *))<BR>{<BR>&nbsp;struct class_dev_iter iter;<BR>&nbsp;struct device *dev;<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (!class)<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;if (!class-&gt;p) {<BR>&nbsp;&nbsp;WARN(1, "%s called for class '%s' before it was initialized",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, class-&gt;name);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}</P>
<P>&nbsp;class_dev_iter_init(&amp;iter, class, start, NULL);<BR>&nbsp;while ((dev = class_dev_iter_next(&amp;iter))) {<BR>&nbsp;&nbsp;error = fn(dev, data);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}<BR>&nbsp;class_dev_iter_exit(&amp;iter);</P>
<P>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(class_for_each_device);</P>
<P><FONT class=extract>/**<BR>&nbsp;* class_find_device - device iterator for locating a particular device<BR>&nbsp;* @class: the class we're iterating<BR>&nbsp;* @start: Device to begin with<BR>&nbsp;* @data: data for the match function<BR>&nbsp;* @match: function to check device<BR>&nbsp;*<BR>&nbsp;* This is similar to the class_for_each_dev() function above, but it<BR>&nbsp;* returns a reference to a device that is 'found' for later use, as<BR>&nbsp;* determined by the @match callback.<BR>&nbsp;*<BR>&nbsp;* The callback should return 0 if the device doesn't match and non-zero<BR>&nbsp;* if it does.&nbsp; If the callback returns non-zero, this function will<BR>&nbsp;* return to the caller and not iterate over any more devices.<BR>&nbsp;*<BR>&nbsp;* Note, you will need to drop the reference with put_device() after use.<BR>&nbsp;*<BR>&nbsp;* @fn is allowed to do anything including calling back into class<BR>&nbsp;* code.&nbsp; There's no locking restriction.<BR>&nbsp;*/<BR>struct device *class_find_device(struct class *class, struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int (*match)(struct device *, const void *))<BR>{<BR>&nbsp;struct class_dev_iter iter;<BR>&nbsp;struct device *dev;</FONT></P>
<P><FONT class=extract>&nbsp;if (!class)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;if (!class-&gt;p) {<BR>&nbsp;&nbsp;WARN(1, "%s called for class '%s' before it was initialized",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, class-&gt;name);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;class_dev_iter_init(&amp;iter, class, start, NULL);<BR>&nbsp;while ((dev = class_dev_iter_next(&amp;iter))) {<BR>&nbsp;&nbsp;if (match(dev, data)) {<BR>&nbsp;&nbsp;&nbsp;get_device(dev);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;class_dev_iter_exit(&amp;iter);</FONT></P>
<P><FONT class=extract>&nbsp;return dev;<BR>}<BR>EXPORT_SYMBOL_GPL(class_find_device);</FONT></P>
<P>int class_interface_register(struct class_interface *class_intf)<BR>{<BR>&nbsp;struct class *parent;<BR>&nbsp;struct class_dev_iter iter;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;if (!class_intf || !class_intf-&gt;class)<BR>&nbsp;&nbsp;return -ENODEV;</P>
<P>&nbsp;parent = class_get(class_intf-&gt;class);<BR>&nbsp;if (!parent)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;mutex_lock(&amp;parent-&gt;p-&gt;mutex);<BR>&nbsp;list_add_tail(&amp;class_intf-&gt;node, &amp;parent-&gt;p-&gt;interfaces);<BR>&nbsp;if (class_intf-&gt;add_dev) {<BR>&nbsp;&nbsp;class_dev_iter_init(&amp;iter, parent, NULL, NULL);<BR>&nbsp;&nbsp;while ((dev = class_dev_iter_next(&amp;iter)))<BR>&nbsp;&nbsp;&nbsp;class_intf-&gt;add_dev(dev, class_intf);<BR>&nbsp;&nbsp;class_dev_iter_exit(&amp;iter);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;parent-&gt;p-&gt;mutex);</P>
<P>&nbsp;return 0;<BR>}</P>
<P>void class_interface_unregister(struct class_interface *class_intf)<BR>{<BR>&nbsp;struct class *parent = class_intf-&gt;class;<BR>&nbsp;struct class_dev_iter iter;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;if (!parent)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;mutex_lock(&amp;parent-&gt;p-&gt;mutex);<BR>&nbsp;list_del_init(&amp;class_intf-&gt;node);<BR>&nbsp;if (class_intf-&gt;remove_dev) {<BR>&nbsp;&nbsp;class_dev_iter_init(&amp;iter, parent, NULL, NULL);<BR>&nbsp;&nbsp;while ((dev = class_dev_iter_next(&amp;iter)))<BR>&nbsp;&nbsp;&nbsp;class_intf-&gt;remove_dev(dev, class_intf);<BR>&nbsp;&nbsp;class_dev_iter_exit(&amp;iter);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;parent-&gt;p-&gt;mutex);</P>
<P>&nbsp;class_put(parent);<BR>}</P>
<P>ssize_t show_class_attr_string(struct class *class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct class_attribute *attr, char *buf)<BR>{<BR>&nbsp;struct class_attribute_string *cs;</P>
<P>&nbsp;cs = container_of(attr, struct class_attribute_string, attr);<BR>&nbsp;return snprintf(buf, PAGE_SIZE, "%s\n", cs-&gt;str);<BR>}</P>
<P>EXPORT_SYMBOL_GPL(show_class_attr_string);</P>
<P>struct class_compat {<BR>&nbsp;struct kobject *kobj;<BR>};</P>
<P>/**<BR>&nbsp;* class_compat_register - register a compatibility class<BR>&nbsp;* @name: the name of the class<BR>&nbsp;*<BR>&nbsp;* Compatibility class are meant as a temporary user-space compatibility<BR>&nbsp;* workaround when converting a family of class devices to a bus devices.<BR>&nbsp;*/<BR>struct class_compat *class_compat_register(const char *name)<BR>{<BR>&nbsp;struct class_compat *cls;</P>
<P>&nbsp;cls = kmalloc(sizeof(struct class_compat), GFP_KERNEL);<BR>&nbsp;if (!cls)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;cls-&gt;kobj = kobject_create_and_add(name, &amp;class_kset-&gt;kobj);<BR>&nbsp;if (!cls-&gt;kobj) {<BR>&nbsp;&nbsp;kfree(cls);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}<BR>&nbsp;return cls;<BR>}<BR>EXPORT_SYMBOL_GPL(class_compat_register);</P>
<P>/**<BR>&nbsp;* class_compat_unregister - unregister a compatibility class<BR>&nbsp;* @cls: the class to unregister<BR>&nbsp;*/<BR>void class_compat_unregister(struct class_compat *cls)<BR>{<BR>&nbsp;kobject_put(cls-&gt;kobj);<BR>&nbsp;kfree(cls);<BR>}<BR>EXPORT_SYMBOL_GPL(class_compat_unregister);</P>
<P>/**<BR>&nbsp;* class_compat_create_link - create a compatibility class device link to<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a bus device<BR>&nbsp;* @cls: the compatibility class<BR>&nbsp;* @dev: the target bus device<BR>&nbsp;* @device_link: an optional device to which a "device" link should be created<BR>&nbsp;*/<BR>int class_compat_create_link(struct class_compat *cls, struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *device_link)<BR>{<BR>&nbsp;int error;</P>
<P>&nbsp;error = sysfs_create_link(cls-&gt;kobj, &amp;dev-&gt;kobj, dev_name(dev));<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;return error;</P>
<P>&nbsp;/*<BR>&nbsp; * Optionally add a "device" link (typically to the parent), as a<BR>&nbsp; * class device would have one and we want to provide as much<BR>&nbsp; * backwards compatibility as possible.<BR>&nbsp; */<BR>&nbsp;if (device_link) {<BR>&nbsp;&nbsp;error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;device_link-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "device");<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;sysfs_remove_link(cls-&gt;kobj, dev_name(dev));<BR>&nbsp;}</P>
<P>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(class_compat_create_link);</P>
<P>/**<BR>&nbsp;* class_compat_remove_link - remove a compatibility class device link to<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a bus device<BR>&nbsp;* @cls: the compatibility class<BR>&nbsp;* @dev: the target bus device<BR>&nbsp;* @device_link: an optional device to which a "device" link was previously<BR>&nbsp;* &nbsp;&nbsp; created<BR>&nbsp;*/<BR>void class_compat_remove_link(struct class_compat *cls, struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *device_link)<BR>{<BR>&nbsp;if (device_link)<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "device");<BR>&nbsp;sysfs_remove_link(cls-&gt;kobj, dev_name(dev));<BR>}<BR>EXPORT_SYMBOL_GPL(class_compat_remove_link);</P>
<P>int __init classes_init(void)<BR>{<BR>&nbsp;class_kset = kset_create_and_add("class", NULL, NULL);<BR>&nbsp;if (!class_kset)<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;return 0;<BR>}</P>
<P>EXPORT_SYMBOL_GPL(class_create_file_ns);<BR>EXPORT_SYMBOL_GPL(class_remove_file_ns);<BR>EXPORT_SYMBOL_GPL(class_unregister);<BR>EXPORT_SYMBOL_GPL(class_destroy);</P>
<P>EXPORT_SYMBOL_GPL(class_interface_register);<BR>EXPORT_SYMBOL_GPL(class_interface_unregister);