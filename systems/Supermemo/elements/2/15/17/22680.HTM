1.2 dev-&gt;open() and dev-&gt;close()<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
<P></P>
<P>In case the driver has to repeatedly poll the device, because it doesn't<BR>have an interrupt coming from it and the polling is too expensive to be done<BR>all the time, or if the device uses a valuable resource (eg. interrupt), it<BR>can <FONT class=extract>use the open and close callback to know when it can stop polling or<BR>release the interrupt and when it must resume polling or grab the interrupt<BR>again. To do that, we would add this to our example driver:</FONT></P>
<P><FONT class=extract>static int button_open(struct input_dev *dev)<BR>{<BR></FONT><FONT class=clozed>&nbsp;if (request_irq(BUTTON_IRQ, button_interrupt, 0, "button", NULL)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk(KERN_ERR "button.c: Can't allocate irq %d\n", button_irq);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EBUSY;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract><FONT class=clozed><FONT class=clozed>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</FONT><BR>}</FONT></FONT></P>
<P><FONT class=extract>static void button_close(struct input_dev *dev)<BR>{<BR></FONT><FONT class=extract><FONT class=clozed><FONT class=clozed>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free_irq(IRQ_AMIGA_VERTB, button_interrupt);<BR></FONT>}</FONT></FONT></P>
<P><FONT class=extract>static int __init button_init(void)<BR>{<BR>&nbsp;...<BR>&nbsp;button_dev-&gt;open = button_open;<BR>&nbsp;button_dev-&gt;close = button_close;<BR>&nbsp;...<BR>}</FONT></P>
<P><FONT class=extract>Note that input core keeps track of number of users for the device and<BR>makes sure that dev-&gt;open() is called only when the first user connects<BR>to the device and that dev-&gt;close() is called when the very last user<BR>disconnects. Calls to both callbacks are serialized.</FONT></P>
<P><FONT class=extract>The open() callback should return a 0 in case of success or any nonzero value<BR>in case of failure. The close() callback (which is void) must always succeed.</FONT>