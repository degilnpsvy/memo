<html>

<head>
<meta http-equiv="description" content="SuperMemo Collection: gobject, Page: Part I. Concepts.. Table of Contents.. .. Background .. Data types and programming .. Exporting a C API.. The GLib Dynamic Type System .. Copy functions .. Conventions .. Non ...">
<meta http-equiv="keywords" content="SuperMemo, gobject, Part I. Concepts.. Table of Contents.. .. Background .. Data types and programming .. Exporting a C API.. The GLib Dynamic Type System .. Copy functions .. Conventions .. Non ...">
<meta name="GENERATOR" content="SuperMemo for Windows (Build 14.04)">
<title>gobject: Part I. Concepts.. Table ... (SuperMemo collection)</title>
</head>

<body>

<p align="center"><b><font size="5">gobject: Part I. Concepts.. Table ... </font></b><br>(12 elements)</p>
<a name="TopOfPages"> </a>
<b>Contents:</b>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#FFCCFF">
<tr>
<td width="100%">
  <a href="index.htm">Root</a> <a href="28672.htm"> - Next</a> - <a href="index.htm">Parent</a> - <a href="28672.htm">Next sibling</a>
<font size="2">
<ul>
<li><a href="index.htm">GObject Reference Manual.. .. for GObject 2.52.0 The latest version of this documentation can be found on-line at https://developer.gnome.org/gobject/unstable/.</a></li>
<ul>
<li>This page: Part I. Concepts.. Table of Contents.. .. Background .. Data types and programming .. Exporting a C API.. The GLib Dynamic Type System .. Copy functions .. Conventions .. Non ...</li>
<ol>
<li>Background.. Data types and programming .. Exporting a C API.. GObject, and its lower-level type system, GType, are used by GTK+ and most GNOME libraries to provide: .. object ... (see <a href="#28662">below)</a>
<li>Exporting a C API.. C APIs are defined by a set of functions and global variables which are usually exported from a binary. C functions have an arbitrary number of arguments ... (see <a href="#23118">below)</a>
<li>The GLib Dynamic Type System.. Copy functions .. Conventions .. Non-instantiable non-classed fundamental types .. Instantiable classed types: objects .. Initialization and ... (see <a href="#28663">below)</a>
<li>Conventions.. There are a number of conventions users are expected to follow when creating new types which are to be exported in a header file: .. Type names (including object ... (see <a href="#28664">below)</a>
<li>Non-instantiable non-classed fundamental types.. A lot of types are not instantiable by the type system and do not have a class. Most of these types are fundamental trivial ... (see <a href="#28665">below)</a>
<li>Instantiable classed types: objects.. This section covers the theory behind objects. See How to define and implement a new GObject for the recommended way to define a GObject. ... (see <a href="#28666">below)</a>
<li>Non-instantiable classed types: interfaces.. This section covers the theory behind interfaces. See How to define and implement interfaces for the recommended way to define an ... (see <a href="#28667">below)</a>
<li>The GObject base class.. Object instantiation.. Object memory management.. Reference count.. Weak References.. Reference counts and cycles.. Object properties.. Accessing ... (see <a href="#24000">below)</a>
<li>Object memory management.. The memory-management API for GObjects is a bit complicated but the idea behind it is pretty simple: the goal is to provide a flexible model based on ... (see <a href="#28668">below)</a>
<li>Object properties.. One of GObject's nice features is its generic get/set mechanism for object properties. When an object is instantiated, the object's class_init handler ... (see <a href="#28669">below)</a>
<li>The GObject messaging system.. Closures.. C Closures.. Non-C closures (for the fearless).. Signals.. Signal registration.. Signal connection.. Signal emission.. The detail ... (see <a href="#28670">below)</a>
<li>Signals.. GObject's signals have nothing to do with standard UNIX signals: they connect arbitrary application-specific events with any number of listeners. For example, in GTK+ ... (see <a href="#28671">below)</a>
</ol>
</ul>
</ul>
</font>
</td>
</tr>
</table>
</center>
</div>

<div align="center">
<center>
<table border="4" cellpadding="5" cellspacing="5" width="100%" bgcolor="#FFFF00" bordercolor="#FF0000">
<tr>
<td>
<b>Subject: Topic #23859: Part I. Concepts.. Table of Contents.. .. Background .. Data types and programming .. Exporting a C API.. The GLib Dynamic Type System .. Copy functions .. Conventions .. Non ...</b><p>
</td>
</tr>
<tr>
<td bordercolor="#FFCC00">
<DIV class=titlepage>
<DIV>
<DIV>
<H1 class=title>Part&nbsp;I.&nbsp;Concepts</H1></DIV></DIV></DIV>
<DIV class=toc>
<P><B>Table of Contents</B></P>
<DL class=toc>
<DT><SPAN class=chapter><A href="https://developer.gnome.org/gobject/stable/chapter-intro.html">Background</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-intro.html#id-1.3.2.5">Data types and programming</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/ch01s02.html">Exporting a C API</A></SPAN></DT></DL>
<DT><SPAN class=chapter><A href="https://developer.gnome.org/gobject/stable/chapter-gtype.html">The GLib Dynamic Type System</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-gtype.html#gtype-copy">Copy functions</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-conventions.html">Conventions</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable.html">Non-instantiable non-classed fundamental types</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-instantiable-classed.html">Instantiable classed types: objects</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gtype-instantiable-classed.html#gtype-instantiable-classed-init-done">Initialization and Destruction</A></SPAN></DT></DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html">Non-instantiable classed types: interfaces</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-init">Interface Initialization</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-dest">Interface Destruction</A></SPAN></DT></DL></DD></DL>
<DT><SPAN class=chapter><A href="https://developer.gnome.org/gobject/stable/chapter-gobject.html">The GObject base class</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-gobject.html#gobject-instantiation">Object instantiation</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html">Object memory management</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-refcount">Reference count</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-weakref">Weak References</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-cycles">Reference counts and cycles</A></SPAN></DT></DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gobject-properties.html">Object properties</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-properties.html#gobject-multi-properties">Accessing multiple properties at once</A></SPAN></DT></DL></DD></DL>
<DT><SPAN class=chapter><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html">The GObject messaging system</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#closure">Closures</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.5">C Closures</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.6">Non-C closures (for the fearless)</A></SPAN></DT></DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/signal.html">Signals</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-registration">Signal registration</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-connection">Signal connection</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-emission">Signal emission</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-detail">The <SPAN class=emphasis><EM>detail</EM></SPAN> argument</A></SPAN></DT></DL></DD></DL></DD></DL></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28662">Topic #28662: Background.. Data types and programming .. Exporting a C API.. GObject, and its lower-level type system, GType, are used by GTK+ and most GNOME libraries to provide: .. object ...</a></P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title>Background</H2></DIV></DIV></DIV>
<DIV class=toc>
<DL class=toc>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-intro.html#id-1.3.2.5">Data types and programming</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/ch01s02.html">Exporting a C API</A></SPAN></DT></DL></DIV>
<P>GObject, and its lower-level type system, GType, are used by GTK+ and most GNOME libraries to provide: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>object-oriented C-based APIs and</P>
<LI class=listitem>
<P>automatic transparent API bindings to other compiled or interpreted languages.</P></LI></UL></DIV>
<P></P>
<P>A lot of programmers are used to working with compiled-only or dynamically interpreted-only languages and do not understand the challenges associated with cross-language interoperability. This introduction tries to provide an insight into these challenges and briefly describes the solution chosen by GLib. </P>
<P>The following chapters go into greater detail into how GType and GObject work and how you can use them as a C programmer. It is useful to keep in mind that allowing access to C objects from other interpreted languages was one of the major design goals: this can often explain the sometimes rather convoluted APIs and features present in this library. </P>
<DIV class=sect1>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id-1.3.2.5></A>Data types and programming</H2></DIV></DIV></DIV>
<P>One could say that a programming language is merely a way to create data types and manipulate them. Most languages provide a number of language-native types and a few primitives to create more complex types based on these primitive types. </P>
<P>In C, the language provides types such as <SPAN class=emphasis><EM>char</EM></SPAN>, <SPAN class=emphasis><EM>long</EM></SPAN>, <SPAN class=emphasis><EM>pointer</EM></SPAN>. During compilation of C code, the compiler maps these language types to the compiler's target architecture machine types. If you are using a C interpreter (assuming one exists), the interpreter (the program which interprets the source code and executes it) maps the language types to the machine types of the target machine at runtime, during the program execution (or just before execution if it uses a Just In Time compiler engine). </P>
<P>Perl and Python are interpreted languages which do not really provide type definitions similar to those used by C. Perl and Python programmers manipulate variables and the type of the variables is decided only upon the first assignment or upon the first use which forces a type on the variable. The interpreter also often provides a lot of automatic conversions from one type to the other. For example, in Perl, a variable which holds an integer can be automatically converted to a string given the required context: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>my $tmp <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>10</SPAN><SPAN class="gtkdoc opt">;</SPAN>
print <SPAN class=string>"this is an integer converted to a string:"</SPAN> <SPAN class="gtkdoc opt">.</SPAN> $tmp <SPAN class="gtkdoc opt">.</SPAN> <SPAN class=string>"</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">;</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>Of course, it is also often possible to explicitly specify conversions when the default conversions provided by the language are not intuitive. </P></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="23118">Topic #23118: Exporting a C API.. C APIs are defined by a set of functions and global variables which are usually exported from a binary. C functions have an arbitrary number of arguments ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Exporting a C API</H2></DIV></DIV></DIV>
<P>C APIs are defined by a set of functions and global variables which are usually exported from a binary. C functions have an arbitrary number of arguments and one return value. Each function is thus uniquely identified by the function name and the set of C types which describe the function arguments and return value. The global variables exported by the API are similarly identified by their name and their type. </P>
<P>A C API is thus merely defined by a set of names to which a set of types are associated. If you know the function calling convention and the mapping of the C types to the machine types used by the platform you are on, you can resolve the name of each function to find where the code associated to this function is located in memory, and then construct a valid argument list for the function. Finally, all you have to do is trigger a call to the target C function with the argument list. </P>
<P>For the sake of discussion, here is a sample C function and the associated 32 bit x86 assembly code generated by GCC on a Linux computer: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>function_foo</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">int</SPAN> foo<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">int</SPAN>
<SPAN class=function>main</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">int</SPAN>   argc<SPAN class="gtkdoc opt">,</SPAN>
      <SPAN class="gtkdoc kwb">char</SPAN> <SPAN class="gtkdoc opt">*</SPAN>argv<SPAN class="gtkdoc opt">[])</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
	<SPAN class=function>function_foo</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=number>10</SPAN><SPAN class="gtkdoc opt">);</SPAN>

	<SPAN class=keyword>return</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

push   $<SPAN class=number>0xa</SPAN>
call   <SPAN class=number>0x80482f4</SPAN> <SPAN class="gtkdoc opt">&lt;</SPAN>function_foo<SPAN class="gtkdoc opt">&gt;</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>The assembly code shown above is pretty straightforward: the first instruction pushes the hexadecimal value 0xa (decimal value 10) as a 32-bit integer on the stack and calls <CODE class=function>function_foo</CODE>. As you can see, C function calls are implemented by GCC as native function calls (this is probably the fastest implementation possible). </P>
<P>Now, let's say we want to call the C function <CODE class=function>function_foo</CODE> from a Python program. To do this, the Python interpreter needs to: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>Find where the function is located. This probably means finding the binary generated by the C compiler which exports this function.</P>
<LI class=listitem>
<P>Load the code of the function in executable memory.</P>
<LI class=listitem>
<P>Convert the Python parameters to C-compatible parameters before calling the function.</P>
<LI class=listitem>
<P>Call the function with the right calling convention.</P>
<LI class=listitem>
<P>Convert the return values of the C function to Python-compatible variables to return them to the Python code.</P></LI></UL></DIV>
<P></P>
<P>The process described above is pretty complex and there are a lot of ways to make it entirely automatic and transparent to C and Python programmers: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>The first solution is to write by hand a lot of glue code, once for each function exported or imported, which does the Python-to-C parameter conversion and the C-to-Python return value conversion. This glue code is then linked with the interpreter which allows Python programs to call Python functions which delegate work to C functions.</P>
<LI class=listitem>
<P>Another, nicer solution is to automatically generate the glue code, once for each function exported or imported, with a special compiler which reads the original function signature.</P>
<LI class=listitem>
<P>The solution used by GLib is to use the GType library which holds at runtime a description of all the objects manipulated by the programmer. This so-called <SPAN class=emphasis><EM>dynamic type</EM></SPAN> <A class=footnote href="https://developer.gnome.org/gobject/stable/ch01s02.html#ftn.id-1.3.2.6.6.1.3.1.2" name=id-1.3.2.6.6.1.3.1.2><SUP class=footnote>[1]</SUP></A> library is then used by special generic glue code to automatically convert function parameters and function calling conventions between different runtime domains.</P></LI></UL></DIV>
<P>The greatest advantage of the solution implemented by GType is that the glue code sitting at the runtime domain boundaries is written once: the figure below states this more clearly. </P>
<DIV class=figure><A name=id-1.3.2.6.6.2></A>
<P class=title><B>Figure&nbsp;1.&nbsp;</B></P>
<DIV class=figure-contents>
<DIV class=mediaobject align=center><IMG src="https://developer.gnome.org/gobject/stable/glue.png" align=middle></DIV></DIV></DIV>
<P><BR class=figure-break>Currently, there exist at least Python and Perl generic glue code which makes it possible to use C objects written with GType directly in Python or Perl, with a minimum amount of work: there is no need to generate huge amounts of glue code either automatically or by hand. </P>
<P>Although that goal was arguably laudable, its pursuit has had a major influence on the whole GType/GObject library. C programmers are likely to be puzzled at the complexity of the features exposed in the following chapters if they forget that the GType/GObject library was not only designed to offer OO-like features to C programmers but also transparent cross-language interoperability. </P>
<DIV class=footnotes><BR>
<HR style="WIDTH: 100px; TEXT-ALIGN: left; MARGIN-LEFT: 0px">

<DIV id=ftn.id-1.3.2.6.6.1.3.1.2 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/ch01s02.html#id-1.3.2.6.6.1.3.1.2"><SUP class=para>[1] </SUP></A>There are numerous different implementations of dynamic type systems: all C++ compilers have one, Java and .NET have one too. A dynamic type system allows you to get information about every instantiated object at runtime. It can be implemented by a process-specific database: every new object created registers the characteristics of its associated type in the type system. It can also be implemented by introspection interfaces. The common point between all these different type systems and implementations is that they all allow you to query for object metadata at runtime. </P></DIV></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28663">Topic #28663: The GLib Dynamic Type System.. Copy functions .. Conventions .. Non-instantiable non-classed fundamental types .. Instantiable classed types: objects .. Initialization and ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title>The GLib Dynamic Type System</H2></DIV></DIV></DIV>
<DIV class=toc>
<DL class=toc>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-gtype.html#gtype-copy">Copy functions</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-conventions.html">Conventions</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable.html">Non-instantiable non-classed fundamental types</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-instantiable-classed.html">Instantiable classed types: objects</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gtype-instantiable-classed.html#gtype-instantiable-classed-init-done">Initialization and Destruction</A></SPAN></DT></DL>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html">Non-instantiable classed types: interfaces</A></SPAN> 
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-init">Interface Initialization</A></SPAN> 
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-dest">Interface Destruction</A></SPAN></DT></DL></DD></DL></DIV>
<P>A type, as manipulated by the GLib type system, is much more generic than what is usually understood as an Object type. It is best explained by looking at the structure and the functions used to register new types in the type system. </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> _GTypeInfo               GTypeInfo<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc kwb">struct</SPAN> _GTypeInfo
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=comment>/* interface types, classed types, instantiated types */</SPAN>
  guint16                class_size<SPAN class="gtkdoc opt">;</SPAN>
  
  GBaseInitFunc          base_init<SPAN class="gtkdoc opt">;</SPAN>
  GBaseFinalizeFunc      base_finalize<SPAN class="gtkdoc opt">;</SPAN>
  
  <SPAN class=comment>/* classed types, instantiated types */</SPAN>
  GClassInitFunc         class_init<SPAN class="gtkdoc opt">;</SPAN>
  GClassFinalizeFunc     class_finalize<SPAN class="gtkdoc opt">;</SPAN>
  gconstpointer          class_data<SPAN class="gtkdoc opt">;</SPAN>
  
  <SPAN class=comment>/* instantiated types */</SPAN>
  guint16                instance_size<SPAN class="gtkdoc opt">;</SPAN>
  guint16                n_preallocs<SPAN class="gtkdoc opt">;</SPAN>
  GInstanceInitFunc      instance_init<SPAN class="gtkdoc opt">;</SPAN>
  
  <SPAN class=comment>/* value handling */</SPAN>
  <SPAN class="gtkdoc kwb">const</SPAN> GTypeValueTable <SPAN class="gtkdoc opt">*</SPAN>value_table<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">};</SPAN>
GType <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-static">g_type_register_static</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>GType             parent_type<SPAN class="gtkdoc opt">,</SPAN>
                              <SPAN class="gtkdoc kwb">const</SPAN> gchar      <SPAN class="gtkdoc opt">*</SPAN>type_name<SPAN class="gtkdoc opt">,</SPAN>
                              <SPAN class="gtkdoc kwb">const</SPAN> GTypeInfo  <SPAN class="gtkdoc opt">*</SPAN>info<SPAN class="gtkdoc opt">,</SPAN>
                              GTypeFlags        flags<SPAN class="gtkdoc opt">);</SPAN>
GType <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-fundamental">g_type_register_fundamental</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>GType                       type_id<SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class="gtkdoc kwb">const</SPAN> gchar                <SPAN class="gtkdoc opt">*</SPAN>type_name<SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class="gtkdoc kwb">const</SPAN> GTypeInfo            <SPAN class="gtkdoc opt">*</SPAN>info<SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class="gtkdoc kwb">const</SPAN> GTypeFundamentalInfo <SPAN class="gtkdoc opt">*</SPAN>finfo<SPAN class="gtkdoc opt">,</SPAN>
                                   GTypeFlags                  flags<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P><CODE class=function><A title=g_type_register_static&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-static">g_type_register_static</A></CODE>, <CODE class=function><A title=g_type_register_dynamic&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-dynamic">g_type_register_dynamic</A></CODE> and <CODE class=function><A title=g_type_register_fundamental&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-fundamental">g_type_register_fundamental</A></CODE> are the C functions, defined in <CODE class=filename>gtype.h</CODE> and implemented in <CODE class=filename>gtype.c</CODE> which you should use to register a new <A title=GType class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GType"><SPAN class=type>GType</SPAN></A> in the program's type system. It is not likely you will ever need to use <CODE class=function><A title=g_type_register_fundamental&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-fundamental">g_type_register_fundamental</A></CODE> but in case you want to, the last chapter explains how to create new fundamental types. </P>
<P>Fundamental types are top-level types which do not derive from any other type while other non-fundamental types derive from other types. Upon initialization, the type system not only initializes its internal data structures but it also registers a number of core types: some of these are fundamental types. Others are types derived from these fundamental types. </P>
<P>Fundamental and non-fundamental types are defined by: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>class size: the class_size field in <A title="struct GTypeInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInfo"><SPAN class=type>GTypeInfo</SPAN></A>. </P>
<LI class=listitem>
<P>class initialization functions (C++ constructor): the <CODE class=function>base_init</CODE> and <CODE class=function>class_init</CODE> fields in <A title="struct GTypeInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInfo"><SPAN class=type>GTypeInfo</SPAN></A>. </P>
<LI class=listitem>
<P>class destruction functions (C++ destructor): the base_finalize and class_finalize fields in <A title="struct GTypeInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInfo"><SPAN class=type>GTypeInfo</SPAN></A>. </P>
<LI class=listitem>
<P>instance size (C++ parameter to new): the instance_size field in <A title="struct GTypeInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInfo"><SPAN class=type>GTypeInfo</SPAN></A>. </P>
<LI class=listitem>
<P>instantiation policy (C++ type of new operator): the n_preallocs field in <A title="struct GTypeInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInfo"><SPAN class=type>GTypeInfo</SPAN></A>. </P>
<LI class=listitem>
<P>copy functions (C++ copy operators): the value_table field in <A title="struct GTypeInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInfo"><SPAN class=type>GTypeInfo</SPAN></A>. </P>
<LI class=listitem>
<P>type characteristic flags: <A title="enum GTypeFlags" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeFlags"><SPAN class=type>GTypeFlags</SPAN></A>. </P></LI></UL></DIV>
<P>Fundamental types are also defined by a set of <A title="enum GTypeFundamentalFlags" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeFundamentalFlags"><SPAN class=type>GTypeFundamentalFlags</SPAN></A> which are stored in a <A title="struct GTypeFundamentalInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeFundamentalInfo"><SPAN class=type>GTypeFundamentalInfo</SPAN></A>. Non-fundamental types are furthermore defined by the type of their parent which is passed as the parent_type parameter to <CODE class=function><A title=g_type_register_static&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-static">g_type_register_static</A></CODE> and <CODE class=function><A title=g_type_register_dynamic&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-dynamic">g_type_register_dynamic</A></CODE>. </P>
<DIV class=sect1>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=gtype-copy></A>Copy functions</H2></DIV></DIV></DIV>
<P>The major common point between <SPAN class=emphasis><EM>all</EM></SPAN> GLib types (fundamental and non-fundamental, classed and non-classed, instantiable and non-instantiable) is that they can all be manipulated through a single API to copy/assign them. </P>
<P>The <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A> structure is used as an abstract container for all of these types. Its simplistic API (defined in <CODE class=filename>gobject/gvalue.h</CODE>) can be used to invoke the value_table functions registered during type registration: for example <CODE class=function><A title=g_value_copy&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-copy">g_value_copy</A></CODE> copies the content of a <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A> to another <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A>. This is similar to a C++ assignment which invokes the C++ copy operator to modify the default bit-by-bit copy semantics of C++/C structures/classes. </P>
<P>The following code shows how you can copy around a 64 bit integer, as well as a <A class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject"><SPAN class=type>GObject</SPAN></A> instance pointer: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">static void</SPAN> <SPAN class=function>test_int</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  GValue a_value <SPAN class="gtkdoc opt">=</SPAN> G_VALUE_INIT<SPAN class="gtkdoc opt">;</SPAN>
  GValue b_value <SPAN class="gtkdoc opt">=</SPAN> G_VALUE_INIT<SPAN class="gtkdoc opt">;</SPAN>
  guint64 a<SPAN class="gtkdoc opt">,</SPAN> b<SPAN class="gtkdoc opt">;</SPAN>

  a <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0xdeadbeef</SPAN><SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-init">g_value_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>a_value<SPAN class="gtkdoc opt">,</SPAN> G_TYPE_UINT64<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-set-uint64">g_value_set_uint64</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>a_value<SPAN class="gtkdoc opt">,</SPAN> a<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-init">g_value_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>b_value<SPAN class="gtkdoc opt">,</SPAN> G_TYPE_UINT64<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-copy">g_value_copy</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>a_value<SPAN class="gtkdoc opt">, &amp;</SPAN>b_value<SPAN class="gtkdoc opt">);</SPAN>

  b <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-get-uint64">g_value_get_uint64</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>b_value<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN>a <SPAN class="gtkdoc opt">==</SPAN> b<SPAN class="gtkdoc opt">) {</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-print">g_print</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"Yay !! 10 lines of code to copy around a uint64.</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc opt">}</SPAN> <SPAN class=keyword>else</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-print">g_print</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"Are you sure this is not a Z80 ?</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc opt">}</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN> <SPAN class=function>test_object</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  GObject <SPAN class="gtkdoc opt">*</SPAN>obj<SPAN class="gtkdoc opt">;</SPAN>
  GValue obj_vala <SPAN class="gtkdoc opt">=</SPAN> G_VALUE_INIT<SPAN class="gtkdoc opt">;</SPAN>
  GValue obj_valb <SPAN class="gtkdoc opt">=</SPAN> G_VALUE_INIT<SPAN class="gtkdoc opt">;</SPAN>
  obj <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>VIEWER_TYPE_FILE<SPAN class="gtkdoc opt">,</SPAN> NULL<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-init">g_value_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>obj_vala<SPAN class="gtkdoc opt">,</SPAN> VIEWER_TYPE_FILE<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-set-object">g_value_set_object</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>obj_vala<SPAN class="gtkdoc opt">,</SPAN> obj<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-init">g_value_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>obj_valb<SPAN class="gtkdoc opt">,</SPAN> G_TYPE_OBJECT<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=comment>/* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.</SPAN>
<SPAN class=comment>   * This function thus calls g_object_ref.</SPAN>
<SPAN class=comment>   * It is interesting to note that the assignment works here because</SPAN>
<SPAN class=comment>   * VIEWER_TYPE_FILE is a G_TYPE_OBJECT.</SPAN>
<SPAN class=comment>   */</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-copy">g_value_copy</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>obj_vala<SPAN class="gtkdoc opt">, &amp;</SPAN>obj_valb<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT:CAPS">G_OBJECT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>obj<SPAN class="gtkdoc opt">));</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT:CAPS">G_OBJECT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>obj<SPAN class="gtkdoc opt">));</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>The important point about the above code is that the exact semantics of the copy calls is undefined since they depend on the implementation of the copy function. Certain copy functions might decide to allocate a new chunk of memory and then to copy the data from the source to the destination. Others might want to simply increment the reference count of the instance and copy the reference to the new GValue. </P>
<P>The value table used to specify these assignment functions is documented in <A title="struct GTypeValueTable" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeValueTable"><SPAN class=type>GTypeValueTable</SPAN></A>. </P>
<P>Interestingly, it is also very unlikely you will ever need to specify a value_table during type registration because these value_tables are inherited from the parent types for non-fundamental types. </P></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28664">Topic #28664: Conventions.. There are a number of conventions users are expected to follow when creating new types which are to be exported in a header file: .. Type names (including object ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=sect1>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Conventions</H2></DIV></DIV></DIV>
<P>There are a number of conventions users are expected to follow when creating new types which are to be exported in a header file: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>Type names (including object names) must be at least three characters long and start with &#8216;a&#8211;z&#8217;, &#8216;A&#8211;Z&#8217; or &#8216;_&#8217;. </P></LI>
<LI class=listitem>
<P>Use the <CODE class=function>object_method</CODE> pattern for function names: to invoke the method named <CODE class=function>save</CODE> on an instance of object type <SPAN class=type>file</SPAN>, call <CODE class=function>file_save</CODE>. </P></LI>
<LI class=listitem>
<P>Use prefixing to avoid namespace conflicts with other projects. If your library (or application) is named <SPAN class=emphasis><EM>Viewer</EM></SPAN>, prefix all your function names with <SPAN class=emphasis><EM>viewer_</EM></SPAN>. For example: <CODE class=function>viewer_object_method</CODE>. </P></LI>
<LI class=listitem>
<P>Create a macro named <CODE class=function>PREFIX_TYPE_OBJECT</CODE> which always returns the GType for the associated object type. For an object of type <SPAN class=emphasis><EM>File</EM></SPAN> in the <SPAN class=emphasis><EM>Viewer</EM></SPAN> namespace, use: <CODE class=function>VIEWER_TYPE_FILE</CODE>. This macro is implemented using a function named <CODE class=function>prefix_object_get_type</CODE>; for example, <CODE class=function>viewer_file_get_type</CODE>. </P></LI>
<LI class=listitem>
<P>Use <A title=G_DECLARE_FINAL_TYPE() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DECLARE-FINAL-TYPE:CAPS"><CODE class=function>G_DECLARE_FINAL_TYPE</CODE></A> or <A title=G_DECLARE_DERIVABLE_TYPE() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DECLARE-DERIVABLE-TYPE:CAPS"><CODE class=function>G_DECLARE_DERIVABLE_TYPE</CODE></A> to define various other conventional macros for your object: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: circle">
<LI class=listitem>
<P><CODE class=function>PREFIX_OBJECT (obj)</CODE>, which returns a pointer of type <SPAN class=type>PrefixObject</SPAN>. This macro is used to enforce static type safety by doing explicit casts wherever needed. It also enforces dynamic type safety by doing runtime checks. It is possible to disable the dynamic type checks in production builds (see building GLib). For example, we would create <CODE class=function>VIEWER_FILE (obj)</CODE> to keep the previous example. </P></LI>
<LI class=listitem>
<P><CODE class=function>PREFIX_OBJECT_CLASS (klass)</CODE>, which is strictly equivalent to the previous casting macro: it does static casting with dynamic type checking of class structures. It is expected to return a pointer to a class structure of type <SPAN class=type>PrefixObjectClass</SPAN>. An example is: <CODE class=function>VIEWER_FILE_CLASS</CODE>. </P></LI>
<LI class=listitem>
<P><CODE class=function>PREFIX_IS_OBJECT (obj)</CODE>, which returns a <SPAN class=type>gboolean</SPAN> which indicates whether the input object instance pointer is non-<SPAN class=type>NULL</SPAN> and of type <SPAN class=type>OBJECT</SPAN>. For example, <CODE class=function>VIEWER_IS_FILE</CODE>. </P></LI>
<LI class=listitem>
<P><CODE class=function>PREFIX_IS_OBJECT_CLASS (klass)</CODE>, which returns a boolean if the input class pointer is a pointer to a class of type OBJECT. For example, <CODE class=function>VIEWER_IS_FILE_CLASS</CODE>. </P></LI>
<LI class=listitem>
<P><CODE class=function>PREFIX_OBJECT_GET_CLASS (obj)</CODE>, which returns the class pointer associated to an instance of a given type. This macro is used for static and dynamic type safety purposes (just like the previous casting macros). For example, <CODE class=function>VIEWER_FILE_GET_CLASS</CODE>. </P></LI></UL></DIV></LI></UL></DIV>
<P>The implementation of these macros is pretty straightforward: a number of simple-to-use macros are provided in <CODE class=filename>gtype.h</CODE>. For the example we used above, we would write the following trivial code to declare the macros: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc ppc">#define VIEWER_TYPE_FILE viewer_file_get_type ()</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DECLARE-FINAL-TYPE:CAPS">G_DECLARE_FINAL_TYPE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile<SPAN class="gtkdoc opt">,</SPAN> viewer_file<SPAN class="gtkdoc opt">,</SPAN> VIEWER<SPAN class="gtkdoc opt">,</SPAN> <SPAN class="gtkdoc kwb">FILE</SPAN><SPAN class="gtkdoc opt">,</SPAN> GObject<SPAN class="gtkdoc opt">)</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Unless your code has special requirements, you can use the <CODE class=function><A title=G_DEFINE_TYPE() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE:CAPS">G_DEFINE_TYPE</A></CODE> macro to define a class: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE:CAPS">G_DEFINE_TYPE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile<SPAN class="gtkdoc opt">,</SPAN> viewer_file<SPAN class="gtkdoc opt">,</SPAN> G_TYPE_OBJECT<SPAN class="gtkdoc opt">)</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Otherwise, the <CODE class=function>viewer_file_get_type</CODE> function must be implemented manually: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>GType <SPAN class=function>viewer_file_get_type</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static</SPAN> GType type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN>type <SPAN class="gtkdoc opt">==</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">) {</SPAN>
    <SPAN class="gtkdoc kwb">const</SPAN> GTypeInfo info <SPAN class="gtkdoc opt">= {</SPAN>
      <SPAN class=comment>/* You fill this structure. */</SPAN>
    <SPAN class="gtkdoc opt">};</SPAN>
    type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-static">g_type_register_static</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>G_TYPE_OBJECT<SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class=string>"ViewerFile"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class="gtkdoc opt">&amp;</SPAN>info<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc opt">}</SPAN>
  <SPAN class=keyword>return</SPAN> type<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P></DIV>
<DIV class=footer>
<HR>
</DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28665">Topic #28665: Non-instantiable non-classed fundamental types.. A lot of types are not instantiable by the type system and do not have a class. Most of these types are fundamental trivial ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Non-instantiable non-classed fundamental types</H2></DIV></DIV></DIV>
<P>A lot of types are not instantiable by the type system and do not have a class. Most of these types are fundamental trivial types such as <SPAN class=emphasis><EM>gchar</EM></SPAN>, and are already registered by GLib. </P>
<P>In the rare case of needing to register such a type in the type system, fill a <A title="struct GTypeInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInfo"><SPAN class=type>GTypeInfo</SPAN></A> structure with zeros since these types are also most of the time fundamental: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>GTypeInfo info <SPAN class="gtkdoc opt">= {</SPAN>
  <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">,</SPAN>                                <SPAN class=comment>/* class_size */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* base_init */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* base_destroy */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* class_init */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* class_destroy */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* class_data */</SPAN>
  <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">,</SPAN>                                <SPAN class=comment>/* instance_size */</SPAN>
  <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">,</SPAN>                                <SPAN class=comment>/* n_preallocs */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* instance_init */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* value_table */</SPAN>
<SPAN class="gtkdoc opt">};</SPAN>
<SPAN class="gtkdoc kwb">static const</SPAN> GTypeValueTable value_table <SPAN class="gtkdoc opt">= {</SPAN>
  value_init_long0<SPAN class="gtkdoc opt">,</SPAN>                <SPAN class=comment>/* value_init */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* value_free */</SPAN>
  value_copy_long0<SPAN class="gtkdoc opt">,</SPAN>                <SPAN class=comment>/* value_copy */</SPAN>
  NULL<SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* value_peek_pointer */</SPAN>
  <SPAN class=string>"i"</SPAN><SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* collect_format */</SPAN>
  value_collect_int<SPAN class="gtkdoc opt">,</SPAN>        <SPAN class=comment>/* collect_value */</SPAN>
  <SPAN class=string>"p"</SPAN><SPAN class="gtkdoc opt">,</SPAN>                        <SPAN class=comment>/* lcopy_format */</SPAN>
  value_lcopy_char<SPAN class="gtkdoc opt">,</SPAN>                <SPAN class=comment>/* lcopy_value */</SPAN>
<SPAN class="gtkdoc opt">};</SPAN>
info<SPAN class="gtkdoc opt">.</SPAN>value_table <SPAN class="gtkdoc opt">= &amp;</SPAN>value_table<SPAN class="gtkdoc opt">;</SPAN>
type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-fundamental">g_type_register_fundamental</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>G_TYPE_CHAR<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=string>"gchar"</SPAN><SPAN class="gtkdoc opt">, &amp;</SPAN>info<SPAN class="gtkdoc opt">, &amp;</SPAN>finfo<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Having non-instantiable types might seem a bit useless: what good is a type if you cannot instantiate an instance of that type ? Most of these types are used in conjunction with <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A>s: a GValue is initialized with an integer or a string and it is passed around by using the registered type's value_table. <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A>s (and by extension these trivial fundamental types) are most useful when used in conjunction with object properties and signals.
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28666">Topic #28666: Instantiable classed types: objects.. This section covers the theory behind objects. See How to define and implement a new GObject for the recommended way to define a GObject. ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Instantiable classed types: objects</H2></DIV></DIV></DIV>
<P>This section covers the theory behind objects. See <A title="How to define and implement a new GObject" class=xref href="https://developer.gnome.org/gobject/stable/howto-gobject.html"><I>How to define and implement a new GObject</I></A> for the recommended way to define a GObject. </P>
<P>Types which are registered with a class and are declared instantiable are what most closely resembles an <SPAN class=emphasis><EM>object</EM></SPAN>. Although <A class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject"><SPAN class=type>GObject</SPAN></A>s (detailed in <A title="The GObject base class" class=xref href="https://developer.gnome.org/gobject/stable/chapter-gobject.html"><I>The GObject base class</I></A>) are the most well known type of instantiable classed types, other kinds of similar objects used as the base of an inheritance hierarchy have been externally developed and they are all built on the fundamental features described below. </P>
<P>For example, the code below shows how you could register such a fundamental object type in the type system (using none of the GObject convenience API): </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  GObject parent<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=comment>/* instance members */</SPAN>
  gchar <SPAN class="gtkdoc opt">*</SPAN>filename<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> ViewerFile<SPAN class="gtkdoc opt">;</SPAN>

<SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  GObjectClass parent<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=comment>/* class members */</SPAN>
  <SPAN class=comment>/* the first is public, pure and virtual */</SPAN>
  <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>open<SPAN class="gtkdoc opt">)  (</SPAN>ViewerFile  <SPAN class="gtkdoc opt">*</SPAN>self<SPAN class="gtkdoc opt">,</SPAN>
                 GError     <SPAN class="gtkdoc opt">**</SPAN>error<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=comment>/* the second is public and virtual */</SPAN>
  <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>close<SPAN class="gtkdoc opt">) (</SPAN>ViewerFile  <SPAN class="gtkdoc opt">*</SPAN>self<SPAN class="gtkdoc opt">,</SPAN>
                 GError     <SPAN class="gtkdoc opt">**</SPAN>error<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> ViewerFileClass<SPAN class="gtkdoc opt">;</SPAN>

<SPAN class="gtkdoc ppc">#define VIEWER_TYPE_FILE (viewer_file_get_type ())</SPAN>

GType 
<SPAN class=function>viewer_file_get_type</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static</SPAN> GType type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN>type <SPAN class="gtkdoc opt">==</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">) {</SPAN>
    <SPAN class="gtkdoc kwb">const</SPAN> GTypeInfo info <SPAN class="gtkdoc opt">= {</SPAN>
      <SPAN class=keyword>sizeof</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFileClass<SPAN class="gtkdoc opt">),</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>           <SPAN class=comment>/* base_init */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>           <SPAN class=comment>/* base_finalize */</SPAN>
      <SPAN class="gtkdoc opt">(</SPAN>GClassInitFunc<SPAN class="gtkdoc opt">)</SPAN> viewer_file_class_init<SPAN class="gtkdoc opt">,</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>           <SPAN class=comment>/* class_finalize */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>           <SPAN class=comment>/* class_data */</SPAN>
      <SPAN class=keyword>sizeof</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile<SPAN class="gtkdoc opt">),</SPAN>
      <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">,</SPAN>              <SPAN class=comment>/* n_preallocs */</SPAN>
      <SPAN class="gtkdoc opt">(</SPAN>GInstanceInitFunc<SPAN class="gtkdoc opt">)</SPAN> NULL <SPAN class=comment>/* instance_init */</SPAN>
    <SPAN class="gtkdoc opt">};</SPAN>
    type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-static">g_type_register_static</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>G_TYPE_OBJECT<SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class=string>"ViewerFile"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class="gtkdoc opt">&amp;</SPAN>info<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc opt">}</SPAN>
  <SPAN class=keyword>return</SPAN> type<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>Upon the first call to <CODE class=function>viewer_file_get_type</CODE>, the type named <SPAN class=emphasis><EM>ViewerFile</EM></SPAN> will be registered in the type system as inheriting from the type <SPAN class=emphasis><EM>G_TYPE_OBJECT</EM></SPAN>. </P>
<P>Every object must define two structures: its class structure and its instance structure. All class structures must contain as first member a <A title="struct GTypeClass" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeClass"><SPAN class=type>GTypeClass</SPAN></A> structure. All instance structures must contain as first member a <A title="struct GTypeInstance" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInstance"><SPAN class=type>GTypeInstance</SPAN></A> structure. The declaration of these C types, coming from <CODE class=filename>gtype.h</CODE> is shown below: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">struct</SPAN> _GTypeClass
<SPAN class="gtkdoc opt">{</SPAN>
  GType g_type<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">};</SPAN>
<SPAN class="gtkdoc kwb">struct</SPAN> _GTypeInstance
<SPAN class="gtkdoc opt">{</SPAN>
  GTypeClass <SPAN class="gtkdoc opt">*</SPAN>g_class<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">};</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>These constraints allow the type system to make sure that every object instance (identified by a pointer to the object's instance structure) contains in its first bytes a pointer to the object's class structure. </P>
<P>This relationship is best explained by an example: let's take object B which inherits from object A: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class=comment>/* A definitions */</SPAN>
<SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  GTypeInstance parent<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">int</SPAN> field_a<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">int</SPAN> field_b<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> A<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  GTypeClass parent_class<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>method_a<SPAN class="gtkdoc opt">) (</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>method_b<SPAN class="gtkdoc opt">) (</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> AClass<SPAN class="gtkdoc opt">;</SPAN>

<SPAN class=comment>/* B definitions. */</SPAN>
<SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  A parent<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">int</SPAN> field_c<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">int</SPAN> field_d<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> B<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  AClass parent_class<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>method_c<SPAN class="gtkdoc opt">) (</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>method_d<SPAN class="gtkdoc opt">) (</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> BClass<SPAN class="gtkdoc opt">;</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>The C standard mandates that the first field of a C structure is stored starting in the first byte of the buffer used to hold the structure's fields in memory. This means that the first field of an instance of an object B is A's first field which in turn is <SPAN class=type>GTypeInstance</SPAN>'s first field which in turn is <EM class=structfield><CODE>g_class</CODE></EM>, a pointer to B's class structure. </P>
<P>Thanks to these simple conditions, it is possible to detect the type of every object instance by doing: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>B <SPAN class="gtkdoc opt">*</SPAN>b<SPAN class="gtkdoc opt">;</SPAN>
b<SPAN class="gtkdoc opt">-&gt;</SPAN>parent<SPAN class="gtkdoc opt">.</SPAN>parent<SPAN class="gtkdoc opt">.</SPAN>g_class<SPAN class="gtkdoc opt">-&gt;</SPAN>g_type</PRE></TD></TR></TBODY></TABLE></DIV>
<P>or, more quickly: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>B <SPAN class="gtkdoc opt">*</SPAN>b<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">((</SPAN>GTypeInstance <SPAN class="gtkdoc opt">*)</SPAN> b<SPAN class="gtkdoc opt">)-&gt;</SPAN>g_class<SPAN class="gtkdoc opt">-&gt;</SPAN>g_type</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gtype-instantiable-classed-init-done></A>Initialization and Destruction</H3></DIV></DIV></DIV>
<P>instantiation of these types can be done with <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE>, which will look up the type information structure associated with the type requested. Then, the instance size and instantiation policy (if the <EM class=structfield><CODE>n_preallocs</CODE></EM> field is set to a non-zero value, the type system allocates the object's instance structures in chunks rather than mallocing for every instance) declared by the user are used to get a buffer to hold the object's instance structure. </P>
<P>If this is the first instance of the object ever created, the type system must create a class structure. It allocates a buffer to hold the object's class structure and initializes it. The first part of the class structure (ie: the embedded parent class structure) is initialized by copying the contents from the class structure of the parent class. The rest of class structure is initialized to zero. If there is no parent, the entire class structure is initialized to zero. The type system then invokes the <CODE class=function>base_class_initialization</CODE> functions (<A title=GBaseInitFunc&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GBaseInitFunc"><SPAN class=type>GBaseInitFunc</SPAN></A>) from topmost fundamental object to bottom-most most derived object. The object's <CODE class=function>class_init</CODE> (<A title=GClassInitFunc&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GClassInitFunc"><SPAN class=type>GClassInitFunc</SPAN></A>) function is invoked afterwards to complete initialization of the class structure. Finally, the object's interfaces are initialized (we will discuss interface initialization in more detail later). </P>
<P>Once the type system has a pointer to an initialized class structure, it sets the object's instance class pointer to the object's class structure and invokes the object's <CODE class=function>instance_init</CODE> (<A title=GInstanceInitFunc&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GInstanceInitFunc"><SPAN class=type>GInstanceInitFunc</SPAN></A>) functions, from top-most fundamental type to bottom-most most-derived type. </P>
<P>Object instance destruction through <CODE class=function><A title=g_type_free_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</A></CODE> is very simple: the instance structure is returned to the instance pool if there is one and if this was the last living instance of the object, the class is destroyed. </P>
<P>Class destruction (the concept of destruction is sometimes partly referred to as finalization in GType) is the symmetric process of the initialization: interfaces are destroyed first. Then, the most derived class_finalize (<A title=GClassFinalizeFunc&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GClassFinalizeFunc"><SPAN class=type>GClassFinalizeFunc</SPAN></A>) function is invoked. Finally, the base_class_finalize (<A title=GBaseFinalizeFunc&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GBaseFinalizeFunc"><SPAN class=type>GBaseFinalizeFunc</SPAN></A>) functions are invoked from bottom-most most-derived type to top-most fundamental type and the class structure is freed. </P>
<P>The base initialization/finalization process is very similar to the C++ constructor/destructor paradigm. The practical details are different though and it is important not to get confused by superficial similarities. GTypes have no instance destruction mechanism. It is the user's responsibility to implement correct destruction semantics on top of the existing GType code. (This is what GObject does: see <A title="The GObject base class" class=xref href="https://developer.gnome.org/gobject/stable/chapter-gobject.html"><I>The GObject base class</I></A>.) Furthermore, C++ code equivalent to the <CODE class=function>base_init</CODE> and <CODE class=function>class_init</CODE> callbacks of GType is usually not needed because C++ cannot really create object types at runtime. </P>
<P>The instantiation/finalization process can be summarized as follows: </P>
<DIV class=table><A name=gtype-init-fini-table></A>
<P class=title><B>Table&nbsp;1.&nbsp;GType Instantiation/Finalization</B></P>
<DIV class=table-contents>
<TABLE class=table summary="GType Instantiation/Finalization" border=1>
<COLGROUP>
<COL align=left>
<COL align=left>
<COL align=left></COLGROUP>
<THEAD>
<TR>
<TH align=left>Invocation time</TH>
<TH align=left>Function invoked</TH>
<TH align=left>Function's parameters</TH></TR></THEAD>
<TBODY>
<TR>
<TD rowSpan=3 align=left>First call to <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> for target type</TD>
<TD align=left>type's <CODE class=function>base_init</CODE> function</TD>
<TD align=left>On the inheritance tree of classes from fundamental type to target type. <CODE class=function>base_init</CODE> is invoked once for each class structure.</TD></TR>
<TR>
<TD align=left>target type's <CODE class=function>class_init</CODE> function</TD>
<TD align=left>On target type's class structure</TD></TR>
<TR>
<TD align=left>interface initialization, see <A title="Interface Initialization" class=xref href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-init">the section called &#8220;Interface Initialization&#8221;</A> </TD>
<TD align=left>&nbsp;</TD></TR>
<TR>
<TD align=left>Each call to <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> for target type</TD>
<TD align=left>target type's <CODE class=function>instance_init</CODE> function</TD>
<TD align=left>On object's instance</TD></TR>
<TR>
<TD rowSpan=3 align=left>Last call to <CODE class=function><A title=g_type_free_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</A></CODE> for target type</TD>
<TD align=left>interface destruction, see <A title="Interface Destruction" class=xref href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-dest">the section called &#8220;Interface Destruction&#8221;</A> </TD>
<TD align=left>&nbsp;</TD></TR>
<TR>
<TD align=left>target type's <CODE class=function>class_finalize</CODE> function</TD>
<TD align=left>On target type's class structure</TD></TR>
<TR>
<TD align=left>type's <CODE class=function>base_finalize</CODE> function</TD>
<TD align=left>On the inheritance tree of classes from fundamental type to target type. <CODE class=function>base_finalize</CODE> is invoked once for each class structure.</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28667">Topic #28667: Non-instantiable classed types: interfaces.. This section covers the theory behind interfaces. See How to define and implement interfaces for the recommended way to define an ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Non-instantiable classed types: interfaces</H2></DIV></DIV></DIV>
<P>This section covers the theory behind interfaces. See <A title="How to define and implement interfaces" class=xref href="https://developer.gnome.org/gobject/stable/howto-interface.html"><I>How to define and implement interfaces</I></A> for the recommended way to define an interface. </P>
<P>GType's interfaces are very similar to Java's interfaces. They allow to describe a common API that several classes will adhere to. Imagine the play, pause and stop buttons on hi-fi equipment &#8212; those can be seen as a playback interface. Once you know what they do, you can control your CD player, MP3 player or anything that uses these symbols. To declare an interface you have to register a non-instantiable classed type which derives from <A title="struct GTypeInterface" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInterface"><SPAN class=type>GTypeInterface</SPAN></A>. The following piece of code declares such an interface. </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc ppc">#define VIEWER_TYPE_EDITABLE viewer_editable_get_type ()</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DECLARE-INTERFACE:CAPS">G_DECLARE_INTERFACE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditable<SPAN class="gtkdoc opt">,</SPAN> viewer_editable<SPAN class="gtkdoc opt">,</SPAN> VIEWER<SPAN class="gtkdoc opt">,</SPAN> EDITABLE<SPAN class="gtkdoc opt">,</SPAN> GObject<SPAN class="gtkdoc opt">)</SPAN>

<SPAN class="gtkdoc kwb">struct</SPAN> _ViewerEditableInterface <SPAN class="gtkdoc opt">{</SPAN>
  GTypeInterface parent<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>save<SPAN class="gtkdoc opt">) (</SPAN>ViewerEditable  <SPAN class="gtkdoc opt">*</SPAN>self<SPAN class="gtkdoc opt">,</SPAN>
                GError         <SPAN class="gtkdoc opt">**</SPAN>error<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">};</SPAN>

<SPAN class="gtkdoc kwb">void</SPAN> <SPAN class=function>viewer_editable_save</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditable  <SPAN class="gtkdoc opt">*</SPAN>self<SPAN class="gtkdoc opt">,</SPAN>
                           GError         <SPAN class="gtkdoc opt">**</SPAN>error<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>The interface function, <CODE class=function>viewer_editable_save</CODE> is implemented in a pretty simple way: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">void</SPAN>
<SPAN class=function>viewer_editable_save</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditable  <SPAN class="gtkdoc opt">*</SPAN>self<SPAN class="gtkdoc opt">,</SPAN>
                      GError         <SPAN class="gtkdoc opt">**</SPAN>error<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  ViewerEditableinterface <SPAN class="gtkdoc opt">*</SPAN>iface<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-return-if-fail">g_return_if_fail</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function>VIEWER_IS_EDITABLE</SPAN> <SPAN class="gtkdoc opt">(</SPAN>self<SPAN class="gtkdoc opt">));</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-return-if-fail">g_return_if_fail</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>error <SPAN class="gtkdoc opt">==</SPAN> NULL <SPAN class="gtkdoc opt">|| *</SPAN>error <SPAN class="gtkdoc opt">==</SPAN> NULL<SPAN class="gtkdoc opt">);</SPAN>

  iface <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function>VIEWER_EDITABLE_GET_INTERFACE</SPAN> <SPAN class="gtkdoc opt">(</SPAN>self<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-return-if-fail">g_return_if_fail</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>iface<SPAN class="gtkdoc opt">-&gt;</SPAN>save <SPAN class="gtkdoc opt">!=</SPAN> NULL<SPAN class="gtkdoc opt">);</SPAN>
  iface<SPAN class="gtkdoc opt">-&gt;</SPAN><SPAN class=function>save</SPAN> <SPAN class="gtkdoc opt">(</SPAN>self<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P><CODE class=function>viewer_editable_get_type</CODE> registers a type named <SPAN class=emphasis><EM>ViewerEditable</EM></SPAN> which inherits from <SPAN class=type>G_TYPE_INTERFACE</SPAN>. All interfaces must be children of <SPAN class=type>G_TYPE_INTERFACE</SPAN> in the inheritance tree. </P>
<P>An interface is defined by only one structure which must contain as first member a <A title="struct GTypeInterface" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GTypeInterface"><SPAN class=type>GTypeInterface</SPAN></A> structure. The interface structure is expected to contain the function pointers of the interface methods. It is good style to define helper functions for each of the interface methods which simply call the interface's method directly: <CODE class=function>viewer_editable_save</CODE> is one of these. </P>
<P>If you have no special requirements you can use the <A title=G_IMPLEMENT_INTERFACE() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-IMPLEMENT-INTERFACE:CAPS">G_IMPLEMENT_INTERFACE</A> macro to implement an interface: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_save</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditable <SPAN class="gtkdoc opt">*</SPAN>self<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-print">g_print</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"File implementation of editable interface save method.</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_editable_interface_init</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditableInterface <SPAN class="gtkdoc opt">*</SPAN>iface<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  iface<SPAN class="gtkdoc opt">-&gt;</SPAN>save <SPAN class="gtkdoc opt">=</SPAN> viewer_file_save<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE-WITH-CODE:CAPS">G_DEFINE_TYPE_WITH_CODE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile<SPAN class="gtkdoc opt">,</SPAN> viewer_file<SPAN class="gtkdoc opt">,</SPAN> VIEWER_TYPE_FILE<SPAN class="gtkdoc opt">,</SPAN>
                         <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-IMPLEMENT-INTERFACE:CAPS">G_IMPLEMENT_INTERFACE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>VIEWER_TYPE_EDITABLE<SPAN class="gtkdoc opt">,</SPAN>
                                                viewer_file_editable_interface_init<SPAN class="gtkdoc opt">));</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>If your code does have special requirements, you must write a custom <CODE class=function>get_type</CODE> function to register your GType which inherits from some <A class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject"><SPAN class=type>GObject</SPAN></A> and which implements the interface <SPAN class=type>ViewerEditable</SPAN>. For example, this code registers a new <SPAN class=type>ViewerFile</SPAN> class which implements <SPAN class=type>ViewerEditable</SPAN>: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_save</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditable <SPAN class="gtkdoc opt">*</SPAN>editable<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-print">g_print</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"File implementation of editable interface save method.</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_editable_interface_init</SPAN> <SPAN class="gtkdoc opt">(</SPAN>gpointer g_iface<SPAN class="gtkdoc opt">,</SPAN>
                                     gpointer iface_data<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  ViewerEditableInterface <SPAN class="gtkdoc opt">*</SPAN>iface <SPAN class="gtkdoc opt">=</SPAN> g_iface<SPAN class="gtkdoc opt">;</SPAN>

  iface<SPAN class="gtkdoc opt">-&gt;</SPAN>save <SPAN class="gtkdoc opt">=</SPAN> viewer_file_save<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

GType 
<SPAN class=function>viewer_file_get_type</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static</SPAN> GType type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN>type <SPAN class="gtkdoc opt">==</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">) {</SPAN>
    <SPAN class="gtkdoc kwb">const</SPAN> GTypeInfo info <SPAN class="gtkdoc opt">= {</SPAN>
      <SPAN class=keyword>sizeof</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFileClass<SPAN class="gtkdoc opt">),</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* base_init */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* base_finalize */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* class_init */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* class_finalize */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* class_data */</SPAN>
      <SPAN class=keyword>sizeof</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile<SPAN class="gtkdoc opt">),</SPAN>
      <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">,</SPAN>      <SPAN class=comment>/* n_preallocs */</SPAN>
      NULL    <SPAN class=comment>/* instance_init */</SPAN>
    <SPAN class="gtkdoc opt">};</SPAN>
    <SPAN class="gtkdoc kwb">const</SPAN> GInterfaceInfo editable_info <SPAN class="gtkdoc opt">= {</SPAN>
      <SPAN class="gtkdoc opt">(</SPAN>GInterfaceInitFunc<SPAN class="gtkdoc opt">)</SPAN> viewer_file_editable_interface_init<SPAN class="gtkdoc opt">,</SPAN>  <SPAN class=comment>/* interface_init */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* interface_finalize */</SPAN>
      NULL    <SPAN class=comment>/* interface_data */</SPAN>
    <SPAN class="gtkdoc opt">};</SPAN>
    type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-static">g_type_register_static</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>VIEWER_TYPE_FILE<SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class=string>"ViewerFile"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                                   <SPAN class="gtkdoc opt">&amp;</SPAN>info<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">);</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-add-interface-static">g_type_add_interface_static</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>type<SPAN class="gtkdoc opt">,</SPAN>
                                 VIEWER_TYPE_EDITABLE<SPAN class="gtkdoc opt">,</SPAN>
                                 <SPAN class="gtkdoc opt">&amp;</SPAN>editable_info<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc opt">}</SPAN>
  <SPAN class=keyword>return</SPAN> type<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P><CODE class=function><A title=g_type_add_interface_static&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-add-interface-static">g_type_add_interface_static</A></CODE> records in the type system that a given type implements also <SPAN class=type>FooInterface</SPAN> (<CODE class=function>foo_interface_get_type</CODE> returns the type of <SPAN class=type>FooInterface</SPAN>). The <A title="struct GInterfaceInfo" class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#GInterfaceInfo"><SPAN class=type>GInterfaceInfo</SPAN></A> structure holds information about the implementation of the interface: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">struct</SPAN> _GInterfaceInfo
<SPAN class="gtkdoc opt">{</SPAN>
  GInterfaceInitFunc     interface_init<SPAN class="gtkdoc opt">;</SPAN>
  GInterfaceFinalizeFunc interface_finalize<SPAN class="gtkdoc opt">;</SPAN>
  gpointer               interface_data<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">};</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gtype-non-instantiable-classed-init></A>Interface Initialization</H3></DIV></DIV></DIV>
<P>When an instantiable classed type which implements an interface (either directly or by inheriting an implementation from a superclass) is created for the first time, its class structure is initialized following the process described in <A title="Instantiable classed types: objects" class=xref href="https://developer.gnome.org/gobject/stable/gtype-instantiable-classed.html">the section called &#8220;Instantiable classed types: objects&#8221;</A>. After that, the interface implementations associated with the type are initialized. </P>
<P>First a memory buffer is allocated to hold the interface structure. The parent's interface structure is then copied over to the new interface structure (the parent interface is already initialized at that point). If there is no parent interface, the interface structure is initialized with zeros. The <EM class=structfield><CODE>g_type</CODE></EM> and the <EM class=structfield><CODE>g_instance_type</CODE></EM> fields are then initialized: <EM class=structfield><CODE>g_type</CODE></EM> is set to the type of the most-derived interface and <EM class=structfield><CODE>g_instance_type</CODE></EM> is set to the type of the most derived type which implements this interface. </P>
<P>The interface's <CODE class=function>base_init</CODE> function is called, and then the interface's <CODE class=function>default_init</CODE> is invoked. Finally if the type has registered an implementation of the interface, the implementation's <CODE class=function>interface_init</CODE> function is invoked. If there are multiple implementations of an interface the <CODE class=function>base_init</CODE> and <CODE class=function>interface_init</CODE> functions will be invoked once for each implementation initialized. </P>
<P>It is thus recommended to use a <CODE class=function>default_init</CODE> function to initialize an interface. This function is called only once for the interface no matter how many implementations there are. The <CODE class=function>default_init</CODE> function is declared by <A title=G_DEFINE_INTERFACE() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DEFINE-INTERFACE:CAPS">G_DEFINE_INTERFACE</A> which can be used to define the interface: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DEFINE-INTERFACE:CAPS">G_DEFINE_INTERFACE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditable<SPAN class="gtkdoc opt">,</SPAN> viewer_editable<SPAN class="gtkdoc opt">,</SPAN> G_TYPE_OBJECT<SPAN class="gtkdoc opt">);</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_editable_default_init</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditableInterface <SPAN class="gtkdoc opt">*</SPAN>iface<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=comment>/* add properties and signals here, will only be called once */</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Or you can do that yourself in a GType function for your interface: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>GType
<SPAN class=function>viewer_editable_get_type</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static</SPAN> <SPAN class="gtkdoc kwc">volatile</SPAN> gsize type_id <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Threads.html#g-once-init-enter">g_once_init_enter</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>type_id<SPAN class="gtkdoc opt">)) {</SPAN>
    <SPAN class="gtkdoc kwb">const</SPAN> GTypeInfo info <SPAN class="gtkdoc opt">= {</SPAN>
      <SPAN class=keyword>sizeof</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditableInterface<SPAN class="gtkdoc opt">),</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* base_init */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* base_finalize */</SPAN>
      viewer_editable_default_init<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=comment>/* class_init */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* class_finalize */</SPAN>
      NULL<SPAN class="gtkdoc opt">,</SPAN>   <SPAN class=comment>/* class_data */</SPAN>
      <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">,</SPAN>      <SPAN class=comment>/* instance_size */</SPAN>
      <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">,</SPAN>      <SPAN class=comment>/* n_preallocs */</SPAN>
      NULL    <SPAN class=comment>/* instance_init */</SPAN>
    <SPAN class="gtkdoc opt">};</SPAN>
    GType type <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-register-static">g_type_register_static</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>G_TYPE_INTERFACE<SPAN class="gtkdoc opt">,</SPAN>
                                         <SPAN class=string>"ViewerEditable"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                                         <SPAN class="gtkdoc opt">&amp;</SPAN>info<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">);</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Threads.html#g-once-init-leave">g_once_init_leave</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>type_id<SPAN class="gtkdoc opt">,</SPAN> type<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc opt">}</SPAN>
  <SPAN class=keyword>return</SPAN> type_id<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_editable_default_init</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerEditableInterface <SPAN class="gtkdoc opt">*</SPAN>iface<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=comment>/* add properties and signals here, will only called once */</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>In summary, interface initialization uses the following functions: </P>
<P></P>
<DIV class=table><A name=ginterface-init-table></A>
<P class=title><B>Table&nbsp;2.&nbsp;Interface Initialization</B></P>
<DIV class=table-contents>
<TABLE class=table summary="Interface Initialization" border=1>
<COLGROUP>
<COL align=left>
<COL align=left>
<COL align=left></COLGROUP>
<THEAD>
<TR>
<TH align=left>Invocation time</TH>
<TH align=left>Function Invoked</TH>
<TH align=left>Function's parameters</TH>
<TH>Remark</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=left>First call to <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> for <SPAN class=emphasis><EM>any</EM></SPAN> type implementing interface </TD>
<TD align=left>interface's <CODE class=function>base_init</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>Rarely necessary to use this. Called once per instantiated classed type implementing the interface.</TD></TR>
<TR>
<TD align=left>First call to <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> for <SPAN class=emphasis><EM>each</EM></SPAN> type implementing interface </TD>
<TD align=left>interface's <CODE class=function>default_init</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>Register interface's signals, properties, etc. here. Will be called once.</TD></TR>
<TR>
<TD align=left>First call to <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> for <SPAN class=emphasis><EM>any</EM></SPAN> type implementing interface </TD>
<TD align=left>implementation's <CODE class=function>interface_init</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>Initialize interface implementation. Called for each class that that implements the interface. Initialize the interface method pointers in the interface structure to the implementing class's implementation. </TD></TR></TBODY></TABLE></DIV></DIV>
<P><BR class=table-break></P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gtype-non-instantiable-classed-dest></A>Interface Destruction</H3></DIV></DIV></DIV>
<P>When the last instance of an instantiable type which registered an interface implementation is destroyed, the interface's implementations associated to the type are destroyed. </P>
<P>To destroy an interface implementation, GType first calls the implementation's <CODE class=function>interface_finalize</CODE> function and then the interface's most-derived <CODE class=function>base_finalize</CODE> function. </P>
<P>Again, it is important to understand, as in <A title="Interface Initialization" class=xref href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-init">the section called &#8220;Interface Initialization&#8221;</A>, that both <CODE class=function>interface_finalize</CODE> and <CODE class=function>base_finalize</CODE> are invoked exactly once for the destruction of each implementation of an interface. Thus, if you were to use one of these functions, you would need to use a static integer variable which would hold the number of instances of implementations of an interface such that the interface's class is destroyed only once (when the integer variable reaches zero). </P>
<P>The above process can be summarized as follows: </P>
<DIV class=table><A name=ginterface-fini-table></A>
<P class=title><B>Table&nbsp;3.&nbsp;Interface Finalization</B></P>
<DIV class=table-contents>
<TABLE class=table summary="Interface Finalization" border=1>
<COLGROUP>
<COL align=left>
<COL align=left>
<COL align=left></COLGROUP>
<THEAD>
<TR>
<TH align=left>Invocation time</TH>
<TH align=left>Function Invoked</TH>
<TH align=left>Function's parameters</TH></TR></THEAD>
<TBODY>
<TR>
<TD rowSpan=2 align=left>Last call to <CODE class=function><A title=g_type_free_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</A></CODE> for type implementing interface </TD>
<TD align=left>interface's <CODE class=function>interface_finalize</CODE> function</TD>
<TD align=left>On interface's vtable</TD></TR>
<TR>
<TD align=left>interface's <CODE class=function>base_finalize</CODE> function</TD>
<TD align=left>On interface's vtable</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="24000">Topic #24000: The GObject base class.. Object instantiation.. Object memory management.. Reference count.. Weak References.. Reference counts and cycles.. Object properties.. Accessing ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title>The GObject base class</H2></DIV></DIV></DIV>
<DIV class=toc>
<DL class=toc>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-gobject.html#gobject-instantiation">Object instantiation</A></SPAN></DT>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html">Object memory management</A></SPAN></DT>
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-refcount">Reference count</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-weakref">Weak References</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-cycles">Reference counts and cycles</A></SPAN></DT></DL></DD>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/gobject-properties.html">Object properties</A></SPAN></DT>
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/gobject-properties.html#gobject-multi-properties">Accessing multiple properties at once</A></SPAN></DT></DL></DD></DL></DIV>
<P>The previous chapter discussed the details of GLib's Dynamic Type System. The GObject library also contains an implementation for a base fundamental type named <A class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject"><SPAN class=type>GObject</SPAN></A>. </P>
<P><A class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject"><SPAN class=type>GObject</SPAN></A> is a fundamental classed instantiable type. It implements: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>Memory management with reference counting</P></LI>
<LI class=listitem>
<P>Construction/Destruction of instances</P></LI>
<LI class=listitem>
<P>Generic per-object properties with set/get function pairs</P></LI>
<LI class=listitem>
<P>Easy use of signals</P></LI></UL></DIV>
<P>All the GNOME libraries which use the GLib type system (like GTK+ and GStreamer) inherit from <A class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject"><SPAN class=type>GObject</SPAN></A> which is why it is important to understand the details of how it works. </P>
<DIV class=sect1>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=gobject-instantiation></A>Object instantiation</H2></DIV></DIV></DIV>
<P>The <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE> family of functions can be used to instantiate any GType which inherits from the GObject base type. All these functions make sure the class and instance structures have been correctly initialized by GLib's type system and then invoke at one point or another the constructor class method which is used to: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>Allocate and clear memory through <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE>, </P></LI>
<LI class=listitem>
<P>Initialize the object's instance with the construction properties. </P></LI></UL></DIV>
<P>Although one can expect all class and instance members (except the fields pointing to the parents) to be set to zero, some consider it good practice to explicitly set them. </P>
<P>Once all construction operations have been completed and constructor properties set, the constructed class method is called. </P>
<P>Objects which inherit from GObject are allowed to override this constructed class method. The example below shows how <SPAN class=type>ViewerFile</SPAN> overrides the parent's construction process: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc ppc">#define VIEWER_TYPE_FILE viewer_file_get_type ()</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DECLARE-FINAL-TYPE:CAPS">G_DECLARE_FINAL_TYPE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile<SPAN class="gtkdoc opt">,</SPAN> viewer_file<SPAN class="gtkdoc opt">,</SPAN> VIEWER<SPAN class="gtkdoc opt">,</SPAN> <SPAN class="gtkdoc kwb">FILE</SPAN><SPAN class="gtkdoc opt">,</SPAN> GObject<SPAN class="gtkdoc opt">)</SPAN>

<SPAN class="gtkdoc kwb">struct</SPAN> _ViewerFile
<SPAN class="gtkdoc opt">{</SPAN>
  GObject parent_instance<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=comment>/* instance members */</SPAN>
<SPAN class="gtkdoc opt">};</SPAN>

<SPAN class=comment>/* will create viewer_file_get_type and set viewer_file_parent_class */</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE:CAPS">G_DEFINE_TYPE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile<SPAN class="gtkdoc opt">,</SPAN> viewer_file<SPAN class="gtkdoc opt">,</SPAN> G_TYPE_OBJECT<SPAN class="gtkdoc opt">)</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_constructed</SPAN> <SPAN class="gtkdoc opt">(</SPAN>GObject <SPAN class="gtkdoc opt">*</SPAN>obj<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=comment>/* update the object state depending on constructor properties */</SPAN>

  <SPAN class=comment>/* Always chain up to the parent constructed function to complete object</SPAN>
<SPAN class=comment>   * initialisation. */</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT-CLASS:CAPS">G_OBJECT_CLASS</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>viewer_file_parent_class<SPAN class="gtkdoc opt">)-&gt;</SPAN><SPAN class=function>constructed</SPAN> <SPAN class="gtkdoc opt">(</SPAN>obj<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_class_init</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFileClass <SPAN class="gtkdoc opt">*</SPAN>klass<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  GObjectClass <SPAN class="gtkdoc opt">*</SPAN>object_class <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT-CLASS:CAPS">G_OBJECT_CLASS</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>klass<SPAN class="gtkdoc opt">);</SPAN>

  object_class<SPAN class="gtkdoc opt">-&gt;</SPAN>constructed <SPAN class="gtkdoc opt">=</SPAN> viewer_file_constructed<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_init</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFile <SPAN class="gtkdoc opt">*</SPAN>self<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=comment>/* initialize the object */</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>If the user instantiates an object <SPAN class=type>ViewerFile</SPAN> with: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>ViewerFile <SPAN class="gtkdoc opt">*</SPAN>file <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>VIEWER_TYPE_FILE<SPAN class="gtkdoc opt">,</SPAN> NULL<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>If this is the first instantiation of such an object, the <CODE class=function>viewer_file_class_init</CODE> function will be invoked after any <CODE class=function>viewer_file_base_class_init</CODE> function. This will make sure the class structure of this new object is correctly initialized. Here, <CODE class=function>viewer_file_class_init</CODE> is expected to override the object's class methods and setup the class' own methods. In the example above, the constructor method is the only overridden method: it is set to <CODE class=function>viewer_file_constructor</CODE>. </P>
<P>Once <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE> has obtained a reference to an initialized class structure, it invokes its constructor method to create an instance of the new object, if the constructor has been overridden in <CODE class=function>viewer_file_class_init</CODE>. Overridden constructors must chain up to their parent&#8217;s constructor. In order to find the parent class and chain up to the parent class constructor, we can use the <CODE class=literal>viewer_file_parent_class</CODE> pointer that has been set up for us by the <A title=G_DEFINE_TYPE() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE:CAPS"><CODE class=literal>G_DEFINE_TYPE</CODE></A> macro. </P>
<P>Finally, at one point or another, <CODE class=function>g_object_constructor</CODE> is invoked by the last constructor in the chain. This function allocates the object's instance buffer through <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> which means that the <CODE class=function>instance_init</CODE> function is invoked at this point if one was registered. After <CODE class=function>instance_init</CODE> returns, the object is fully initialized and should be ready to have its methods called by the user. When <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> returns, <CODE class=function>g_object_constructor</CODE> sets the construction properties (i.e. the properties which were given to <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE>) and returns to the user's constructor. </P>
<P>The process described above might seem a bit complicated, but it can be summarized easily by the table below which lists the functions invoked by <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE> and their order of invocation: </P>
<P></P>
<DIV class=table><A name=gobject-construction-table></A>
<P class=title><B>Table&nbsp;4.&nbsp;<CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE></B></P>
<DIV class=table-contents>
<TABLE class=table summary=g_object_new border=1>
<COLGROUP>
<COL align=left>
<COL align=left>
<COL align=left></COLGROUP>
<THEAD>
<TR>
<TH align=left>Invocation time</TH>
<TH align=left>Function invoked</TH>
<TH align=left>Function's parameters</TH>
<TH>Remark</TH></TR></THEAD>
<TBODY>
<TR>
<TD rowSpan=4 align=left>First call to <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE> for target type</TD>
<TD align=left>target type's <CODE class=function>base_init</CODE> function</TD>
<TD align=left>On the inheritance tree of classes from fundamental type to target type. <CODE class=function>base_init</CODE> is invoked once for each class structure.</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR>
<TR>
<TD align=left>target type's <CODE class=function>class_init</CODE> function</TD>
<TD align=left>On target type's class structure</TD>
<TD>Here, you should make sure to initialize or override class methods (that is, assign to each class' method its function pointer) and create the signals and the properties associated to your object. </TD></TR>
<TR>
<TD align=left>interface's <CODE class=function>base_init</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>&nbsp;</TD></TR>
<TR>
<TD align=left>interface's <CODE class=function>interface_init</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>&nbsp;</TD></TR>
<TR>
<TD rowSpan=3 align=left>Each call to <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE> for target type</TD>
<TD align=left>target type's class <CODE class=function>constructor</CODE> method: <CODE class=function>GObjectClass-&gt;constructor</CODE> </TD>
<TD align=left>On object's instance</TD>
<TD>If you need to handle construct properties in a custom way, or implement a singleton class, override the constructor method and make sure to chain up to the object's parent class before doing your own initialization. In doubt, do not override the constructor method. </TD></TR>
<TR>
<TD align=left>type's <CODE class=function>instance_init</CODE> function</TD>
<TD align=left>On the inheritance tree of classes from fundamental type to target type. the <CODE class=function>instance_init</CODE> provided for each type is invoked once for each instance structure.</TD>
<TD>Provide an <CODE class=function>instance_init</CODE> function to initialize your object before its construction properties are set. This is the preferred way to initialize a GObject instance. This function is equivalent to C++ constructors. </TD></TR>
<TR>
<TD align=left>target type's class <CODE class=function>constructed</CODE> method: <CODE class=function>GObjectClass-&gt;constructed</CODE> </TD>
<TD align=left>On object's instance</TD>
<TD>If you need to perform object initialization steps after all construct properties have been set. This is the final step in the object initialization process, and is only called if the <CODE class=function>constructor</CODE> method returned a new object instance (rather than, for example, an existing singleton). </TD></TR></TBODY></TABLE></DIV></DIV>
<P><BR class=table-break></P>
<P>Readers should feel concerned about one little twist in the order in which functions are invoked: while, technically, the class' constructor method is called <SPAN class=emphasis><EM>before</EM></SPAN> the GType's <CODE class=function>instance_init</CODE> function (since <CODE class=function><A title=g_type_create_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</A></CODE> which calls <CODE class=function>instance_init</CODE> is called by <CODE class=function>g_object_constructor</CODE> which is the top-level class constructor method and to which users are expected to chain to), the user's code which runs in a user-provided constructor will always run <SPAN class=emphasis><EM>after</EM></SPAN> GType's <CODE class=function>instance_init</CODE> function since the user-provided constructor <SPAN class=emphasis><EM>must</EM></SPAN> (you've been warned) chain up <SPAN class=emphasis><EM>before</EM></SPAN> doing anything useful. </P></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28668">Topic #28668: Object memory management.. The memory-management API for GObjects is a bit complicated but the idea behind it is pretty simple: the goal is to provide a flexible model based on ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Object memory management</H2></DIV></DIV></DIV>
<P>The memory-management API for GObjects is a bit complicated but the idea behind it is pretty simple: the goal is to provide a flexible model based on reference counting which can be integrated in applications which use or require different memory management models (such as garbage collection). The methods which are used to manipulate this reference count are described below. </P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gobject-memory-refcount></A>Reference count</H3></DIV></DIV></DIV>
<P>The functions <CODE class=function><A title=g_object_ref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref">g_object_ref</A></CODE>/<CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> respectively increase and decrease the reference count. These functions are thread-safe. <CODE class=function><A title=g_clear_object&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-clear-object">g_clear_object</A></CODE> is a convenience wrapper around <CODE class=function>g_object_unref</CODE> which also clears the pointer passed to it. </P>
<P>The reference count is initialized to one by <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE> which means that the caller is currently the sole owner of the newly-created reference. When the reference count reaches zero, that is, when <CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> is called by the last client holding a reference to the object, the <SPAN class=emphasis><EM>dispose</EM></SPAN> and the <SPAN class=emphasis><EM>finalize</EM></SPAN> class methods are invoked. </P>
<P>Finally, after <SPAN class=emphasis><EM>finalize</EM></SPAN> is invoked, <CODE class=function><A title=g_type_free_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</A></CODE> is called to free the object instance. Depending on the memory allocation policy decided when the type was registered (through one of the <CODE class=function>g_type_register_*</CODE> functions), the object's instance memory will be freed or returned to the object pool for this type. Once the object has been freed, if it was the last instance of the type, the type's class will be destroyed as described in <A title="Instantiable classed types: objects" class=xref href="https://developer.gnome.org/gobject/stable/gtype-instantiable-classed.html">the section called &#8220;Instantiable classed types: objects&#8221;</A> and <A title="Non-instantiable classed types: interfaces" class=xref href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html">the section called &#8220;Non-instantiable classed types: interfaces&#8221;</A>. </P>
<P>The table below summarizes the destruction process of a GObject: </P>
<DIV class=table><A name=gobject-destruction-table></A>
<P class=title><B>Table&nbsp;5.&nbsp;<CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE></B></P>
<DIV class=table-contents>
<TABLE class=table summary=g_object_unref border=1>
<COLGROUP>
<COL align=left>
<COL align=left>
<COL align=left></COLGROUP>
<THEAD>
<TR>
<TH align=left>Invocation time</TH>
<TH align=left>Function invoked</TH>
<TH align=left>Function's parameters</TH>
<TH>Remark</TH></TR></THEAD>
<TBODY>
<TR>
<TD rowSpan=2 align=left>Last call to <CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> for an instance of target type </TD>
<TD align=left>target type's dispose class function</TD>
<TD align=left>GObject instance</TD>
<TD>When dispose ends, the object should not hold any reference to any other member object. The object is also expected to be able to answer client method invocations (with possibly an error code but no memory violation) until finalize is executed. dispose can be executed more than once. dispose should chain up to its parent implementation just before returning to the caller. </TD></TR>
<TR>
<TD align=left>target type's finalize class function</TD>
<TD align=left>GObject instance</TD>
<TD>Finalize is expected to complete the destruction process initiated by dispose. It should complete the object's destruction. finalize will be executed only once. finalize should chain up to its parent implementation just before returning to the caller. The reason why the destruction process is split is two different phases is explained in <A title="Reference counts and cycles" class=xref href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-cycles">the section called &#8220;Reference counts and cycles&#8221;</A>. </TD></TR>
<TR>
<TD rowSpan=4 align=left>Last call to <CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> for the last instance of target type </TD>
<TD align=left>interface's <CODE class=function>interface_finalize</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR>
<TR>
<TD align=left>interface's <CODE class=function>base_finalize</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR>
<TR>
<TD align=left>target type's <CODE class=function>class_finalize</CODE> function</TD>
<TD align=left>On target type's class structure</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR>
<TR>
<TD align=left>type's <CODE class=function>base_finalize</CODE> function</TD>
<TD align=left>On the inheritance tree of classes from fundamental type to target type. <CODE class=function>base_init</CODE> is invoked once for each class structure.</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR></TBODY></TABLE></DIV></DIV>
<P><BR class=table-break></P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gobject-memory-weakref></A>Weak References</H3></DIV></DIV></DIV>
<P>Weak references are used to monitor object finalization: <CODE class=function><A title=g_object_weak_ref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-weak-ref">g_object_weak_ref</A></CODE> adds a monitoring callback which does not hold a reference to the object but which is invoked when the object runs its dispose method. As such, each weak ref can be invoked more than once upon object finalization (since dispose can run more than once during object finalization). </P>
<P><CODE class=function><A title=g_object_weak_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-weak-unref">g_object_weak_unref</A></CODE> can be used to remove a monitoring callback from the object. </P>
<P>Weak references are also used to implement <CODE class=function><A title=g_object_add_weak_pointer&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-add-weak-pointer">g_object_add_weak_pointer</A></CODE> and <CODE class=function><A title=g_object_remove_weak_pointer&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-remove-weak-pointer">g_object_remove_weak_pointer</A></CODE>. These functions add a weak reference to the object they are applied to which makes sure to nullify the pointer given by the user when object is finalized. </P>
<P>Similarly, <A title=GWeakRef class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GWeakRef"><SPAN class=type>GWeakRef</SPAN></A> can be used to implement weak references if thread safety is required. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gobject-memory-cycles></A>Reference counts and cycles</H3></DIV></DIV></DIV>
<P>GObject's memory management model was designed to be easily integrated in existing code using garbage collection. This is why the destruction process is split in two phases: the first phase, executed in the dispose handler is supposed to release all references to other member objects. The second phase, executed by the finalize handler is supposed to complete the object's destruction process. Object methods should be able to run without program error in-between the two phases. </P>
<P>This two-step destruction process is very useful to break reference counting cycles. While the detection of the cycles is up to the external code, once the cycles have been detected, the external code can invoke <CODE class=function><A title=g_object_run_dispose&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-run-dispose">g_object_run_dispose</A></CODE> which will indeed break any existing cycles since it will run the dispose handler associated to the object and thus release all references to other objects. </P>
<P>This explains one of the rules about the dispose handler stated earlier: the dispose handler can be invoked multiple times. Let's say we have a reference count cycle: object A references B which itself references object A. Let's say we have detected the cycle and we want to destroy the two objects. One way to do this would be to invoke <CODE class=function><A title=g_object_run_dispose&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-run-dispose">g_object_run_dispose</A></CODE> on one of the objects. </P>
<P>If object A releases all its references to all objects, this means it releases its reference to object B. If object B was not owned by anyone else, this is its last reference count which means this last unref runs B's dispose handler which, in turn, releases B's reference on object A. If this is A's last reference count, this last unref runs A's dispose handler which is running for the second time before A's finalize handler is invoked ! </P>
<P>The above example, which might seem a bit contrived, can really happen if GObjects are being handled by language bindings &#8212; hence the rules for object destruction should be closely followed. </P></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28669">Topic #28669: Object properties.. One of GObject's nice features is its generic get/set mechanism for object properties. When an object is instantiated, the object's class_init handler ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Object properties</H2></DIV></DIV></DIV>
<P>One of GObject's nice features is its generic get/set mechanism for object properties. When an object is instantiated, the object's <CODE class=function>class_init</CODE> handler should be used to register the object's properties with <CODE class=function><A title=g_object_class_install_properties&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-properties">g_object_class_install_properties</A></CODE>. </P>
<P>The best way to understand how object properties work is by looking at a real example of how it is used: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class=comment>/************************************************/</SPAN>
<SPAN class=comment>/* Implementation                               */</SPAN>
<SPAN class=comment>/************************************************/</SPAN>

<SPAN class="gtkdoc kwb">enum</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  PROP_FILENAME <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>1</SPAN><SPAN class="gtkdoc opt">,</SPAN>
  PROP_ZOOM_LEVEL<SPAN class="gtkdoc opt">,</SPAN>
  N_PROPERTIES
<SPAN class="gtkdoc opt">};</SPAN>

<SPAN class="gtkdoc kwb">static</SPAN> GParamSpec <SPAN class="gtkdoc opt">*</SPAN>obj_properties<SPAN class="gtkdoc opt">[</SPAN>N_PROPERTIES<SPAN class="gtkdoc opt">] = {</SPAN> NULL<SPAN class="gtkdoc opt">, };</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_set_property</SPAN> <SPAN class="gtkdoc opt">(</SPAN>GObject      <SPAN class="gtkdoc opt">*</SPAN>object<SPAN class="gtkdoc opt">,</SPAN>
                          guint         property_id<SPAN class="gtkdoc opt">,</SPAN>
                          <SPAN class="gtkdoc kwb">const</SPAN> GValue <SPAN class="gtkdoc opt">*</SPAN>value<SPAN class="gtkdoc opt">,</SPAN>
                          GParamSpec   <SPAN class="gtkdoc opt">*</SPAN>pspec<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  ViewerFile <SPAN class="gtkdoc opt">*</SPAN>self <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function>VIEWER_FILE</SPAN> <SPAN class="gtkdoc opt">(</SPAN>object<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>switch</SPAN> <SPAN class="gtkdoc opt">(</SPAN>property_id<SPAN class="gtkdoc opt">)</SPAN>
    <SPAN class="gtkdoc opt">{</SPAN>
    <SPAN class=keyword>case</SPAN> PROP_FILENAME<SPAN class="gtkdoc opt">:</SPAN>
      <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Memory-Allocation.html#g-free">g_free</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>self<SPAN class="gtkdoc opt">-&gt;</SPAN>priv<SPAN class="gtkdoc opt">-&gt;</SPAN>filename<SPAN class="gtkdoc opt">);</SPAN>
      self<SPAN class="gtkdoc opt">-&gt;</SPAN>priv<SPAN class="gtkdoc opt">-&gt;</SPAN>filename <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-dup-string">g_value_dup_string</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>value<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-print">g_print</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"filename: %s</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">,</SPAN> self<SPAN class="gtkdoc opt">-&gt;</SPAN>priv<SPAN class="gtkdoc opt">-&gt;</SPAN>filename<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=keyword>break</SPAN><SPAN class="gtkdoc opt">;</SPAN>

    <SPAN class=keyword>case</SPAN> PROP_ZOOM_LEVEL<SPAN class="gtkdoc opt">:</SPAN>
      self<SPAN class="gtkdoc opt">-&gt;</SPAN>priv<SPAN class="gtkdoc opt">-&gt;</SPAN>zoom_level <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-get-uint">g_value_get_uint</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>value<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-print">g_print</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"zoom level: %u</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">,</SPAN> self<SPAN class="gtkdoc opt">-&gt;</SPAN>priv<SPAN class="gtkdoc opt">-&gt;</SPAN>zoom_level<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=keyword>break</SPAN><SPAN class="gtkdoc opt">;</SPAN>

    <SPAN class=keyword>default</SPAN><SPAN class="gtkdoc opt">:</SPAN>
      <SPAN class=comment>/* We don't have any other property... */</SPAN>
      <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT-WARN-INVALID-PROPERTY-ID:CAPS">G_OBJECT_WARN_INVALID_PROPERTY_ID</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>object<SPAN class="gtkdoc opt">,</SPAN> property_id<SPAN class="gtkdoc opt">,</SPAN> pspec<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=keyword>break</SPAN><SPAN class="gtkdoc opt">;</SPAN>
    <SPAN class="gtkdoc opt">}</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_get_property</SPAN> <SPAN class="gtkdoc opt">(</SPAN>GObject    <SPAN class="gtkdoc opt">*</SPAN>object<SPAN class="gtkdoc opt">,</SPAN>
                          guint       property_id<SPAN class="gtkdoc opt">,</SPAN>
                          GValue     <SPAN class="gtkdoc opt">*</SPAN>value<SPAN class="gtkdoc opt">,</SPAN>
                          GParamSpec <SPAN class="gtkdoc opt">*</SPAN>pspec<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  ViewerFile <SPAN class="gtkdoc opt">*</SPAN>self <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function>VIEWER_FILE</SPAN> <SPAN class="gtkdoc opt">(</SPAN>object<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>switch</SPAN> <SPAN class="gtkdoc opt">(</SPAN>property_id<SPAN class="gtkdoc opt">)</SPAN>
    <SPAN class="gtkdoc opt">{</SPAN>
    <SPAN class=keyword>case</SPAN> PROP_FILENAME<SPAN class="gtkdoc opt">:</SPAN>
      <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-set-string">g_value_set_string</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>value<SPAN class="gtkdoc opt">,</SPAN> self<SPAN class="gtkdoc opt">-&gt;</SPAN>priv<SPAN class="gtkdoc opt">-&gt;</SPAN>filename<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=keyword>break</SPAN><SPAN class="gtkdoc opt">;</SPAN>

    <SPAN class=keyword>case</SPAN> PROP_ZOOM_LEVEL<SPAN class="gtkdoc opt">:</SPAN>
      <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-set-uint">g_value_set_uint</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>value<SPAN class="gtkdoc opt">,</SPAN> self<SPAN class="gtkdoc opt">-&gt;</SPAN>priv<SPAN class="gtkdoc opt">-&gt;</SPAN>zoom_level<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=keyword>break</SPAN><SPAN class="gtkdoc opt">;</SPAN>

    <SPAN class=keyword>default</SPAN><SPAN class="gtkdoc opt">:</SPAN>
      <SPAN class=comment>/* We don't have any other property... */</SPAN>
      <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT-WARN-INVALID-PROPERTY-ID:CAPS">G_OBJECT_WARN_INVALID_PROPERTY_ID</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>object<SPAN class="gtkdoc opt">,</SPAN> property_id<SPAN class="gtkdoc opt">,</SPAN> pspec<SPAN class="gtkdoc opt">);</SPAN>
      <SPAN class=keyword>break</SPAN><SPAN class="gtkdoc opt">;</SPAN>
    <SPAN class="gtkdoc opt">}</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">static void</SPAN>
<SPAN class=function>viewer_file_class_init</SPAN> <SPAN class="gtkdoc opt">(</SPAN>ViewerFileClass <SPAN class="gtkdoc opt">*</SPAN>klass<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  GObjectClass <SPAN class="gtkdoc opt">*</SPAN>object_class <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT-CLASS:CAPS">G_OBJECT_CLASS</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>klass<SPAN class="gtkdoc opt">);</SPAN>

  object_class<SPAN class="gtkdoc opt">-&gt;</SPAN>set_property <SPAN class="gtkdoc opt">=</SPAN> viewer_file_set_property<SPAN class="gtkdoc opt">;</SPAN>
  object_class<SPAN class="gtkdoc opt">-&gt;</SPAN>get_property <SPAN class="gtkdoc opt">=</SPAN> viewer_file_get_property<SPAN class="gtkdoc opt">;</SPAN>

  obj_properties<SPAN class="gtkdoc opt">[</SPAN>PROP_FILENAME<SPAN class="gtkdoc opt">] =</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-param-spec-string">g_param_spec_string</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"filename"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                         <SPAN class=string>"Filename"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                         <SPAN class=string>"Name of the file to load and display from."</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                         NULL  <SPAN class=comment>/* default value */</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                         G_PARAM_CONSTRUCT_ONLY <SPAN class="gtkdoc opt">|</SPAN> G_PARAM_READWRITE<SPAN class="gtkdoc opt">));</SPAN>

  obj_properties<SPAN class="gtkdoc opt">[</SPAN>PROP_ZOOM_LEVEL<SPAN class="gtkdoc opt">] =</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-param-spec-uint">g_param_spec_uint</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=string>"zoom-level"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                       <SPAN class=string>"Zoom level"</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                       <SPAN class=string>"Zoom level to view the file at."</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                       <SPAN class=number>0</SPAN>  <SPAN class=comment>/* minimum value */</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                       <SPAN class=number>10</SPAN> <SPAN class=comment>/* maximum value */</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                       <SPAN class=number>2</SPAN>  <SPAN class=comment>/* default value */</SPAN><SPAN class="gtkdoc opt">,</SPAN>
                       G_PARAM_READWRITE<SPAN class="gtkdoc opt">));</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-properties">g_object_class_install_properties</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>object_class<SPAN class="gtkdoc opt">,</SPAN>
                                     N_PROPERTIES<SPAN class="gtkdoc opt">,</SPAN>
                                     obj_properties<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class=comment>/************************************************/</SPAN>
<SPAN class=comment>/* Use                                          */</SPAN>
<SPAN class=comment>/************************************************/</SPAN>

ViewerFile <SPAN class="gtkdoc opt">*</SPAN>file<SPAN class="gtkdoc opt">;</SPAN>
GValue val <SPAN class="gtkdoc opt">=</SPAN> G_VALUE_INIT<SPAN class="gtkdoc opt">;</SPAN>

file <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>VIEWER_TYPE_FILE<SPAN class="gtkdoc opt">,</SPAN> NULL<SPAN class="gtkdoc opt">);</SPAN>

<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-init">g_value_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>val<SPAN class="gtkdoc opt">,</SPAN> G_TYPE_UINT<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html#g-value-set-char">g_value_set_char</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>val<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>11</SPAN><SPAN class="gtkdoc opt">);</SPAN>

<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-property">g_object_set_property</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT:CAPS">G_OBJECT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>file<SPAN class="gtkdoc opt">),</SPAN> <SPAN class=string>"zoom-level"</SPAN><SPAN class="gtkdoc opt">, &amp;</SPAN>val<SPAN class="gtkdoc opt">);</SPAN>

<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-unset">g_value_unset</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>val<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>The client code above looks simple but a lot of things happen under the hood: </P>
<P><CODE class=function><A title=g_object_set_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-property">g_object_set_property</A></CODE> first ensures a property with this name was registered in <SPAN class=emphasis><EM>file</EM></SPAN>'s <CODE class=function>class_init</CODE> handler. If so it walks the class hierarchy, from bottom-most most-derived type, to top-most fundamental type to find the class which registered that property. It then tries to convert the user-provided <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A> into a <SPAN class=type>GValue</SPAN> whose type is that of the associated property. </P>
<P>If the user provides a <SPAN class=type>signed char</SPAN> <SPAN class=type>GValue</SPAN>, as is shown here, and if the object's property was registered as an <SPAN class=type>unsigned int</SPAN>, <CODE class=function><A title=g_value_transform&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-transform">g_value_transform</A></CODE> will try to transform the input signed char into an unsigned int. Of course, the success of the transformation depends on the availability of the required transform function. In practice, there will almost always be a transformation <A class=footnote href="https://developer.gnome.org/gobject/stable/gobject-properties.html#ftn.id-1.3.4.6.5.5" name=id-1.3.4.6.5.5><SUP class=footnote>[2]</SUP></A> which matches and conversion will be carried out if needed. </P>
<P>After transformation, the <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A> is validated by <CODE class=function><A title=g_param_value_validate&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#g-param-value-validate">g_param_value_validate</A></CODE> which makes sure the user's data stored in the <A title=GValue class=link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#GValue"><SPAN class=type>GValue</SPAN></A> matches the characteristics specified by the property's <A title="struct GParamSpec" class=link href="https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#GParamSpec"><SPAN class=type>GParamSpec</SPAN></A>. Here, the <A title="struct GParamSpec" class=link href="https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#GParamSpec"><SPAN class=type>GParamSpec</SPAN></A> we provided in <CODE class=function>class_init</CODE> has a validation function which makes sure that the GValue contains a value which respects the minimum and maximum bounds of the <A title="struct GParamSpec" class=link href="https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#GParamSpec"><SPAN class=type>GParamSpec</SPAN></A>. In the example above, the client's GValue does not respect these constraints (it is set to 11, while the maximum is 10). As such, the <CODE class=function><A title=g_object_set_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-property">g_object_set_property</A></CODE> function will return with an error. </P>
<P>If the user's GValue had been set to a valid value, <CODE class=function><A title=g_object_set_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-property">g_object_set_property</A></CODE> would have proceeded with calling the object's <CODE class=function>set_property</CODE> class method. Here, since our implementation of <SPAN class=type>ViewerFile</SPAN> did override this method, execution would jump to <CODE class=function>viewer_file_set_property</CODE> after having retrieved from the <A title="struct GParamSpec" class=link href="https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#GParamSpec"><SPAN class=type>GParamSpec</SPAN></A> the <SPAN class=emphasis><EM>param_id</EM></SPAN> <A class=footnote href="https://developer.gnome.org/gobject/stable/gobject-properties.html#ftn.id-1.3.4.6.7.7" name=id-1.3.4.6.7.7><SUP class=footnote>[3]</SUP></A> which had been stored by <CODE class=function><A title=g_object_class_install_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-property">g_object_class_install_property</A></CODE>. </P>
<P>Once the property has been set by the object's <CODE class=function>set_property</CODE> class method, execution returns to <CODE class=function><A title=g_object_set_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-property">g_object_set_property</A></CODE> which makes sure that the "notify" signal is emitted on the object's instance with the changed property as parameter unless notifications were frozen by <CODE class=function><A title=g_object_freeze_notify&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-freeze-notify">g_object_freeze_notify</A></CODE>. </P>
<P><CODE class=function><A title=g_object_thaw_notify&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-thaw-notify">g_object_thaw_notify</A></CODE> can be used to re-enable notification of property modifications through the <A title="The &#8220;notify&#8221; signal" class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject-notify"><SPAN class=type>&#8220;notify&#8221;</SPAN></A> signal. It is important to remember that even if properties are changed while property change notification is frozen, the "notify" signal will be emitted once for each of these changed properties as soon as the property change notification is thawed: no property change is lost for the "notify" signal, although multiple notifications for a single property are compressed. Signals can only be delayed by the notification freezing mechanism. </P>
<P>It sounds like a tedious task to set up GValues every time when one wants to modify a property. In practice one will rarely do this. The functions <CODE class=function><A title=g_object_set_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-property">g_object_set_property</A></CODE> and <CODE class=function><A title=g_object_get_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-get-property">g_object_get_property</A></CODE> are meant to be used by language bindings. For application there is an easier way and that is described next. </P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gobject-multi-properties></A>Accessing multiple properties at once</H3></DIV></DIV></DIV>
<P>It is interesting to note that the <CODE class=function><A title=g_object_set&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set">g_object_set</A></CODE> and <CODE class=function><A title=g_object_set_valist&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-valist">g_object_set_valist</A></CODE> (variadic version) functions can be used to set multiple properties at once. The client code shown above can then be re-written as: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>ViewerFile <SPAN class="gtkdoc opt">*</SPAN>file<SPAN class="gtkdoc opt">;</SPAN>
file <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=comment>/* */</SPAN><SPAN class="gtkdoc opt">;</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set">g_object_set</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#G-OBJECT:CAPS">G_OBJECT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>file<SPAN class="gtkdoc opt">),</SPAN>
              <SPAN class=string>"zoom-level"</SPAN><SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>6</SPAN><SPAN class="gtkdoc opt">,</SPAN> 
              <SPAN class=string>"filename"</SPAN><SPAN class="gtkdoc opt">,</SPAN> <SPAN class=string>"~/some-file.txt"</SPAN><SPAN class="gtkdoc opt">,</SPAN> 
              NULL<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>This saves us from managing the GValues that we were needing to handle when using <CODE class=function><A title=g_object_set_property&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set-property">g_object_set_property</A></CODE>. The code above will trigger one notify signal emission for each property modified. </P>
<P>Equivalent <CODE class=function>_get</CODE> versions are also available: <CODE class=function><A title=g_object_get&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-get">g_object_get</A></CODE> and <CODE class=function><A title=g_object_get_valist&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-get-valist">g_object_get_valist</A></CODE> (variadic version) can be used to get numerous properties at once. </P>
<P>These high level functions have one drawback &#8212; they don't provide a return value. One should pay attention to the argument types and ranges when using them. A known source of errors is to pass a different type from what the property expects; for instance, passing an integer when the property expects a floating point value and thus shifting all subsequent parameters by some number of bytes. Also forgetting the terminating <CODE class=literal>NULL</CODE> will lead to undefined behaviour. </P>
<P>This explains how <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE>, <CODE class=function><A title=g_object_newv&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-newv">g_object_newv</A></CODE> and <CODE class=function><A title=g_object_new_valist&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new-valist">g_object_new_valist</A></CODE> work: they parse the user-provided variable number of parameters and invoke <CODE class=function><A title=g_object_set&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set">g_object_set</A></CODE> on the parameters only after the object has been successfully constructed. The "notify" signal will be emitted for each property set. </P></DIV>
<DIV class=footnotes><BR>
<HR style="WIDTH: 100px; TEXT-ALIGN: left; MARGIN-LEFT: 0px">

<DIV id=ftn.id-1.3.4.6.5.5 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/gobject-properties.html#id-1.3.4.6.5.5"><SUP class=para>[2] </SUP></A>Its behaviour might not be what you expect but it is up to you to actually avoid relying on these transformations. </P></DIV>
<DIV id=ftn.id-1.3.4.6.7.7 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/gobject-properties.html#id-1.3.4.6.7.7"><SUP class=para>[3] </SUP></A>It should be noted that the param_id used here need only to uniquely identify each <A title="struct GParamSpec" class=link href="https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#GParamSpec"><SPAN class=type>GParamSpec</SPAN></A> within the <SPAN class=type>ViewerFileClass</SPAN> such that the switch used in the set and get methods actually works. Of course, this locally-unique integer is purely an optimization: it would have been possible to use a set of <SPAN class=emphasis><EM>if (strcmp (a, b) == 0) {} else if (strcmp (a, b) == 0) {}</EM></SPAN> statements. </P></DIV></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28670">Topic #28670: The GObject messaging system.. Closures.. C Closures.. Non-C closures (for the fearless).. Signals.. Signal registration.. Signal connection.. Signal emission.. The detail ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title>The GObject messaging system</H2></DIV></DIV></DIV>
<DIV class=toc>
<DL class=toc>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#closure">Closures</A></SPAN></DT>
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.5">C Closures</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.6">Non-C closures (for the fearless)</A></SPAN></DT></DL></DD>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/signal.html">Signals</A></SPAN></DT>
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-registration">Signal registration</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-connection">Signal connection</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-emission">Signal emission</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-detail">The <SPAN class=emphasis><EM>detail</EM></SPAN> argument</A></SPAN></DT></DL></DD></DL></DIV>
<DIV class=sect1>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=closure></A>Closures</H2></DIV></DIV></DIV>
<P>Closures are central to the concept of asynchronous signal delivery which is widely used throughout GTK+ and GNOME applications. A closure is an abstraction, a generic representation of a callback. It is a small structure which contains three objects: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>a function pointer (the callback itself) whose prototype looks like: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>return_type <SPAN class=function>function_callback</SPAN> <SPAN class="gtkdoc opt">(</SPAN>&#8230; <SPAN class="gtkdoc opt">,</SPAN> gpointer user_data<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P></LI>
<LI class=listitem>
<P>the <EM class=parameter><CODE>user_data</CODE></EM> pointer which is passed to the callback upon invocation of the closure </P></LI>
<LI class=listitem>
<P>a function pointer which represents the destructor of the closure: whenever the closure's refcount reaches zero, this function will be called before the closure structure is freed. </P></LI></UL></DIV>
<P></P>
<P>The <A title="struct GClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GClosure"><SPAN class=type>GClosure</SPAN></A> structure represents the common functionality of all closure implementations: there exists a different closure implementation for each separate runtime which wants to use the GObject type system. <A class=footnote href="https://developer.gnome.org/gobject/stable/chapter-signal.html#ftn.id-1.3.5.2.3.2" name=id-1.3.5.2.3.2><SUP class=footnote>[4]</SUP></A> The GObject library provides a simple <A title="struct GCClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GCClosure"><SPAN class=type>GCClosure</SPAN></A> type which is a specific implementation of closures to be used with C/C++ callbacks. </P>
<P>A <A title="struct GClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GClosure"><SPAN class=type>GClosure</SPAN></A> provides simple services: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>Invocation (<CODE class=function><A title=g_closure_invoke&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-invoke">g_closure_invoke</A></CODE>): this is what closures were created for: they hide the details of callback invocation from the callback invoker.</P></LI>
<LI class=listitem>
<P>Notification: the closure notifies listeners of certain events such as closure invocation, closure invalidation and closure finalization. Listeners can be registered with <CODE class=function><A title=g_closure_add_finalize_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-add-finalize-notifier">g_closure_add_finalize_notifier</A></CODE> (finalization notification), <CODE class=function><A title=g_closure_add_invalidate_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-add-invalidate-notifier">g_closure_add_invalidate_notifier</A></CODE> (invalidation notification) and <CODE class=function><A title=g_closure_add_marshal_guards&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-add-marshal-guards">g_closure_add_marshal_guards</A></CODE> (invocation notification). There exist symmetric deregistration functions for finalization and invalidation events (<CODE class=function><A title=g_closure_remove_finalize_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-remove-finalize-notifier">g_closure_remove_finalize_notifier</A></CODE> and <CODE class=function><A title=g_closure_remove_invalidate_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-remove-invalidate-notifier">g_closure_remove_invalidate_notifier</A></CODE>) but not for the invocation process. <A class=footnote href="https://developer.gnome.org/gobject/stable/chapter-signal.html#ftn.id-1.3.5.2.4.2.2.1.6" name=id-1.3.5.2.4.2.2.1.6><SUP class=footnote>[5]</SUP></A></P></LI></UL></DIV>
<P></P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id-1.3.5.2.5></A>C Closures</H3></DIV></DIV></DIV>
<P>If you are using C or C++ to connect a callback to a given event, you will either use simple <A title="struct GCClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GCClosure"><SPAN class=type>GCClosure</SPAN></A>s which have a pretty minimal API or the even simpler <CODE class=function><A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect">g_signal_connect</A></CODE> functions (which will be presented a bit later). </P>
<P><CODE class=function><A title=g_cclosure_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-new">g_cclosure_new</A></CODE> will create a new closure which can invoke the user-provided callback_func with the user-provided <EM class=parameter><CODE>user_data</CODE></EM> as its last parameter. When the closure is finalized (second stage of the destruction process), it will invoke the <EM class=parameter><CODE>destroy_data</CODE></EM> function if the user has supplied one. </P>
<P><CODE class=function><A title=g_cclosure_new_swap&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-new-swap">g_cclosure_new_swap</A></CODE> will create a new closure which can invoke the user-provided <EM class=parameter><CODE>callback_func</CODE></EM> with the user-provided <EM class=parameter><CODE>user_data</CODE></EM> as its first parameter (instead of being the last parameter as with <CODE class=function><A title=g_cclosure_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-new">g_cclosure_new</A></CODE>). When the closure is finalized (second stage of the destruction process), it will invoke the <EM class=parameter><CODE>destroy_data</CODE></EM> function if the user has supplied one. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id-1.3.5.2.6></A>Non-C closures (for the fearless)</H3></DIV></DIV></DIV>
<P>As was explained above, closures hide the details of callback invocation. In C, callback invocation is just like function invocation: it is a matter of creating the correct stack frame for the called function and executing a <SPAN class=emphasis><EM>call</EM></SPAN> assembly instruction. </P>
<P>C closure marshallers transform the array of GValues which represent the parameters to the target function into a C-style function parameter list, invoke the user-supplied C function with this new parameter list, get the return value of the function, transform it into a GValue and return this GValue to the marshaller caller. </P>
<P>A generic C closure marshaller is available as <A title=g_cclosure_marshal_generic&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-marshal-generic"><CODE class=function>g_cclosure_marshal_generic</CODE></A> which implements marshalling for all function types using libffi. Custom marshallers for different types are not needed apart from performance critical code where the libffi-based marshaller may be too slow. </P>
<P>An example of a custom marshaller is given below, illustrating how <SPAN class=type>GValue</SPAN>s can be converted to a C function call. The marshaller is for a C function which takes an integer as its first parameter and returns void. </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-marshal-VOID--INT">g_cclosure_marshal_VOID__INT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>GClosure     <SPAN class="gtkdoc opt">*</SPAN>closure<SPAN class="gtkdoc opt">,</SPAN>
                              GValue       <SPAN class="gtkdoc opt">*</SPAN>return_value<SPAN class="gtkdoc opt">,</SPAN>
                              guint         n_param_values<SPAN class="gtkdoc opt">,</SPAN>
                              <SPAN class="gtkdoc kwb">const</SPAN> GValue <SPAN class="gtkdoc opt">*</SPAN>param_values<SPAN class="gtkdoc opt">,</SPAN>
                              gpointer      invocation_hint<SPAN class="gtkdoc opt">,</SPAN>
                              gpointer      marshal_data<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>GMarshalFunc_VOID__INT<SPAN class="gtkdoc opt">) (</SPAN>gpointer     data1<SPAN class="gtkdoc opt">,</SPAN>
                                          gint         arg_1<SPAN class="gtkdoc opt">,</SPAN>
                                          gpointer     data2<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc kwc">register</SPAN> GMarshalFunc_VOID__INT callback<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwc">register</SPAN> GCClosure <SPAN class="gtkdoc opt">*</SPAN>cc <SPAN class="gtkdoc opt">= (</SPAN>GCClosure<SPAN class="gtkdoc opt">*)</SPAN> closure<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwc">register</SPAN> gpointer data1<SPAN class="gtkdoc opt">,</SPAN> data2<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-return-if-fail">g_return_if_fail</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>n_param_values <SPAN class="gtkdoc opt">==</SPAN> <SPAN class=number>2</SPAN><SPAN class="gtkdoc opt">);</SPAN>

  data1 <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-peek-pointer">g_value_peek_pointer</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>param_values <SPAN class="gtkdoc opt">+</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  data2 <SPAN class="gtkdoc opt">=</SPAN> closure<SPAN class="gtkdoc opt">-&gt;</SPAN>data<SPAN class="gtkdoc opt">;</SPAN>

  callback <SPAN class="gtkdoc opt">= (</SPAN>GMarshalFunc_VOID__INT<SPAN class="gtkdoc opt">) (</SPAN>marshal_data <SPAN class="gtkdoc opt">?</SPAN> marshal_data <SPAN class="gtkdoc opt">:</SPAN> cc<SPAN class="gtkdoc opt">-&gt;</SPAN>callback<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=function>callback</SPAN> <SPAN class="gtkdoc opt">(</SPAN>data1<SPAN class="gtkdoc opt">,</SPAN>
            <SPAN class=function>g_marshal_value_peek_int</SPAN> <SPAN class="gtkdoc opt">(</SPAN>param_values <SPAN class="gtkdoc opt">+</SPAN> <SPAN class=number>1</SPAN><SPAN class="gtkdoc opt">),</SPAN>
            data2<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>There exist other kinds of marshallers, for example there is a generic Python marshaller which is used by all Python closures (a Python closure is used to invoke a callback written in Python). This Python marshaller transforms the input GValue list representing the function parameters into a Python tuple which is the equivalent structure in Python. </P></DIV></DIV>
<DIV class=footnotes><BR>
<HR style="WIDTH: 100px; TEXT-ALIGN: left; MARGIN-LEFT: 0px">

<DIV id=ftn.id-1.3.5.2.3.2 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.3.2"><SUP class=para>[4] </SUP></A>In practice, closures sit at the boundary of language runtimes: if you are writing Python code and one of your Python callbacks receives a signal from a GTK+ widget, the C code in GTK+ needs to execute your Python code. The closure invoked by the GTK+ object invokes the Python callback: it behaves as a normal C object for GTK+ and as a normal Python object for Python code. </P></DIV>
<DIV id=ftn.id-1.3.5.2.4.2.2.1.6 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.4.2.2.1.6"><SUP class=para>[5] </SUP></A>Closures are reference counted and notify listeners of their destruction in a two-stage process: the invalidation notifiers are invoked before the finalization notifiers. </P></DIV></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<P align="center"><b><a name="28671">Topic #28671: Signals.. GObject's signals have nothing to do with standard UNIX signals: they connect arbitrary application-specific events with any number of listeners. For example, in GTK+ ...</a> (<a href="#TopOfPages"><font size="1">top</font></a></b>)</P>
<div align="center">
<center>
<table border="1" cellpadding="5" cellspacing="5" width="100%" bgcolor="#99CCFF">
<tr>
<td bordercolor="#0066FF">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Signals</H2></DIV></DIV></DIV>
<P>GObject's signals have nothing to do with standard UNIX signals: they connect arbitrary application-specific events with any number of listeners. For example, in GTK+, every user event (keystroke or mouse move) is received from the windowing system and generates a GTK+ event in the form of a signal emission on the widget object instance. </P>
<P>Each signal is registered in the type system together with the type on which it can be emitted: users of the type are said to <SPAN class=emphasis><EM>connect</EM></SPAN> to the signal on a given type instance when they register a closure to be invoked upon the signal emission. Users can also emit the signal by themselves or stop the emission of the signal from within one of the closures connected to the signal. </P>
<P>When a signal is emitted on a given type instance, all the closures connected to this signal on this type instance will be invoked. All the closures connected to such a signal represent callbacks whose signature looks like: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>return_type <SPAN class=function>function_callback</SPAN> <SPAN class="gtkdoc opt">(</SPAN>gpointer instance<SPAN class="gtkdoc opt">,</SPAN> &#8230;<SPAN class="gtkdoc opt">,</SPAN> gpointer user_data<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-registration></A>Signal registration</H3></DIV></DIV></DIV>
<P>To register a new signal on an existing type, we can use any of <CODE class=function><A title=g_signal_newv&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-newv">g_signal_newv</A></CODE>, <CODE class=function><A title=g_signal_new_valist&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new-valist">g_signal_new_valist</A></CODE> or <CODE class=function><A title=g_signal_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new">g_signal_new</A></CODE> functions: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>guint <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-newv">g_signal_newv</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">const</SPAN> gchar        <SPAN class="gtkdoc opt">*</SPAN>signal_name<SPAN class="gtkdoc opt">,</SPAN>
                     GType               itype<SPAN class="gtkdoc opt">,</SPAN>
                     GSignalFlags        signal_flags<SPAN class="gtkdoc opt">,</SPAN>
                     GClosure           <SPAN class="gtkdoc opt">*</SPAN>class_closure<SPAN class="gtkdoc opt">,</SPAN>
                     GSignalAccumulator  accumulator<SPAN class="gtkdoc opt">,</SPAN>
                     gpointer            accu_data<SPAN class="gtkdoc opt">,</SPAN>
                     GSignalCMarshaller  c_marshaller<SPAN class="gtkdoc opt">,</SPAN>
                     GType               return_type<SPAN class="gtkdoc opt">,</SPAN>
                     guint               n_params<SPAN class="gtkdoc opt">,</SPAN>
                     GType              <SPAN class="gtkdoc opt">*</SPAN>param_types<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>The number of parameters to these functions is a bit intimidating but they are relatively simple: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P><EM class=parameter><CODE>signal_name</CODE></EM>: is a string which can be used to uniquely identify a given signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>itype</CODE></EM>: is the instance type on which this signal can be emitted. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>signal_flags</CODE></EM>: partly defines the order in which closures which were connected to the signal are invoked. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>class_closure</CODE></EM>: this is the default closure for the signal: if it is not NULL upon the signal emission, it will be invoked upon this emission of the signal. The moment where this closure is invoked compared to other closures connected to that signal depends partly on the signal_flags. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>accumulator</CODE></EM>: this is a function pointer which is invoked after each closure has been invoked. If it returns FALSE, signal emission is stopped. If it returns TRUE, signal emission proceeds normally. It is also used to compute the return value of the signal based on the return value of all the invoked closures. For example, an accumulator could ignore <CODE class=literal>NULL</CODE> returns from closures; or it could build a list of the values returned by the closures. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>accumulator_data</CODE></EM>: this pointer will be passed down to each invocation of the accumulator during emission. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>c_marshaller</CODE></EM>: this is the default C marshaller for any closure which is connected to this signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>return_type</CODE></EM>: this is the type of the return value of the signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>n_params</CODE></EM>: this is the number of parameters this signal takes. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>param_types</CODE></EM>: this is an array of GTypes which indicate the type of each parameter of the signal. The length of this array is indicated by n_params. </P></LI></UL></DIV>
<P></P>
<P>As you can see from the above definition, a signal is basically a description of the closures which can be connected to this signal and a description of the order in which the closures connected to this signal will be invoked. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-connection></A>Signal connection</H3></DIV></DIV></DIV>
<P>If you want to connect to a signal with a closure, you have three possibilities: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>You can register a class closure at signal registration: this is a system-wide operation. i.e.: the class closure will be invoked during each emission of a given signal on <SPAN class=emphasis><EM>any</EM></SPAN> of the instances of the type which supports that signal. </P></LI>
<LI class=listitem>
<P>You can use <CODE class=function><A title=g_signal_override_class_closure&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-override-class-closure">g_signal_override_class_closure</A></CODE> which overrides the class closure of a given type. It is possible to call this function only on a derived type of the type on which the signal was registered. This function is of use only to language bindings. </P></LI>
<LI class=listitem>
<P>You can register a closure with the <CODE class=function><A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect">g_signal_connect</A></CODE> family of functions. This is an instance-specific operation: the closure will be invoked only during emission of a given signal on a given instance. </P></LI></UL></DIV>
<P>It is also possible to connect a different kind of callback on a given signal: emission hooks are invoked whenever a given signal is emitted whatever the instance on which it is emitted. Emission hooks are used for example to get all mouse_clicked emissions in an application to be able to emit the small mouse click sound. Emission hooks are connected with <CODE class=function><A title=g_signal_add_emission_hook&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-add-emission-hook">g_signal_add_emission_hook</A></CODE> and removed with <CODE class=function><A title=g_signal_remove_emission_hook&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-remove-emission-hook">g_signal_remove_emission_hook</A></CODE>. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-emission></A>Signal emission</H3></DIV></DIV></DIV>
<P>Signal emission is done through the use of the <CODE class=function><A title=g_signal_emit&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit">g_signal_emit</A></CODE> family of functions. </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">void</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emitv">g_signal_emitv</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">const</SPAN> GValue <SPAN class="gtkdoc opt">*</SPAN>instance_and_params<SPAN class="gtkdoc opt">,</SPAN>
                     guint         signal_id<SPAN class="gtkdoc opt">,</SPAN>
                     GQuark        detail<SPAN class="gtkdoc opt">,</SPAN>
                     GValue       <SPAN class="gtkdoc opt">*</SPAN>return_value<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>The <EM class=parameter><CODE>instance_and_params</CODE></EM> array of GValues contains the list of input parameters to the signal. The first element of the array is the instance pointer on which to invoke the signal. The following elements of the array contain the list of parameters to the signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>signal_id</CODE></EM> identifies the signal to invoke. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>detail</CODE></EM> identifies the specific detail of the signal to invoke. A detail is a kind of magic token/argument which is passed around during signal emission and which is used by closures connected to the signal to filter out unwanted signal emissions. In most cases, you can safely set this value to zero. See <A title="The detail argument" class=xref href="https://developer.gnome.org/gobject/stable/signal.html#signal-detail">the section called &#8220;The <SPAN class=emphasis><EM>detail</EM></SPAN> argument&#8221;</A> for more details about this parameter. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>return_value</CODE></EM> holds the return value of the last closure invoked during emission if no accumulator was specified. If an accumulator was specified during signal creation, this accumulator is used to calculate the return value as a function of the return values of all the closures invoked during emission. If no closure is invoked during emission, the <EM class=parameter><CODE>return_value</CODE></EM> is nonetheless initialized to zero/null. </P></LI></UL></DIV>
<P></P>
<P>Signal emission can be decomposed in 5 steps: </P>
<DIV class=orderedlist>
<OL class=orderedlist type=1>
<LI class=listitem>
<P><CODE class=literal>RUN_FIRST</CODE>: if the <A class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#G-SIGNAL-RUN-FIRST:CAPS"><CODE class=literal>G_SIGNAL_RUN_FIRST</CODE></A> flag was used during signal registration and if there exists a class closure for this signal, the class closure is invoked. </P></LI>
<LI class=listitem>
<P><CODE class=literal>EMISSION_HOOK</CODE>: if any emission hook was added to the signal, they are invoked from first to last added. Accumulate return values. </P></LI>
<LI class=listitem>
<P><CODE class=literal>HANDLER_RUN_FIRST</CODE>: if any closure were connected with the <CODE class=function><A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect">g_signal_connect</A></CODE> family of functions, and if they are not blocked (with the <CODE class=function><A title=g_signal_handler_block&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-handler-block">g_signal_handler_block</A></CODE> family of functions) they are run here, from first to last connected. </P></LI>
<LI class=listitem>
<P><CODE class=literal>RUN_LAST</CODE>: if the <CODE class=literal>G_SIGNAL_RUN_LAST</CODE> flag was set during registration and if a class closure was set, it is invoked here. </P></LI>
<LI class=listitem>
<P><CODE class=literal>HANDLER_RUN_LAST</CODE>: if any closure were connected with the <CODE class=function>g_signal_connect_after</CODE> family of functions, if they were not invoked during <CODE class=literal>HANDLER_RUN_FIRST</CODE> and if they are not blocked, they are run here, from first to last connected. </P></LI>
<LI class=listitem>
<P><CODE class=literal>RUN_CLEANUP</CODE>: if the <CODE class=literal>G_SIGNAL_RUN_CLEANUP</CODE> flag was set during registration and if a class closure was set, it is invoked here. Signal emission is completed here. </P></LI></OL></DIV>
<P></P>
<P>If, at any point during emission (except in <CODE class=literal>RUN_CLEANUP</CODE> state), one of the closures or emission hook stops the signal emission with <CODE class=function><A title=g_signal_stop_emission&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-stop-emission">g_signal_stop_emission</A></CODE>, emission jumps to <CODE class=literal>RUN_CLEANUP</CODE> state. </P>
<P>If, at any point during emission, one of the closures or emission hook emits the same signal on the same instance, emission is restarted from the <CODE class=literal>RUN_FIRST</CODE> state. </P>
<P>The accumulator function is invoked in all states, after invocation of each closure (except in <CODE class=literal>RUN_EMISSION_HOOK</CODE> and <CODE class=literal>RUN_CLEANUP</CODE>). It accumulates the closure return value into the signal return value and returns TRUE or FALSE. If, at any point, it does not return TRUE, emission jumps to <CODE class=literal>RUN_CLEANUP</CODE> state. </P>
<P>If no accumulator function was provided, the value returned by the last handler run will be returned by <CODE class=function><A title=g_signal_emit&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit">g_signal_emit</A></CODE>. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-detail></A>The <SPAN class=emphasis><EM>detail</EM></SPAN> argument</H3></DIV></DIV></DIV>
<P>All the functions related to signal emission or signal connection have a parameter named the <SPAN class=emphasis><EM>detail</EM></SPAN>. Sometimes, this parameter is hidden by the API but it is always there, in one form or another. </P>
<P>Of the three main connection functions, only one has an explicit detail parameter as a <A href="https://developer.gnome.org/gobject/glib-Quarks.html#GQuark"><SPAN class=type>GQuark</SPAN></A>: <A title=g_signal_connect_closure_by_id&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect-closure-by-id"><CODE class=function>g_signal_connect_closure_by_id</CODE></A>. <A class=footnote href="https://developer.gnome.org/gobject/stable/signal.html#ftn.id-1.3.5.3.8.3.3" name=id-1.3.5.3.8.3.3><SUP class=footnote>[6]</SUP></A> </P>
<P>The two other functions, <A title=g_signal_connect_closure&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect-closure"><CODE class=function>g_signal_connect_closure</CODE></A> and <A title=g_signal_connect_data&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect-data"><CODE class=function>g_signal_connect_data</CODE></A> hide the detail parameter in the signal name identification. Their <EM class=parameter><CODE>detailed_signal</CODE></EM> parameter is a string which identifies the name of the signal to connect to. The format of this string should match <SPAN class=emphasis><EM>signal_name::detail_name</EM></SPAN>. For example, connecting to the signal named <SPAN class=emphasis><EM>notify::cursor_position</EM></SPAN> will actually connect to the signal named <SPAN class=emphasis><EM>notify</EM></SPAN> with the <SPAN class=emphasis><EM>cursor_position</EM></SPAN> detail. Internally, the detail string is transformed to a GQuark if it is present. </P>
<P>Of the four main signal emission functions, one hides it in its signal name parameter: <A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect"><CODE class=function>g_signal_connect</CODE></A>. The other three have an explicit detail parameter as a <A href="https://developer.gnome.org/gobject/glib-Quarks.html#GQuark"><SPAN class=type>GQuark</SPAN></A> again: <A title=g_signal_emit&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit"><CODE class=function>g_signal_emit</CODE></A>, <A title=g_signal_emitv&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emitv"><CODE class=function>g_signal_emitv</CODE></A> and <A title=g_signal_emit_valist&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit-valist"><CODE class=function>g_signal_emit_valist</CODE></A>. </P>
<P>If a detail is provided by the user to the emission function, it is used during emission to match against the closures which also provide a detail. If a closure's detail does not match the detail provided by the user, it will not be invoked (even though it is connected to a signal which is being emitted). </P>
<P>This completely optional filtering mechanism is mainly used as an optimization for signals which are often emitted for many different reasons: the clients can filter out which events they are interested in before the closure's marshalling code runs. For example, this is used extensively by the <A title="The &#8220;notify&#8221; signal" class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject-notify"><EM class=structfield><CODE>notify</CODE></EM></A> signal of GObject: whenever a property is modified on a GObject, instead of just emitting the <SPAN class=emphasis><EM>notify</EM></SPAN> signal, GObject associates as a detail to this signal emission the name of the property modified. This allows clients who wish to be notified of changes to only one property to filter most events before receiving them. </P>
<P>As a simple rule, users can and should set the detail parameter to zero: this will disable completely this optional filtering for that signal. </P></DIV>
<DIV class=footnotes><BR>
<HR style="WIDTH: 100px; TEXT-ALIGN: left; MARGIN-LEFT: 0px">

<DIV id=ftn.id-1.3.5.3.8.3.3 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/signal.html#id-1.3.5.3.8.3.3"><SUP class=para>[6] </SUP></A>A GQuark is an integer which uniquely represents a string. It is possible to transform back and forth between the integer and string representations with the functions <CODE class=function><A href="https://developer.gnome.org/gobject/glib-Quarks.html#g-quark-from-string">g_quark_from_string</A></CODE> and <CODE class=function><A href="https://developer.gnome.org/gobject/glib-Quarks.html#g-quark-to-string">g_quark_to_string</A></CODE>. </P></DIV></DIV>
</td>
</tr>
</table>
</center>
</div>
<hr>
<div align="center">
<center>
<table border="2" cellpadding="5" cellspacing="5" width="100%" bgcolor="#FFCC66">
<tr>
<td width="100%">
<p><b>About using this material:</b></p>
<p>The best way to <b>learn</b> this material is to use <a href="http://www.supermemo.com/english/smintro.htm">SuperMemo</a> software.<br>
SuperMemo is the world's leader in accelerated learning technologies
 (see: <a href="http://www.supermemo.com">SuperMemo Website</a>)
<p>
No download URL currently available
</td>
</tr>
<tr>
<td width="100%">
<b>Contact data:</b></p>
<a href="http://www.supermemo.com">www.supermemo.com</a><br>
date: 2017/4/11 17:57:00<br>
Page generated with:<br> SuperMemo 2008<br>Build: 14.04 of Feb 18, 2010
</td>
</tr>
<tr>
<td width="100%">
</td>
</tr>
</table>
</center>
</div>
</body>

</html>
